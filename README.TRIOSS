                         - RTAI_TRIOSS, what is it? -

It is the name of the macro RTAI_TRIOSS that, if set, enables RTAI to run 3
OSes altoghether, i.e:
- RTAI
- FUSION (aka xenomai now)
- Linux

To get it working you have to use hal-trioss-whatever patches, found in 
"base/arch/i386/patches". When Linux is patched with a hal-trioss-whatever 
patch and RTAI_TRIOSS is not set you revert to the usual RTAI+Linux mode, 
which could be called (and indeed is) RTAI_DUOSS now :-). The all stuff is
for Linux 2.6.xx only, since there is no FUSION for Linux 2.4.xx. 

What said above, combined with maintaining compatibility with Linux 2.4.xx, 
does not rule standard RTAI+Linux out. So in "base/arch/i386/patches" there 
are also the usual hal-linux-whatever patches, to support the leanest and 
fastest RTAIs for both Linux 2.4.xx and 2.6.xx. 

So if you do not care of working with FUSION go on as usual. If you are
using the CVS that means you have to care nothing because it is structured
for DUOSS already.
 
Thus this README is just for those wanting to get the 3 OSes above working
together, where toghether can mean 2 things:
1 - running separated applications;
2 - integrating applications.

What is important to keep in mind is that in both cases RTAI will be the
the highest priority OS always, as such it will keep full preemptability on 
both FUSION and Linux, at any time and everywhere. The only preemptability 
delay will be caused by ADEOS use of hw interrupts locks, but that is always 
there and TRIOSS enables interrupts quickly to improve determinism and 
efficiency. Nonetheless there will be a bit more overhead with TRIOSS than 
DUOSS: because of a deeper ADEOS pipeline and the need to protect FUSION 
task context switches in hardware, as it is done for Linux already. 
So, once more, keep the usual RTAI, if you do not need to interoperate 
with FUSION. 

That said, point 1 above can be useful "per se" already, but clearly point 2 
should be the most appealing. In fact point 1 might appear almost useless 
at first, if one needs timing both RTAI and FUSION independently. The reason 
being they use the same hardware timers. Simply think about the fact that 
both RTAI and FUSION can keep Linux timing alive but will not care of being 
helpful to each either, since they grab the same hard timers for themselves. 
Since a possible solution to this problem will be seen later on, point 1 is
also definetely useful.

How does it work? The answer is simple: as usual. It is just the same 
RTAI LXRT coscheduler scheme on ADEOS. Simply and shortly: FUSION and Linux 
are treated the same, but FUSION will be capable, RTAI native preemptions
apart, to run in real time simply because it is at a priority higher than
Linux on the ADEOS pipe. Note that such a scheme allows RTAI to stack any 
number of OSes, working on the ADEOS stack, just with a trivial 
generalisation.

In such a view a FUSION task has to do just what a Linux task does to use
RTAI APIs, i.e.: call rtai_task_init, or any of its flavours, and then use 
whatever API it wants, be it for RTAI, FUSION or Linux. Notice that you must 
not make the task hard real time, in FUSION it will be so automatically, 
again at a priority just below that of RTAI. Clearly you must have hardened 
your task for FUSION by using: rt_task_schadow. In short you have to call both 
rt_task_schadow and rtai_task_init, in whatever order, but not 
rt_make_hard_real_time, FUSION tasks are soft real time for RTAI, much as
those of Linux. Doing so you will be able to have FUSION hard real time while 
using both RTAI and FUSION.

The stuff is new and fun, improvements and further extensions of the idea
can be envisaged easily, thoug they have still to come. Notice also that, 
since RTAI can preempt anything anywhere, as already hinted, there is the 
need to protect FUSION context switches by hard disabling interrupts. 
Since it is unlikely that FUSION (aka xenomai) will ever care of adding 
such a protection for the sole scope of being friendly to RTAI, you'll 
have to do it yoursels. It is trivial though, just wrap the inlined function 
xnarch_switch_to, found in xenomai "include/nucleus/asm-i386/system.h, 
as in the following:
static inline void xnarch_switch_to (xnarchtcb_t *out_tcb, xnarchtcb_t *in_tcb)
{
do { unsigned long flags; rthal_local_irq_save_hw(flags);
.
. keep here the body of the function as it is now
.
rthal_local_irq_restore_hw(flags); } while (0);
}

That done you have to care to load all the needed FUSION modules before those
of RTAI and then use them as usual. As said it is new (likely the first time 
you can run 2 real time OSes toghether in Linux?) and may need to mature. 
In any case the idea is simple and embedded in the RTAI LXRT coscheduler. 
That should make it not too difficult to be rubustified and improved. 
At the moment we use it as a useful way to stress test RTAI in an anusual 
evironment.

As it is now, i.e magma CVS, RTAI comes structured without any specific 
RTAI_TRIOSS making support. So you'll have to set up RTAI_TRIOSS by hand. 
For that patch Linux with the due patch and simply disable the RTAI_DUOSS 
macro in "base/include/asm-i386/rtai_hal.h", it is at the very beginning 
of the file.
Then go on with the usual making, recall also to modify xenomai as said above.
See README.INSTALL also. Hopefully it will be all configurable and 
made automatically in a better way soon.

Anybody interested can see a simple application in:
"showroom/v3.x/user/trioss". Follow what suggested in the README found
there to use it.

Back to the independent timings for RTAI and FUSION it is possible to say
that we can envisage many solutions. At the moment an easy one is available
already for relatively recent UP machines supporting the local APIC. In
such a case you can compile FUSION against a Linux copy with the APIC 
disabled, while RTAI should be compiled for a Linux copy with the APIC 
enabled. In such a way FUSION will use the 8254 timer and RTAI the APIC 
timer. Thus applications will be able to run in both modes 1/2 above with 
independent hard time source. 
Other solutions will be provided, as time allows, but you are welcome in
helping with your own.

Paolo.

