		      <*> RTAI_KCOMEDI IN USER SPACE <*>

This porting of KCOMEDI to user space is done using the standard extension 
feature of LXRT and makes COMEDI simmetrically usable in kernel and user 
space within RTAI, in soft/hard real time. To use KCOMEDI in user space you 
have just to know how to use it in kernel space, whatever space you are 
going to work in.

There are however some problems forbidding the above statements to be true
unconditionally.

One is related to the couple of name returning functions: 
"comedi_get_driver_name" and "comedi_get_board_name".

In kernel space the requested name is simply got by returning a pointer to 
a directly addressable global namestring, which is useless in user space. 
So there is the need of copying the namestring available in kernel space to 
user space, thus the calling convention must be changed. So the following 
two aliases, usable both in kernel and user space, have been made available:
void *rt_comedi_get_driver_name(unsigned int dev, char *name);
void *rt_comedi_get_board_name(unsigned int dev, char *name);
On success both of them return "name", NULL otherwise.

The solution of the above problem is simple and, almost, compulsory. In fact 
the only real problem to be solved for a symmetric approach to KCOMEDI in 
kernel and user space has been the use of a callback function in user space,
for which a fairly general, but frozen, usage scheme has been devised.

The callback method made available is based on using a built in callback 
function that triggers an rt_send_if and allows returning back to the user
an important unsigned long mask, made available by the standard COMEDI 
callback support as its first argument.

The related support comes from using the following functions, available in 
kernel space also (if you'll like it):
int rt_comedi_register_callback(void *dev, unsigned int subdev, unsigned int mask, int (*callback)(unsigned int, void *), void *task);
- the first 3 arguments are the same as in "comedi_register_callback", 
  "callback" is discarded while "task" is the pointer to an RTAI task that
  waits for asynchronous events to happen.

The standard COMEDI: int comedi_register_callback(unsigned int minor, unsigned
int subdev, unsigned int mask, int (*cb)(unsigned int, void * ), void *arg), 
is also available in user space, for compatibility reasons, in the form of a 
macro that redirects it to "rt_comedi_register_callback", setting "cb" to NULL
while "arg" MUST be assigned the pointer to the task to be used. There is 
clearly no need for anything similar in kernel space as the original COMEDI 
function is available directly, but the user space approach might prove viable
in kernel space also.

After the COMEDI callback has been initialised a user could synchronise its
application with COMEDI asynchronous events by using any of the available 
rt_receive functions, receiving the mask value made available by COMEDI 
callbacks in the received unsigned long msg. For an easier the following 
functions, usable in kernel space also, have been added:

unsigned long rt_comedi_wait(void);

unsigned long rt_comedi_wait_if(void);
- this function is equivalent to "rt_comedi_wait" but returns immediately 
  if no COMEDI event has ben signalled yet. Useful for polling COMEDI events, 
  through the returned unsigned integer mask, without blocking.

unsigned long rt_comedi_wait_until(RTIME until);
- this function is equivalent to "rt_comedi_wait" but features an absolute 
  timeout, given by "until".

unsigned long rt_comedi_wait_timed(RTIME delay);
- this function is equivalent to "rt_comedi_wait" but features a relative 
  timeout, given by "delay".

- The returned value is always the unsigned integer mask made available by 
  the standard COMEDI callback as its first argument, for its use see the 
  COMEDI manual and code.

Once more we emphasize that "rt_comedi_wait", "rt_comedi_wait_if", 
"rt_comedi_wait_until" and "rt_comedi_wait_timed" are nothing but disguised 
versions of "rt_receive", "rt_receive_if", "rt_receive_until" and 
"rt_receive_timed" returning the needed COMEDI callback mask parameter.

It is likely that the illustrated callback scheme and synchronisation is better 
exploited by using a thread acting as an asynchronous COMEDI events manager in 
hard real time. However it is by no means the only way as the above wait 
functions can be used anywhere and rt_comedi_wait_if makes it possible an easy 
implementation of a polling scheme.

There is an example in RTAI "showroom" CVS, "user/comedi".

"The Comedi Players"
