***** Various precise tunings of RTAI timing facilities *****
=============================================================

Please type "./calibration_helperc -h" to understand how to use it. 
A more detailed explanation follows below.
Let's recall that calibrations are required only for the oneshot mode. 
Nothing can be done for periodic hard timers, but choosing their ticking
frequency.
That said, there are two calibrations to be cared of: hard timers, APIC 
and 8254, shots programming and scheduling latencies, to be compensated by 
appropriately anticipating the timer shots.


Calibration of hard timers, APIC and 8254, shots programming
============================================================

Their calibration is fast and hiddenly done at the schedule module insmoding. 
So there is no need to care for it anymore.

Scheduling latencies calibration
================================

There is the need of two different scheduling latency calibrations, one for 
user and one for kernel space tasks. In fact there is a sizeable difference, 
kernel space latencies being less the those in user space.
The related values can be obtained by configuring RTAI with the RTAI_BUSY_TIME_ALIGN option disabled and then running the calibration_helper, either 
within the installed "calibration' directory or from the RTAI build directory.
The following option and the related defaults are available:
-h, --help: prints a synthetic usage of what described here;
-p <period (us)>, --period <period (us)>: assigns the task period to be used 
	calibrating the scheduling latencies, defaulting to 200 (us) if this
	option is not set;
-t <duration (s)>, --time <duration (s)>: the duration of the requested 
	calibration, a 1 (s) default value being assumed;
-l <conv. tol.>, --time <conv. tol.>: the acceptable tolerance, in ns, within 
	which the latency must stay for a converged calibration, default 
	100 (ns).
As it can be seen from the related code, it could be useful to notice that 
the scheduling latencies are somewhat depending on their set values. So the
calibrator iterates the calibration procedure till convergence within the above
set bound.
It should be noticed that, for sake of simplicity, the calibrator provides 
different latencies for kernel and user space tasks, but only a single one 
can be set at RTAI configuration. So it is up to the user to choose the right 
compromise between the twos, resorting to what follows for a more precise match.
Moreover if latencies tests are run after calibrating one could see a slightly
higher the expected result, especially in user space, due the slighter higher
overhead of the latter. Nevertheless, generally, it should be better to correct 
not the result of the calibrator.

Busy wait looping for a sharper on time latency calibration
==========================================================

The RTAI scheduler s the possibility of assigning scheduling latencies slightly
in excess of those required and then wait for a sharper matching of the 
scheduling time by busy waiting on the hard timer.
That is achieved by enabling the configuration option: RTAI_BUSY_TIME_ALIGN.
Since the busy wait is done at the exiting of the scheduler there is still a
completion overhead to be set to take into account the closure of the whole
return path, till the exiting of the timing function called. In fact after 
enabling RTAI_BUSY_TIME_ALIGN, there is the possibility of setting such 
completion values with the options: RTAI_KERN_BUSY_ALIGN_RET_DELAY, 
RTAI_USER_BUSY_ALIGN_RET_DELAY, whose default is zero. The needed values 
can be calibrated by rerunning the calibrator task with:
- the calibrated latency value,
- RTAI_BUSY_TIME_ALIGN enabled;
- RTAI_KERN_BUSY_ALIGN_RET_DELAY and RTAI_USER_BUSY_ALIGN_RET_DELAY set to one.
By reconfiguring RTAI with the obtained value it should be possible to verify 
the previously claimed sharper timing. To be sure to engage the busy wait, 
sometimes a user might use such an option in combination with a longer than 
needed latency calibration value. Such a longer than needed value comes by 
nature for kernel space tasks when the calibrated latency is set with the 
user space tasks one.
Since a zero value for the return delays disables such a feature even when 
RTAI_BUSY_TIME_ALIGN is enabled, such an option can be used selectively for
kernel and user space alone. So, as hinted already, one could set the 
calibrated user space latency, set RTAI_USER_BUSY_ALIGN_RET_DELAY to zero and
RTAI_KERN_BUSY_ALIGN_RET_DELAY to its calibrated value, thus obtain similar 
sharp result in both spaces.
On any decently recent machine the busy wait overhead is well sub us, so 
practically negligible in any case.
