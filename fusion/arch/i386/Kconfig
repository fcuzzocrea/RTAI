mainmenu "RTAI/x86 configuration"

source Kconfig

source "nucleus/Kconfig"

menu "Machine (x86)"

config RTAI_HW_FPU
	bool "Enable FPU support"
	default y
	help
	The FPU executes instructions from the processor's normal
	instruction stream. It can handle the types of high-precision
	floating-point processing operations commonly found in
	scientific, engineering, and business applications.
	If your target system has no FPU, say NO here; otherwise,
	enabling FPU support when available may greatly improve
	performance. You can obtain more information about the
	Float-Point Unit on the x86 platform at the following URL:
	http://www.intel.com/design/intarch/techinfo/Pentium/fpu.htm

config RTAI_HW_PERIODIC_TIMER
	bool "Enable periodic timer support"
	default y
	help
	On this architecture, the nucleus provides both aperiodic and
	periodic timing modes. In aperiodic mode, timing accuracy is
	higher - since it is not rounded to a constant time slice - at
	the expense of a lesser efficicency when many timers are
	simultaneously active. The aperiodic mode gives better results
	in configuration involving a few threads requesting timing
	services over different time scales that cannot be easily
	expressed as multiples of a single base tick, or would lead to
	a waste of high frequency periodic ticks. You can disable
	the periodic support for this architecture to save a few
	hundreds bytes if you plan to use the system timer in
	aperiodic mode only.

config RTAI_HW_TIMER_LATENCY
	depends on RTAI_OPT_EXPERT
	string "Timer tuning latency (ns)"
	default 0
	help
	This parameter accounts for the time (in nanoseconds) needed
	to program the underlying time source in one-shot timing mode.
	This value will be used to reduce the scheduling jitter induced
	by the time needed to setup the timer for its next shot. A
	default value of 0 (recommended) will cause this value to be
	estimated by the nucleus at startup.
	Depending on whether CONFIG_X86_LOCAL_APIC is enabled or not
	in the kernel configuration RTAI is compiled
	against, CONFIG_RTAI_HW_TIMER_LATENCY will either refer to the
	local APIC or 8254 timer latency value.

config RTAI_HW_SCHED_LATENCY
	depends on RTAI_OPT_EXPERT
	string "Scheduling latency (ns)"
	default 0
	help
	Scheduling latency is the time between the termination of an
	interrupt handler and the execution of the first instruction
	of the real-time thread this handler resumes. A default value
	of 0 (recommended) will cause this value to be estimated by
	the nucleus at startup.

config  RTAI_HW_X86_VSYSCALL_ENABLE
	depends on RTAI_OPT_EXPERT
	bool "Enable VSYSCALL support"
	default y
	help
	When enabled, this option makes the real-time applications in
	user-space rely on Linux's VSYSCALL support for issuing
	RTAI/fusion system calls, instead of doing a "int 0x80"
	instruction. VSYSCALL will in turn dispatch the system call
	the most efficient way to the proper RTAI/fusion module
	running in kernel space.
	When available, VSYSCALL makes use of the SYSENTER/SYSEXIT
	fast system call instructions which have been introduced with
	the Intel PPro, and are also supported by recent AMD CPUs.
	If unsure, just look at the flags reported by /proc/cpuinfo on
	your x86 hardware: if "sep" is listed, then RTAI performances
	would likely benefit from activating this option; if it is not
	listed, then disable this option.

if RTAI_HW_X86_VSYSCALL_ENABLE

choice
	prompt "VSYSCALL access"
	help
	Only NPTL-based glibc can actually make use of the VSYSCALL
	support; this choice controls whether RTAI/fusion should
	follow an adaptive approach so that it would work over
	LinuxThreads and NPTL indifferently, or if it should force the
	use of VSYSCALL. The former approach is more conservative and
	slightly less efficient if your runtime environment is always
	NTPL-based, whilst the latter is a bit faster but will not
	work with LinuxThreads.

config RTAI_HW_X86_VSYSCALL_ADAPTIVE
	bool "Adaptive"
	help
	Conservative VSYSCALL access; will work on both LinuxThreads
	and NPTL-based setups, adapting to the underlying system call
	invocation mechanism.

config RTAI_HW_X86_VSYSCALL_FORCED
	bool "Forced"
	help
	Hardwired VSYSCALL access; will work on NPTL-based setups
	only.

endchoice

endif

config RTAI_HW_X86_VSYSCALL
        bool
        depends on !RTAI_OPT_EXPERT || RTAI_HW_X86_VSYSCALL_ENABLE
        default y

config RTAI_HW_X86_VSYSCALL_HARDWIRED
        bool
        depends on RTAI_OPT_EXPERT && RTAI_HW_X86_VSYSCALL_ENABLE && RTAI_HW_X86_VSYSCALL_FORCED
        default y

menu "SMI workaround"

config RTAI_HW_SMI_DETECT_DISABLE
        depends on RTAI_OPT_EXPERT
        bool "Disable SMI detection"
        default n
        help
        SMI are System Management Interrupts, generated by Intel ICH
        (I/O connector hubs) to allow handling of some specific events;
        on systems where they exist, they are the highest priority
        interrupts (even higher priority than NMIs). Common SMI sources
        are power management, legacy devices emulation by BIOS, SMBus
        and TCO watchdog. 

        SMI are problematic for RTAI, because their handling may span
        accross hundreds of microseconds, causing unacceptable interrupt 
        latency. Furthermore, their vectors are stored in some ROM, 
        and hence may not be altered.

        For this reason, RTAI contains code to detect chipsets using
        SMIs and optionnaly activate some workarounds to stop SMIs.

        Enabling this option will cause RTAI not to try and detect whether 
        your hardware use SMIs. This option is mostly useful if you know
        that your system does not use SMIs and really want to size RTAI 
        modules down. The detection code has no run-time space overhead,
        only disk-space overhead.

config RTAI_HW_SMI_DETECT
        bool
        depends on !RTAI_OPT_EXPERT || !RTAI_HW_SMI_DETECT_DISABLE
        default y

config RTAI_HW_SMI_WORKAROUND
        depends on RTAI_HW_SMI_DETECT
        bool "Enable SMI workaround"
        default n
        help
        SMI are System Management Interrupts, generated by Intel ICH
        (I/O connector hubs) to allow handling of some specific events;
        on systems where they exist, they are the highest priority
        interrupts (even higher priority than NMIs). Common SMI sources
        are power management, legacy devices emulation by BIOS, SMBus
        and TCO watchdog. 

        SMI are problematic for RTAI, because their handling may span
        accross hundreds of microseconds, causing unacceptable interrupt 
        latency. Furthermore, their vectors are stored in some ROM, 
        and hence may not be altered.

        For this reason, RTAI contains code to detect chipsets using
        SMIs and optionnaly activate some workarounds to stop SMIs.
        Enabling this option cause those workarounds to be activated.

if RTAI_HW_SMI_WORKAROUND

config RTAI_HW_SMI_ALL
        bool "Globally disable SMI"
        default y
        help
        This option causes the SMIs to be globally disabled, which avoid
        any jitter they could cause with a big drawback: any peripheral or
        feature relying on them will stop working when RTAI is running.

        The alternative is to selectively enable the SMIs sources needed 
        by your peripherals. The main drawback is that the peripheral 
        which you need may be the one causing jitter, so that extensive
        testing is needed when choosing to not disable SMI globally. 
        Another drawback is that other unknown SMI sources may exist which
        RTAI can not disable.

        This option causes the SMIs to be globally disabled.

config RTAI_HW_SMI_INTEL_USB2
        bool "Enable Intel-Specific USB2 SMI"
        depends on !RTAI_HW_SMI_ALL
        default n
        help
        This options enables Intel-specific USB2 SMI logic to cause SMIs.

config RTAI_HW_SMI_LEGACY_USB2
        bool "Enable legacy USB2 SMI"
        depends on !RTAI_HW_SMI_ALL
        default n
        help
        This options enables legacy USB2 logic to cause SMIs.

config RTAI_HW_SMI_PERIODIC
        bool "Enable periodic SMI"
        depends on !RTAI_HW_SMI_ALL
        default n
        help
        This options enables the ICH to generate a periodic SMI.

config RTAI_HW_SMI_TCO
        bool "Enable TCO SMI"
        depends on !RTAI_HW_SMI_ALL
        default n
        help
        This options enables the TCO logic to generate SMIs.

config RTAI_HW_SMI_MC
        bool "Enable microcontroller SMI"
        depends on !RTAI_HW_SMI_ALL
        default n
        help
        This options enables the ICH to trap access to the 
        microcontroller range.

config RTAI_HW_SMI_APMC
        bool "Enable APM SMI"
        depends on !RTAI_HW_SMI_ALL
        default n
        help
        This options enables writes to the APM control register to 
        cause SMIs.

config RTAI_HW_SMI_LEGACY_USB
        bool "Enable legacy USB SMI"
        depends on !RTAI_HW_SMI_ALL
        default n
        help
        This options enables legacy USB circuit to cause SMIs.

config RTAI_HW_SMI_BIOS
        bool "Enable ACPI BIOS SMI"
        depends on !RTAI_HW_SMI_ALL
        default n
        help
        This options enables SMI to be used for communication
        between ACPI software and BIOS software.

endif

endmenu

endmenu

source "skins/Kconfig"

menu "Drivers"

source "drivers/Kconfig"

endmenu

source "sim/Kconfig"
