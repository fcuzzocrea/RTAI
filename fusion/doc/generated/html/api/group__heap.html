<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Dynamic memory allocation services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Dynamic memory allocation services.<br>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Dynamic memory allocation services.<p>
The implementation of the memory allocator follows the algorithm described in a USENIX 1988 paper called "Design of a General Purpose Memory Allocator for the 4.3BSD Unix Kernel" by Marshall K. McKusick and Michael J. Karels. You can find it at various locations on the net, including <a href="http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf.">http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf.</a> A minor variation allows this implementation to have 'extendable' heaps when needed, with multiple memory extents providing autonomous page address spaces.<p>
The data structures hierarchy is as follows:<p>
HEAP { block_buckets[] extent_queue -------+ } | V EXTENT #1 {  page_map[npages] page_array[npages][pagesize] } -+ | | V EXTENT #n {  page_map[npages] page_array[npages][pagesize] } 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="heap_8c.html">heap.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamic memory allocation services. <br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__heap.html#a2">xnheap_init</a> (xnheap_t *heap, void *heapaddr, u_long heapsize, u_long pagesize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a memory heap. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__heap.html#a3">xnheap_destroy</a> (xnheap_t *heap, void(*flushfn)(void *extaddr, u_long extsize))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a memory heap. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__heap.html#a5">xnheap_alloc</a> (xnheap_t *heap, u_long size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a memory block from a memory heap. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__heap.html#a6">xnheap_free</a> (xnheap_t *heap, void *block)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a memory block to a memory heap. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__heap.html#a7">xnheap_extend</a> (xnheap_t *heap, void *extaddr, u_long extsize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extend a memory heap. </em> <a href="#a7"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a5" doxytag="heap.c::xnheap_alloc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void * xnheap_alloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnheap_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_long&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a memory block from a memory heap. 
<p>
Allocates a contiguous region of memory from an active memory heap. Such allocation is guaranteed to be time-bounded.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>heap</em>&nbsp;</td><td>The descriptor address of the heap to get memory from.</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>The size in bytes of the requested block. Sizes lower or equal to the page size are rounded either to the minimum allocation size if lower than this value, or to the minimum alignment size if greater or equal to this value. In the current implementation, with MINALLOC = 8 and MINALIGN = 16, a 7 bytes request will be rounded to 8 bytes, and a 17 bytes request will be rounded to 32.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The address of the allocated region upon success, or NULL if no memory is available from the specified heap.</dd></dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of any context.     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="heap.c::xnheap_destroy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnheap_destroy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnheap_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>flushfn</em>)(void *extaddr, u_long extsize)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroys a memory heap. 
<p>
Destroys a memory heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>heap</em>&nbsp;</td><td>The descriptor address of the destroyed heap.</td></tr>
    <tr><td valign=top><em>flushfn</em>&nbsp;</td><td>If non-NULL, the address of a flush routine which will be called for each extent attached to the heap. This routine can be used by the calling code to further release the heap memory.</td></tr>
  </table>
</dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine must be called on behalf of a thread.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="heap.c::xnheap_extend" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnheap_extend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnheap_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>extaddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_long&nbsp;</td>
          <td class="mdname" nowrap> <em>extsize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Extend a memory heap. 
<p>
Add a new extent to an existing memory heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>heap</em>&nbsp;</td><td>The descriptor address of the heap to add an extent to.</td></tr>
    <tr><td valign=top><em>extaddr</em>&nbsp;</td><td>The address of the extent memory.</td></tr>
    <tr><td valign=top><em>extsize</em>&nbsp;</td><td>The size of the extent memory (in bytes). In the current implementation, this size must match the one of the initial extent passed to <a class="el" href="group__heap.html#a2">xnheap_init()</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, or -EINVAL is returned if <em>extsize</em> differs from the initial extent's size.</dd></dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of any context.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="heap.c::xnheap_free" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnheap_free </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnheap_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>block</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release a memory block to a memory heap. 
<p>
Releases a memory region to the memory heap it was previously allocated from.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>heap</em>&nbsp;</td><td>The descriptor address of the heap to release memory to.</td></tr>
    <tr><td valign=top><em>block</em>&nbsp;</td><td>The address of the region to be returned to the heap.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, or -EINVAL is returned whenever the block is not a valid region of the specified heap.</dd></dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of any context.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="heap.c::xnheap_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnheap_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnheap_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>heapaddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_long&nbsp;</td>
          <td class="mdname" nowrap> <em>heapsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_long&nbsp;</td>
          <td class="mdname" nowrap> <em>pagesize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a memory heap. 
<p>
Initializes a memory heap suitable for time-bounded allocation requests of dynamic memory.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>heap</em>&nbsp;</td><td>The address of a heap descriptor which will be used to store the allocation data. This descriptor must always be valid while the heap is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign=top><em>heapaddr</em>&nbsp;</td><td>The address of the heap storage area. All allocations will be made from the given area in time-bounded mode. Since additional extents can be added to a heap, this parameter is also known as the "initial extent".</td></tr>
    <tr><td valign=top><em>heapsize</em>&nbsp;</td><td>The size in bytes of the initial extent pointed at by <em>heapaddr</em>. <em>heapsize</em> must be a multiple of pagesize and lower than 16 Mbytes. <em>heapsize</em> must be large enough to contain an internal header. The following formula gives the size of this header: hdrsize = (sizeof(xnextent_t) + ((heapsize - sizeof(xnextent_t))) / (pagesize + 1) + 15) &amp; ~15.</td></tr>
    <tr><td valign=top><em>pagesize</em>&nbsp;</td><td>The size in bytes of the fundamental memory page which will be used to subdivide the heap internally. Choosing the right page size is important regarding performance and memory fragmentation issues, so it might be a good idea to take a look at <a href="http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf">http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf</a> to pick the best one for your needs. In the current implementation, pagesize must be a power of two in the range [ 8 .. 32768] inclusive.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, or one of the following error codes:</dd></dl>
<ul>
<li>-EINVAL is returned whenever a parameter is invalid.</li></ul>
<p>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of any context.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jun 30 17:31:16 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
