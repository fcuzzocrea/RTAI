<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Mutex services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Mutex services.<br>
<small>
[<a class="el" href="group__native.html">Native RTAI API.</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Mutex services.<p>
A mutex is a MUTual EXclusion object, and is useful for protecting shared data structures from concurrent modifications, and implementing critical sections and monitors.<p>
A mutex has two possible states: unlocked (not owned by any task), and locked (owned by one task). A mutex can never be owned by two different tasks simultaneously. A task attempting to lock a mutex that is already locked by another task is blocked until the latter unlocks the mutex first. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8c.html">mutex.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the RTAI project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga2">rt_mutex_create</a> (RT_MUTEX *mutex, const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a mutex.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga3">rt_mutex_delete</a> (RT_MUTEX *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a mutex.  <a href="#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga4">rt_mutex_lock</a> (RT_MUTEX *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire a mutex.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga5">rt_mutex_unlock</a> (RT_MUTEX *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock mutex.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga6">rt_mutex_inquire</a> (RT_MUTEX *mutex, RT_MUTEX_INFO *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inquire about a mutex.  <a href="#ga6"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga2" doxytag="mutex.c::rt_mutex_create"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_mutex_create           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_MUTEX *&nbsp;</td>
          <td class="mdname" nowrap> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a mutex. 
<p>
Create a mutual exclusion object that allows multiple threads to synchronize access to a shared resource. A mutex is left in an unlocked state after creation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The address of a mutex descriptor RTAI will use to store the mutex-related data. This descriptor must always be valid while the mutex is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the mutex. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created mutex.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li></ul>
<p>
Context: This routine can be called on behalf of a task or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="mutex.c::rt_mutex_delete"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_mutex_delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_MUTEX *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a mutex. 
<p>
Destroy a mutex and release all the tasks currently pending on it. A mutex exists in the system since <a class="el" href="group__mutex.html#ga2">rt_mutex_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The descriptor address of the affected mutex.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a mutex descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>sem</em> is a deleted mutex descriptor.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure if tasks have been woken up as a result of the deletion.<p>
Context: This routine can always be called on behalf of a task, or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="mutex.c::rt_mutex_inquire"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_mutex_inquire           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_MUTEX *&nbsp;</td>
          <td class="mdname" nowrap> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>RT_MUTEX_INFO *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inquire about a mutex. 
<p>
Return various information about the status of a given mutex.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The descriptor address of the inquired mutex.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The address of a structure the mutex information will be written to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a mutex descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>sem</em> is a deleted mutex descriptor.</li></ul>
<p>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="mutex.c::rt_mutex_lock"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_mutex_lock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_MUTEX *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire a mutex. 
<p>
Attempt to lock a mutex. The calling task is blocked until the mutex is available, in which case it is locked again before this service returns. Mutexes have an ownership property, which means that their current owner is tracked. RTAI mutexes are implicitely recursive and implement the priority inheritance protocol.<p>
Since a nested locking count is maintained for the current owner, <a class="el" href="group__mutex.html#ga4">rt_mutex_lock()</a> and <a class="el" href="group__mutex.html#ga5">rt_mutex_unlock()</a> must be used in pairs.<p>
Tasks pend on mutexes by priority order.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The descriptor address of the mutex to acquire.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mutex</em> is not a mutex descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>mutex</em> is a deleted mutex descriptor, including if the deletion occurred while the caller was sleeping on it.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga15">rt_task_unblock()</a> has been called for the waiting task before the mutex has become available.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure unless the mutex is immediately available. If the caller is blocked, the current owner priority might be temporarily raised as a consequence of the priority inheritance protocol.<p>
Context: This routine must be called on behalf of a task.     </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="mutex.c::rt_mutex_unlock"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_mutex_unlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_MUTEX *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock mutex. 
<p>
Release a mutex. If the mutex is pended, the first waiting task (by priority order) is immediately unblocked and transfered the ownership of the mutex; otherwise, the mutex is left in an unlocked state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The descriptor address of the released mutex.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mutex</em> is not a mutex descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>mutex</em> is a deleted mutex descriptor.</li></ul>
<p>
<ul>
<li>-EACCES is returned if <em>mutex</em> is not owned by the current task.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure if a task is woken up as a result of the operation.<p>
Context: This routine can be called on behalf of a task or from the initialization code.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 13:23:41 2004 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9 </small></address>
</body>
</html>
