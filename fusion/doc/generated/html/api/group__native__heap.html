<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Memory heap services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Memory heap services.<br>
<small>
[<a class="el" href="group__native.html">Native RTAI API.</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Memory heap services.<p>
Memory heaps are built over Xenomai's heap objects, which in turn provide the needed support for sharing a memory area between kernel and user-space using direct memory mapping. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skins_2rtai_2heap_8c.html">heap.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the RTAI project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#ga3">rt_heap_create</a> (RT_HEAP *heap, const char *name, size_t heapsize, int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a real-time memory heap.  <a href="#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#ga4">rt_heap_delete</a> (RT_HEAP *heap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a real-time heap.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#ga5">rt_heap_alloc</a> (RT_HEAP *heap, size_t size, RTIME timeout, void **bufp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a buffer.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#ga6">rt_heap_free</a> (RT_HEAP *heap, void *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a buffer.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#ga7">rt_heap_inquire</a> (RT_HEAP *heap, RT_HEAP_INFO *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inquire about a heap.  <a href="#ga7"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga5" doxytag="heap.c::rt_heap_alloc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_heap_alloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_HEAP *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>bufp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a buffer. 
<p>
This service allocates a buffer from the heap's internal pool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The descriptor address of the heap to allocate a buffer from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The requested size in bytes of the buffer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for a buffer of sufficient size to be available (see note). Passing RT_TIME_INFINITE causes the caller to block indefinitely until some buffer is eventually available. Passing RT_TIME_NONBLOCK causes the service to return immediately without waiting if no buffer is available on entry.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufp</em>&nbsp;</td><td>A pointer to a memory location which will be written upon success with the address of the allocated buffer. The buffer should be freed using <a class="el" href="group__native__heap.html#ga6">rt_heap_free()</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>heap</em> is not a heap descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>q</em> is a deleted heap descriptor.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if <em>timeout</em> is different from RT_TIME_NONBLOCK and no buffer is available within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to RT_TIME_NONBLOCK and no buffer is immediately available on entry.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga15">rt_task_unblock()</a> has been called for the waiting task before any buffer was available.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine only if <em>timeout</em> is equal to RT_TIME_NONBLOCK.</li></ul>
<p>
<ul>
<li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__native__timer.html#ga6">rt_timer_start()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed in nanoseconds. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="heap.c::rt_heap_create"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_heap_create           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_HEAP *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>heapsize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a real-time memory heap. 
<p>
Initializes a memory heap suitable for time-bounded allocation requests of dynamic memory. Memory heaps can be local to the kernel space, or shared between kernel and user-space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The address of a heap descriptor RTAI will use to store the heap-related data. This descriptor must always be valid while the heap is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the heap. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created heap.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>heapsize</em>&nbsp;</td><td>The size (in bytes) of the buffer pool which is going to be pre-allocated to the heap. Memory buffers will be claimed and released to this pool. The buffer pool is not extensible, so this value must be compatible with the highest memory pressure that could be expected.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The heap creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new heap:</td></tr>
  </table>
</dl>
<ul>
<li>H_FIFO makes tasks pend in FIFO order on the heap when waiting for available buffers.</li></ul>
<p>
<ul>
<li>H_PRIO makes tasks pend in priority order on the heap when waiting for available buffers.</li></ul>
<p>
<ul>
<li>H_SHARED causes the heap to be sharable between kernel and user-space tasks. Otherwise, the new heap is only available for kernel-based usage.</li></ul>
<p>
<ul>
<li>H_DMA causes the buffer pool associated to the heap to be allocated in physically contiguous memory, suitable for DMA operations with I/O devices. A 128Kb limit exists for <em>heapsize</em> when this flag is passed.</li></ul>
<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>heapsize</em> is null.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if not enough system memory is available to create the heap. Additionally, and if H_SHARED has been passed in <em>mode</em>, errors while mapping the buffer pool in the caller's address space might beget this return code too.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>User-space task</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="heap.c::rt_heap_delete"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_heap_delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_HEAP *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>heap</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a real-time heap. 
<p>
Destroy a heap and release all the tasks currently pending on it. A heap exists in the system since <a class="el" href="group__native__heap.html#ga3">rt_heap_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The descriptor address of the affected heap.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>heap</em> is not a heap descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>heap</em> is a deleted heap descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>User-space task</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="heap.c::rt_heap_free"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_heap_free           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_HEAP *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a buffer. 
<p>
This service releases a buffer to the heap's internal pool. If some task is currently waiting for a buffer so that it's pending request could be satisfied as a result of the release, it is immediately resumed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The address of the heap descriptor to which the buffer <em>buf</em> belong.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The address of the buffer to free.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, or -EINVAL if <em>buf</em> is not a valid buffer previously allocated by the <a class="el" href="group__native__heap.html#ga5">rt_heap_alloc()</a> service.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="heap.c::rt_heap_inquire"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_heap_inquire           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_HEAP *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RT_HEAP_INFO *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inquire about a heap. 
<p>
Return various information about the status of a given heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The descriptor address of the inquired heap.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The address of a structure the heap information will be written to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>heap</em> is not a message queue descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>heap</em> is a deleted queue descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Nov 13 23:16:31 2004 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
