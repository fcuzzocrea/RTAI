<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Pipe management services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Pipe management services.<br>
<small>
[<a class="el" href="group__native.html">Native RTAI API.</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Pipe management services. 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="pipe_8c.html">pipe.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the RTAI project. <br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pipe.html#a9">rt_pipe_open</a> (RT_PIPE *pipe, int minor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a pipe. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pipe.html#a10">rt_pipe_close</a> (RT_PIPE *pipe)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a pipe. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ssize_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pipe.html#a11">rt_pipe_read</a> (RT_PIPE *pipe, RT_PIPE_MSG **msgp, RTIME timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a message from a pipe. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ssize_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pipe.html#a12">rt_pipe_write</a> (RT_PIPE *pipe, RT_PIPE_MSG *msg, size_t size, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a message to a pipe. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ssize_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pipe.html#a13">rt_pipe_stream</a> (RT_PIPE *pipe, const  void *buf, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream bytes to a pipe. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ssize_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pipe.html#a14">rt_pipe_flush</a> (RT_PIPE *pipe)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush the pipe. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RT_PIPE_MSG *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pipe.html#a15">rt_pipe_alloc</a> (size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a message buffer. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pipe.html#a16">rt_pipe_free</a> (RT_PIPE_MSG *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a message buffer. </em> <a href="#a16"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a15" doxytag="pipe.c::rt_pipe_alloc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RT_PIPE_MSG * rt_pipe_alloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a message buffer. 
<p>
This service allocates a message buffer from the system heap which can be subsequently filled then passed to <a class="el" href="group__pipe.html#a12">rt_pipe_write()</a> for sending. The beginning of the available data area of <em>size</em> contiguous bytes is accessible from RT_PIPE_MSGPTR(msg).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>size</em>&nbsp;</td><td>The requested size in bytes of the buffer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The address of the allocated message buffer upon success, or NULL if the allocation fails.</dd></dl>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="pipe.c::rt_pipe_close" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_pipe_close </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_PIPE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pipe</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a pipe. 
<p>
This service closes a pipe previously opened by <a class="el" href="group__pipe.html#a9">rt_pipe_open()</a>. Data pending for transmission to user-space are lost.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pipe</em>&nbsp;</td><td>The descriptor address of the affected pipe.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF can be returned if <em>pipe</em> is scrambled.</li></ul>
<p>
Context: This routine can be called on behalf of a task or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="pipe.c::rt_pipe_flush" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_pipe_flush </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_PIPE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pipe</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flush the pipe. 
<p>
This service flushes any pending data buffered by <a class="el" href="group__pipe.html#a13">rt_pipe_stream()</a>. The data will be immediately sent to the user-space side of the pipe.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to flush.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes flushed upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EIO is returned if the user-space side of the pipe is not yet open.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li></ul>
<p>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="pipe.c::rt_pipe_free" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_pipe_free </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_PIPE_MSG *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a message buffer. 
<p>
This service releases a message buffer returned by <a class="el" href="group__pipe.html#a11">rt_pipe_read()</a> to the system heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>msg</em>&nbsp;</td><td>The address of the message buffer to free.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, or -EINVAL if <em>msg</em> is not a valid message buffer previously allocated by the <a class="el" href="group__pipe.html#a15">rt_pipe_alloc()</a> service.</dd></dl>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="pipe.c::rt_pipe_open" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_pipe_open </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_PIPE *&nbsp;</td>
          <td class="mdname" nowrap> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>minor</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open a pipe. 
<p>
This service opens a bi-directional communication channel allowing data exchange between real-time tasks and regular user-space processes. Pipes natively preserve message boundaries, but can also be used in byte stream mode from kernel to user space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pipe</em>&nbsp;</td><td>The address of a pipe descriptor RTAI will use to store the pipe-related data. This descriptor must always be valid while the pipe is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign=top><em>minor</em>&nbsp;</td><td>The minor number of the device associated with the pipe.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENODEV is returned if <em>minor</em> is not a valid minor number of for pipe pseudo-devices.</li></ul>
<p>
<ul>
<li>-EBUSY is returned if <em>minor</em> is already open.</li></ul>
<p>
Context: This routine can be called on behalf of a task or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="pipe.c::rt_pipe_read" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_pipe_read </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_PIPE *&nbsp;</td>
          <td class="mdname" nowrap> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RT_PIPE_MSG **&nbsp;</td>
          <td class="mdname" nowrap> <em>msgp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read a message from a pipe. 
<p>
This service retrieves the next message sent from the user-space side of the pipe. <a class="el" href="group__pipe.html#a11">rt_pipe_read()</a> always preserves message boundaries, which means that all data sent through the same write(2) operation on the user-space side will be gathered in a single message by this service.<p>
Unless otherwise specified, the caller is blocked for a given amount of time if no data is immediately available on entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to read from.</td></tr>
    <tr><td valign=top><em>msgp</em>&nbsp;</td><td>A pointer to a memory location which will be written upon success with the address of the received message. Once consumed, the message space should be freed using <a class="el" href="group__pipe.html#a16">rt_pipe_free()</a>. The application code can retrieve the actual data and size carried by the message by respectively using the RT_PIPE_MSGPTR() and RT_PIPE_MSGSIZE() macros.</td></tr>
    <tr><td valign=top><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for some message to arrive (see note). Passing RT_TIME_INFINITE causes the caller to block indefinitely until some data is eventually available. Passing RT_TIME_NONBLOCK causes the service to return immediately without waiting if no data is available on entry.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of read bytes available from the received message is returned upon success; this value will be equal to RT_PIPE_MSGSIZE(*msgp). Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if <em>timeout</em> is different from RT_TIME_NONBLOCK and no data is available within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to RT_TIME_NONBLOCK and no data is immediately available on entry.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#a15">rt_task_unblock()</a> has been called for the waiting task before any data was available.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure if no data is available on entry and <em>timeout</em> is different from RT_TIME_NONBLOCK.<p>
Context: This routine can be called on behalf of a task. It can also be called on behalf of an interrupt context or from the initialization code provided <em>timeout</em> is equal to RT_TIME_NONBLOCK.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__timer.html#a6">rt_timer_start()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed in nanoseconds. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="pipe.c::rt_pipe_stream" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_pipe_stream </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_PIPE *&nbsp;</td>
          <td class="mdname" nowrap> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stream bytes to a pipe. 
<p>
This service writes a sequence of bytes to be received by the user-space side of the pipe. Unlike <a class="el" href="group__pipe.html#a12">rt_pipe_write()</a>, this service does not preserve message boundaries. Instead, an internal buffer is filled on the fly with the data. The actual sending may be delayed until the internal buffer is full, or the Linux kernel is re-entered after the real-time kernel enters a quiescent state.<p>
Data buffers sent by the <a class="el" href="group__pipe.html#a13">rt_pipe_stream()</a> service are always transmitted in FIFO order (i.e. RT_PIPE_NORMAL mode).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to write to.</td></tr>
    <tr><td valign=top><em>buf</em>&nbsp;</td><td>The address of the first data byte to send. The data will be copied to an internal buffer before emission.</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>The size in bytes of the buffer. Zero is a valid value, in which case the service returns immediately without buffering any data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of sent bytes upon success; this value will be equal to <em>size</em>. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EIO is returned if the user-space side of the pipe is not yet open.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li></ul>
<p>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="pipe.c::rt_pipe_write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_pipe_write </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_PIPE *&nbsp;</td>
          <td class="mdname" nowrap> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RT_PIPE_MSG *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write a message to a pipe. 
<p>
This service writes a complete message to be received by the user-space side of the pipe. <a class="el" href="group__pipe.html#a12">rt_pipe_write()</a> always preserves message boundaries, which means that all data sent through a single call of this service will be gathered in a single read(2) operation on the user-space side.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to write to.</td></tr>
    <tr><td valign=top><em>msg</em>&nbsp;</td><td>The address of the message to be sent. The message space must have been allocated using the <a class="el" href="group__pipe.html#a15">rt_pipe_alloc()</a> service. Once passed to <a class="el" href="group__pipe.html#a12">rt_pipe_write()</a>, the memory pointed to by <em>msg</em> is no more under the control of the application code and thus should not be referenced by it anymore; deallocation of this memory will be automatically handled as needed.</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>The size in bytes of the message. Zero is a valid value, in which case the service returns immediately without sending any message.</td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td>A set of flags affecting the operation:</td></tr>
  </table>
</dl>
<ul>
<li>RT_PIPE_URGENT causes the message to be prepended to the output queue, ensuring a LIFO ordering.</li></ul>
<p>
<ul>
<li>RT_PIPE_NORMAL causes the message to be appended to the output queue, ensuring a FIFO ordering.</li></ul>
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Upon success, this service returns <em>size</em> if the latter is non-zero, or the number of bytes flushed otherwise. Upon error, one of the following error codes is returned:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EIO is returned if the user-space side of the pipe is not yet open.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li></ul>
<p>
Side-effect: <a class="el" href="group__pipe.html#a12">rt_pipe_write()</a> causes any data buffered by <a class="el" href="group__pipe.html#a13">rt_pipe_stream()</a> to be flushed prior to sending the message. For this reason, <a class="el" href="group__pipe.html#a12">rt_pipe_write()</a> can return a non-zero byte count to the caller if some pending data has been flushed, even if <em>size</em> was zero on entry.<p>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jun 30 17:31:16 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
