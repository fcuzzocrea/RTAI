<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Registry services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Registry services.<br>
<small>
[<a class="el" href="group__native.html">Native RTAI API.</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
The registry provides a mean to index real-time object descriptors created by the RTAI skin on unique alphanumeric keys. When labeled this way, a real-time object is globally exported; it can be searched for, and its descriptor returned to the caller for further use; the latter operation is called a "binding". When no object has been registered under the given name yet, the registry can be asked to set up a rendez-vous, blocking the caller until the object is eventually registered.<p>
The registry is a simple yet powerful mechanism for sharing real-time objects between kernel-based and user-space tasks, or between tasks belonging to different user-space processes. Once the binding has been done, an exported object can be controlled through the regular API using the ubiquitous descriptor returned by the registry.<p>
All high-level real-time objects created by the RTAI skin can be registered. The name parameter passed to the various object creation routines is used to have the new object indexed by the RTAI registry. Such registration is always optional though, and can be avoided by passing a null or empty name string. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="registry_8c.html">registry.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the RTAI project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga14">rt_registry_enter</a> (const char *key, void *objaddr, rt_handle_t *phandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a real-time object.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga15">rt_registry_bind</a> (const char *key, RTIME timeout, rt_handle_t *phandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind to a real-time object.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga16">rt_registry_remove</a> (rt_handle_t handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forcibly unregister a real-time object.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga17">rt_registry_remove_safe</a> (rt_handle_t handle, RTIME timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister an idle real-time object.  <a href="#ga17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga18">rt_registry_get</a> (rt_handle_t handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find and lock a real-time object into the registry.  <a href="#ga18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u_long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga19">rt_registry_put</a> (rt_handle_t handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a real-time object from the registry.  <a href="#ga19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registry.html#ga20">rt_registry_fetch</a> (rt_handle_t handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a real-time object into the registry.  <a href="#ga20"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga15" doxytag="registry.c::rt_registry_bind"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_registry_bind           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>rt_handle_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>phandle</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bind to a real-time object. 
<p>
This service retrieves the registry handle of a given object identified by its key. Unless otherwise specified, this service will block the caller if the object is not registered yet, waiting for such registration to occur.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>A valid NULL-terminated string which identifies the object to bind to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing RT_TIME_INFINITE causes the caller to block indefinitely until the object is registered. Passing RT_TIME_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phandle</em>&nbsp;</td><td>A pointer to a memory location which will be written upon success with the generic handle defined by the registry for the retrieved object. Contents of this memory is undefined on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>key</em> is NULL.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga15">rt_task_unblock()</a> has been called for the waiting task before the retrieval has completed.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to RT_TIME_NONBLOCK and the searched object is not registered on entry.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine only if <em>timeout</em> is equal to RT_TIME_NONBLOCK.</li></ul>
<p>
<ul>
<li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__native__timer.html#ga6">rt_timer_start()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed in nanoseconds. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="registry.c::rt_registry_enter"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_registry_enter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>objaddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>rt_handle_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>phandle</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a real-time object. 
<p>
This service allocates a new registry slot for an associated object, and indexes it by an alphanumeric key for later retrieval.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>A valid NULL-terminated string by which the object will be indexed and later retrieved in the registry. Since it is assumed that such key is stored into the registered object, it will *not* be copied but only kept by reference in the registry.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objaddr</em>&nbsp;</td><td>An opaque pointer to the object to index by <em>key</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phandle</em>&nbsp;</td><td>A pointer to a generic handle defined by the registry which will uniquely identify the indexed object, until the latter is unregistered using the <a class="el" href="group__registry.html#ga16">rt_registry_remove()</a> service.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>key</em> or <em>objaddr</em> are NULL.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the object.</li></ul>
<p>
<ul>
<li>-EEXIST is returned if the <em>key</em> is already in use.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga20" doxytag="registry.c::rt_registry_fetch"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u_long rt_registry_fetch           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rt_handle_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>handle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find a real-time object into the registry. 
<p>
This service retrieves an object from its handle into the registry and returns the memory address of its descriptor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The generic handle of the object to fetch. If RT_REGISTRY_SELF is passed, the object is the calling RTAI task.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The memory address of the object's descriptor is returned on success. Otherwise, NULL is returned if <em>handle</em> does not reference a registered object.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine only if <em>handle</em> is different from RT_REGISTRY_SELF.</li></ul>
<p>
<ul>
<li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga18" doxytag="registry.c::rt_registry_get"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void * rt_registry_get           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rt_handle_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>handle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find and lock a real-time object into the registry. 
<p>
This service retrieves an object from its handle into the registry and prevents it deletion atomically. A locking count is tracked, so that <a class="el" href="group__registry.html#ga18">rt_registry_get()</a> and <a class="el" href="group__registry.html#ga19">rt_registry_put()</a> must be used in pair.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The generic handle of the object to find and lock. If RT_REGISTRY_SELF is passed, the object is the calling RTAI task.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The memory address of the object's descriptor is returned on success. Otherwise, NULL is returned if <em>handle</em> does not reference a registered object.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine only if <em>handle</em> is different from RT_REGISTRY_SELF.</li></ul>
<p>
<ul>
<li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga19" doxytag="registry.c::rt_registry_put"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u_long rt_registry_put           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rt_handle_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>handle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock a real-time object from the registry. 
<p>
This service decrements the lock count of a registered object previously locked by a call to <a class="el" href="group__registry.html#ga18">rt_registry_get()</a>. The object is actually unlocked from the registry when the locking count falls down to zero, thus waking up any task currently waiting inside <a class="el" href="group__registry.html#ga16">rt_registry_remove()</a> for unregistering it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The generic handle of the object to unlock. If RT_REGISTRY_SELF is passed, the object is the calling RTAI task.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The decremented lock count is returned upon success. Zero is also returned if <em>handle</em> does not reference a registered object.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine only if <em>handle</em> is different from RT_REGISTRY_SELF.</li></ul>
<p>
<ul>
<li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible if the lock count falls down to zero and some task is currently waiting for the object to be unlocked.     </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="registry.c::rt_registry_remove"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_registry_remove           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rt_handle_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>handle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Forcibly unregister a real-time object. 
<p>
This service forcibly removes an object from the registry. The removal is performed regardless of the current object's locking status.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The generic handle of the object to remove.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOENT is returned if <em>handle</em> does not reference a registered object.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga17" doxytag="registry.c::rt_registry_remove_safe"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_registry_remove_safe           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rt_handle_t&nbsp;</td>
          <td class="mdname" nowrap> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unregister an idle real-time object. 
<p>
This service removes an object from the registry. The caller might sleep as a result of waiting for the target object to be unlocked prior to the removal (see <a class="el" href="group__registry.html#ga19">rt_registry_put()</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The generic handle of the object to remove.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>If the object is locked on entry, <em>param</em> gives the number of clock ticks to wait for the unlocking to occur (see note). Passing RT_TIME_INFINITE causes the caller to block indefinitely until the object is unlocked. Passing RT_TIME_NONBLOCK causes the service to return immediately without waiting if the object is locked on entry.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOENT is returned if <em>handle</em> does not reference a registered object.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to RT_TIME_NONBLOCK and the object is locked on entry.</li></ul>
<p>
<ul>
<li>-EBUSY is returned if <em>handle</em> refers to a locked object and the caller could not sleep until it is unlocked.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if the object cannot be removed within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga15">rt_task_unblock()</a> has been called for the calling task waiting for the object to be unlocked.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine only if <em>timeout</em> is equal to RT_TIME_NONBLOCK.</li></ul>
<p>
<ul>
<li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible if the object to remove is currently locked and the calling context can sleep.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__native__timer.html#ga6">rt_timer_start()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed in nanoseconds. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Nov 19 18:53:36 2004 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
