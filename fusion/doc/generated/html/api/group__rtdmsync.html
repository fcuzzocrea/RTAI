<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI Fusion API: Synchronisation Services</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Synchronisation Services<br>
<small>
[<a class="el" href="group__driverapi.html">Driver Development API</a>]</small>
</h1>
<p>
Collaboration diagram for Synchronisation Services:<center><table><tr><td><img src="group__rtdmsync.png" border="0" alt="" usemap="#group____rtdmsync_map">
<map name="group____rtdmsync_map">
<area href="group__driverapi.html" shape="rect" coords="8,8,173,32" alt="">
</map></td></tr></table></center>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Global Lock across Scheduler Invocation</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga20">RTDM_EXECUTE_ATOMICALLY</a>(code_block)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute code block atomically.  <a href="#ga20"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Spinlock with Preemption Deactivation</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga21" doxytag="rtdmsync::RTDM_LOCK_UNLOCKED"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga21">RTDM_LOCK_UNLOCKED</a>&nbsp;&nbsp;&nbsp;SPIN_LOCK_UNLOCKED</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static lock initialisation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga22">rtdm_lock_init</a>(lock)&nbsp;&nbsp;&nbsp;spin_lock_init(lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamic lock initialisation.  <a href="#ga22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga23">rtdm_lock_get</a>(lock)&nbsp;&nbsp;&nbsp;rthal_spin_lock(lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire lock from non-preemptible contexts.  <a href="#ga23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga24">rtdm_lock_put</a>(lock)&nbsp;&nbsp;&nbsp;rthal_spin_unlock(lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release lock without preemption restoration.  <a href="#ga24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga25">rtdm_lock_get_irqsave</a>(lock, context)&nbsp;&nbsp;&nbsp;rthal_spin_lock_irqsave(lock, context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire lock and disable preemption.  <a href="#ga25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga26">rtdm_lock_put_irqrestore</a>(lock, context)&nbsp;&nbsp;&nbsp;rthal_spin_unlock_irqrestore(lock, context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release lock and restore preemption state.  <a href="#ga26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga27">rtdm_lock_irqsave</a>(context)&nbsp;&nbsp;&nbsp;rthal_local_irq_save(context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable preemption locally.  <a href="#ga27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga28">rtdm_lock_irqrestore</a>(context)&nbsp;&nbsp;&nbsp;rthal_local_irq_restore(context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore preemption state.  <a href="#ga28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga0" doxytag="rtdmsync::rtdm_lock_t"></a>
typedef spinlock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga0">rtdm_lock_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock variable. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga1" doxytag="rtdmsync::rtdm_lockctx_t"></a>
typedef unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga1">rtdm_lockctx_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Variable to save the context while holding a lock. <br></td></tr>
<tr><td colspan="2"><br><h2>Timeout Sequence Management</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga2">rtdm_toseq_init</a> (rtdm_toseq_t *timeout_seq, __s64 timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a timeout sequence.  <a href="#ga2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Event Services</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga3">rtdm_event_init</a> (rtdm_event_t *event, unsigned long pending)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise an event.  <a href="#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga4">rtdm_event_destroy</a> (rtdm_event_t *event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy an event.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga5">rtdm_event_pulse</a> (rtdm_event_t *event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal an event occurrence to currently listening waiters.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga6">rtdm_event_clear</a> (rtdm_event_t *event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear event state.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga7">rtdm_event_signal</a> (rtdm_event_t *event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal an event occurrence.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga8">rtdm_event_wait</a> (rtdm_event_t *event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on event occurrence.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga9">rtdm_event_timedwait</a> (rtdm_event_t *event, __s64 timeout, rtdm_toseq_t *timeout_seq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on event occurrence with timeout.  <a href="#ga9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Semaphore Services</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga10">rtdm_sem_init</a> (rtdm_sem_t *sem, unsigned long value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a semaphore.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga11">rtdm_sem_destroy</a> (rtdm_sem_t *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a semaphore.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga12">rtdm_sem_down</a> (rtdm_sem_t *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrement a semaphore.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga13">rtdm_sem_timeddown</a> (rtdm_sem_t *sem, __s64 timeout, rtdm_toseq_t *timeout_seq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrement a semaphore with timeout.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga14">rtdm_sem_up</a> (rtdm_sem_t *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment a semaphore.  <a href="#ga14"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Mutex Services</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga15">rtdm_mutex_init</a> (rtdm_mutex_t *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a mutex.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga16">rtdm_mutex_destroy</a> (rtdm_mutex_t *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a mutex.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga17">rtdm_mutex_lock</a> (rtdm_mutex_t *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a mutex.  <a href="#ga17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga18">rtdm_mutex_timedlock</a> (rtdm_mutex_t *mutex, __s64 timeout, rtdm_toseq_t *timeout_seq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a mutex with timeout.  <a href="#ga18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga19">rtdm_mutex_unlock</a> (rtdm_mutex_t *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a mutex.  <a href="#ga19"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ga20" doxytag="rtdm_driver.h::RTDM_EXECUTE_ATOMICALLY"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define RTDM_EXECUTE_ATOMICALLY          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">code_block&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                                           \
    spl_t   s;                                                              \
                                                                            \
    xnlock_get_irqsave(&amp;nklock, s);                                         \
    code_block;                                                             \
    xnlock_put_irqrestore(&amp;nklock, s);                                      \
}
</pre></div>Execute code block atomically. 
<p>
Generally, it is illegal to suspend the current task by calling <a class="el" href="group__rtdmtask.html#ga10">rtdm_task_sleep()</a>, <a class="el" href="group__rtdmsync.html#ga8">rtdm_event_wait()</a>, etc. while holding a spinlock. In contrast, this macro allows to combine several operations including potentially rescheduling calls to an atomic code block with respect to other <a class="el" href="group__rtdmsync.html#ga20">RTDM_EXECUTE_ATOMICALLY()</a> blocks. The macro is a light-weight alternative for protecting code blocks via mutexes, and it can even be used to synchronise real-time and non-real-time contexts.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>code_block</em>&nbsp;</td><td>Commands to be executed atomically</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>It is not allowed to leave the code block explicitely by using <code>break</code>, <code>return</code>, <code>goto</code>, etc. This would leave the global lock held during the code block execution in an inconsistent state. Moreover, do not embed complex operations into the code bock. Consider that they will be executed under preemption lock with interrupts switched-off.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible, depends on functions called within <em>code_block</em>.     </td>
  </tr>
</table>
<a class="anchor" name="ga23" doxytag="rtdm_driver.h::rtdm_lock_get"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtdm_lock_get          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">lock&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rthal_spin_lock(lock)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire lock from non-preemptible contexts. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga25" doxytag="rtdm_driver.h::rtdm_lock_get_irqsave"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtdm_lock_get_irqsave          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">lock,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>context&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rthal_spin_lock_irqsave(lock, context)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire lock and disable preemption. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable to store the context in</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga22" doxytag="rtdm_driver.h::rtdm_lock_init"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtdm_lock_init          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">lock&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;spin_lock_init(lock)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dynamic lock initialisation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga28" doxytag="rtdm_driver.h::rtdm_lock_irqrestore"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtdm_lock_irqrestore          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">context&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rthal_local_irq_restore(context)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restore preemption state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable which stored the context</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga27" doxytag="rtdm_driver.h::rtdm_lock_irqsave"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtdm_lock_irqsave          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">context&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rthal_local_irq_save(context)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disable preemption locally. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable to store the context in</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga24" doxytag="rtdm_driver.h::rtdm_lock_put"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtdm_lock_put          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">lock&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rthal_spin_unlock(lock)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release lock without preemption restoration. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga26" doxytag="rtdm_driver.h::rtdm_lock_put_irqrestore"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtdm_lock_put_irqrestore          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">lock,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>context&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rthal_spin_unlock_irqrestore(lock, context)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release lock and restore preemption state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable which stored the context</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga6" doxytag="drvlib.c::rtdm_event_clear"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_event_clear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_event_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>event</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear event state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#ga3">rtdm_event_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="drvlib.c::rtdm_event_destroy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_event_destroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_event_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>event</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy an event. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#ga3">rtdm_event_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="drvlib.c::rtdm_event_init"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_event_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_event_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>pending</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialise an event. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pending</em>&nbsp;</td><td>Non-zero if event shall be initialised as set, 0 otherwise</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="drvlib.c::rtdm_event_pulse"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_event_pulse           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_event_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>event</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signal an event occurrence to currently listening waiters. 
<p>
This function wakes up all current waiters of the given event, but it does not change the event state. Subsequently callers of <a class="el" href="group__rtdmsync.html#ga8">rtdm_event_wait()</a> or rtdm_event_wait_until() will therefore be blocked first.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#ga3">rtdm_event_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="drvlib.c::rtdm_event_signal"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_event_signal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_event_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>event</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signal an event occurrence. 
<p>
This function sets the given event and wakes up all current waiters. If no waiter is presently registered, the next call to <a class="el" href="group__rtdmsync.html#ga8">rtdm_event_wait()</a> or rtdm_event_wait_until() will return immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#ga3">rtdm_event_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="drvlib.c::rtdm_event_timedwait"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtdm_event_timedwait           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_event_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>__s64&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>rtdm_toseq_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout_seq</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait on event occurrence with timeout. 
<p>
This function waits or tests for the occurence of the given event, taking the provided timeout into account. On successful return, the event is reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#ga3">rtdm_event_init()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, 0 for infinite, or any negative value for non-blocking (test for event occurrence) </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#ga2">rtdm_toseq_init()</a> or rtdm_toseq_absinit(), or NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitely via <a class="el" href="group__rtdmtask.html#ga7">rtdm_task_unblock()</a>.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>event</em> has been destroyed.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="drvlib.c::rtdm_event_wait"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtdm_event_wait           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_event_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>event</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait on event occurrence. 
<p>
This is the light-weight version of <a class="el" href="group__rtdmsync.html#ga9">rtdm_event_timedwait()</a>, implying an infinite timeout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#ga3">rtdm_event_init()</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitely via <a class="el" href="group__rtdmtask.html#ga7">rtdm_task_unblock()</a>.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>event</em> has been destroyed.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="drvlib.c::rtdm_mutex_destroy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_mutex_destroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_mutex_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy a mutex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga15">rtdm_mutex_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="drvlib.c::rtdm_mutex_init"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_mutex_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_mutex_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialise a mutex. 
<p>
This function initalises a basic mutex with priority inversion protection. "Basic", as it does not allow a mutex owner to recursively lock the same mutex again.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga17" doxytag="drvlib.c::rtdm_mutex_lock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtdm_mutex_lock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_mutex_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request a mutex. 
<p>
This is the light-weight version of <a class="el" href="group__rtdmsync.html#ga18">rtdm_mutex_timedlock()</a>, implying an infinite timeout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga15">rtdm_mutex_init()</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EIDRM is returned if <em>mutex</em> has been destroyed.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga18" doxytag="drvlib.c::rtdm_mutex_timedlock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtdm_mutex_timedlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_mutex_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>__s64&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>rtdm_toseq_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout_seq</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request a mutex with timeout. 
<p>
This function tries to acquire the given mutex. If it is not available, the caller is blocked unless non-blocking operation was selected.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga15">rtdm_mutex_init()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, 0 for infinite, or any negative value for non-blocking operation </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#ga2">rtdm_toseq_init()</a> or rtdm_toseq_absinit(), or NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is negative and the semaphore value is currently not positive.</li></ul>
<p>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitely via <a class="el" href="group__rtdmtask.html#ga7">rtdm_task_unblock()</a>.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>mutex</em> has been destroyed.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga19" doxytag="drvlib.c::rtdm_mutex_unlock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_mutex_unlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_mutex_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release a mutex. 
<p>
This function releases the given mutex, waking up a potential waiter which was blocked upon <a class="el" href="group__rtdmsync.html#ga17">rtdm_mutex_lock()</a> or <a class="el" href="group__rtdmsync.html#ga18">rtdm_mutex_timedlock()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga15">rtdm_mutex_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="drvlib.c::rtdm_sem_destroy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_sem_destroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_sem_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy a semaphore. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#ga10">rtdm_sem_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="drvlib.c::rtdm_sem_down"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtdm_sem_down           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_sem_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Decrement a semaphore. 
<p>
This is the light-weight version of <a class="el" href="group__rtdmsync.html#ga13">rtdm_sem_timeddown()</a>, implying an infinite timeout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#ga10">rtdm_sem_init()</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitely via <a class="el" href="group__rtdmtask.html#ga7">rtdm_task_unblock()</a>.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>sem</em> has been destroyed.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="drvlib.c::rtdm_sem_init"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_sem_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_sem_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialise a semaphore. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Initial value of the semaphore</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="drvlib.c::rtdm_sem_timeddown"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtdm_sem_timeddown           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_sem_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>__s64&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>rtdm_toseq_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout_seq</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Decrement a semaphore with timeout. 
<p>
This function tries to decrement the given semphore's value if it is positive on entry. If not, the caller is blocked unless non-blocking operation was selected.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#ga10">rtdm_sem_init()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, 0 for infinite, or any negative value for non-blocking operation </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#ga2">rtdm_toseq_init()</a> or rtdm_toseq_absinit(), or NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is negative and the semaphore value is currently not positive.</li></ul>
<p>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitely via <a class="el" href="group__rtdmtask.html#ga7">rtdm_task_unblock()</a>.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>sem</em> has been destroyed.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="drvlib.c::rtdm_sem_up"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_sem_up           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_sem_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Increment a semaphore. 
<p>
This function increments the given semphore's value, waking up a potential waiter which was blocked upon <a class="el" href="group__rtdmsync.html#ga12">rtdm_sem_down()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#ga10">rtdm_sem_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="drvlib.c::rtdm_toseq_init"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtdm_toseq_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtdm_toseq_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout_seq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>__s64&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialise a timeout sequence. 
<p>
This service initialises a timeout sequence handle according to the given timeout value. Timeout sequences allow to maintain a continuous <em>timeout</em> across multiple calls of blocking synchronisation services. A typical application scenario is given below.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Timeout sequence handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, 0 for infinite, or any negative value for non-blocking</td></tr>
  </table>
</dl>
Application Scenario: <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> device_service_routine(...)
{
    rtdm_toseq_t timeout_seq;
    ...

    <a class="code" href="group__rtdmsync.html#ga2">rtdm_toseq_init</a>(&amp;timeout_seq, timeout);
    ...
    <span class="keywordflow">while</span> (received &lt; requested) {
        ret = <a class="code" href="group__rtdmsync.html#ga9">rtdm_event_timedwait</a>(&amp;data_available, timeout, &amp;timeout_seq);
        <span class="keywordflow">if</span> (ret &lt; 0)    <span class="comment">// including -ETIMEDOUT</span>
            <span class="keywordflow">break</span>;

        <span class="comment">// receive some data</span>
        ...
    }
    ...
}
</pre></div> Using a timeout sequence in such a scenario avoids that the user-provided relative <code>timeout</code> is restarted on every call to <a class="el" href="group__rtdmsync.html#ga9">rtdm_event_timedwait()</a>, potentially causing an overall delay that is larger than specified by <code>timeout</code>. Moreover, all functions supporting timeout sequences also interpret special timeout values (infinite and non-blocking), disburdening the driver developer from handling them separately.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Sep 1 23:09:42 2005 for RTAI Fusion API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
