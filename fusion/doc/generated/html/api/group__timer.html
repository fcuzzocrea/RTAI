<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Timer services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Timer services.<br>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>,&nbsp;<a class="el" href="group__native.html">Native RTAI API.</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
The Xenomai timer facility behaves slightly differently depending on the underlying system timer mode, i.e. periodic or aperiodic. In periodic mode, the hardware timer ticks periodically without any external programming (aside of the initial one which sets its period). In such a case, a BSD timer wheel (see "Redesigning the BSD Callout and Timer Facilities" by Adam M. Costello and George Varghese) is used to its full addressing capabilities.<p>
If the underlying timer source is aperiodic, we need to reprogram the next shot after each tick at hardware level, and we cannot count on a strictly periodic source. In such a case, the timer manager only uses a single slot (#0) from the wheel as a plain linked list, which is ordered by increasing timeout values of the running timers.<p>
Depending on the above mode, the timer object stores time values either as count of periodic ticks, or as count of CPU ticks. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skins_2rtai_2timer_8c.html">timer.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the RTAI project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga0">xntimer_init</a> (xntimer_t *timer, void(*handler)(void *cookie), void *cookie)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a timer object.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga1">xntimer_destroy</a> (xntimer_t *timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a timer object.  <a href="#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga4">xntimer_start</a> (xntimer_t *timer, xnticks_t value, xnticks_t interval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arm a timer.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga5">xntimer_stop</a> (xntimer_t *timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disarm a timer.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">xnticks_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga6">xntimer_get_date</a> (xntimer_t *timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the absolute expiration date.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">xnticks_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga7">xntimer_get_timeout</a> (xntimer_t *timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the relative expiration date.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga8">xntimer_do_timers</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process a timer tick.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga9">xntimer_freeze</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Freeze all timers.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SRTIME&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga10">rt_timer_ns2ticks</a> (SRTIME ns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert nanoseconds to internal clock ticks.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SRTIME&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga11">rt_timer_ticks2ns</a> (SRTIME ticks)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert internal clock ticks to nanoseconds.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga12">rt_timer_inquire</a> (RT_TIMER_INFO *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inquire about the timer.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RTIME&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga13">rt_timer_read</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current system time.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RTIME&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga14">rt_timer_tsc</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current TSC value.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga15">rt_timer_spin</a> (RTIME ns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Busy wait burning CPU cycles.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga16">rt_timer_start</a> (RTIME nstick)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the system timer.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga17">rt_timer_stop</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop the system timer.  <a href="#ga17"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga12" doxytag="timer.c::rt_timer_inquire"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_timer_inquire           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TIMER_INFO *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>info</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inquire about the timer. 
<p>
Return various information about the status of the system timer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The address of a structure the timer information will be written to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This service always returns 0.</dd></dl>
The information block returns the period and the current system date. The period can have the following values:<p>
<ul>
<li>RT_TIMER_UNSET is a special value indicating that the system timer is inactive. A call to <a class="el" href="group__timer.html#ga16">rt_timer_start()</a> activates it.</li></ul>
<p>
<ul>
<li>RT_TIMER_ONESHOT is a special value indicating that the timer has been set up in oneshot mode.</li></ul>
<p>
<ul>
<li>Any other period value indicates that the system timer is currently running in periodic mode; it is a count of nanoseconds representing the period of the timer, i.e. the duration of a periodic tick or "jiffy".</li></ul>
<p>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="timer.c::rt_timer_ns2ticks"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">SRTIME rt_timer_ns2ticks           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SRTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ns</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert nanoseconds to internal clock ticks. 
<p>
Convert a count of nanoseconds to internal clock ticks. This routine opearates on signed nanosecond values.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ns</em>&nbsp;</td><td>The count of nanoseconds to convert.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The corresponding value expressed in internal clock ticks (see note). If the system timer is inactive or operating in oneshot mode, this routine returns <em>ns</em> unmodified.</dd></dl>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__timer.html#ga16">rt_timer_start()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed as CPU ticks (e.g. TSC value). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="timer.c::rt_timer_read"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RTIME rt_timer_read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the current system time. 
<p>
Return the current time maintained by the system timer.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current time expressed in clock ticks (see note).</dd></dl>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__timer.html#ga16">rt_timer_start()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed in nanoseconds. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="timer.c::rt_timer_spin"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_timer_spin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ns</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Busy wait burning CPU cycles. 
<p>
Enter a busy waiting loop for a count of nanoseconds. The precision of this service largely depends on the availability of a time stamp counter on the current CPU.<p>
Since this service is usually called with interrupts enabled, the caller might be preempted by other real-time activities, therefore the actual delay might be longer than specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ns</em>&nbsp;</td><td>The time to wait expressed in nanoseconds.</td></tr>
  </table>
</dl>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="timer.c::rt_timer_start"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_timer_start           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>nstick</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start the system timer. 
<p>
The real-time kernel needs a time source to provide the time-related services to the RTAI tasks. <a class="el" href="group__timer.html#ga16">rt_timer_start()</a> sets the current operation mode of the system timer. On architectures that provide a oneshot-programmable time source, the system timer can operate either in oneshot or periodic mode. In oneshot mode, the underlying hardware will be reprogrammed after each clock tick so that the next one occurs after a (possibly non-constant) specified interval, at the expense of a larger overhead due to hardware programming duties. Periodic mode provides timing services at a lower programming cost when the underlying hardware is a true PIT (and not a simple decrementer), but at the expense of a lower precision since all delays are rounded up to the constant interval value used to program the timer.<p>
This service defines the time unit which will be relevant when specifying time intervals to the services taking timeout or delays as input parameters. In periodic mode, clock ticks will represent periodic jiffies. In oneshot mode, clock ticks will represent nanoseconds.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nstick</em>&nbsp;</td><td>The timer period in nanoseconds. If this parameter is equal to RT_TIMER_ONESHOT, the underlying hardware timer is set to operate in oneshot-programmable mode. In this mode, timing accuracy is higher - since it is not rounded to a constant time slice - at the expense of a lesser efficicency when many timers are simultaneously active. The oneshot mode gives better results in configuration involving a few tasks requesting timing services over different time scales that cannot be easily expressed as multiples of a single base tick, or would lead to a waste of high frequency periodical ticks.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if the timer has already been set. <a class="el" href="group__pod.html#ga22">xnpod_stop_timer()</a> must be issued before <a class="el" href="group__pod.html#ga21">xnpod_start_timer()</a> is called again.</li></ul>
<p>
<ul>
<li>-ENOSYS is returned if the underlying architecture does not support the requested oneshot timing.</li></ul>
<p>
Context: This routine can be called on behalf of a task or the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="ga17" doxytag="timer.c::rt_timer_stop"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_timer_stop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stop the system timer. 
<p>
This service stops the system timer previously started by a call to <a class="el" href="group__timer.html#ga16">rt_timer_start()</a>. Calling <a class="el" href="group__timer.html#ga17">rt_timer_stop()</a> whilst the system timer has not been started leads to a null-effect.<p>
Context: This routine can be called on behalf of a task or the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="timer.c::rt_timer_ticks2ns"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">SRTIME rt_timer_ticks2ns           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SRTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ticks</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert internal clock ticks to nanoseconds. 
<p>
Convert a count of internal clock ticks to nanoseconds. This routine opearates on signed tick values.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ticks</em>&nbsp;</td><td>The count of internal clock ticks to convert (see note).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The corresponding value expressed in nanoseconds.</dd></dl>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__timer.html#ga16">rt_timer_start()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed as CPU ticks (e.g. TSC value). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="timer.c::rt_timer_tsc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RTIME rt_timer_tsc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the current TSC value. 
<p>
Return the value of the time stamp counter (TSC) maintained by the CPU of the underlying architecture.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current value of the TSC.</dd></dl>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="timer.c::xntimer_destroy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void xntimer_destroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xntimer_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>timer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release a timer object. 
<p>
Destroys a timer. After it has been destroyed, all resources associated with the timer have been released. The timer is automatically deactivated before deletion if active on entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
</dl>
Context: This routine can be called on behalf of a thread or ISR.     </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="timer.c::xntimer_do_timers"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void xntimer_do_timers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Process a timer tick. 
<p>
<p><b>For internal use only.</b></p>
<p>
This routine informs all active timers that the clock has been updated by processing the timer wheel. Elapsed timer actions will be fired.<p>
Context: Called from ISR with nklock locked, interrupts off.<p>
<dl compact><dt><b>Note:</b></dt><dd>Only active timers are inserted into the timer wheel. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="timer.c::xntimer_freeze"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void xntimer_freeze           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Freeze all timers. 
<p>
<p><b>For internal use only.</b></p>
<p>
This routine deactivates all active timers atomically.<p>
Context: Called from ISR with nklock locked, interrupts off.<p>
<dl compact><dt><b>Note:</b></dt><dd>Always make sure the nklock is free when stopping the underlying timing source by calling xnarch_stop_timer(), otherwise, deadlock situations would arise on some architectures. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="timer.c::xntimer_get_date"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">xnticks_t xntimer_get_date           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xntimer_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>timer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the absolute expiration date. 
<p>
Return the next expiration date of a timer in absolute clock ticks (see note).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The expiration date converted to the current time unit. The special value XN_INFINITE is returned if <em>timer</em> is currently inactive.</dd></dl>
Context: This routine can be called on behalf of a thread or ISR.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__pod.html#ga21">xnpod_start_timer()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed in nanoseconds. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="timer.c::xntimer_get_timeout"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">xnticks_t xntimer_get_timeout           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xntimer_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>timer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the relative expiration date. 
<p>
Return the next expiration date of a timer in relative clock ticks (see note).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The expiration date converted to the current time unit. The special value XN_INFINITE is returned if <em>timer</em> is currently inactive. In oneshot mode, it might happen that the timer has already expired when this service is run (even if the associated handler has not been fired yet); in such a case, 1 is returned.</dd></dl>
Context: This routine can be called on behalf of a thread or ISR.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__pod.html#ga21">xnpod_start_timer()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed in nanoseconds. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga0" doxytag="timer.c::xntimer_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void xntimer_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xntimer_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void(*)(void *cookie)&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>cookie</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a timer object. 
<p>
Creates a timer. When created, a timer is left disarmed; it must be started using <a class="el" href="group__timer.html#ga4">xntimer_start()</a> in order to be activated.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a timer descriptor Xenomai will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The routine to call upon expiration of the timer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the nucleus will pass unmodified to the handler as its unique argument.</td></tr>
  </table>
</dl>
There is no limitation on the number of timers which can be created/active concurrently.<p>
Context: This routine can be called on behalf of a thread or ISR.     </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="timer.c::xntimer_start"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int xntimer_start           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xntimer_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>xnticks_t&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>xnticks_t&nbsp;</td>
          <td class="mdname" nowrap> <em>interval</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Arm a timer. 
<p>
Activates a timer so that the associated timeout handler will be fired after each expiration time. A timer can be either periodic or single-shot, depending on the reload value passed to this routine. The given timer must have been previously initialized by a call to <a class="el" href="group__timer.html#ga0">xntimer_init()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The relative date of the initial timer shot, expressed in clock ticks (see note).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>The reload value of the timer. It is a periodic interval value to be used for reprogramming the next timer shot, expressed in clock ticks (see note). If <em>interval</em> is equal to XN_INFINITE, the timer will not be reloaded after it has expired.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-EAGAIN is returned if the underlying time source is operating in one-shot mode and <em>value</em> is anterior to the current date.</li></ul>
<p>
Context: This routine can be called on behalf of a thread or ISR.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__pod.html#ga21">xnpod_start_timer()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed in nanoseconds. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="timer.c::xntimer_stop"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int xntimer_stop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xntimer_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>timer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disarm a timer. 
<p>
This service deactivates a timer previously armed using <a class="el" href="group__timer.html#ga4">xntimer_start()</a>. Once disarmed, the timer can be subsequently re-armed using the latter service.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
</dl>
Context: This routine can be called on behalf of a thread or ISR.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Oct 19 10:58:00 2004 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
