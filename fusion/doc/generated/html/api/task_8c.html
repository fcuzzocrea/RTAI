<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: task.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>skins/rtai/task.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This file is part of the RTAI project. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Copyright (C) 2004 Philippe Gerum &lt;<a href="mailto:rpm@xenomai.org">rpm@xenomai.org</a>&gt;</dd></dl>
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.<p>
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.<p>
You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
<p>

<p>
Include dependency graph for task.c:<p><center><img src="task_8c__incl.png" border="0" usemap="#task.c_map" alt="Include dependency graph"></center>
<map name="task.c_map">
<area href="task_8h.html" shape="rect" coords="251,223,318,242" alt="">
<area href="timer_8h.html" shape="rect" coords="341,154,413,172" alt="">
<area href="types_8h-source.html" shape="rect" coords="413,84,487,103" alt="">
<area href="registry_8h-source.html" shape="rect" coords="363,223,451,242" alt="">
</map>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a4">rt_task_create</a> (RT_TASK *task, const  char *name, int stksize, int prio, int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new real-time task. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a5">rt_task_start</a> (RT_TASK *task, void(*entry)(void *cookie), void *cookie)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start a real-time task. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a6">rt_task_suspend</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend a real-time task. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a7">rt_task_resume</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume a real-time task. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a8">rt_task_delete</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a real-time task. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a9">rt_task_yield</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manual round-robin. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a10">rt_task_set_periodic</a> (RT_TASK *task, RTIME idate, RTIME period)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a real-time task periodic. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a11">rt_task_wait_period</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the next periodic release point. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a12">rt_task_set_priority</a> (RT_TASK *task, int prio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the base priority of a real-time task. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a13">rt_task_sleep</a> (RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay the calling task (relative). </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a14">rt_task_sleep_until</a> (RTIME date)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay the calling task (absolute). </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a15">rt_task_unblock</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock a real-time task. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a16">rt_task_inquire</a> (RT_TASK *task, RT_TASK_INFO *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inquire about a real-time task. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="task_8c.html#a17">rt_task_add_hook</a> (int type, void(*routine)(void *cookie))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a task hook. </em> <a href="#a17"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a17" doxytag="task.c::rt_task_add_hook" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_add_hook </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>routine</em>)(void *cookie)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Install a task hook. 
<p>
The real-time kernel allows to register user-defined routines which get called whenever a specific scheduling event occurs. Multiple hooks can be chained for a single event type, and get called on a FIFO basis.<p>
The scheduling is locked while a hook is executing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>type</em>&nbsp;</td><td>Defines the kind of hook to install:</td></tr>
  </table>
</dl>
<ul>
<li>RT_HOOK_TSTART: The user-defined routine will be called on behalf of the starter task whenever a new task starts. An opaque cookie is passed to the routine which can use it to retrieve the descriptor address of the started task through the <a class="el" href="task_8h.html#a13">RT_HOOK_TASKPTR()</a> macro.</li></ul>
<p>
<ul>
<li>RT_HOOK_TDELETE: The user-defined routine will be called on behalf of the deletor task whenever a task is deleted. An opaque cookie is passed to the routine which can use it to retrieve the descriptor address of the deleted task through the <a class="el" href="task_8h.html#a13">RT_HOOK_TASKPTR()</a> macro.</li></ul>
<p>
<ul>
<li>RT_HOOK_TSWITCH: The user-defined routine will be called on behalf of the resuming task whenever a context switch takes place. An opaque cookie is passed to the routine which can use it to retrieve the descriptor address of the task which has been switched in through the <a class="el" href="task_8h.html#a13">RT_HOOK_TASKPTR()</a> macro.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>routine</em>&nbsp;</td><td>The address of the user-supplied routine to call.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise, one of the following error codes indicates the cause of the failure:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>type</em> is incorrect.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if not enough memory is available from the system heap to add the new hook.</li></ul>
<p>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="task.c::rt_task_create" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_create </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>stksize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>prio</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new real-time task. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>The address of a task descriptor RTAI will use to store the task-related data. This descriptor must always be valid while the task is active therefore it must be allocated in permanent memory.</td></tr>
  </table>
</dl>
The task is left in an innocuous state until it is actually started by <a class="el" href="task_8c.html#a5">rt_task_start()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the task. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created task.</td></tr>
    <tr><td valign=top><em>stksize</em>&nbsp;</td><td>The size of the stack (in bytes) for the new task. If zero is passed, a reasonable pre-defined size will be substituted.</td></tr>
    <tr><td valign=top><em>prio</em>&nbsp;</td><td>The base priority of the new thread. This value must range from [1 .. 99] (inclusive) where 1 is the highest priority.</td></tr>
    <tr><td valign=top><em>mode</em>&nbsp;</td><td>The task creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new task:</td></tr>
  </table>
</dl>
<ul>
<li>T_FPU allows the task to use the FPU whenever available on the platform.</li></ul>
<p>
<ul>
<li>T_CPU(cpuid) makes the new task affine to CPU # <b>cpuid</b>. CPU identifiers range from 0 to CONFIG_RTAI_HW_NRCPUS - 1 (inclusive).</li></ul>
<p>
Passing T_FPU|T_CPU(1) in the <em>mode</em> parameter thus creates a task with FPU support enabled and which will be affine to CPU #1.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to create or register the task.</li></ul>
<p>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li></ul>
<p>
Context: This routine can be called on behalf of a task or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="task.c::rt_task_delete" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_delete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a real-time task. 
<p>
Terminate a task and release all the real-time kernel resources it currently holds. A task exists in the system since <a class="el" href="task_8c.html#a4">rt_task_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
The DELETE hooks are called on behalf of the calling context (if any). The information stored in the task control block remains valid until all hooks have been called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>The descriptor address of the affected task. If <em>task</em> is NULL, the current task is deleted.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor, or if <em>task</em> is NULL but not called from a task context.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure if the current task self-deletes.<p>
Context: This routine can always be called on behalf of a task. It can also be called on behalf of the initialization code provided <em>task</em> is non-NULL.     </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="task.c::rt_task_inquire" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_inquire </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RT_TASK_INFO *&nbsp;</td>
          <td class="mdname" nowrap> <em>info</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inquire about a real-time task. 
<p>
Return various information about the status of a given task.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>The descriptor address of the inquired task. If <em>task</em> is NULL, the current task is inquired.</td></tr>
    <tr><td valign=top><em>info</em>&nbsp;</td><td>The address of a structure the task information will be written to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned and status information is written to the structure pointed at by  upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor, or if <em>task</em> is NULL but not called from a task context.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li></ul>
<p>
Context: This routine can always be called on behalf of a task. It can also be called on behalf of an interrupt context or from the initialization code provided <em>task</em> is non-NULL.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="task.c::rt_task_resume" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_resume </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resume a real-time task. 
<p>
Forcibly resume the execution of a task which has been previously suspended by a call to <a class="el" href="task_8c.html#a6">rt_task_suspend()</a>.<p>
The suspension nesting count is decremented so that <a class="el" href="task_8c.html#a7">rt_task_resume()</a> will only resume the task if this count falls down to zero as a result of the current invocation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>The descriptor address of the affected task.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure if the suspension nesting level falls down to zero as a result of the current invocation.<p>
Context: This routine can be called on behalf of a task, interrupt context, or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="task.c::rt_task_set_periodic" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_set_periodic </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>idate</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>period</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a real-time task periodic. 
<p>
Make a task periodic by programing its first release point and its period in the processor time line. Subsequent calls to <a class="el" href="task_8c.html#a11">rt_task_wait_period()</a> will delay the task until the next periodic release point in the processor timeline is reached.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>The descriptor address of the affected task. This task is immediately delayed until the first periodic release point is reached. If <em>task</em> is NULL, the current task is set periodic.</td></tr>
    <tr><td valign=top><em>idate</em>&nbsp;</td><td>The initial (absolute) date of the first release point, expressed in clock ticks (see note). The affected task will be delayed until this point is reached.</td></tr>
    <tr><td valign=top><em>period</em>&nbsp;</td><td>The period of the task, expressed in clock ticks (see note).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if <em>idate</em> has already elapsed.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if the system timer has not been started using <a class="el" href="skins_2rtai_2timer_8c.html#a6">rt_timer_start()</a>.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure if the operation affects the current task and <em>idate</em> has not elapsed yet.<p>
Context: This routine can always be called on behalf of a task. It can also be called on behalf of the initialization code provided <em>task</em> is non-NULL.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="skins_2rtai_2timer_8c.html#a6">rt_timer_start()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed in nanoseconds. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="task.c::rt_task_set_priority" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_set_priority </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>prio</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the base priority of a real-time task. 
<p>
Changing the base priority does not affect the priority boost the target task might have obtained as a consequence of a previous priority inheritance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>The descriptor address of the affected task.</td></tr>
    <tr><td valign=top><em>prio</em>&nbsp;</td><td>The new task priority. This value must range from [1 .. 99] (inclusive) where 1 is the highest priority.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li></ul>
<p>
Side-effects:<p>
<ul>
<li>This service calls the rescheduling procedure.</li></ul>
<p>
<ul>
<li>Assigning the same priority to a running or ready task moves it to the end of its priority group, thus causing a manual round-robin.</li></ul>
<p>
Context: This routine can always be called on behalf of a task. It can also be called on behalf of an interrupt context or from the initialization code provided <em>task</em> is non-NULL.     </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="task.c::rt_task_sleep" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_sleep </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>delay</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delay the calling task (relative). 
<p>
Delay the execution of the calling task for a number of internal clock ticks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>delay</em>&nbsp;</td><td>The number of clock ticks to wait before resuming the task (see note). Passing zero causes the task to return immediately with no delay.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="task_8c.html#a15">rt_task_unblock()</a> has been called for the sleeping task before the sleep time has elapsed.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if the system timer is inactive.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure unless a null delay is given.<p>
Context: This routine can be called on behalf of a task.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="skins_2rtai_2timer_8c.html#a6">rt_timer_start()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed in nanoseconds. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="task.c::rt_task_sleep_until" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_sleep_until </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>date</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delay the calling task (absolute). 
<p>
Delay the execution of the calling task until a given date is reached.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>date</em>&nbsp;</td><td>The absolute date in clock ticks to wait before resuming the task (see note). Passing an already elapsed date causes the task to return immediately with no delay.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="task_8c.html#a15">rt_task_unblock()</a> has been called for the sleeping task before the sleep time has elapsed.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if <em>date</em> has already elapsed.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if the system timer is inactive.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure unless an already elapsed date is given.<p>
Context: This routine can be called on behalf of a task.<p>
<dl compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="skins_2rtai_2timer_8c.html#a6">rt_timer_start()</a> service. In periodic mode, clock ticks are expressed as periodic jiffies. In oneshot mode, clock ticks are expressed in nanoseconds. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="task.c::rt_task_start" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_start </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>entry</em>)(void *cookie), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>cookie</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start a real-time task. 
<p>
Start a (newly) created task, scheduling it for the first time. This call releases the target task from the dormant state.<p>
The START hooks are called on behalf of the calling context (if any, see <a class="el" href="task_8c.html#a17">rt_task_add_hook()</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>The descriptor address of the affected task which must have been previously created by the <a class="el" href="task_8c.html#a4">rt_task_create()</a> service.</td></tr>
    <tr><td valign=top><em>entry</em>&nbsp;</td><td>The address of the task's body routine. In other words, it is the task entry point.</td></tr>
    <tr><td valign=top><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the real-time kernel will pass to the emerging task as the sole argument of its entry point.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li></ul>
<p>
<ul>
<li>-EBUSY is returned if <em>task</em> is already started.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure.<p>
Context: This routine can be called on behalf of a task context or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="task.c::rt_task_suspend" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_suspend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Suspend a real-time task. 
<p>
Forcibly suspend the execution of a task. This task will not be eligible for scheduling until it is explicitly resumed by a call to <a class="el" href="task_8c.html#a7">rt_task_resume()</a>.<p>
A nesting count is maintained so that <a class="el" href="task_8c.html#a6">rt_task_suspend()</a> and <a class="el" href="task_8c.html#a7">rt_task_resume()</a> must be used in pairs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>The descriptor address of the affected task. If <em>task</em> is NULL, the current task is suspended.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor, or if <em>task</em> is NULL but not called from a task context.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure if the current task suspends itself.<p>
Context: This routine can always be called on behalf of a task. It can also be called on behalf of an interrupt context or from the initialization code provided <em>task</em> is non-NULL.     </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="task.c::rt_task_unblock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_unblock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unblock a real-time task. 
<p>
Break the task out of any wait it is currently in. This call clears all delay and/or resource wait condition for the target task. However, <a class="el" href="task_8c.html#a15">rt_task_unblock()</a> does not resume a task which has been forcibly suspended by a previous call to <a class="el" href="task_8c.html#a6">rt_task_suspend()</a>. If all suspensive conditions are gone, the task becomes eligible anew for scheduling.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>The descriptor address of the affected task.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li></ul>
<p>
Side-effects: This service calls the rescheduling procedure.<p>
Context: This routine can be called on behalf of a task, interrupt context or from the initialization code.     </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="task.c::rt_task_wait_period" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_wait_period </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for the next periodic release point. 
<p>
Make the current task wait for the next periodic release point in the processor time line.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <a class="el" href="task_8c.html#a10">rt_task_set_periodic()</a> has not previously been called for the calling task.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="task_8c.html#a15">rt_task_unblock()</a> has been called for the waiting task before the next periodic release point has been reached.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if a timer overrun occurred, which indicates that a previous release point has been missed by the calling task.</li></ul>
<p>
Side-effect: This routine calls the rescheduling procedure unless an overrun has been detected. In the latter case, the current task immediately returns from this service without being delayed.<p>
Context: This routine can be called on behalf of a task.     </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="task.c::rt_task_yield" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_yield </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Manual round-robin. 
<p>
Move the current task to the end of its priority group, so that the next equal-priority task in ready state is switched in.<p>
Side-effect: This routine calls the rescheduling procedure.<p>
Context: This routine can be called on behalf of a task.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Jun 18 17:10:15 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
