#!/bin/bash

myusage() {
    cat >&1 <<EOF
rtai-test [options]
  -w <number>	spawn N workloads (dd if=/dev/zero of=/dev/null) default=1
  -d <device>	used as alternate src in workload (dd if=$device ..)
		The device must be mounted, and (unfortunately) cannot
		be an NFS mount a real device (ex /dev/hda) will
		generate interrupts
  -W <script>   script is an alternate workload.  If you need to pass args
		to your program, use quotes.  The program must clean
		up its children when it gets a SIGTERM
   -L	     	writes to logfile (default "test-load-`uname -r`") (via script)
  -N <name>	same as -L, but prepend "$name-" (without -L, logname="$name-")
		prepending allows you to give a full path.

  # following options are passed thru to latency, klatency
  -s	print statistics of sampled data
  -h	print histogram of sampled data
  -q	quiet, no print 1 sec sampled data
  -T <sec test>
  -l <data/header lines>
  -H <bucketcount>
  -B <bucketsize ns>
EOF
exit 1
}

#set -e	# ctrl-C's should end everything, not just subshells. 
	# commenting it out may help to debug stuff.

set -o notify	# see dd's finish immediately.(or not!)

loudly() {
    # run task after announcing it
    echo;  date;
    echo running $PWD: $*
    $* &
    top -bn1c | head -$(( 12 + $workload ))
    wait
}

# defaults for cpu workload 
device=/dev/zero	
typeset -a dd_jobs
dd_jobs=()

# used in generate-loads
mkload() { exec dd if=$device of=/dev/null $* ; }

generate_loads() {
    local jobsct=$1; shift;

    reaper() { echo something died $*; }
    trap reaper CHLD
    trap cleanup_load EXIT	# under all exit conditions
    
    for (( ; $jobsct ; jobsct-- )) ; do
	mkload &
	dd_jobs[${#dd_jobs[*]}]=$!
    done;

    echo dd workload started, pids ${dd_jobs[*]}
}

cleanup_load() {
    # kill the workload
    echo killing workload pids ${dd_jobs[*]}
    kill ${dd_jobs[*]};
    unset dd_jobs;
}

run_w_load() {
    local opts="$*";
    [ "$opts"  = '' ] && opts='-q -s -T 10'

    cat /proc/interrupts
    generate_loads $workload
    (
	cd ../testsuite/latency
	loudly ./run -- -T 10 -s -l 5
	loudly ./run -- -h $opts
	
	cd ../klatency
	loudly ./run -- -T 10 -s -l 5
	loudly ./run -- -h $opts;
    )
    cat /proc/interrupts
}



if [ -f /proc/config.gz ] ; then

    # check/warn on problem configs
    
    eval `zgrep CONFIG_CPU_FREQ /proc/config.gz`;
    if [ ! -z "$CONFIG_CPU_FREQ" ] ; then
	echo "warning: CONFIG_CPU_FREQ=$CONFIG_CPU_FREQ may be problematic"
    fi

fi

workload=1	# default = 1 job
pass=		# pass thru to latency, klatency
loadpass=	# pass thru to subshell, ie: script -c "rtai-load $loadpass"
logfile=
logprefix=	# if both empty means no logging

while getopts 'd:shqT:l:H:B:uLN:w:W:' FOO ; do

    case $FOO in
	s|h|q)
	    pass="$pass -$FOO" ;;
	T|l|H|B)
	    pass="$pass -$FOO $OPTARG" ;;
	d) 
	    device=$OPTARG    
	    echo creating workload using dd if=$device
	    if !(mount | grep -q ^$device) ; then
		echo d option must be a block device, ie one of:
		mount | cut -d\  -f1 | egrep -ve 'sysfs|proc|depts'
		exit;
	    fi
	    loadpass="$loadpass -d $device"
	    ;;
	L)
	    logfile=test-load-`uname -r`  ;;
	N)
	    logprefix=$OPTARG ;;
	w)
	    workload=$OPTARG
	    loadpass="$loadpass -w $workload"  ;;
	W)
	    altwork="$OPTARG" ;;
	?)
	    myusage ;;
    esac
done

# all args have been handled, and split into 2 passthrus
shift $(($OPTIND - 1));


if [ "$logprefix$logfile" != "" ]; then
    # restart inside a script invocation, passing all
    script -c "./rtai-test $loadpass $pass $*" "$logprefix$logfile"
else
    if [ "$altwork" != "" ]; then
	mkload() { exec $altwork; }
    fi
    echo running $0 $pass $*
    run_w_load $pass $*
fi

exit;

#################################################


TODO:

get workload child reaper to work when child is killed from separate
window, or when it finishes, as a dd 'if=/dev/hda ...' will eventually
do.


add -W <program invocation>  (mostly works)

The program should generate a load that is appropriately demanding
upon cpu, interrupts, devices, etc.  

It should also work when invoked more than once, and scale the loads
reasonably linearly (since the -w will count by N).

Also, if it spawns subtasks, it should end them all when it gets SIGTERM.

Much more testing.  Heres a weak start..

#!/bin/bash
PATH=.:$PATH
rtai-test -L
rtai-test -N foo -T 18 -l 6 -s
rtai-test -L -N foo1-
rtai-test -N foo0 -w0 -l 5 -T 30 -h
rtai-test -L -N foo4- -w4
rtai-test -L -N foo4W- -w4 -W 'dd if=/dev/hda1 of=/dev/null'
