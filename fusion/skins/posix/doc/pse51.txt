Overview
========

The POSIX emulation module on top of RTAI/fusion aims at providing an
(almost) PSE51 compatible API. In order to help porting applications
from other PSE51 compatible APIS (like RTLinux) it will contain some
non portable extensions to the POSIX specification.

This skin already contains most basic features :
- threads,
- mutexes,
- semaphores,
- condition variables,
- basic support for then "reliable" signals (not realtime ones),
- cancellation, cancellation handlers
- thread specific data.

The POSIX skin creates real-time threads running either embodied into
kernel modules, or inside regular applications in user-space.


Known variations from the POSIX specification.
===============================================

The RTAI/fusion PSE51 skin was implemented following as closely as
possible the single unix specification V3, which can hence serve as a
documentation for its API. This specification can be accessed at the
following URL :

http://www.unix.org/single_unix_specification

However, you may observe some variations from the interfaces and behaviours
described in this specification. Here are the known ones :

- the skin header file does not define the _POSIX* compile-time constants ;
 
- nor does it defines the objects static initializers
  (PTHREAD_MUTEX_INITIALIZER, etc...) except for pthread_once_t ;

- manually setting the thread stack address in thread attributes is not
  supported ;

- thread attributes contain non portable extensions : 
  . pthread_attr_set/getfp_np to control whether the thread to be created will
  use the FPU,
  . pthread_attr_set/getname to choose the name of threads,
  . pthread_attr_set/getaffinity to set the threads processor affinity ;

- priority ceiling protocol is not supported, use priority inheritance instead ;

- simultaneous calls to pthread_join() specifying the same target thread simply
  locks all the callers until the target thread exits, is canceled or killed.

- most functions should be asynchronous signal safe.


Use of the POSIX skin from user-space applications
==================================================

In user-space, deterministic replacements are provided for critical
services of Linux's native POSIX interface. System calls to these
services implemented in kernel space by the POSIX skin are contained
into the libpthread_rt.so library built from the lib/ sub-directory
contents, and are aimed at shadowing the original Linux calls for the
application, either from the LinuxThreads or NPTL libraries.

Native POSIX services which do not require any interaction with the
Linux kernel (e.g. pthread_mutexattr_*) and/or do not involve
time-critical issues for their callers (e.g. pthread_exit()), are not
overriden by the POSIX support in user-space, but can instead be used
directly and seamlessly by the application.

The list of shadowed POSIX services is available from the file
lib/posix.wrappers.

--------------------------------------------------------------------
Building an application which uses the real-time POSIX support
requires using the proper compilation and link flags returned by the
'rtai-config' script (default location is
/usr/realtime/bin/rtai-config). You should have a look at the demos/
sub-directory, which contains a small Makefile illustrating the use of
such script on a simple code example.
--------------------------------------------------------------------

Original (i.e. un-shadowed) calls can still be invoked from the
application, by prefixing their name with
"__real_". E.g. __real_sem_init() calls the original initialization
routine for semaphores as provided by the LinuxThreads/NPTL
implementation. All services listed in lib/posix.wrappers are
substituted with their RTAI replacement when invoked through their
vanilla names.

Caveat: Use of the static initializers PTHREAD_MUTEX_INITIALIZER and
PTHREAD_COND_INITIALIZER in setting up mutex and condition variable
replacements is invalid; dynamic initialization through the
pthread_mutex_init() and pthread_cond_init() routines must be used
instead, otherwise, mutex and condition variable-related calls would
always return an error status (EINVAL).


Undefined behaviour.
=====================

Some special cases are not covered by the POSIX specification or described as
being "undefined", but some implementation decisions had to be made :

- trying to post a semaphore whose count is already SEM_VALUE_MAX returns
  EINVAL ;

- pthread_equal simply compares the two pthread_t, which are pointers, no
  attempts is made to verify whether the corresponding threads exist.



TODO List
==========

The PSE51 skin is still a work in progress, it lacks some features which will be 
added gradually :
- RTLinux non portable extensions ;
- CLOCK_REALTIME support (the only clock supported is CLOCK_MONOTONIC for now,
  which does not make any difference as long as clock_gettime does not get 
  called);
- spinlocks/rwlocks/barriers/message queues ;
- SA_SIGINFO sigaction flag, realtime signals ;
- timers.



Module parameters
=================

The following parameters can be passed at startup to the PSE51
API emulation module:

- "tick_hz_arg", clock tick period. Defaults to aperiodic.
