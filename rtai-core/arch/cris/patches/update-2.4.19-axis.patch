diff -Nur /home/starvik/download/kernel/linux-2.4.19/Documentation/Configure.help ./Documentation/Configure.help
--- /home/starvik/download/kernel/linux-2.4.19/Documentation/Configure.help	Sat Aug  3 02:39:42 2002
+++ ./Documentation/Configure.help	Wed Oct 23 12:28:59 2002
@@ -12771,9 +12771,9 @@
 
 Debugging RAM test driver
 CONFIG_MTD_MTDRAM
-  This enables a test MTD device driver which uses vmalloc() to
-  provide storage.  You probably want to say 'N' unless you're
-  testing stuff.
+  This enables a test MTD device driver which uses vmalloc()
+  or an absolute address to provide storage.  
+  You probably want to say 'N' unless you're testing stuff.
 
 MTDRAM erase block size in KB
 CONFIG_MTDRAM_ERASE_SIZE
@@ -12788,6 +12788,8 @@
   emulated by the MTDRAM driver.  If the MTDRAM driver is built
   as a module, it is also possible to specify this as a parameter when
   loading the module.
+  If you want to set the size and position at runtime, set to 0, 
+  in that case set the ABS_POS parameter to 0 as well.
 
 SRAM Hexadecimal Absolute position or 0
 CONFIG_MTDRAM_ABS_POS
@@ -23687,6 +23689,14 @@
 CONFIG_ETRAX_FLASH_BUSWIDTH
   Width in bytes of the Flash bus (1, 2 or 4). Is usually 2.
 
+Root filesystem device
+CONFIG_ETRAX_ROOT_DEVICE
+  Specifies the device that should be mounted as root filesystem
+  when booting from flash. The axisflashmap driver adds an additional
+  mtd partition for the appended root filesystem image, so this option
+  should normally be the mtdblock device for the partition after the
+  last partition in the partition table.
+
 # Choice: crisleds
 LED configuration on PA
 CONFIG_ETRAX_PA_LEDS
@@ -23836,6 +23846,28 @@
   For products with only one or two controllable LEDs,
   set this to same as CONFIG_ETRAX_LED1G (normally 2).
 
+Network LED behavior
+CONFIG_ETRAX_NETWORK_LED_ON_WHEN_LINK
+  Selecting LED_on_when_link will light the LED when there is a 
+  connection and will flash off when there is activity. 
+  
+  Selecting LED_on_when_activity will light the LED only when 
+  there is activity.
+  
+  This setting will also affect the behaviour of other activity LEDs 
+  e.g. Bluetooth. 
+
+Network LED behavior
+CONFIG_ETRAX_NETWORK_LED_ON_WHEN_ACTIVITY
+ Selecting LED_on_when_link will light the LED when there is a 
+  connection and will flash off when there is activity. 
+  
+  Selecting LED_on_when_activity will light the LED only when 
+  there is activity.
+  
+  This setting will also affect the behaviour of other activity LEDs 
+  e.g. Bluetooth. 
+
 Flash LED off during activity
 CONFIG_ETRAX_LED_OFF_DURING_ACTIVITY
   This option allows you to decide whether the network LED (and
@@ -23896,6 +23928,13 @@
   didn't before).  The kernel halts when it boots, waiting for gdb if
   this option is turned on!
 
+ETRAX fast timer API
+CONFIG_ETRAX_FAST_TIMER
+  This options enables the API to a fast timer implementation using
+  timer1 to get sub jiffie resolution timers (primarily one-shot 
+  timers).
+  This is needed if CONFIG_ETRAX_SERIAL_FAST_TIMER is enabled.
+
 Etrax bus waitstates
 CONFIG_ETRAX_DEF_R_WAITSTATES
   Waitstates for SRAM, Flash and peripherals (not DRAM).  95f8 is a
@@ -23969,9 +24008,23 @@
 
 Etrax General port B data
 CONFIG_ETRAX_DEF_R_PORT_PB_DATA
-  Configures the initial data for the general port A bits.  Most
+  Configures the initial data for the general port B bits.  Most
   products should use FF here.
 
+Etrax shutdown support
+CONFIG_ETRAX_SOFT_SHUTDOWN
+  Enable this if Etrax is used with a power-supply that can be turned
+  off and on with PS_ON signal. Gives the possibility to detect 
+  powerbutton and then do a power off after unmounting disks.
+
+Etrax shutdown support output
+CONFIG_ETRAX_SHUTDOWN_BIT
+  Configure what pin on CSPO-port that is used for controlling power supply.
+
+Etrax shutdown support input
+CONFIG_ETRAX_POWERBUTTON_BIT
+  Configure where power button is connected.    
+
 Etrax General port device
 CONFIG_ETRAX_GPIO
   Enables the Etrax general port device (major 120, minors 0 and 1).
@@ -24028,6 +24081,12 @@
   applications (e.g. PPP).  Maybe this should be more adaptive some
   day...
 
+Etrax Serial port ser0 support
+CONFIG_ETRAX_SERIAL_PORT0
+  Enables the ETRAX 100 serial driver for ser0 (ttyS0)
+  Normally you want this on, unless you use external DMA 1 that uses
+  the same DMA channels.
+
 Etrax Serial port ser0 DTR, RI, DSR and CD support on PB
 CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_PB
   Enables the status and control signals DTR, RI, DSR and CD on PB for
@@ -24139,7 +24198,7 @@
 
 Etrax100 I2C Support
 CONFIG_ETRAX_I2C
-  Enables an I2C driver on PB0 and PB1 on ETRAX100.
+  Enables an I2C driver on ETRAX100.
   EXAMPLE usage:
         i2c_arg = I2C_WRITEARG(STA013_WRITE_ADDR, reg, val);
        ioctl(fd, _IO(ETRAXI2C_IOCTYPE, I2C_WRITEREG), i2c_arg);
@@ -24154,6 +24213,14 @@
   I2C driver, like the DS1302 realtime-clock driver.  If you are
   uncertain, choose Y here.
 
+Etrax100 I2C data pin configuration
+CONFIG_ETRAX_I2C_DATA_PORT
+  Selects the pin on Port B where the data pin is connected
+
+Etrax100 I2C clock pin configuration
+CONFIG_ETRAX_I2C_CLK_PORT
+  Select the pin on Port B where the clock pin is connected
+
 Etrax100 I2C EEPROM (NVRAM) support
 CONFIG_ETRAX_I2C_EEPROM
   Enables I2C EEPROM (non-volatile RAM) on PB0 and PB1 using the I2C
@@ -24179,16 +24246,21 @@
   Options: Probed, 2k, 8k, 16k.
   (Probing works for 2k and 8k but not that well for 16k)
 
-Etrax DS1302 Real-Time Clock driver
-CONFIG_ETRAX_DS1302
-  Enables the driver for the DS1302 Real-Time Clock battery-backed
-  chip on some products.  The kernel reads the time when booting, and
+Etrax Real-Time Clock drivers
+CONFIG_ETRAX_RTC
+  Enables drivers for the Real-Time Clock battery-backed chips on 
+  some products. The kernel reads the time when booting, and
   the date can be set using ioctl(fd, RTC_SET_TIME, &rt) with rt a
   rtc_time struct (see <file:include/asm-cris/rtc.h>) on the /dev/rtc
   device, major 121.  You can check the time with cat /proc/rtc, but
   normal time reading should be done using libc function time and
   friends.
 
+Etrax DS1302 Real-Time Clock driver
+CONFIG_ETRAX_DS1302
+  Enables the driver for the DS1302 Real-Time Clock battery-backed
+  chip on some products. 
+
 Etrax DS1302 RST on the Generic Port
 CONFIG_ETRAX_DS1302_RST_ON_GENERIC_PORT
   If your product has the RST signal line for the DS1302 RTC on the
@@ -24212,6 +24284,32 @@
   This is the bit number for the SDA signal line of the DS1302 RTC on
   Port PB. This is probably best left at 2.
 
+Etrax DS1302 Trickle charger value
+CONFIG_ETRAX_DS1302_TRICKLE_CHARGE
+  This controls the initial value of the trickle charge register.
+  0 = disabled (use this if you are unsure or have a non rechargable battery)
+  Otherwise the following values can be OR:ed together to control the 
+  charge current:
+  1 = 2kohm, 2 = 4kohm, 3 = 4kohm
+  4 = 1 diode, 8 = 2 diodes
+  Allowed values are (increasing current): 0, 11, 10, 9, 7, 6, 5
+
+Etrax PCF8563 Real-Time Clock driver
+CONFIG_ETRAX_PCF8563
+  Enables the driver for the PCF8563 Real-Time Clock battery-backed
+  chip on some products.  
+
+Etrax 100 ATA/IDE support
+CONFIG_ETRAX_IDE
+  Enable this to get support for ATA/IDE.
+  You can't use parallell ports or SCSI ports
+  at the same time.
+
+Etrax 100 IDE delay
+CONFIG_ETRAX_IDE_DELAY
+  Number of seconds to wait for IDE drives to spin up after an IDE
+  reset.
+
 Etrax 100 IDE Reset
 CONFIG_ETRAX_IDE_CSP0_8_RESET
   Configures the pin used to reset the IDE bus.
@@ -24253,6 +24351,16 @@
   This option enables the ETRAX 100LX built-in 10/100Mbit Ethernet
   controller.
 
+ETRAX 100 Ethernet slave controller
+CONFIG_ETRAX_ETHERNET_LPSLAVE
+  This option enables a slave ETRAX 100 or ETRAX 100LX, connected to a 
+  master ETRAX 100 or ETRAX 100LX through par0 and par1, to act as an 
+  Ethernet controller.
+
+ETRAX 100 Ethernet slave controller LEDS
+CONFIG_ETRAX_ETHERNET_LPSLAVE_HAS_LEDS
+  Enable if the slave has it's own LEDs.
+
 ETRAX 100LX Synchronous serial ports
 CONFIG_ETRAX_SYNCHRONOUS_SERIAL
   This option enables support for the ETRAX 100LX built-in
@@ -24277,11 +24385,6 @@
 CONFIG_ETRAX_SYNCHRONOUS_SERIAL1_DMA
   Makes synchronous serial port 1 use DMA.
 
-Delay for drives to regain consciousness
-CONFIG_IDE_DELAY
-  Number of seconds to wait for IDE drives to spin up after an IDE
-  reset.
-
 ARTPEC-1 support
 CONFIG_JULIETTE
   The ARTPEC-1 is a video-compression chip used in the AXIS 2100
@@ -24307,6 +24410,12 @@
   Enable the built-in watchdog timer support on Etrax100 embedded
   network computers.
 
+Etrax100 watchdog
+CONFIG_ETRAX_WATCHDOG_NICE_DOGGY 
+  By enabling this you make sure that the watchdog does not bite while
+  printing oopses. Recommended for development systems but not for 
+  production releases.
+
 # Choice: crisdebug
 Serial-0
 CONFIG_ETRAX_DEBUG_PORT0
diff -Nur /home/starvik/download/kernel/linux-2.4.19/Documentation/cris/README ./Documentation/cris/README
--- /home/starvik/download/kernel/linux-2.4.19/Documentation/cris/README	Wed May  2 01:04:56 2001
+++ ./Documentation/cris/README	Wed Oct 23 12:28:59 2002
@@ -1,6 +1,6 @@
 Linux 2.4 on the CRIS architecture
 ==================================
-$Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+$Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
 
 This is a port of Linux 2.4 to Axis Communications ETRAX 100LX embedded 
 network CPU. For more information about CRIS and ETRAX please see further
@@ -103,7 +103,7 @@
 ETRAX 100LX 10/100MBit ethernet v2.0 (c) 2000 Axis Communications AB
 eth0 initialized
 eth0: changed MAC to 00:40:8C:CD:00:00
-ETRAX 100LX serial-driver $Revision: 1.1 $, (c) 2000 Axis Communications AB
+ETRAX 100LX serial-driver $Revision: 1.1 $, (c) 2000 Axis Communications AB
 ttyS0 at 0xb0000060 is a builtin UART with DMA
 ttyS1 at 0xb0000068 is a builtin UART with DMA
 ttyS2 at 0xb0000070 is a builtin UART with DMA
@@ -133,8 +133,7 @@
 Hostname is bbox1
 Telnetd starting, using port 23.
   using /bin/sash as shell.
-sftpd[15]: sftpd $Revision: 1.1 $ starting up
-
+sftpd[15]: sftpd $Revision: 1.1 $ starting up
 
 
 And here is how some /proc entries look:
@@ -181,9 +180,7 @@
 -rwxr-xr-x  1 342      100         48104  Jan 01 00:00 sh
 -rwxr-xr-x  1 342      100         16252  Jan 01 00:00 telnetd
 
-
-(All programs are statically linked to the libc at this point - we have not ported the
- shared libraries yet)
+(Statically linked binaries shown)
 
 
 
diff -Nur /home/starvik/download/kernel/linux-2.4.19/Documentation/filesystems/metafiles.txt ./Documentation/filesystems/metafiles.txt
--- /home/starvik/download/kernel/linux-2.4.19/Documentation/filesystems/metafiles.txt	Thu Jan  1 01:00:00 1970
+++ ./Documentation/filesystems/metafiles.txt	Wed Oct 23 12:28:59 2002
@@ -0,0 +1,92 @@
+Metafiles
+=========
+
+Metafiles are used to let a filesystem builder, such as mkcramfs and
+mkfs.jffs2, ignore files and change attributes of files while building
+the filesystem.
+
+This document briefly describes how Axis Communications are using metafiles
+with mkcramfs amd mkfs.jffs2 and is also a proposal of a metafile standard
+for filesystem builders.
+
+
+
+Metafile Format
+===============
+
+An instruction is a line in a metafile telling the filesystem builder if
+anything special should be done with a file or directory before writing it to
+the filesystem. The following instructions should be recognized by the
+filesystem builder:
+
+
+Ignore
+------
+Syntax: "Ignore: FILE"
+
+Ignores a file or directory. I.e. FILE is not included in the filesystem.
+The metafiles themselves are always ignored and do not have to be mentioned
+in any metafiles.
+
+
+IgnoreContents
+--------------
+Syntax: "IgnoreContents: DIRECTORY"
+
+Ignores the contents of a directory. I.e. DIRECTORY is included in the
+filesystem but all files and directories in DIRECTORY are ignored.
+
+
+Include
+-------
+Syntax: "Include: FILE"
+
+Includes a file or directory. If an Include instruction is found in a
+metafile, all files or directories (in the same directory as the metafile)
+that are not included will be ignored (NOTE!).
+
+
+Device
+------
+Syntax: "Device: FILE TYPE MAJOR MINOR"
+
+Convert a regular file to a device special file. If FILE exists it will be
+written to the filesystem as a character or block special file with
+MAJOR and MINOR numbers. TYPE is 'b' for block and 'c' for character device.
+
+Example: To create the character special file /dev/ttyS0 using metafiles,
+add the following line to the metafile in the /dev directory:
+
+Device: ttyS0 c 4 64
+
+
+UserId
+------
+Syntax: "UserId: FILE UID"
+
+Change file owner. The owner of FILE will be UID.
+
+
+DefaultUserId
+-------------
+Syntax: "DefaultUserId: UID"
+
+Change file owner recursively. All files and directories in this directory
+will be owned by UID unless overridden with the UserId instruction.
+
+
+GroupId
+-------
+Syntax: "GroupId: FILE GID"
+
+Change group ownership on a file or directory. The group membership of FILE
+will be GID.
+
+
+DefaultGroupId
+--------------
+Syntax: "DefaultGroupId: UID"
+
+Change gruop ownership recursively. The group membership of all files and
+directories in this directory will be GID unless overridden with the GroupId
+instruction.
diff -Nur /home/starvik/download/kernel/linux-2.4.19/Documentation/parisc/mm ./Documentation/parisc/mm
--- /home/starvik/download/kernel/linux-2.4.19/Documentation/parisc/mm	Thu Jan  1 01:00:00 1970
+++ ./Documentation/parisc/mm	Wed Oct 23 12:28:59 2002
@@ -0,0 +1,31 @@
+
+The current state of Linux/PA-RISC mm is BROKEN.
+
+Someone needs to sit down and thoroughly rewrite all the cache flushing
+macro definitions.  Here are some of the problems, followed by what I
+think needs to be done about them.
+
+(1) We're using fdce / fice everywhere.  This has to stop (except in
+the routines which flush the entire cache).  The right instructions to
+be using are fdc/fic.
+
+(2) fdc/fic will throw exceptions if the address they reference isn't
+mapped.  Therefore we need to check the page is mapped before flushing
+(we're guaranteed not to have the page dirty if we don't have a software
+mapping for it any longer, right?)
+
+(3) the flush macros are right now tunnelled down to one routine to flush
+the data cache and one routine to flush the insn cache.  this is wrong.
+we should take hints from how we're called and optimise our routines
+accordingly.
+
+(4) fdc/fic actually take space register arguments.  fic takes an 3-bit sr
+argument and fdc takes a 2-bit sr argument.  right now, there's a lot of
+pissing about with %sr1 and all the macros use %sr1.  This is crazy.  We
+normally _know_ what's being referred to, and it's the current task.  So
+if we want to flush that, just use %sr3.  If it happens to be kernel,
+use %sr0 for fdc and %sr4 for fic.
+
+(5) we need to write flush_kernel_dcache_range and use it on kernel
+addresses.  all the macros are defined to work on the _current task's_
+virtual address space.
diff -Nur /home/starvik/download/kernel/linux-2.4.19/Makefile ./Makefile
--- /home/starvik/download/kernel/linux-2.4.19/Makefile	Sat Aug  3 02:39:46 2002
+++ ./Makefile	Wed Oct 23 12:28:59 2002
@@ -5,7 +5,7 @@
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
-ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+ARCH := cris
 KERNELPATH=kernel-$(shell echo $(KERNELRELEASE) | sed -e "s/-//g")
 
 CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
@@ -19,7 +19,10 @@
 HOSTCC  	= gcc
 HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 
-CROSS_COMPILE 	=
+# Avoid having an absolute path here.  Ask whichever gcc-cris was
+# found in the PATH for the path to the assembler; use that directory.
+# Use a simple make variable to evaluate the test once only.
+CROSS_COMPILE 	:= $(shell dirname `gcc-cris -mlinux -print-prog-name=as`)/
 
 #
 # Include the make variables (CC, etc...)
diff -Nur /home/starvik/download/kernel/linux-2.4.19/README ./README
--- /home/starvik/download/kernel/linux-2.4.19/README	Sat Aug  3 02:39:42 2002
+++ ./README	Wed Oct 23 12:28:59 2002
@@ -150,12 +150,13 @@
 
 COMPILING the kernel:
 
- - Make sure you have gcc 2.95.3 available.  gcc 2.91.66 (egcs-1.1.2) may
+ - Make sure you have gcc-2.91.66 (egcs-1.1.2) available.  gcc 2.95.2 may
    also work but is not as safe, and *gcc 2.7.2.3 is no longer supported*.
    Also remember to upgrade your binutils package (for as/ld/nm and company)
    if necessary. For more information, refer to ./Documentation/Changes.
 
-   Please note that you can still run a.out user programs with this kernel.
+   Please note that you can still run a.out user programs with this
+   kernel.
 
  - Do a "make bzImage" to create a compressed kernel image.  If you want
    to make a boot disk (without root filesystem or LILO), insert a floppy
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/boot/compressed/decompress.ld ./arch/cris/boot/compressed/decompress.ld
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/boot/compressed/decompress.ld	Fri Jul 27 00:10:06 2001
+++ ./arch/cris/boot/compressed/decompress.ld	Wed Oct 23 12:28:59 2002
@@ -13,6 +13,7 @@
 		_stext = . ;
 		*(.text)
 		*(.rodata)
+		*(.rodata.*)
 		_etext = . ;
 	} > dram
 	.data :
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/boot/rescue/Makefile ./arch/cris/boot/rescue/Makefile
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/boot/rescue/Makefile	Mon Feb 25 20:37:52 2002
+++ ./arch/cris/boot/rescue/Makefile	Wed Oct 23 12:28:59 2002
@@ -53,7 +53,7 @@
 
 modules:
 
-modules-install:
+modules_install:
 
 depend:
 	$(CC) -M *.S > .depend
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/config.in ./arch/cris/config.in
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/config.in	Mon Feb 25 20:37:52 2002
+++ ./arch/cris/config.in	Wed Oct 23 12:28:59 2002
@@ -39,6 +39,8 @@
 	bool 'Disable watchdog during Oops printouts' CONFIG_ETRAX_WATCHDOG_NICE_DOGGY
 fi
 
+bool 'Enable ETRAX fast timer API' CONFIG_ETRAX_FAST_TIMER
+
 endmenu
 
 mainmenu_option next_comment
@@ -152,6 +154,11 @@
 
 source drivers/md/Config.in
 
+source drivers/pcmcia/Config.in
+if [ "$CONFIG_PCMCIA" != "n" ]; then
+   define_bool CONFIG_VIRTUAL_BUS y
+fi
+
 if [ "$CONFIG_NET" = "y" ]; then
   source net/Config.in
 fi
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/Config.in ./arch/cris/drivers/Config.in
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/Config.in	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/drivers/Config.in	Wed Oct 23 12:28:59 2002
@@ -23,50 +23,153 @@
 
 bool 'Serial-port support' CONFIG_ETRAX_SERIAL
 if [ "$CONFIG_ETRAX_SERIAL" = "y" ]; then
-#  bool '  Use fast timers for DMA flush and RS-485 timing' CONFIG_ETRAX_SERIAL_FAST_TIMER n
-  define_bool CONFIG_ETRAX_SERIAL_FAST_TIMER n
+  bool '  Use fast timers for serial DMA flush (experimental)' CONFIG_ETRAX_SERIAL_FAST_TIMER
   if [ "$CONFIG_ETRAX_SERIAL_FAST_TIMER" = "n" ]; then
     bool '  Fast serial port DMA flush' CONFIG_ETRAX_SERIAL_FLUSH_DMA_FAST
-    if [ "$CONFIG_ETRAX100_SERIAL_FLUSH_DMA_FAST" = "n" ]; then
+    if [ "$CONFIG_ETRAX_SERIAL_FLUSH_DMA_FAST" = "n" ]; then
       int '  Receive flush timeout (ticks) ' CONFIG_ETRAX_SERIAL_RX_TIMEOUT_TICKS 5
     fi
   fi
   bool '  Serial port 0 enabled' CONFIG_ETRAX_SERIAL_PORT0
   if [ "$CONFIG_ETRAX_SERIAL_PORT0" = "y" ]; then
-    bool '  Ser0 DTR, RI, DSR, CD on PB' CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_PB
-    if [ "$CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_PB" = "y" ]; then
-      int '    Ser0 DTR on PB bit' CONFIG_ETRAX_SER0_DTR_ON_PB_BIT 4
-      int '    Ser0 RI  on PB bit' CONFIG_ETRAX_SER0_RI_ON_PB_BIT 5
-      int '    Ser0 DSR on PB bit' CONFIG_ETRAX_SER0_DSR_ON_PB_BIT 6
-      int '    Ser0 CD  on PB bit' CONFIG_ETRAX_SER0_CD_ON_PB_BIT 7
+  choice 'Ser0 DTR, RI, DSR and CD assignment' \
+  "No_DTR_RI_DSR_CD      CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_NONE \
+   DTR_RI_DSR_CD_on_PA   CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_PA \
+   DTR_RI_DSR_CD_on_PB   CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_PB \
+   DTR_RI_DSR_CD_mixed_on_PA_and_PB  CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_MIXED" \
+     No_DTR_RI_DSR_CD
+
+    if [ "$CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_PA" = "y" -o \
+         "$CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_MIXED" = "y" ]; then
+      int '    Ser0 DTR on PA bit (-1 = not used)' CONFIG_ETRAX_SER0_DTR_ON_PA_BIT 4
+      int '    Ser0 RI  on PA bit (-1 = not used)' CONFIG_ETRAX_SER0_RI_ON_PA_BIT 5
+      int '    Ser0 DSR on PA bit (-1 = not used)' CONFIG_ETRAX_SER0_DSR_ON_PA_BIT 6
+      int '    Ser0 CD  on PA bit (-1 = not used)' CONFIG_ETRAX_SER0_CD_ON_PA_BIT 7
+    else
+      define_int CONFIG_ETRAX_SER0_DTR_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER0_RI_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER0_DSR_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER0_CD_ON_PA_BIT -1
+    fi
+    if [ "$CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_PB" = "y" -o \
+         "$CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_MIXED" = "y" ]; then
+      int '    Ser0 DTR on PB bit (-1 = not used)' CONFIG_ETRAX_SER0_DTR_ON_PB_BIT 4
+      int '    Ser0 RI  on PB bit (-1 = not used)' CONFIG_ETRAX_SER0_RI_ON_PB_BIT 5
+      int '    Ser0 DSR on PB bit (-1 = not used)' CONFIG_ETRAX_SER0_DSR_ON_PB_BIT 6
+      int '    Ser0 CD  on PB bit (-1 = not used)' CONFIG_ETRAX_SER0_CD_ON_PB_BIT 7
+    else
+      define_int CONFIG_ETRAX_SER0_DTR_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER0_RI_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER0_DSR_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER0_CD_ON_PB_BIT -1
     fi
   fi
 
   bool '  Serial port 1 enabled' CONFIG_ETRAX_SERIAL_PORT1
   if [ "$CONFIG_ETRAX_SERIAL_PORT1" = "y" ]; then
-    bool '  Ser1 DTR, RI, DSR, CD on PB' CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_ON_PB
-    if [ "$CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_ON_PB" = "y" ]; then
-      int '    Ser1 DTR on PB bit' CONFIG_ETRAX_SER1_DTR_ON_PB_BIT 4
-      int '    Ser1 RI  on PB bit' CONFIG_ETRAX_SER1_RI_ON_PB_BIT 5
-      int '    Ser1 DSR on PB bit' CONFIG_ETRAX_SER1_DSR_ON_PB_BIT 6
-      int '    Ser1 CD  on PB bit' CONFIG_ETRAX_SER1_CD_ON_PB_BIT 7
+  choice 'Ser1 DTR, RI, DSR and CD assignment' \
+  "No_DTR_RI_DSR_CD      CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_ON_NONE \
+   DTR_RI_DSR_CD_on_PA   CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_ON_PA \
+   DTR_RI_DSR_CD_on_PB   CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_ON_PB \
+   DTR_RI_DSR_CD_mixed_on_PA_and_PB  CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_MIXED" \
+     No_DTR_RI_DSR_CD
+
+    if [ "$CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_ON_PA" = "y" -o \
+         "$CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_MIXED" = "y" ]; then
+      int '    Ser1 DTR on PA bit (-1 = not used)' CONFIG_ETRAX_SER1_DTR_ON_PA_BIT 4
+      int '    Ser1 RI  on PA bit (-1 = not used)' CONFIG_ETRAX_SER1_RI_ON_PA_BIT 5
+      int '    Ser1 DSR on PA bit (-1 = not used)' CONFIG_ETRAX_SER1_DSR_ON_PA_BIT 6
+      int '    Ser1 CD  on PA bit (-1 = not used)' CONFIG_ETRAX_SER1_CD_ON_PA_BIT 7
+    else
+      define_int CONFIG_ETRAX_SER1_DTR_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER1_RI_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER1_DSR_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER1_CD_ON_PA_BIT -1
+    fi
+    if [ "$CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_ON_PB" = "y" -o \
+         "$CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_MIXED" = "y" ]; then
+      int '    Ser1 DTR on PB bit (-1 = not used)' CONFIG_ETRAX_SER1_DTR_ON_PB_BIT 4
+      int '    Ser1 RI  on PB bit (-1 = not used)' CONFIG_ETRAX_SER1_RI_ON_PB_BIT 5
+      int '    Ser1 DSR on PB bit (-1 = not used)' CONFIG_ETRAX_SER1_DSR_ON_PB_BIT 6
+      int '    Ser1 CD  on PB bit (-1 = not used)' CONFIG_ETRAX_SER1_CD_ON_PB_BIT 7
+    else
+      define_int CONFIG_ETRAX_SER1_DTR_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER1_RI_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER1_DSR_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER1_CD_ON_PB_BIT -1
     fi
   fi
+
   if [ "$CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_PB" = "y" -a \
        "$CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_ON_PB" = "y" ]; then
     comment 'Make sure you dont have the same PB bits more than once!'
   fi
   bool '  Serial port 2 enabled' CONFIG_ETRAX_SERIAL_PORT2
   if [ "$CONFIG_ETRAX_SERIAL_PORT2" = "y" ]; then
-    bool '    Ser2 DTR, RI, DSR, CD on PA' CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_ON_PA
-    if [ "$CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_ON_PA" = "y" ]; then
-      int '      Ser2 DTR on PA bit' CONFIG_ETRAX_SER2_DTR_ON_PA_BIT 4
-      int '      Ser2 RI  on PA bit' CONFIG_ETRAX_SER2_RI_ON_PA_BIT 5
-      int '      Ser2 DSR on PA bit' CONFIG_ETRAX_SER2_DSR_ON_PA_BIT 6
-      int '      Ser2 CD  on PA bit' CONFIG_ETRAX_SER2_CD_ON_PA_BIT 7
-    fi 
+  choice 'Ser2 DTR, RI, DSR and CD assignment' \
+  "No_DTR_RI_DSR_CD      CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_ON_NONE \
+   DTR_RI_DSR_CD_on_PA   CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_ON_PA \
+   DTR_RI_DSR_CD_on_PB   CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_ON_PB \
+   DTR_RI_DSR_CD_mixed_on_PA_and_PB  CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_MIXED" \
+     No_DTR_RI_DSR_CD
+    if [ "$CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_ON_PA" = "y" -o \
+         "$CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_MIXED" = "y" ]; then
+      int '    Ser2 DTR on PA bit (-1 = not used)' CONFIG_ETRAX_SER2_DTR_ON_PA_BIT 4
+      int '    Ser2 RI  on PA bit (-1 = not used)' CONFIG_ETRAX_SER2_RI_ON_PA_BIT 5
+      int '    Ser2 DSR on PA bit (-1 = not used)' CONFIG_ETRAX_SER2_DSR_ON_PA_BIT 6
+      int '    Ser2 CD  on PA bit (-1 = not used)' CONFIG_ETRAX_SER2_CD_ON_PA_BIT 7
+    else
+      define_int CONFIG_ETRAX_SER2_DTR_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER2_RI_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER2_DSR_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER2_CD_ON_PA_BIT -1
+    fi
+    if [ "$CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_ON_PB" = "y" -o \
+         "$CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_MIXED" = "y" ]; then
+      int '    Ser2 DTR on PB bit (-1 = not used)' CONFIG_ETRAX_SER2_DTR_ON_PB_BIT 4
+      int '    Ser2 RI  on PB bit (-1 = not used)' CONFIG_ETRAX_SER2_RI_ON_PB_BIT 5
+      int '    Ser2 DSR on PB bit (-1 = not used)' CONFIG_ETRAX_SER2_DSR_ON_PB_BIT 6
+      int '    Ser2 CD  on PB bit (-1 = not used)' CONFIG_ETRAX_SER2_CD_ON_PB_BIT 7
+    else
+      define_int CONFIG_ETRAX_SER2_DTR_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER2_RI_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER2_DSR_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER2_CD_ON_PB_BIT -1
+    fi
   fi
   bool '  Serial port 3 enabled' CONFIG_ETRAX_SERIAL_PORT3
+  if [ "$CONFIG_ETRAX_SERIAL_PORT3" = "y" ]; then
+  choice 'Ser3 DTR, RI, DSR and CD assignment' \
+  "No_DTR_RI_DSR_CD      CONFIG_ETRAX_SER3_DTR_RI_DSR_CD_ON_NONE \
+   DTR_RI_DSR_CD_on_PA   CONFIG_ETRAX_SER3_DTR_RI_DSR_CD_ON_PA \
+   DTR_RI_DSR_CD_on_PB   CONFIG_ETRAX_SER3_DTR_RI_DSR_CD_ON_PB \
+   DTR_RI_DSR_CD_mixed_on_PA_and_PB  CONFIG_ETRAX_SER3_DTR_RI_DSR_CD_MIXED" \
+     No_DTR_RI_DSR_CD
+    if [ "$CONFIG_ETRAX_SER3_DTR_RI_DSR_CD_ON_PA" = "y" -o \
+         "$CONFIG_ETRAX_SER3_DTR_RI_DSR_CD_MIXED" = "y" ]; then
+      int '    Ser3 DTR on PA bit (-1 = not used)' CONFIG_ETRAX_SER3_DTR_ON_PA_BIT -1
+      int '    Ser3 RI  on PA bit (-1 = not used)' CONFIG_ETRAX_SER3_RI_ON_PA_BIT -1
+      int '    Ser3 DSR on PA bit (-1 = not used)' CONFIG_ETRAX_SER3_DSR_ON_PA_BIT -1
+      int '    Ser3 CD  on PA bit (-1 = not used)' CONFIG_ETRAX_SER3_CD_ON_PA_BIT -1
+    else
+      define_int CONFIG_ETRAX_SER3_DTR_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER3_RI_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER3_DSR_ON_PA_BIT -1
+      define_int CONFIG_ETRAX_SER3_CD_ON_PA_BIT -1
+    fi
+    if [ "$CONFIG_ETRAX_SER3_DTR_RI_DSR_CD_ON_PB" = "y" -o \
+         "$CONFIG_ETRAX_SER3_DTR_RI_DSR_CD_MIXED" = "y" ]; then
+      int '    Ser3 DTR on PB bit (-1 = not used)' CONFIG_ETRAX_SER3_DTR_ON_PB_BIT -1
+      int '    Ser3 RI  on PB bit (-1 = not used)' CONFIG_ETRAX_SER3_RI_ON_PB_BIT -1
+      int '    Ser3 DSR on PB bit (-1 = not used)' CONFIG_ETRAX_SER3_DSR_ON_PB_BIT -1
+      int '    Ser3 CD  on PB bit (-1 = not used)' CONFIG_ETRAX_SER3_CD_ON_PB_BIT -1
+    else
+      define_int CONFIG_ETRAX_SER3_DTR_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER3_RI_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER3_DSR_ON_PB_BIT -1
+      define_int CONFIG_ETRAX_SER3_CD_ON_PB_BIT -1
+    fi
+  fi
   bool '  RS-485 support' CONFIG_ETRAX_RS485
   if [ "$CONFIG_ETRAX_RS485" = "y" ]; then
     bool '    RS-485 mode on PA' CONFIG_ETRAX_RS485_ON_PA
@@ -140,7 +243,6 @@
 	define_bool CONFIG_MTD y
 
 	define_bool CONFIG_MTD_CFI y
-	define_bool CONFIG_MTD_CFI_INTELEXT n
 	define_bool CONFIG_MTD_CFI_AMDSTD y
 
 	define_bool CONFIG_MTD_OBSOLETE_CHIPS y
@@ -149,6 +251,7 @@
 	define_bool CONFIG_MTD_CHAR y
 	define_bool CONFIG_MTD_BLOCK y
 	define_bool CONFIG_MTD_PARTITIONS y
+	define_bool CONFIG_MTD_CONCAT y
 fi
 
 bool 'I2C support' CONFIG_ETRAX_I2C
@@ -156,6 +259,11 @@
 # this is true for most products since PB-I2C seems to be somewhat
 # flawed.. 
 	bool 'I2C uses PB not PB-I2C' CONFIG_ETRAX_I2C_USES_PB_NOT_PB_I2C
+
+	if [ "$CONFIG_ETRAX_I2C_USES_PB_NOT_PB_I2C" = "y" ]; then
+          int '  I2C SDA bit number' CONFIG_ETRAX_I2C_DATA_PORT 0
+          int '  I2C SCL bit number' CONFIG_ETRAX_I2C_CLK_PORT 1
+	fi
 fi
 
 bool 'I2C EEPROM (non-volatile RAM) support' CONFIG_ETRAX_I2C_EEPROM
@@ -176,12 +284,6 @@
   hex  '  PB user changeable bits mask' CONFIG_ETRAX_PB_CHANGEABLE_BITS FF
 fi
 
-bool 'ARTPEC-1 support' CONFIG_JULIETTE
-
-if [ "$CONFIG_JULIETTE" = "y" ]; then
-
-fi
-
 bool 'USB host' CONFIG_ETRAX_USB_HOST
 if [ "$CONFIG_ETRAX_USB_HOST" = "y" ]; then
 	define_bool CONFIG_USB y
@@ -191,12 +293,19 @@
 	define_bool CONFIG_USB n
 fi
 
-bool 'DS1302 Real Time Clock support' CONFIG_ETRAX_DS1302
+bool 'Real Time Clock support' CONFIG_ETRAX_RTC
+if [ "$CONFIG_ETRAX_RTC" = "y" ]; then
+  choice '  RTC chip' \
+    "DS1302 CONFIG_ETRAX_DS1302 \
+     PCF8563  CONFIG_ETRAX_PCF8563" DS1302
+fi
+
 if [ "$CONFIG_ETRAX_DS1302" = "y" ]; then
   bool '  DS1302 RST on Generic Port' CONFIG_ETRAX_DS1302_RST_ON_GENERIC_PORT
   int '  DS1302 RST bit number' CONFIG_ETRAX_DS1302_RSTBIT 2
   int '  DS1302 SCL bit number' CONFIG_ETRAX_DS1302_SCLBIT 1
   int '  DS1302 SDA bit number' CONFIG_ETRAX_DS1302_SDABIT 0
+  int '  DS1302 Trickle charger value' CONFIG_ETRAX_DS1302_TRICKLE_CHARGE 0
 fi
 
 endmenu
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/axisflashmap.c ./arch/cris/drivers/axisflashmap.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/axisflashmap.c	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/drivers/axisflashmap.c	Wed Oct 23 12:28:59 2002
@@ -11,6 +11,26 @@
  * partition split defined below.
  *
  * $Log: update-2.4.19-axis.patch,v $
  * Revision 1.1  2004/06/06 14:10:20  rpm
  * Initial revision
  *
  * Revision 1.1  2004/01/02 15:11:03  pgerum
  * Add Axis update to 2.4.19
  *
+ * Revision 1.28  2002/10/01 08:08:43  jonashg
+ * The first partition ends at the start of the partition table.
+ *
+ * Revision 1.27  2002/08/21 09:23:13  jonashg
+ * Speling.
+ *
+ * Revision 1.26  2002/08/21 08:35:20  jonashg
+ * Cosmetic change to printouts.
+ *
+ * Revision 1.25  2002/08/21 08:15:42  jonashg
+ * Made it compile even without CONFIG_MTD_CONCAT defined.
+ *
+ * Revision 1.24  2002/08/20 13:12:35  jonashg
+ * * New approach to probing. Probe cse0 and cse1 separately and (mtd)concat
+ *   the results.
+ * * Removed compile time tests concerning how the mtdram driver has been
+ *   configured. The user will know about the misconfiguration at runtime
+ *   instead. (The old approach made it impossible to use mtdram for anything
+ *   else than RAM boot).
+ *
  * Revision 1.23  2002/05/13 12:12:28  johana
  * Allow compile without CONFIG_MTD_MTDRAM but warn at compiletime and
  * be informative at runtime.
@@ -98,13 +118,15 @@
 #include <linux/kernel.h>
 #include <linux/config.h>
 
-#include <linux/mtd/mtd.h>
+#include <linux/mtd/concat.h>
 #include <linux/mtd/map.h>
-#include <linux/mtd/partitions.h>
+#include <linux/mtd/mtd.h>
 #include <linux/mtd/mtdram.h>
+#include <linux/mtd/partitions.h>
 
 #include <asm/axisflashmap.h>
 #include <asm/mmu.h>
+#include <asm/sv_addr_ag.h>
 
 #ifdef CONFIG_CRIS_LOW_MAP
 #define FLASH_UNCACHED_ADDR  KSEG_8
@@ -114,63 +136,65 @@
 #define FLASH_CACHED_ADDR    KSEG_F
 #endif
 
-/*
- * WINDOW_SIZE is the total size where the flash chips may be mapped.
- * MTD probes should find all devices there and it does not matter
- * if there are unmapped gaps or aliases (mirrors of flash devices).
- * The MTD probes will ignore them.
- */
-
-#define WINDOW_SIZE  (128 * 1024 * 1024)
-
-extern unsigned long romfs_start, romfs_length, romfs_in_flash; /* From head.S */
+/* From head.S */
+extern unsigned long romfs_start, romfs_length, romfs_in_flash;
 
-/* 
- * Map driver
- *
- * We run into tricky coherence situations if we mix cached with uncached
- * accesses to we use the uncached version here.
- */
+/* Map driver functions. */
 
 static __u8 flash_read8(struct map_info *map, unsigned long ofs)
 {
-	return *(__u8 *)(FLASH_UNCACHED_ADDR + ofs);
+	return *(__u8 *)(map->map_priv_1 + ofs);
 }
 
 static __u16 flash_read16(struct map_info *map, unsigned long ofs)
 {
-	return *(__u16 *)(FLASH_UNCACHED_ADDR + ofs);
+	return *(__u16 *)(map->map_priv_1 + ofs);
 }
 
 static __u32 flash_read32(struct map_info *map, unsigned long ofs)
 {
-	return *(volatile unsigned int *)(FLASH_UNCACHED_ADDR + ofs);
+	return *(volatile unsigned int *)(map->map_priv_1 + ofs);
 }
 
 static void flash_copy_from(struct map_info *map, void *to,
 			    unsigned long from, ssize_t len)
 {
-	memcpy(to, (void *)(FLASH_UNCACHED_ADDR + from), len);
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
 }
 
 static void flash_write8(struct map_info *map, __u8 d, unsigned long adr)
 {
-	*(__u8 *)(FLASH_UNCACHED_ADDR + adr) = d;
+	*(__u8 *)(map->map_priv_1 + adr) = d;
 }
 
 static void flash_write16(struct map_info *map, __u16 d, unsigned long adr)
 {
-	*(__u16 *)(FLASH_UNCACHED_ADDR + adr) = d;
+	*(__u16 *)(map->map_priv_1 + adr) = d;
 }
 
 static void flash_write32(struct map_info *map, __u32 d, unsigned long adr)
 {
-	*(__u32 *)(FLASH_UNCACHED_ADDR + adr) = d;
+	*(__u32 *)(map->map_priv_1 + adr) = d;
 }
 
-static struct map_info axis_map = {
-	name: "Axis flash",
-	size: WINDOW_SIZE,
+/*
+ * The map for chip select e0.
+ *
+ * We run into tricky coherence situations if we mix cached with uncached
+ * accesses to we only use the uncached version here.
+ *
+ * The size field is the total size where the flash chips may be mapped on the
+ * chip select. MTD probes should find all devices there and it does not matter
+ * if there are unmapped gaps or aliases (mirrors of flash devices). The MTD
+ * probes will ignore them.
+ *
+ * The start address in map_priv_1 is in virtual memory so we cannot use
+ * MEM_CSE0_START but must rely on that FLASH_UNCACHED_ADDR is the start
+ * address of cse0.
+ */
+static struct map_info map_cse0 = {
+	name: "cse0",
+	size: MEM_CSE0_SIZE,
 	buswidth: CONFIG_ETRAX_FLASH_BUSWIDTH,
 	read8: flash_read8,
 	read16: flash_read16,
@@ -179,15 +203,35 @@
 	write8: flash_write8,
 	write16: flash_write16,
 	write32: flash_write32,
+	map_priv_1: FLASH_UNCACHED_ADDR
 };
 
-/* If no partition-table was found, we use this default-set.
+/*
+ * The map for chip select e1.
+ *
+ * If there was a gap between cse0 and cse1, map_priv_1 would get the wrong
+ * address, but there isn't.
  */
+static struct map_info map_cse1 = {
+	name: "cse1",
+	size: MEM_CSE1_SIZE,
+	buswidth: CONFIG_ETRAX_FLASH_BUSWIDTH,
+	read8: flash_read8,
+	read16: flash_read16,
+	read32: flash_read32,
+	copy_from: flash_copy_from,
+	write8: flash_write8,
+	write16: flash_write16,
+	write32: flash_write32,
+	map_priv_1: FLASH_UNCACHED_ADDR + MEM_CSE0_SIZE
+};
 
+/* If no partition-table was found, we use this default-set. */
 #define MAX_PARTITIONS         7  
 #define NUM_DEFAULT_PARTITIONS 3
 
-/* Default flash size is 2MB. CONFIG_ETRAX_PTABLE_SECTOR is most likely the
+/*
+ * Default flash size is 2MB. CONFIG_ETRAX_PTABLE_SECTOR is most likely the
  * size of one flash block and "filesystem"-partition needs 5 blocks to be able
  * to use JFFS.
  */
@@ -209,10 +253,11 @@
 	}
 };
 
+/* Initialize the ones normally used. */
 static struct mtd_partition axis_partitions[MAX_PARTITIONS] = {
 	{
 		name: "part0",
-		size: 0,
+		size: CONFIG_ETRAX_PTABLE_SECTOR,
 		offset: 0
 	},
 	{
@@ -247,48 +292,118 @@
 	},
 };
 
+/*
+ * Probe a chip select for AMD-compatible (JEDEC) or CFI-compatible flash
+ * chips in that order (because the amd_flash-driver is faster).
+ */
+static struct mtd_info *probe_cs(struct map_info *map_cs)
+{
+	struct mtd_info *mtd_cs = NULL;
+
+	printk("%s: Probing a 0x%08lx bytes large window at 0x%08lx.\n",
+	       map_cs->name, map_cs->size, map_cs->map_priv_1);
+
+#ifdef CONFIG_MTD_AMDSTD
+	mtd_cs = do_map_probe("amd_flash", map_cs);
+#endif
+#ifdef CONFIG_MTD_CFI
+	if (!mtd_cs) {
+		mtd_cs = do_map_probe("cfi_probe", map_cs);
+	}
+#endif
+
+	return mtd_cs;
+}
+
 /* 
- * This is the master MTD device for which all the others are just
- * auto-relocating aliases.
+ * Probe each chip select individually for flash chips. If there are chips on
+ * both cse0 and cse1, the mtd_info structs will be concatenated to one struct
+ * so that MTD partitions can cross chip boundries.
+ *
+ * The only known restriction to how you can mount your chips is that each
+ * chip select must hold similar flash chips. But you need external hardware
+ * to do that anyway and you can put totally different chips on cse0 and cse1
+ * so it isn't really much of a restriction.
  */
-static struct mtd_info *mymtd;
+static struct mtd_info *flash_probe(void)
+{
+	struct mtd_info *mtd_cse0;
+	struct mtd_info *mtd_cse1;
+	struct mtd_info *mtd_cse;
+
+	mtd_cse0 = probe_cs(&map_cse0);
+	mtd_cse1 = probe_cs(&map_cse1);
+
+	if (!mtd_cse0 && !mtd_cse1) {
+		/* No chip found. */
+		return NULL;
+	}
+
+	if (mtd_cse0 && mtd_cse1) {
+#ifdef CONFIG_MTD_CONCAT
+		struct mtd_info *mtds[] = { mtd_cse0, mtd_cse1 };
+		
+		/* Since the concatenation layer adds a small overhead we
+		 * could try to figure out if the chips in cse0 and cse1 are
+		 * identical and reprobe the whole cse0+cse1 window. But since
+		 * flash chips are slow, the overhead is relatively small.
+		 * So we use the MTD concatenation layer instead of further
+		 * complicating the probing procedure.
+		 */
+		mtd_cse = mtd_concat_create(mtds,
+					    sizeof(mtds) / sizeof(mtds[0]),
+					    "cse0+cse1");
+#else
+		printk(KERN_ERR "%s and %s: Cannot concatenate due to kernel "
+		       "(mis)configuration!\n", map_cse0.name, map_cse1.name);
+		mtd_cse = NULL;
+#endif
+		if (!mtd_cse) {
+			printk(KERN_ERR "%s and %s: Concatenation failed!\n",
+			       map_cse0.name, map_cse1.name);
+
+			/* The best we can do now is to only use what we found
+			 * at cse0.
+			 */ 
+			mtd_cse = mtd_cse0;
+			map_destroy(mtd_cse1);
+		}
+	} else {
+		mtd_cse = mtd_cse0? mtd_cse0 : mtd_cse1;
+	}
+
+	return mtd_cse;
+}
 
-/* CFI-scan the flash, and if there was a chip, read the partition-table
+/*
+ * Probe the flash chip(s) and, if it succeeds, read the partition-table
  * and register the partitions with MTD.
  */
-
-static int __init
-init_axis_flash(void)
+static int __init init_axis_flash(void)
 {
+	struct mtd_info *mymtd;
 	int err = 0;
 	int pidx = 0;
 	struct partitiontable_head *ptable_head;
 	struct partitiontable_entry *ptable;
-	int use_default_ptable = 1; /* Until proven otherwise */
-	const char *pmsg = "  /dev/flash%d at 0x%x, size 0x%x\n";
-
-	printk(KERN_NOTICE "Axis flash mapping: %x at %lx\n",
-	       WINDOW_SIZE, FLASH_CACHED_ADDR);
-#ifdef CONFIG_MTD_AMDSTD
-	mymtd = (struct mtd_info *)do_map_probe("amd_flash", &axis_map);
-#endif
+	int use_default_ptable = 1; /* Until proven otherwise. */
+	const char *pmsg = "  /dev/flash%d at 0x%08x, size 0x%08x\n";
 
-#ifdef CONFIG_MTD_CFI
-	if (!mymtd) {
-		mymtd = (struct mtd_info *)do_map_probe("cfi_probe", &axis_map);
+	if (!(mymtd = flash_probe())) {
+		/* There's no reason to use this module if no flash chip can
+		 * be identified. Make sure that's understood.
+		 */
+		panic("axisflashmap found no flash chip!\n");
 	}
-#endif
 
-	if(!mymtd) {
-		printk("%s: No flash chip found!\n", axis_map.name);
-		return -ENXIO;
-	}
+	printk("%s: 0x%08x bytes of flash memory.\n",
+	       mymtd->name, mymtd->size);
 
 	mymtd->module = THIS_MODULE;
 
 	ptable_head = (struct partitiontable_head *)(FLASH_CACHED_ADDR +
-		CONFIG_ETRAX_PTABLE_SECTOR + PARTITION_TABLE_OFFSET);
-	pidx++;  /* first partition is always set to the default */
+		      CONFIG_ETRAX_PTABLE_SECTOR + PARTITION_TABLE_OFFSET);
+	pidx++;  /* First partition is always set to the default. */
 
 	if ((ptable_head->magic == PARTITION_TABLE_MAGIC)
 	    && (ptable_head->size <
@@ -322,20 +437,17 @@
 			csum += *p++;
 			csum += *p++;
 		}
-		/* printk("  total csum: 0x%08X 0x%08X\n",
-		   csum, ptable_head->checksum); */
 		ptable_ok = (csum == ptable_head->checksum);
 
 		/* Read the entries and use/show the info.  */
-		printk(" Found %s partition table at 0x%08lX-0x%08lX.\n",
-		       (ptable_ok ? "valid" : "invalid"),
-		       (unsigned long)ptable_head,
-		       (unsigned long)max_addr);
+		printk(" Found a%s partition table at 0x%p-0x%p.\n",
+		       (ptable_ok ? " valid" : "n invalid"), ptable_head,
+		       max_addr);
 
 		/* We have found a working bootblock.  Now read the
-		   partition table.  Scan the table.  It ends when
-		   there is 0xffffffff, that is, empty flash.  */
-		
+		 * partition table.  Scan the table.  It ends when
+		 * there is 0xffffffff, that is, empty flash.
+		 */
 		while (ptable_ok
 		       && ptable->offset != 0xffffffff
 		       && ptable < max_addr
@@ -352,59 +464,64 @@
 		use_default_ptable = !ptable_ok;
 	}
 
+	if (romfs_in_flash) {
+		/* Add an overlapping device for the root partition (romfs). */
+
+		axis_partitions[pidx].name = "romfs";
+		axis_partitions[pidx].size = romfs_length;
+		axis_partitions[pidx].offset = romfs_start - FLASH_CACHED_ADDR;
+		axis_partitions[pidx].mask_flags |= MTD_WRITEABLE;
+
+		printk(" Adding readonly flash partition for romfs image:\n");
+		printk(pmsg, pidx, axis_partitions[pidx].offset,
+		       axis_partitions[pidx].size);
+		pidx++;
+	}
+
 	if (use_default_ptable) {
-		printk(" Using default partition table\n");
+		printk(" Using default partition table.\n");
 		err = add_mtd_partitions(mymtd, axis_default_partitions,
 		                         NUM_DEFAULT_PARTITIONS);
 	} else {
-		if (romfs_in_flash) {
-			axis_partitions[pidx].name = "romfs";
-			axis_partitions[pidx].size = romfs_length;
-			axis_partitions[pidx].offset = romfs_start -
-						       FLASH_CACHED_ADDR;
-			axis_partitions[pidx].mask_flags |= MTD_WRITEABLE;
-
-			printk(" Adding readonly partition for romfs image:\n");
-			printk(pmsg, pidx, axis_partitions[pidx].offset,
-			       axis_partitions[pidx].size);
-			pidx++;
-		}
-
 		err = add_mtd_partitions(mymtd, axis_partitions, pidx);
 	}
-	if (!err && !romfs_in_flash) {
-#ifdef CONFIG_MTD_MTDRAM
-		/* Allocate, initialise and forget the mtd ram struct
-		 * when booting from RAM
-		 */
-		struct mtd_info *romfs_mtd = (struct mtd_info *)kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
-		printk("MTD RAM device romfs_start: 0x%08lX len %lu\n",
-		       romfs_start, romfs_length);
 
-#if (CONFIG_MTDRAM_TOTAL_SIZE != 0) || (CONFIG_MTDRAM_ABS_POS != 0)
-#error "You must set CONFIG_MTDRAM_TOTAL_SIZE and CONFIG_MTDRAM_ABS_POS to 0"
-#endif
-		err = mtdram_init_device(romfs_mtd, (void*)romfs_start, 
-		                         romfs_length, "romfs in RAM");
+	if (err) {
+		panic("axisflashmap could not add MTD partitions!\n");
+	}
+
+	if (!romfs_in_flash) {
+		/* Create an RAM device for the root partition (romfs). */
+
+#if !defined(CONFIG_MTD_MTDRAM) || (CONFIG_MTDRAM_TOTAL_SIZE != 0) || (CONFIG_MTDRAM_ABS_POS != 0)
+		/* No use trying to boot this kernel from RAM. Panic! */
+		printk(KERN_EMERG "axisflashmap: Cannot create an MTD RAM "
+		       "device due to kernel (mis)configuration!\n");
+		panic("This kernel cannot boot from RAM!\n");
 #else
-#warning ######################################
-#warning # You must enable CONFIG_MTD_MTDRAM  #
-#warning # with TOTAL_SIZE 0 and ABS_POS 0 to # 
-#warning # be able to boot with cramfs in RAM #
-#warning ######################################
-/* Maybe overkill to save these bytes in non debug builds, but let's do it..
- * (No point in printing if we don't have a debug port anyway...)
- */
-#ifndef CONFIG_ETRAX_DEBUG_PORT_NULL
-		printk("## Can't mount romfs in RAM using MTDRAM.\n");
-		printk("## You must enable MTD_MTDRAM with TOTAL_SIZE 0 and ABS_POS 0\n");
+		struct mtd_info *mtd_ram;
+
+		mtd_ram = (struct mtd_info *)kmalloc(sizeof(struct mtd_info),
+						     GFP_KERNEL);
+		if (!mtd_ram) {
+			panic("axisflashmap couldn't allocate memory for "
+			      "mtd_info!\n");
+		}
+
+		printk(" Adding RAM partition for romfs image:\n");
+		printk(pmsg, pidx, romfs_start, romfs_length);
+
+		err = mtdram_init_device(mtd_ram, (void*)romfs_start, 
+		                         romfs_length, "romfs");
+		if (err) {
+			panic("axisflashmap could not initialize MTD RAM "
+			      "device!\n");
+		}
 #endif
-#endif /* CONFIG_MTD_MTDRAM */
 	}
+
 	return err;
 }
 
-/* This adds the above to the kernels init-call chain */
-
+/* This adds the above to the kernels init-call chain. */
 module_init(init_axis_flash);
-
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/bluetooth/Makefile ./arch/cris/drivers/bluetooth/Makefile
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/bluetooth/Makefile	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/drivers/bluetooth/Makefile	Wed Oct 23 12:28:59 2002
@@ -1,4 +1,4 @@
-include $(APPS)/Rules.elinux
+include $(AXIS_TOP_DIR)/tools/build/Rules.axis
 
 all:
 
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/ds1302.c ./arch/cris/drivers/ds1302.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/ds1302.c	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/drivers/ds1302.c	Wed Oct 23 12:28:59 2002
@@ -7,6 +7,16 @@
 *! Functions exported: ds1302_readreg, ds1302_writereg, ds1302_init, get_rtc_status
 *!
 *! $Log: update-2.4.19-axis.patch,v $
 *! Revision 1.1  2004/06/06 14:10:20  rpm
 *! Initial revision
 *!
 *! Revision 1.1  2004/01/02 15:11:03  pgerum
 *! Add Axis update to 2.4.19
 *!
+*! Revision 1.15  2002/10/11 16:14:33  johana
+*! Added CONFIG_ETRAX_DS1302_TRICKLE_CHARGE and initial setting of the
+*! trcklecharge register.
+*!
+*! Revision 1.14  2002/10/10 12:15:38  magnusmn
+*! Added support for having the RST signal on bit g0
+*!
+*! Revision 1.13  2002/05/29 15:16:08  johana
+*! Removed unused variables.
+*!
 *! Revision 1.12  2002/04/10 15:35:25  johana
 *! Moved probe function closer to init function and marked it __init.
 *!
@@ -85,7 +95,7 @@
 *!
 *! (C) Copyright 1999, 2000, 2001  Axis Communications AB, LUND, SWEDEN
 *!
-*! $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+*! $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
 *!
 *!***************************************************************************/
 
@@ -322,7 +332,6 @@
 		{
 			struct rtc_time rtc_tm;
 			unsigned char mon, day, hrs, min, sec, leap_yr;
-			unsigned char save_control, save_freq_select;
 			unsigned int yrs;
 
 			if (!capable(CAP_SYS_TIME))
@@ -386,7 +395,6 @@
 		case RTC_SET_CHARGE: /* set the RTC TRICKLE CHARGE register */
 		{
 			int tcs_val;                        
-			unsigned char save_control, save_freq_select;
 
 			if (!capable(CAP_SYS_TIME))
 				return -EPERM;
@@ -492,17 +500,25 @@
 { 
 	if (!ds1302_probe()) {
 #ifdef CONFIG_ETRAX_DS1302_RST_ON_GENERIC_PORT
+#if CONFIG_ETRAX_DS1302_RSTBIT == 27
 		/*
 		 * The only way to set g27 to output is to enable ATA.
 		 *
 		 * Make sure that R_GEN_CONFIG is setup correct.
 		 */
     		genconfig_shadow = ((genconfig_shadow &
-				     ~IO_MASK(R_GEN_CONFIG, ata))
-				   | 
+				     ~IO_MASK(R_GEN_CONFIG, ata)) | 
 				   (IO_STATE(R_GEN_CONFIG, ata, select)));    
     		*R_GEN_CONFIG = genconfig_shadow;
-    		if (!ds1302_probe())
+#elif CONFIG_ETRAX_DS1302_RSTBIT == 0
+		
+		/* Set the direction of this bit to out. */		
+    		genconfig_shadow = ((genconfig_shadow &
+				     ~IO_MASK(R_GEN_CONFIG, g0dir)) | 
+				   (IO_STATE(R_GEN_CONFIG, g0dir, out)));    
+    		*R_GEN_CONFIG = genconfig_shadow;
+#endif
+		if (!ds1302_probe())
       			return -1;
 #else
     		return -1;
@@ -514,5 +530,8 @@
 		       ds1302_name, RTC_MAJOR_NR);
 		return -1;
 	}
+	/* Initialise trickle charger */
+	ds1302_writereg(RTC_TRICKLECHARGER,
+			RTC_TCR_PATTERN |(CONFIG_ETRAX_DS1302_TRICKLE_CHARGE & 0x0F));
 	return 0;
 }
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/ethernet.c ./arch/cris/drivers/ethernet.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/ethernet.c	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/drivers/ethernet.c	Wed Oct 23 12:28:59 2002
@@ -1,4 +1,4 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
  *
  * e100net.c: A network driver for the ETRAX 100LX network controller.
  *
@@ -7,6 +7,18 @@
  * The outline of this driver comes from skeleton.c.
  *
  * $Log: update-2.4.19-axis.patch,v $
  * Revision 1.1  2004/06/06 14:10:20  rpm
  * Initial revision
  *
  * Revision 1.1  2004/01/02 15:11:03  pgerum
  * Add Axis update to 2.4.19
  *
+ * Revision 1.33  2002/10/02 20:16:17  hp
+ * SETF, SETS: Use underscored IO_x_ macros rather than incorrect token concatenation
+ *
+ * Revision 1.32  2002/09/16 06:05:58  starvik
+ * Align memory returned by dev_alloc_skb
+ * Moved handling of sent packets to interrupt to avoid reference counting problem
+ *
+ * Revision 1.31  2002/09/10 13:28:23  larsv
+ * Return -EINVAL for unknown ioctls to avoid confusing tools that tests
+ * for supported functionality by issuing special ioctls, i.e. wireless
+ * extensions.
+ *
  * Revision 1.30  2002/05/07 18:50:08  johana
  * Correct spelling in comments.
  *
@@ -163,6 +175,7 @@
 #include <asm/system.h>
 #include <asm/bitops.h>
 #include <asm/ethernet.h>
+#include <asm/cache.h>
 
 //#define ETHDEBUG
 #define D(x)
@@ -264,10 +277,10 @@
 #define GET_BIT(bit,val)   (((val) >> (bit)) & 0x01)
 
 /* Define some macros to access ETRAX 100 registers */
-#define SETF(var, reg, field, val) var = (var & ~IO_MASK(##reg##, field)) | \
-					  IO_FIELD(##reg##, field, val)
-#define SETS(var, reg, field, val) var = (var & ~IO_MASK(##reg##, field)) | \
-					  IO_STATE(##reg##, field, val)
+#define SETF(var, reg, field, val) var = (var & ~IO_MASK_(reg##_, field##_)) | \
+					  IO_FIELD_(reg##_, field##_, val)
+#define SETS(var, reg, field, val) var = (var & ~IO_MASK_(reg##_, field##_)) | \
+					  IO_STATE_(reg##_, field##_, _##val)
 
 static etrax_eth_descr *myNextRxDesc;  /* Points to the next descriptor to
                                           to be processed */
@@ -304,8 +317,7 @@
 static int e100_open(struct net_device *dev);
 static int e100_set_mac_address(struct net_device *dev, void *addr);
 static int e100_send_packet(struct sk_buff *skb, struct net_device *dev);
-static void e100rx_interrupt(int irq, void *dev_id, struct pt_regs *regs);
-static void e100tx_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static void e100rxtx_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 static void e100nw_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 static void e100_rx(struct net_device *dev);
 static int e100_close(struct net_device *dev);
@@ -399,11 +411,14 @@
 	/* Initialise receive descriptors */
 
 	for (i = 0; i < NBR_OF_RX_DESC; i++) {
-		RxDescList[i].skb = dev_alloc_skb(MAX_MEDIA_DATA_SIZE);
+		/* Allocate two extra cachelines to make sure that buffer used by DMA
+		 * does not share cacheline with any other data (to avoid cache bug)
+		 */
+		RxDescList[i].skb = dev_alloc_skb(MAX_MEDIA_DATA_SIZE + 2 * L1_CACHE_BYTES);
 		RxDescList[i].descr.ctrl   = 0;
 		RxDescList[i].descr.sw_len = MAX_MEDIA_DATA_SIZE;
 		RxDescList[i].descr.next   = virt_to_phys(&RxDescList[i + 1]);
-		RxDescList[i].descr.buf    = virt_to_phys(RxDescList[i].skb->data);
+		RxDescList[i].descr.buf    = L1_CACHE_ALIGN(virt_to_phys(RxDescList[i].skb->data));
 		RxDescList[i].descr.status = 0;
 		RxDescList[i].descr.hw_len = 0;
              
@@ -540,14 +555,14 @@
 
 	/* allocate the irq corresponding to the receiving DMA */
 
-	if (request_irq(NETWORK_DMA_RX_IRQ_NBR, e100rx_interrupt, 0,
+	if (request_irq(NETWORK_DMA_RX_IRQ_NBR, e100rxtx_interrupt, 0,
 			cardname, (void *)dev)) {
 		goto grace_exit0;
 	}
 
 	/* allocate the irq corresponding to the transmitting DMA */
 
-	if (request_irq(NETWORK_DMA_TX_IRQ_NBR, e100tx_interrupt, 0,
+	if (request_irq(NETWORK_DMA_TX_IRQ_NBR, e100rxtx_interrupt, 0,
 			cardname, (void *)dev)) {
 		goto grace_exit1;
 	}
@@ -958,21 +973,6 @@
 		*R_IRQ_MASK2_SET = IO_STATE(R_IRQ_MASK2_SET, dma0_eop, set);
 		netif_stop_queue(dev);
 	}
-	else {
-	  /* Report any packets that have been sent */
-		while (myFirstTxDesc != phys_to_virt(*R_DMA_CH0_FIRST) &&
-		       myFirstTxDesc != myNextTxDesc)
-		{
-			np->stats.tx_bytes += myFirstTxDesc->skb->len;
-			np->stats.tx_packets++;
-
-			/* dma is ready with the transmission of the data in tx_skb, so now
-			   we can release the skb memory */
-			dev_kfree_skb(myFirstTxDesc->skb);
-			myFirstTxDesc->skb = 0;
-			myFirstTxDesc = phys_to_virt(myFirstTxDesc->descr.next);				
-		}
-	}
 
 	spin_unlock_irq(&np->lock);
 
@@ -985,11 +985,13 @@
  */
 
 static void
-e100rx_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+e100rxtx_interrupt(int irq, void *dev_id, struct pt_regs * regs)
 {
 	struct net_device *dev = (struct net_device *)dev_id;
+	struct net_local *np = (struct net_local *)dev->priv;
 	unsigned long irqbits = *R_IRQ_MASK2_RD;
  
+	/* Handle received packets */
 	if (irqbits & IO_STATE(R_IRQ_MASK2_RD, dma1_eop, active)) {
 		/* acknowledge the eop interrupt */
 
@@ -1014,44 +1016,26 @@
 			   so we have to loop back and check if so */
 		}
 	}
-}
 
-/* the transmit dma channel interrupt
- *
- * this is supposed to free the skbuff which was pending during transmission,
- * and inform the kernel that we can send one more buffer
- */
+	/* Report any packets that have been sent */
+	while (myFirstTxDesc != phys_to_virt(*R_DMA_CH0_FIRST) &&
+	       myFirstTxDesc != myNextTxDesc)
+	{
+		np->stats.tx_bytes += myFirstTxDesc->skb->len;
+		np->stats.tx_packets++;
 
-static void
-e100tx_interrupt(int irq, void *dev_id, struct pt_regs * regs)
-{
-	struct net_device *dev = (struct net_device *)dev_id;
-	unsigned long irqbits = *R_IRQ_MASK2_RD;
-	struct net_local *np = (struct net_local *)dev->priv;
+		/* dma is ready with the transmission of the data in tx_skb, so now
+		   we can release the skb memory */
+		dev_kfree_skb_irq(myFirstTxDesc->skb);
+		myFirstTxDesc->skb = 0;
+		myFirstTxDesc = phys_to_virt(myFirstTxDesc->descr.next);
+	}
 
-	/* check for a dma0_eop interrupt */
 	if (irqbits & IO_STATE(R_IRQ_MASK2_RD, dma0_eop, active)) {
-		/* Report all sent packets */
-		do {
-			/* acknowledge the eop interrupt */
-			*R_DMA_CH0_CLR_INTR = IO_STATE(R_DMA_CH0_CLR_INTR, clr_eop, do);
-
-			np->stats.tx_bytes += myFirstTxDesc->skb->len;
-			np->stats.tx_packets++;
-
-			/* dma is ready with the transmission of the data in tx_skb, so now
-			   we can release the skb memory */
-			dev_kfree_skb_irq(myFirstTxDesc->skb);
-			myFirstTxDesc->skb = 0;
-
-			if (netif_queue_stopped(dev)) {
-			  	/* Queue is running, disable tx IRQ */
-			  	*R_IRQ_MASK2_CLR = IO_STATE(R_IRQ_MASK2_CLR, dma0_eop, clr);		
-				netif_wake_queue(dev);
-			}
-			myFirstTxDesc = phys_to_virt(myFirstTxDesc->descr.next);
-		} while (myFirstTxDesc != phys_to_virt(*R_DMA_CH0_FIRST) &&
-		         myFirstTxDesc != myNextTxDesc);
+		/* acknowledge the eop interrupt and wake up queue */
+		*R_DMA_CH0_CLR_INTR = IO_STATE(R_DMA_CH0_CLR_INTR, clr_eop, do);
+		*R_IRQ_MASK2_CLR = IO_STATE(R_IRQ_MASK2_CLR, dma0_eop, clr);		
+		netif_wake_queue(dev);
 	}
 }
 
@@ -1140,11 +1124,18 @@
 		memcpy(skb_data_ptr, phys_to_virt(myNextRxDesc->descr.buf), length);
 	}
 	else {
-		/* Large packet, send directly to upper layers and allocate new memory */		 
+		/* Large packet, send directly to upper layers and allocate new 
+		 * memory (aligned to cache line boundary to avoid bug).
+		 * Before sending the skb to upper layers we must make sure that 
+		 * skb->data points to the aligned start of the packet. 
+		 */
+		int align;  
 		skb = myNextRxDesc->skb;
-		skb_put(skb, length);
-		myNextRxDesc->skb = dev_alloc_skb(MAX_MEDIA_DATA_SIZE);
-		myNextRxDesc->descr.buf = virt_to_phys(myNextRxDesc->skb->data);
+		align = phys_to_virt(myNextRxDesc->descr.buf) - (int)skb->data;	
+		skb_put(skb, length + align); 
+		skb_pull(skb, align); /* Remove alignment bytes */
+		myNextRxDesc->skb = dev_alloc_skb(MAX_MEDIA_DATA_SIZE + 2 * L1_CACHE_BYTES);
+		myNextRxDesc->descr.buf = L1_CACHE_ALIGN(virt_to_phys(myNextRxDesc->skb->data));
 	}
 
 	skb->dev = dev;
@@ -1220,7 +1211,6 @@
 static int
 e100_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
-	/* Maybe default should return -EINVAL instead? */
 	switch (cmd) {
 		case SET_ETH_SPEED_10:                  /* 10 Mbps */
 			e100_set_speed(10);
@@ -1240,10 +1230,8 @@
 		case SET_ETH_DUPLEX_AUTO:             /* Autonegotiate duplex*/
 			e100_set_duplex(autoneg);
 			break;
-		default: /* Auto neg */
-			e100_set_speed(0);
-			e100_set_duplex(autoneg);
-			break;
+		default:
+			return -EINVAL;
 	}
 	return 0;
 }
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/gpio.c ./arch/cris/drivers/gpio.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/gpio.c	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/drivers/gpio.c	Wed Oct 23 12:28:59 2002
@@ -1,4 +1,4 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
  *
  * Etrax general port I/O device
  *
@@ -9,6 +9,38 @@
  *             Johan Adolfsson  (read/set directions, write, port G)
  *
  * $Log: update-2.4.19-axis.patch,v $
  * Revision 1.1  2004/06/06 14:10:20  rpm
  * Initial revision
  *
  * Revision 1.1  2004/01/02 15:11:03  pgerum
  * Add Axis update to 2.4.19
  *
+ * Revision 1.20  2002/10/16 21:16:24  johana
+ * Added support for PA high level interrupt.
+ * That gives 2ms response time with iodtest for high levels and 2-12 ms
+ * response time on low levels if the check is not made in
+ * process.c:cpu_idle() as well.
+ *
+ * Revision 1.19  2002/10/14 18:27:33  johana
+ * Implemented alarm handling so select() now works.
+ * Latency is around 6-9 ms with a etrax_gpio_wake_up_check() in
+ * cpu_idle().
+ * Otherwise I get 15-18 ms (same as doing the poll in userspace -
+ * but less overhead).
+ * TODO? Perhaps we should add the check in IMMEDIATE_BH (or whatever it
+ * is in 2.4) as well?
+ * TODO? Perhaps call request_irq()/free_irq() only when needed?
+ * Increased version to 2.5
+ *
+ * Revision 1.18  2002/10/11 15:02:00  johana
+ * Mask inverted 8 bit value in setget_input().
+ *
+ * Revision 1.17  2002/06/17 15:53:01  johana
+ * Added IO_READ_INBITS, IO_READ_OUTBITS, IO_SETGET_INPUT and IO_SETGET_OUTPUT
+ * that take a pointer as argument and thus can handle 32 bit ports (G)
+ * correctly.
+ * These should be used instead of IO_READBITS, IO_SETINPUT and IO_SETOUTPUT.
+ * (especially if Port G bit 31 is used)
+ *
+ * Revision 1.16  2002/06/17 09:59:51  johana
+ * Returning 32 bit values in the ioctl return value doesn't work if bit
+ * 31 is set (could happen for port G), so mask it of with 0x7FFFFFFF.
+ * A new set of ioctl's will be added.
+ *
  * Revision 1.15  2002/05/06 13:19:13  johana
  * IO_SETINPUT returns mask with bit set = inputs for PA and PB as well.
  *
@@ -83,11 +115,19 @@
 #include <asm/svinto.h>
 #include <asm/io.h>
 #include <asm/system.h>
+#include <asm/irq.h>
 
 #define GPIO_MAJOR 120  /* experimental MAJOR number */
 
 #define D(x)
 
+#if 0
+static int dp_cnt;
+#define DP(x) do { dp_cnt++; if (dp_cnt % 1000 == 0) x; }while(0)
+#else
+#define DP(x)
+#endif
+	
 static char gpio_name[] = "etrax gpio";
 
 #if 0
@@ -125,6 +165,8 @@
 
 static struct gpio_private *alarmlist = 0;
 
+static int gpio_some_alarms = 0; /* Set if someone uses alarm */
+
 /* Port A and B use 8 bit access, but Port G is 32 bit */
 #define NUM_PORTS (GPIO_MINOR_B+1)
 
@@ -185,21 +227,81 @@
 
 
 static unsigned int 
-gpio_poll(struct file *filp,
-	  struct poll_table_struct *wait)
+gpio_poll(struct file *file,
+	  poll_table *wait)
 {
-	/* TODO poll on alarms! */
-#if 0
-	if (!ANYTHING_WANTED) {
-		D(printk("gpio_select sleeping task\n"));
-		select_wait(&gpio_wq, table);
+	unsigned int mask = 0;
+	struct gpio_private *priv = (struct gpio_private *)file->private_data;
+	unsigned long data;
+	poll_wait(file, &priv->alarm_wq, wait);
+	if (priv->minor == GPIO_MINOR_A) {
+		unsigned long tmp;
+		data = *R_PORT_PA_DATA;
+		/* PA has support for high level interrupt -
+		 * lets activate for those low and with highalarm set
+		 */
+		tmp = ~data & priv->highalarm & 0xFF;
+		*R_IRQ_MASK1_SET = (tmp << R_IRQ_MASK1_SET__pa0__BITNR);
+	} else if (priv->minor == GPIO_MINOR_B)
+		data = *R_PORT_PB_DATA;
+	else if (priv->minor == GPIO_MINOR_G)
+		data = *R_PORT_G_DATA;
+	else
 		return 0;
+	
+	if ((data & priv->highalarm) ||
+	    (~data & priv->lowalarm)) {
+		mask = POLLIN|POLLRDNORM;
+	}
+	
+	DP(printk("gpio_poll ready: mask 0x%08X\n", mask));
+	return mask;
+}
+
+void etrax_gpio_wake_up_check(void)
+{
+	struct gpio_private *priv = alarmlist;
+	unsigned long data = 0;
+	while (priv) {
+		if (USE_PORTS(priv)) {
+			data = *priv->port;
+		} else if (priv->minor == GPIO_MINOR_G) {
+			data = *R_PORT_G_DATA;
+		}
+		if ((data & priv->highalarm) ||
+		    (~data & priv->lowalarm)) {
+			DP(printk("etrax_gpio_wake_up_check %i\n",priv->minor));
+			wake_up_interruptible(&priv->alarm_wq);
+		}
+		priv = priv->next;
+	}
+}
+
+static void 
+gpio_poll_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	if (gpio_some_alarms) {
+		etrax_gpio_wake_up_check();
+	}
+}
+
+static void 
+gpio_pa_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long tmp;
+	/* Find what PA interrupts are active */
+	tmp = (*R_IRQ_READ1 >> R_IRQ_READ1__pa0__BITNR) & 0xFF;
+	/* Clear them.. */
+	/* NOTE: Maybe we need to be more careful here if some other
+	 * driver uses PA interrupt as well?
+	 */
+	*R_IRQ_MASK1_CLR = (tmp << R_IRQ_MASK1_CLR__pa0__BITNR);
+	if (gpio_some_alarms) {
+		etrax_gpio_wake_up_check();
 	}
-	D(printk("gpio_select ready\n"));
-#endif
-	return 1;
 }
 
+
 static ssize_t gpio_write(struct file * file, const char * buf, size_t count,
                           loff_t *off)
 {
@@ -310,7 +412,7 @@
 {
 	struct gpio_private *p = alarmlist;
 	struct gpio_private *todel = (struct gpio_private *)filp->private_data;
-
+	
 	/* unlink from alarmlist and free the private structure */
 
 	if (p == todel) {
@@ -322,7 +424,17 @@
 	}
 
 	kfree(todel);
-
+	/* Check if there are still any alarms set */
+	p = alarmlist;
+	while (p) {
+		if (p->highalarm | p->lowalarm) {
+			gpio_some_alarms = 1;
+			return 0;
+		}
+		p = p->next;
+	}
+	gpio_some_alarms = 0;
+		
 	return 0;
 }
 
@@ -330,6 +442,107 @@
  * set alarms to wait for using a subsequent select().
  */
 
+unsigned long inline setget_input(struct gpio_private *priv, unsigned long arg)
+{
+	/* Set direction 0=unchanged 1=input, 
+	 * return mask with 1=input 
+	 */
+	unsigned long flags;
+	if (USE_PORTS(priv)) {
+		save_flags(flags); cli();
+		*priv->dir = *priv->dir_shadow &= 
+		~((unsigned char)arg & priv->changeable_dir);
+		restore_flags(flags);
+		return ~(*priv->dir_shadow) & 0xFF; /* Only 8 bits */
+	} else if (priv->minor == GPIO_MINOR_G) {
+		/* We must fiddle with R_GEN_CONFIG to change dir */
+		if (((arg & dir_g_in_bits) != arg) && 
+		    (arg & changeable_dir_g)) {
+			arg &= changeable_dir_g;
+			/* Clear bits in genconfig to set to input */
+			if (arg & (1<<0)) {
+				genconfig_shadow &= ~IO_MASK(R_GEN_CONFIG,g0dir);
+				dir_g_in_bits |= (1<<0);
+				dir_g_out_bits &= ~(1<<0);
+			}
+			if ((arg & 0x0000FF00) == 0x0000FF00) {
+				genconfig_shadow &= ~IO_MASK(R_GEN_CONFIG,g8_15dir);
+				dir_g_in_bits |= 0x0000FF00;
+				dir_g_out_bits &= ~0x0000FF00;
+			}
+			if ((arg & 0x00FF0000) == 0x00FF0000) {
+				genconfig_shadow &= ~IO_MASK(R_GEN_CONFIG,g16_23dir);
+				dir_g_in_bits |= 0x00FF0000;
+				dir_g_out_bits &= ~0x00FF0000;
+			}
+			if (arg & (1<<24)) {
+				genconfig_shadow &= ~IO_MASK(R_GEN_CONFIG,g24dir);
+				dir_g_in_bits |= (1<<24);
+				dir_g_out_bits &= ~(1<<24);
+			}
+			printk("gpio: SETINPUT on port G set "
+				"genconfig to 0x%08lX "
+				"in_bits: 0x%08lX "
+				"out_bits: 0x%08lX\n", 
+			       (unsigned long)genconfig_shadow, 
+			       dir_g_in_bits, dir_g_out_bits);
+			*R_GEN_CONFIG = genconfig_shadow;
+			/* Must be a >120 ns delay before writing this again */
+				
+		}
+		return dir_g_in_bits;
+	}
+	return 0;
+} /* setget_input */
+
+unsigned long inline setget_output(struct gpio_private *priv, unsigned long arg)
+{
+	unsigned long flags;
+	if (USE_PORTS(priv)) {
+		save_flags(flags); cli();
+		*priv->dir = *priv->dir_shadow |= 
+		  ((unsigned char)arg & priv->changeable_dir);
+		restore_flags(flags);
+		return *priv->dir_shadow;
+	} else if (priv->minor == GPIO_MINOR_G) {
+		/* We must fiddle with R_GEN_CONFIG to change dir */			
+		if (((arg & dir_g_out_bits) != arg) &&
+		    (arg & changeable_dir_g)) {
+			/* Set bits in genconfig to set to output */
+			if (arg & (1<<0)) {
+				genconfig_shadow |= IO_MASK(R_GEN_CONFIG,g0dir);
+				dir_g_out_bits |= (1<<0);
+				dir_g_in_bits &= ~(1<<0);
+			}
+			if ((arg & 0x0000FF00) == 0x0000FF00) {
+				genconfig_shadow |= IO_MASK(R_GEN_CONFIG,g8_15dir);
+				dir_g_out_bits |= 0x0000FF00;
+				dir_g_in_bits &= ~0x0000FF00;
+			}
+			if ((arg & 0x00FF0000) == 0x00FF0000) {
+				genconfig_shadow |= IO_MASK(R_GEN_CONFIG,g16_23dir);
+				dir_g_out_bits |= 0x00FF0000;
+				dir_g_in_bits &= ~0x00FF0000;
+			}
+			if (arg & (1<<24)) {
+				genconfig_shadow |= IO_MASK(R_GEN_CONFIG,g24dir);
+				dir_g_out_bits |= (1<<24);
+				dir_g_in_bits &= ~(1<<24);
+			}
+			printk("gpio: SETOUTPUT on port G set "
+				"genconfig to 0x%08lX "
+				"in_bits: 0x%08lX "
+				"out_bits: 0x%08lX\n", 
+			       (unsigned long)genconfig_shadow, 
+			       dir_g_in_bits, dir_g_out_bits);
+			*R_GEN_CONFIG = genconfig_shadow;
+			/* Must be a >120 ns delay before writing this again */
+		}
+		return dir_g_out_bits & 0x7FFFFFFF;
+	}
+	return 0;
+} /* setget_output */
+
 static int
 gpio_leds_ioctl(unsigned int cmd, unsigned long arg);
 
@@ -338,18 +551,19 @@
 	   unsigned int cmd, unsigned long arg)
 {
 	unsigned long flags;
+	unsigned long val;
 	struct gpio_private *priv = (struct gpio_private *)file->private_data;
 	if (_IOC_TYPE(cmd) != ETRAXGPIO_IOCTYPE) {
 		return -EINVAL;
 	}
 
 	switch (_IOC_NR(cmd)) {
-	case IO_READBITS:
+	case IO_READBITS: /* Use IO_READ_INBITS and IO_READ_OUTBITS instead */
 		// read the port
 		if (USE_PORTS(priv)) {
 			return *priv->port;
 		} else if (priv->minor == GPIO_MINOR_G) {
-			return *R_PORT_G_DATA;
+			return (*R_PORT_G_DATA) & 0x7FFFFFFF;
 		}
 		break;
 	case IO_SETBITS:
@@ -377,123 +591,40 @@
 	case IO_HIGHALARM:
 		// set alarm when bits with 1 in arg go high
 		priv->highalarm |= arg;
+		gpio_some_alarms = 1;
 		break;
 	case IO_LOWALARM:
 		// set alarm when bits with 1 in arg go low
 		priv->lowalarm |= arg;
+		gpio_some_alarms = 1;
 		break;
 	case IO_CLRALARM:
 		// clear alarm for bits with 1 in arg
 		priv->highalarm &= ~arg;
 		priv->lowalarm  &= ~arg;
 		break;
-	case IO_READDIR:
+	case IO_READDIR: /* Use IO_SETGET_INPUT/OUTPUT instead! */
 		/* Read direction 0=input 1=output */
 		if (USE_PORTS(priv)) {
 			return *priv->dir_shadow;
 		} else if (priv->minor == GPIO_MINOR_G) {
 			/* Note: Some bits are both in and out,
-			 * Those that are dual is set hare as well.
+			 * Those that are dual is set here as well.
 			 */
-			return dir_g_shadow | dir_g_out_bits;
+			return (dir_g_shadow | dir_g_out_bits) & 0x7FFFFFFF;
 		}
-	case IO_SETINPUT:
+	case IO_SETINPUT: /* Use IO_SETGET_INPUT instead! */
 		/* Set direction 0=unchanged 1=input, 
 		 * return mask with 1=input 
 		 */
-		if (USE_PORTS(priv)) {
-			save_flags(flags); cli();
-			*priv->dir = *priv->dir_shadow &= 
-			~((unsigned char)arg & priv->changeable_dir);
-			restore_flags(flags);
-			return ~(*priv->dir_shadow);
-		} else if (priv->minor == GPIO_MINOR_G) {
-			/* We must fiddle with R_GEN_CONFIG to change dir */
-			if (((arg & dir_g_in_bits) != arg) && 
-			    (arg & changeable_dir_g)) {
-				arg &= changeable_dir_g;
-				/* Clear bits in genconfig to set to input */
-				if (arg & (1<<0)) {
-					genconfig_shadow &= ~IO_MASK(R_GEN_CONFIG,g0dir);
-					dir_g_in_bits |= (1<<0);
-					dir_g_out_bits &= ~(1<<0);
-				}
-				if ((arg & 0x0000FF00) == 0x0000FF00) {
-					genconfig_shadow &= ~IO_MASK(R_GEN_CONFIG,g8_15dir);
-					dir_g_in_bits |= 0x0000FF00;
-					dir_g_out_bits &= ~0x0000FF00;
-				}
-				if ((arg & 0x00FF0000) == 0x00FF0000) {
-					genconfig_shadow &= ~IO_MASK(R_GEN_CONFIG,g16_23dir);
-					dir_g_in_bits |= 0x00FF0000;
-					dir_g_out_bits &= ~0x00FF0000;
-				}
-				if (arg & (1<<24)) {
-					genconfig_shadow &= ~IO_MASK(R_GEN_CONFIG,g24dir);
-					dir_g_in_bits |= (1<<24);
-					dir_g_out_bits &= ~(1<<24);
-				}
-				printk("gpio: SETINPUT on port G set "
-					"genconfig to 0x%08lX "
-					"in_bits: 0x%08lX "
-					"out_bits: 0x%08lX\n", 
-				       (unsigned long)genconfig_shadow, 
-				       dir_g_in_bits, dir_g_out_bits);
-				*R_GEN_CONFIG = genconfig_shadow;
-				/* Must be a >120 ns delay before writing this again */
-				
-			}
-			return dir_g_in_bits;
-		}
-		return 0;
-
-	case IO_SETOUTPUT:
+		return setget_input(priv, arg) & 0x7FFFFFFF;
+		break;
+	case IO_SETOUTPUT: /* Use IO_SETGET_OUTPUT instead! */
 		/* Set direction 0=unchanged 1=output, 
 		 * return mask with 1=output 
 		 */
-		if (USE_PORTS(priv)) {
-			save_flags(flags); cli();
-			*priv->dir = *priv->dir_shadow |= 
-			  ((unsigned char)arg & priv->changeable_dir);
-			restore_flags(flags);
-			return *priv->dir_shadow;
-		} else if (priv->minor == GPIO_MINOR_G) {
-			/* We must fiddle with R_GEN_CONFIG to change dir */			
-			if (((arg & dir_g_out_bits) != arg) &&
-			    (arg & changeable_dir_g)) {
-				/* Set bits in genconfig to set to output */
-				if (arg & (1<<0)) {
-					genconfig_shadow |= IO_MASK(R_GEN_CONFIG,g0dir);
-					dir_g_out_bits |= (1<<0);
-					dir_g_in_bits &= ~(1<<0);
-				}
-				if ((arg & 0x0000FF00) == 0x0000FF00) {
-					genconfig_shadow |= IO_MASK(R_GEN_CONFIG,g8_15dir);
-					dir_g_out_bits |= 0x0000FF00;
-					dir_g_in_bits &= ~0x0000FF00;
-				}
-				if ((arg & 0x00FF0000) == 0x00FF0000) {
-					genconfig_shadow |= IO_MASK(R_GEN_CONFIG,g16_23dir);
-					dir_g_out_bits |= 0x00FF0000;
-					dir_g_in_bits &= ~0x00FF0000;
-				}
-				if (arg & (1<<24)) {
-					genconfig_shadow |= IO_MASK(R_GEN_CONFIG,g24dir);
-					dir_g_out_bits |= (1<<24);
-					dir_g_in_bits &= ~(1<<24);
-				}
-				printk("gpio: SETOUTPUT on port G set "
-					"genconfig to 0x%08lX "
-					"in_bits: 0x%08lX "
-					"out_bits: 0x%08lX\n", 
-				       (unsigned long)genconfig_shadow, 
-				       dir_g_in_bits, dir_g_out_bits);
-				*R_GEN_CONFIG = genconfig_shadow;
-				/* Must be a >120 ns delay before writing this again */
-			}
-			return dir_g_out_bits;
-		}
-		return 0;
+		return setget_output(priv, arg) & 0x7FFFFFFF;
+
 	case IO_SHUTDOWN:
 		SOFT_SHUTDOWN();
 		break;
@@ -521,6 +652,47 @@
 			return -EPERM;
 		}
 		break;
+	case IO_READ_INBITS: 
+		/* *arg is result of reading the input pins */
+		if (USE_PORTS(priv)) {
+			val = *priv->port;
+		} else if (priv->minor == GPIO_MINOR_G) {
+			val = *R_PORT_G_DATA;
+		}
+		if (copy_to_user((unsigned long*)arg, &val, sizeof(val)))
+			return -EFAULT;
+		return 0;
+		break;
+	case IO_READ_OUTBITS:
+		 /* *arg is result of reading the output shadow */
+		if (USE_PORTS(priv)) {
+			val = *priv->shadow;
+		} else if (priv->minor == GPIO_MINOR_G) {
+			val = port_g_data_shadow;
+		}
+		if (copy_to_user((unsigned long*)arg, &val, sizeof(val)))
+			return -EFAULT;
+		break;
+	case IO_SETGET_INPUT: 
+		/* bits set in *arg is set to input,
+		 * *arg updated with current input pins.
+		 */
+		if (copy_from_user(&val, (unsigned long*)arg, sizeof(val)))
+			return -EFAULT;
+		val = setget_input(priv, val);
+		if (copy_to_user((unsigned long*)arg, &val, sizeof(val)))
+			return -EFAULT;
+		break;
+	case IO_SETGET_OUTPUT:
+		/* bits set in *arg is set to output,
+		 * *arg updated with current output pins.
+		 */
+		if (copy_from_user(&val, (unsigned long*)arg, sizeof(val)))
+			return -EFAULT;
+		val = setget_output(priv, val);
+		if (copy_to_user((unsigned long*)arg, &val, sizeof(val)))
+			return -EFAULT;
+		break;
 	default:
 		if (priv->minor == GPIO_MINOR_LEDS)
 			return gpio_leds_ioctl(cmd, arg);
@@ -690,7 +862,21 @@
 
 #endif
 	gpio_init_port_g();
-	printk("ETRAX 100LX GPIO driver v2.3, (c) 2001, 2002 Axis Communications AB\n");
+	printk("ETRAX 100LX GPIO driver v2.5, (c) 2001, 2002 Axis Communications AB\n");
+	/* We call etrax_gpio_wake_up_check() from timer interrupt and
+	 * from cpu_idle() in kernel/process.c
+	 * The check in cpu_idle() reduces latency from ~15 ms to ~6 ms
+	 * in some tests.
+	 */  
+	if (request_irq(TIMER0_IRQ_NBR, gpio_poll_timer_interrupt,
+			SA_SHIRQ | SA_INTERRUPT,"gpio poll", NULL)) {
+		printk("err: timer0 irq for gpio\n");
+	}
+	if (request_irq(PA_IRQ_NBR, gpio_pa_interrupt,
+			SA_SHIRQ | SA_INTERRUPT,"gpio PA", NULL)) {
+		printk("err: PA irq for gpio\n");
+	}
+	
 
 	return res;
 }
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/i2c.c ./arch/cris/drivers/i2c.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/i2c.c	Sun May 20 02:43:05 2001
+++ ./arch/cris/drivers/i2c.c	Wed Oct 23 12:28:59 2002
@@ -12,6 +12,10 @@
 *!                                 don't use PB_I2C if DS1302 uses same bits,
 *!                                 use PB.
 *! $Log: update-2.4.19-axis.patch,v $
 *! Revision 1.1  2004/06/06 14:10:20  rpm
 *! Initial revision
 *!
 *! Revision 1.1  2004/01/02 15:11:03  pgerum
 *! Add Axis update to 2.4.19
 *!
+*! Revision 1.8  2002/08/13 06:31:53  starvik
+*! Made SDA and SCL line configurable
+*! Modified i2c_inbyte to work with PCF8563
+*!
 *! Revision 1.7  2001/04/04 13:11:36  markusl
 *! Updated according to review remarks
 *!
@@ -40,10 +44,10 @@
 *!
 *! ---------------------------------------------------------------------------
 *!
-*! (C) Copyright 1999, 2000, 2001 Axis Communications AB, LUND, SWEDEN
+*! (C) Copyright 1999-2002 Axis Communications AB, LUND, SWEDEN
 *!
 *!***************************************************************************/
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $ */
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $ */
 /****************** INCLUDE FILES SECTION ***********************************/
 
 #include <linux/module.h>
@@ -93,8 +97,15 @@
 
 #ifdef CONFIG_ETRAX_I2C_USES_PB_NOT_PB_I2C
 /* Use PB and not PB_I2C */
-#define SDABIT 0
-#define SCLBIT 1
+#ifndef CONFIG_ETRAX_I2C_DATA_PORT
+#define CONFIG_ETRAX_I2C_DATA_PORT 0
+#endif
+#ifndef CONFIG_ETRAX_I2C_CLK_PORT
+#define CONFIG_ETRAX_I2C_CLK_PORT 1
+#endif
+
+#define SDABIT CONFIG_ETRAX_I2C_DATA_PORT
+#define SCLBIT CONFIG_ETRAX_I2C_CLK_PORT
 #define i2c_enable() 
 #define i2c_disable() 
 
@@ -114,7 +125,7 @@
 
 /* read a bit from the i2c interface */
 
-#define i2c_getbit() (*R_PORT_PB_READ & (1 << SDABIT))
+#define i2c_getbit() (((*R_PORT_PB_READ & (1 << SDABIT))) >> SDABIT)
 
 #else
 /* enable or disable the i2c interface */
@@ -206,7 +217,7 @@
 i2c_outbyte(unsigned char x)
 {
 	int i;
-	
+
 	i2c_dir_out();
 
 	for (i = 0; i < 8; i++) {
@@ -238,65 +249,44 @@
 {
 	unsigned char aBitByte = 0;
 	int i;
-	int iaa;
 
-	/*
-	 * enable output
-	 */
-	i2c_dir_out();
-	/*
-	 * Release data bus by setting
-	 * data high
-	 */
-	i2c_data(I2C_DATA_HIGH);
-	/*
-	 * enable input
-	 */
+	/* Switch off I2C to get bit */
+	i2c_disable();
 	i2c_dir_in();
-	/*
-	 * Use PORT PB instead of I2C
-	 * for input. (I2C not working)
-	 */
-	i2c_clk(1);
-	i2c_data(1);
-	/*
-	 * get bits
-	 */
-	for (i = 0; i < 8; i++) {
-		i2c_delay(CLOCK_LOW_TIME/2);
-		/*
-		 * low clock period
-		 */
+	i2c_delay(CLOCK_HIGH_TIME/2);
+
+	/* Get bit */
+	aBitByte |= i2c_getbit();
+
+	/* Enable I2C */
+	i2c_enable();
+	i2c_dir_out();
+	i2c_delay(CLOCK_LOW_TIME/2);
+
+	for (i = 1; i < 8; i++) {
+		aBitByte <<= 1;
+		/* Clock pulse */
 		i2c_clk(I2C_CLOCK_HIGH);
-		/*
-		 * switch off I2C
-		 */
-		i2c_data(1);
+		i2c_delay(CLOCK_HIGH_TIME);
+		i2c_clk(I2C_CLOCK_LOW);
+		i2c_delay(CLOCK_LOW_TIME);
+
+		/* Switch off I2C to get bit */
 		i2c_disable();
 		i2c_dir_in();
-		/*
-		 * wait before getting bit
-		 */
-		i2c_delay(CLOCK_HIGH_TIME/2);
-		aBitByte = (aBitByte << 1);
-		iaa = i2c_getbit();
-		aBitByte = aBitByte | iaa ;
-		/*
-		 * wait
-		 */
 		i2c_delay(CLOCK_HIGH_TIME/2);
-		/*
-		 * end clock puls
-		 */
+
+		/* Get bit */
+		aBitByte |= i2c_getbit();
+
+		/* Enable I2C */
 		i2c_enable();
 		i2c_dir_out();
-		i2c_clk(I2C_CLOCK_LOW);
-		/*
-		 * low clock period
-		 */
 		i2c_delay(CLOCK_LOW_TIME/2);
 	}
-	i2c_dir_out();
+	i2c_clk(I2C_CLOCK_HIGH);
+	i2c_delay(CLOCK_HIGH_TIME);
+	i2c_clk(I2C_CLOCK_LOW);
 	return aBitByte;
 }
 
@@ -421,7 +411,7 @@
 *#
 *#--------------------------------------------------------------------------*/
 int
-i2c_writereg(unsigned char theSlave, unsigned char theReg,
+i2c_writereg(unsigned char theSlave, unsigned char theReg, 
 	     unsigned char theValue)
 {
 	int error, cntr = 3;
@@ -434,31 +424,12 @@
 		 */
 		save_flags(flags);
 		cli();
-		/*
-		 * generate start condition
-		 */
-		i2c_start();
-		/*
-		 * dummy preamble
-		 */
-		i2c_outbyte(0x01);
-		i2c_data(I2C_DATA_HIGH);
-		i2c_clk(I2C_CLOCK_HIGH);
-		i2c_delay(CLOCK_HIGH_TIME); /* Dummy Acknowledge */
-		i2c_clk(I2C_CLOCK_LOW);
-		i2c_delay(CLOCK_LOW_TIME);
-		i2c_clk(I2C_CLOCK_HIGH);
-		i2c_delay(CLOCK_LOW_TIME); /* Repeated Start Condition */
-		i2c_data(I2C_DATA_LOW);
-		i2c_delay(CLOCK_HIGH_TIME);
-		i2c_clk(I2C_CLOCK_LOW);
-		i2c_delay(CLOCK_LOW_TIME);
 
 		i2c_start();
 		/*
 		 * send slave address
 		 */
-		i2c_outbyte(theSlave);
+		i2c_outbyte((theSlave & 0xfe));
 		/*
 		 * wait for ack
 		 */
@@ -493,7 +464,7 @@
 		restore_flags(flags);
 		
 	} while(error && cntr--);
-	
+
 	i2c_delay(CLOCK_LOW_TIME);
 	
 	return -error;
@@ -512,7 +483,7 @@
 	unsigned char b = 0;
 	int error, cntr = 3;
 	unsigned long flags;
-		
+
 	do {
 		error = 0;
 		/*
@@ -524,28 +495,11 @@
 		 * generate start condition
 		 */
 		i2c_start();
-		/*
-		 * dummy preamble
-		 */
-		i2c_outbyte(0x01);
-		i2c_data(I2C_DATA_HIGH);
-		i2c_clk(I2C_CLOCK_HIGH);
-		i2c_delay(CLOCK_HIGH_TIME); /* Dummy Acknowledge */
-		i2c_clk(I2C_CLOCK_LOW);
-		i2c_delay(CLOCK_LOW_TIME);
-		i2c_clk(I2C_CLOCK_HIGH);
-		i2c_delay(CLOCK_LOW_TIME); /* Repeated Start Condition */
-		i2c_data(I2C_DATA_LOW);
-		i2c_delay(CLOCK_HIGH_TIME);
-		i2c_clk(I2C_CLOCK_LOW);
-		i2c_delay(CLOCK_LOW_TIME);
-    
-		i2c_start();
     
 		/*
 		 * send slave address
 		 */
-		i2c_outbyte(theSlave);
+		i2c_outbyte((theSlave & 0xfe));
 		/*
 		 * wait for ack
 		 */
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/ide.c ./arch/cris/drivers/ide.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/ide.c	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/drivers/ide.c	Wed Oct 23 12:28:59 2002
@@ -1,4 +1,4 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
  *
  * Etrax specific IDE functions, like init and PIO-mode setting etc.
  * Almost the entire ide.c is used for the rest of the Etrax ATA driver.
@@ -8,6 +8,12 @@
  *             Mikael Starvik     (pio setup stuff)
  *
  * $Log: update-2.4.19-axis.patch,v $
  * Revision 1.1  2004/06/06 14:10:20  rpm
  * Initial revision
  *
  * Revision 1.1  2004/01/02 15:11:03  pgerum
  * Add Axis update to 2.4.19
  *
+ * Revision 1.26  2002/09/17 12:16:59  bjornw
+ * Removed unnecessary cli/sti pair
+ *
+ * Revision 1.25  2002/08/19 08:07:19  matsfg
+ * Added IN_WORD.
+ *
  * Revision 1.24  2002/04/22 11:47:21  johana
  * Fix according to 2.4.19-pre7. time_after/time_before and
  * missing end of comment.
@@ -180,9 +186,14 @@
 			    IO_MASK(R_ATA_STATUS_DATA, tr_rdy)))
 		timeleft--;
 }
-
 unsigned char 
 IN_BYTE(ide_ioreg_t reg) {
+        /* data was in the lower 16 bits in the status reg */
+        return (unsigned char)(IN_WORD(reg));
+}
+
+unsigned short 
+IN_WORD(ide_ioreg_t reg) {
 	int status;
 	int timeleft;
 
@@ -226,7 +237,7 @@
 
 	LOWDB(printk("inb: 0x%x from reg 0x%x\n", status & 0xff, reg));
 
-	return (unsigned char)status; /* data was in the lower 16 bits in the status reg */
+        return (unsigned short)status;
 }
 
 /* PIO timing (in R_ATA_CONFIG)
@@ -303,9 +314,6 @@
 	pio = 4;
 	/* pio = ide_get_best_pio_mode(drive, pio, 4, NULL); */
 	
-	save_flags(flags);
-	cli();
-
 	/* set pio mode! */
   	 
 	switch(pio) {
@@ -350,7 +358,6 @@
 					  IO_FIELD( R_ATA_CONFIG, pio_hold,   ATA_PIO4_HOLD ) );
 			break;
 	}
-	restore_flags(flags);
 }
 
 void __init 
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/parport.c ./arch/cris/drivers/parport.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/parport.c	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/drivers/parport.c	Wed Oct 23 12:28:59 2002
@@ -1,4 +1,4 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
  * 
  * Elinux parallel port driver
  * NOTE!
@@ -56,11 +56,11 @@
 //#define CONFIG_PAR0_INT 1
 //#define CONFIG_PAR1_INT 1
 
-#define SETF(var, reg, field, val) \
-	var = (var & ~IO_MASK(##reg##, field)) | IO_FIELD(##reg##, field, val)
-
-#define SETS(var, reg, field, val) \
-	var = (var & ~IO_MASK(##reg##, field)) | IO_STATE(##reg##, field, val)
+/* Define some macros to access ETRAX 100 registers */
+#define SETF(var, reg, field, val) var = (var & ~IO_MASK_(reg##_, field##_)) | \
+					  IO_FIELD_(reg##_, field##_, val)
+#define SETS(var, reg, field, val) var = (var & ~IO_MASK_(reg##_, field##_)) | \
+					  IO_STATE_(reg##_, field##_, _##val)
 
 struct etrax100par_struct {
 	/* parallell port control */
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/pcf8563.c ./arch/cris/drivers/pcf8563.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/pcf8563.c	Thu Jan  1 01:00:00 1970
+++ ./arch/cris/drivers/pcf8563.c	Wed Oct 23 12:28:59 2002
@@ -0,0 +1,287 @@
+/*
+ * PCF8563 RTC
+ *
+ * From Phillips' datasheet:
+ *
+ * The PCF8563 is a CMOS real-time clock/calendar optimized for low power
+ * consumption. A programmable clock output, interupt output and voltage
+ * low detector are also provided. All address and data are transferred
+ * serially via two-line bidirectional I2C-bus. Maximum bus speed is
+ * 400 kbits/s. The built-in word address register is incremented
+ * automatically after each written or read bute.
+ *
+ * Copyright (c) 2002, Axis Communications AB
+ * All rights reserved.
+ *
+ * Author: Tobias Anderberg <tobiasa@axis.com>.
+ *
+ * $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/svinto.h>
+#include <asm/rtc.h>
+#include "i2c.h"
+
+#define PCF8563_MAJOR 121		/* Local major number. */
+#define DEVICE_NAME "rtc"		/* Name which is registered in /proc/devices. */
+#define PCF8563_NAME "PCF8563"
+#define DRIVER_VERSION "$Revision: 1.1 $"
+
+/* I2C bus slave registers. */
+#define RTC_I2C_READ		0xa3
+#define RTC_I2C_WRITE		0xa2
+
+/* Two simple wrapper macros, saves a few keystrokes. */
+#define rtc_read(x) i2c_readreg(RTC_I2C_READ, x)
+#define rtc_write(x,y) i2c_writereg(RTC_I2C_WRITE, x, y)
+	
+static const unsigned char days_in_month[] =
+	{ 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
+
+int pcf8563_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+int pcf8563_open(struct inode *, struct file *);
+int pcf8563_release(struct inode *, struct file *);
+
+static struct file_operations pcf8563_fops = {
+	owner: THIS_MODULE,
+	ioctl: pcf8563_ioctl,
+	open: pcf8563_open,
+	release: pcf8563_release,
+};
+
+unsigned char
+pcf8563_readreg(int reg) 
+{
+	unsigned char res = i2c_readreg(RTC_I2C_READ, reg);
+
+	/* The PCF8563 does not return 0 for unimplemented bits */
+	switch(reg)
+	{
+		case RTC_SECONDS:
+		case RTC_MINUTES:
+		     res &= 0x7f;
+		     break;
+		case RTC_HOURS:
+		case RTC_DAY_OF_MONTH:
+		     res &= 0x3f;
+		     break;
+		case RTC_MONTH:
+		     res = (res & 0x1f) - 1;  /* PCF8563 returns month in range 1-12 */
+		     break;
+	}
+	return res;
+}
+
+void
+pcf8563_writereg(int reg, unsigned char val) 
+{
+	i2c_writereg(RTC_I2C_WRITE,reg,val);
+}
+
+void
+get_rtc_time(struct rtc_time *tm)
+{
+	tm->tm_sec = rtc_read(RTC_SECONDS);
+	tm->tm_min = rtc_read(RTC_MINUTES);
+	tm->tm_hour = rtc_read(RTC_HOURS);
+	tm->tm_mday = rtc_read(RTC_DAY_OF_MONTH);
+	tm->tm_mon = rtc_read(RTC_MONTH);
+	tm->tm_year = rtc_read(RTC_YEAR);
+
+	if (tm->tm_sec & 0x80)
+		printk(KERN_WARNING "%s: RTC Low Voltage - date/time is not reliable!\n", PCF8563_NAME);
+
+	tm->tm_year = BCD_TO_BIN(tm->tm_year) + ((tm->tm_mon & 0x80) ? 100 : 0);
+	tm->tm_sec &= 0x7f;
+	tm->tm_min &= 0x7f;
+	tm->tm_hour &= 0x3f;
+	tm->tm_mday &= 0x3f;
+	tm->tm_mon &= 0x1f;
+
+	BCD_TO_BIN(tm->tm_sec);
+	BCD_TO_BIN(tm->tm_min);
+	BCD_TO_BIN(tm->tm_hour);
+	BCD_TO_BIN(tm->tm_mday);
+	BCD_TO_BIN(tm->tm_mon);
+	tm->tm_mon--; /* Month is 1..12 in RTC but 0..11 in linux */
+}
+
+int __init
+pcf8563_init(void)
+{
+	unsigned char ret;
+	/*
+	 * First of all we need to reset the chip. This is done by
+	 * clearing control1, control2 and clk freq, clear the 
+	 * Voltage Low bit, and resetting all alarms.
+	 */
+	if (rtc_write(RTC_CONTROL1, 0x00) < 0)
+		goto err;
+
+	if (rtc_write(RTC_CONTROL2, 0x00) < 0)
+		goto err;
+
+	if (rtc_write(RTC_CLOCKOUT_FREQ, 0x00) < 0)
+		goto err;
+
+	/* Clear the VL bit in the seconds register. */
+	ret = rtc_read(RTC_SECONDS);
+	
+	if (rtc_write(RTC_SECONDS, (ret & 0x7f)) < 0)
+		goto err;
+		
+	/* Reset the alarms. */
+	if (rtc_write(RTC_MINUTE_ALARM, 0x00) < 0)
+		goto err;
+	
+	if (rtc_write(RTC_HOUR_ALARM, 0x00) < 0)
+		goto err;
+	
+	if (rtc_write(RTC_DAY_ALARM, 0x00) < 0)
+		goto err;
+	
+	if (rtc_write(RTC_WEEKDAY_ALARM, 0x00) < 0)
+		goto err;
+
+	if (register_chrdev(PCF8563_MAJOR, DEVICE_NAME, &pcf8563_fops) < 0) {
+		printk(KERN_INFO "%s: Unable to get major numer %d for RTC device.\n", 
+		       PCF8563_NAME, PCF8563_MAJOR);
+		return -1;
+	}
+
+	printk(KERN_INFO "%s Real-Time Clock Driver, %s\n", PCF8563_NAME, DRIVER_VERSION);
+        
+	/* Check for low voltage, and warn about it.. */
+	if (rtc_read(RTC_SECONDS) & 0x80)
+		printk(KERN_WARNING "%s: RTC Low Voltage - date/time is not reliable!\n", PCF8563_NAME);
+	
+	return 0;
+
+err:
+	printk(KERN_INFO "%s: Error initializing chip.\n", PCF8563_NAME);
+	return -1;
+}
+
+void __exit
+pcf8563_exit(void)
+{
+	if (unregister_chrdev(PCF8563_MAJOR, DEVICE_NAME) < 0) {
+		printk(KERN_INFO "%s: Unable to unregister device.\n", PCF8563_NAME);
+	}
+}
+
+/*
+ * ioctl calls for this driver. Why return -ENOTTY upon error? Because
+ * POSIX says so!
+ */
+int
+pcf8563_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	/* Some sanity checks. */
+	if (_IOC_TYPE(cmd) != RTC_MAGIC)
+		return -ENOTTY;
+
+	if (_IOC_NR(cmd) > RTC_MAX_IOCTL)
+		return -ENOTTY;
+
+	switch (cmd) {
+		case RTC_RD_TIME:
+			{
+				struct rtc_time tm;
+
+				get_rtc_time(&tm);
+
+				if (copy_to_user((struct rtc_time *) arg, &tm, sizeof(struct rtc_time))) {
+					return -EFAULT;
+				}
+
+				return 0;
+			}
+			break;
+		case RTC_SET_TIME:
+			{
+				int leap;
+				int century;
+				unsigned long flags;
+				struct rtc_time tm;
+
+				if (!capable(CAP_SYS_TIME))
+					return -EPERM;
+
+				if (copy_from_user(&tm, (struct rtc_time *) arg, sizeof(struct rtc_time)))
+					return -EFAULT;
+
+				/* Convert from struct tm to struct rtc_time. */
+				tm.tm_year += 1900;
+				tm.tm_mon += 1;
+				
+				leap = ((tm.tm_mon == 2) && ((tm.tm_year % 4) == 0)) ? 1 : 0;
+
+				/* Perform some sanity checks. */
+				if ((tm.tm_year < 1970) ||
+				    (tm.tm_mon > 12) ||
+				    (tm.tm_mday == 0) ||
+				    (tm.tm_mday > days_in_month[tm.tm_mon] + leap) ||
+				    (tm.tm_hour >= 24) ||
+				    (tm.tm_min >= 60) ||
+				    (tm.tm_sec >= 60))
+					return -EINVAL;
+
+				century = (tm.tm_year >= 2000) ? 0x80 : 0;
+				tm.tm_year = tm.tm_year % 100;
+
+				BIN_TO_BCD(tm.tm_year);
+				BIN_TO_BCD(tm.tm_mday);
+				BIN_TO_BCD(tm.tm_hour);
+				BIN_TO_BCD(tm.tm_min);
+				BIN_TO_BCD(tm.tm_sec);
+				tm.tm_mon |= century;
+				
+				rtc_write(RTC_YEAR, tm.tm_year);
+				rtc_write(RTC_MONTH, tm.tm_mon);
+				rtc_write(RTC_DAY_OF_MONTH, tm.tm_mday);
+				rtc_write(RTC_HOURS, tm.tm_hour);
+				rtc_write(RTC_MINUTES, tm.tm_min);
+				rtc_write(RTC_SECONDS, tm.tm_sec);
+
+				return 0;
+			}
+			break;
+		default:
+				return -ENOTTY;
+	}
+
+	return 0;
+}
+
+int 
+pcf8563_open(struct inode *inode, struct file *filp)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+int
+pcf8563_release(struct inode *inode, struct file *filp)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+EXPORT_NO_SYMBOLS;
+module_init(pcf8563_init);
+module_exit(pcf8563_exit);
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/serial.c ./arch/cris/drivers/serial.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/serial.c	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/drivers/serial.c	Wed Oct 23 12:28:59 2002
@@ -1,4 +1,4 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
  *
  * Serial port driver for the ETRAX 100LX chip
  *
@@ -7,6 +7,41 @@
  *      Many, many authors. Based once upon a time on serial.c for 16x50.
  *
  * $Log: update-2.4.19-axis.patch,v $
  * Revision 1.1  2004/06/06 14:10:20  rpm
  * Initial revision
  *
  * Revision 1.1  2004/01/02 15:11:03  pgerum
  * Add Axis update to 2.4.19
  *
+ * Revision 1.40  2002/10/14 05:33:18  starvik
+ * RS-485 uses fast timers even if SERIAL_FAST_TIMER is disabled
+ *
+ * Revision 1.39  2002/09/30 21:00:57  johana
+ * Support for CONFIG_ETRAX_SERx_DTR_RI_DSR_CD_MIXED where the status and
+ * control pins can be mixed between PA and PB.
+ * If no serial port uses MIXED old solution is used
+ * (saves a few bytes and cycles).
+ * control_pins struct uses masks instead of bit numbers.
+ * Corrected dummy values and polarity in line_info() so
+ * /proc/tty/driver/serial is now correct.
+ * (the E100_xxx_GET() macros is really active low - perhaps not obvious)
+ *
+ * Revision 1.38  2002/08/23 11:01:36  starvik
+ * Check that serial port is enabled in all interrupt handlers to avoid
+ * restarts of DMA channels not assigned to serial ports
+ *
+ * Revision 1.37  2002/08/13 13:02:37  bjornw
+ * Removed some warnings because of unused code
+ *
+ * Revision 1.36  2002/08/08 12:50:01  starvik
+ * Serial interrupt is shared with synchronous serial port driver
+ *
+ * Revision 1.35  2002/06/03 10:40:49  starvik
+ * Increased RS-485 RTS toggle timer to 2 characters
+ *
+ * Revision 1.34  2002/05/28 18:59:36  johana
+ * Whitespace and comment fixing to be more like etrax100ser.c 1.71.
+ *
+ * Revision 1.33  2002/05/28 17:55:43  johana
+ * RS-485 uses FAST_TIMER if enabled, and starts a short (one char time)
+ * timer from tranismit_chars (interrupt context).
+ * The timer toggles RTS in interrupt context when expired giving minimum
+ * latencies.
+ *
  * Revision 1.32  2002/05/22 13:58:00  johana
  * Renamed rs_write() to raw_write() and made it inline.
  * New rs_write() handles RS-485 if configured and enabled
@@ -303,7 +338,7 @@
  *
  */
 
-static char *serial_version = "$Revision: 1.1 $";
+static char *serial_version = "$Revision: 1.1 $";
 
 #include <linux/config.h>
 #include <linux/version.h>
@@ -342,7 +377,16 @@
 #include <linux/serial.h>
 /* while we keep our own stuff (struct e100_serial) in a local .h file */
 #include "serial.h"
+#include <asm/fasttimer.h>
 
+#ifdef CONFIG_ETRAX_SERIAL_FAST_TIMER
+#ifdef CONFIG_ETRAX_SERIAL_FLUSH_DMA_FAST
+#error "Disable SERIAL_FLUSH_DMA_FAST to use SERIAL_FAST_TIMER"
+#endif
+#ifndef CONFIG_ETRAX_FAST_TIMER
+#error "Enable FAST_TIMER to use SERIAL_FAST_TIMER"
+#endif
+#endif
 /*
  * All of the compatibilty code so we can compile serial.c against
  * older kernels is hidden in serial_compat.h
@@ -404,8 +448,10 @@
                     const unsigned char *buf, int count);
 static inline int raw_write(struct tty_struct * tty, int from_user,
                             const unsigned char *buf, int count);
+#ifdef CONFIG_ETRAX_RS485
 static int e100_write_rs485(struct tty_struct * tty, int from_user,
                             const unsigned char *buf, int count);
+#endif
 static int 
 get_lsr_info(struct e100_serial * info, unsigned int *value);
 
@@ -519,6 +565,9 @@
 static struct tty_struct *serial_table[NR_PORTS]; 
 static struct termios *serial_termios[NR_PORTS];
 static struct termios *serial_termios_locked[NR_PORTS];
+#ifdef CONFIG_ETRAX_SERIAL_FAST_TIMER
+static struct fast_timer fast_timers[NR_PORTS];
+#endif
 
 #ifdef CONFIG_ETRAX_SERIAL_PROC_ENTRY
 #define PROCSTAT(x) x
@@ -538,7 +587,7 @@
 
 static struct ser_statistics_type ser_stat[NR_PORTS];
 
-#else 
+#else
 
 #define PROCSTAT(x)
 
@@ -546,91 +595,221 @@
 
 /* RS-485 */
 #if defined(CONFIG_ETRAX_RS485)
+#ifdef CONFIG_ETRAX_FAST_TIMER
+static struct fast_timer fast_timers_rs485[NR_PORTS];
+#endif
 #if defined(CONFIG_ETRAX_RS485_ON_PA)
 static int rs485_pa_bit = CONFIG_ETRAX_RS485_ON_PA_BIT;
 #endif
 #endif
-  
 
-/* For now we assume that all bits are on the same port for each serial port */
+/* Info and macros needed for each ports extra control/status signals. */
+#define E100_STRUCT_PORT(line, pinname) \
+ ((CONFIG_ETRAX_SER##line##_##pinname##_ON_PA_BIT >= 0)? \
+		(R_PORT_PA_DATA): ( \
+ (CONFIG_ETRAX_SER##line##_##pinname##_ON_PB_BIT >= 0)? \
+		(R_PORT_PB_DATA):&dummy_ser[##line##]))
+
+#define E100_STRUCT_SHADOW(line, pinname) \
+ ((CONFIG_ETRAX_SER##line##_##pinname##_ON_PA_BIT >= 0)? \
+		(&port_pa_data_shadow): ( \
+ (CONFIG_ETRAX_SER##line##_##pinname##_ON_PB_BIT >= 0)? \
+		(&port_pb_data_shadow):&dummy_ser[line]))
+#define E100_STRUCT_MASK(line, pinname) \
+ ((CONFIG_ETRAX_SER##line##_##pinname##_ON_PA_BIT >= 0)? \
+		(1<<CONFIG_ETRAX_SER##line##_##pinname##_ON_PA_BIT): ( \
+ (CONFIG_ETRAX_SER##line##_##pinname##_ON_PB_BIT >= 0)? \
+		(1<<CONFIG_ETRAX_SER##line##_##pinname##_ON_PB_BIT):DUMMY_##pinname##_MASK))
+
+#define DUMMY_DTR_MASK 1
+#define DUMMY_RI_MASK  2
+#define DUMMY_DSR_MASK 4
+#define DUMMY_CD_MASK  8
+static unsigned char dummy_ser[NR_PORTS] = {0xFF, 0xFF, 0xFF,0xFF};
+
+#if defined(CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_MIXED) || \
+    defined(CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_MIXED) || \
+    defined(CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_MIXED) || \
+    defined(CONFIG_ETRAX_SER3_DTR_RI_DSR_CD_MIXED)
+#define CONFIG_ETRAX_SERX_DTR_RI_DSR_CD_MIXED
+#endif
+
+#ifdef CONFIG_ETRAX_SERX_DTR_RI_DSR_CD_MIXED
+/* The pins can be mixed on PA and PB */
+#define CONTROL_PINS_PORT_NOT_USED(line) \
+  &dummy_ser[line], &dummy_ser[line], \
+  &dummy_ser[line], &dummy_ser[line], \
+  &dummy_ser[line], &dummy_ser[line], \
+  &dummy_ser[line], &dummy_ser[line], \
+  DUMMY_DTR_MASK, DUMMY_RI_MASK, DUMMY_DSR_MASK, DUMMY_CD_MASK
+    
 
-/* Dummy shadow variables */
-#if !defined(CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_PB)
-static unsigned char dummy_ser0 = 0x00;
-static unsigned char dummy_dir_ser0 = 0x00;
-#endif
-#if !defined(CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_ON_PB)
-static unsigned char dummy_ser1 = 0x00;
-static unsigned char dummy_dir_ser1 = 0x00;
-#endif
-#if !defined(CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_ON_PA)
-static unsigned char dummy_ser2 = 0x00;
-static unsigned char dummy_dir_ser2 = 0x00;
-#endif
+struct control_pins
+{
+	volatile unsigned char *dtr_port;
+	unsigned char          *dtr_shadow;
+	volatile unsigned char *ri_port;
+	unsigned char          *ri_shadow;
+	volatile unsigned char *dsr_port;
+	unsigned char          *dsr_shadow;
+	volatile unsigned char *cd_port;
+	unsigned char          *cd_shadow;
+
+	unsigned char dtr_mask;
+	unsigned char ri_mask;
+	unsigned char dsr_mask;
+	unsigned char cd_mask;
+};
+
+static const struct control_pins e100_modem_pins[NR_PORTS] = 
+{
+	/* Ser 0 */
+	{
+#ifdef CONFIG_ETRAX_SERIAL_PORT0
+	E100_STRUCT_PORT(0,DTR), E100_STRUCT_SHADOW(0,DTR),
+	E100_STRUCT_PORT(0,RI),  E100_STRUCT_SHADOW(0,RI),
+	E100_STRUCT_PORT(0,DSR), E100_STRUCT_SHADOW(0,DSR),
+	E100_STRUCT_PORT(0,CD),  E100_STRUCT_SHADOW(0,CD),
+	E100_STRUCT_MASK(0,DTR),
+	E100_STRUCT_MASK(0,RI),
+	E100_STRUCT_MASK(0,DSR),
+	E100_STRUCT_MASK(0,CD)
+#else
+	CONTROL_PINS_PORT_NOT_USED(0)
+#endif	
+	},
 
-static unsigned char dummy_ser3 = 0x00;
-static unsigned char dummy_dir_ser3 = 0x00;
+	/* Ser 1 */
+	{
+#ifdef CONFIG_ETRAX_SERIAL_PORT1	  
+	E100_STRUCT_PORT(1,DTR), E100_STRUCT_SHADOW(1,DTR),
+	E100_STRUCT_PORT(1,RI),  E100_STRUCT_SHADOW(1,RI),
+	E100_STRUCT_PORT(1,DSR), E100_STRUCT_SHADOW(1,DSR),
+	E100_STRUCT_PORT(1,CD),  E100_STRUCT_SHADOW(1,CD),
+	E100_STRUCT_MASK(1,DTR),
+	E100_STRUCT_MASK(1,RI),
+	E100_STRUCT_MASK(1,DSR),
+	E100_STRUCT_MASK(1,CD)
+#else
+	CONTROL_PINS_PORT_NOT_USED(1)
+#endif		
+	},
+
+	/* Ser 2 */
+	{
+#ifdef CONFIG_ETRAX_SERIAL_PORT2	  
+	E100_STRUCT_PORT(2,DTR), E100_STRUCT_SHADOW(2,DTR),
+	E100_STRUCT_PORT(2,RI),  E100_STRUCT_SHADOW(2,RI),
+	E100_STRUCT_PORT(2,DSR), E100_STRUCT_SHADOW(2,DSR),
+	E100_STRUCT_PORT(2,CD),  E100_STRUCT_SHADOW(2,CD),
+	E100_STRUCT_MASK(2,DTR),
+	E100_STRUCT_MASK(2,RI),
+	E100_STRUCT_MASK(2,DSR),
+	E100_STRUCT_MASK(2,CD)
+#else
+	CONTROL_PINS_PORT_NOT_USED(2)
+#endif		
+	},
+
+	/* Ser 3 */
+	{
+#ifdef CONFIG_ETRAX_SERIAL_PORT3	  
+	E100_STRUCT_PORT(3,DTR), E100_STRUCT_SHADOW(3,DTR),
+	E100_STRUCT_PORT(3,RI),  E100_STRUCT_SHADOW(3,RI),
+	E100_STRUCT_PORT(3,DSR), E100_STRUCT_SHADOW(3,DSR),
+	E100_STRUCT_PORT(3,CD),  E100_STRUCT_SHADOW(3,CD),
+	E100_STRUCT_MASK(3,DTR),
+	E100_STRUCT_MASK(3,RI),
+	E100_STRUCT_MASK(3,DSR),
+	E100_STRUCT_MASK(3,CD)
+#else
+	CONTROL_PINS_PORT_NOT_USED(3)
+#endif		
+	}
+};
+#else  /* CONFIG_ETRAX_SERX_DTR_RI_DSR_CD_MIXED */
+
+/* All pins are on either PA or PB for each serial port */
+#define CONTROL_PINS_PORT_NOT_USED(line) \
+  &dummy_ser[line], &dummy_ser[line], \
+  DUMMY_DTR_MASK, DUMMY_RI_MASK, DUMMY_DSR_MASK, DUMMY_CD_MASK
+    
 
-/* Info needed for each ports extra control/status signals.
-   We only supports that all pins uses same register for each port */
 struct control_pins
 {
 	volatile unsigned char *port;
-	volatile unsigned char *shadow;
-	volatile unsigned char *dir_shadow;
-	
-	unsigned char dtr_bit;
-	unsigned char ri_bit;
-	unsigned char dsr_bit;
-	unsigned char cd_bit;
+	unsigned char          *shadow;
+
+	unsigned char dtr_mask;
+	unsigned char ri_mask;
+	unsigned char dsr_mask;
+	unsigned char cd_mask;
 };
 
+#define dtr_port port
+#define dtr_shadow shadow
+#define ri_port port
+#define ri_shadow shadow
+#define dsr_port port
+#define dsr_shadow shadow
+#define cd_port port
+#define cd_shadow shadow
+
 static const struct control_pins e100_modem_pins[NR_PORTS] = 
 {
 	/* Ser 0 */
 	{
-#if defined(CONFIG_ETRAX_SER0_DTR_RI_DSR_CD_ON_PB)
-		R_PORT_PB_DATA, &port_pb_data_shadow, &port_pb_dir_shadow,
-		CONFIG_ETRAX_SER0_DTR_ON_PB_BIT,
-		CONFIG_ETRAX_SER0_RI_ON_PB_BIT,
-		CONFIG_ETRAX_SER0_DSR_ON_PB_BIT,
-		CONFIG_ETRAX_SER0_CD_ON_PB_BIT
+#ifdef CONFIG_ETRAX_SERIAL_PORT0
+	E100_STRUCT_PORT(0,DTR), E100_STRUCT_SHADOW(0,DTR),
+	E100_STRUCT_MASK(0,DTR),
+	E100_STRUCT_MASK(0,RI),
+	E100_STRUCT_MASK(0,DSR),
+	E100_STRUCT_MASK(0,CD)
 #else
-		&dummy_ser0, &dummy_ser0, &dummy_dir_ser0, 0, 1, 2, 3
-#endif
+	CONTROL_PINS_PORT_NOT_USED(0)
+#endif	
 	},
 
 	/* Ser 1 */
 	{
-#if defined(CONFIG_ETRAX_SER1_DTR_RI_DSR_CD_ON_PB)
-		R_PORT_PB_DATA, &port_pb_data_shadow, &port_pb_dir_shadow,
-		CONFIG_ETRAX_SER1_DTR_ON_PB_BIT,
-		CONFIG_ETRAX_SER1_RI_ON_PB_BIT,
-		CONFIG_ETRAX_SER1_DSR_ON_PB_BIT,
-		CONFIG_ETRAX_SER1_CD_ON_PB_BIT
+#ifdef CONFIG_ETRAX_SERIAL_PORT1	  
+	E100_STRUCT_PORT(1,DTR), E100_STRUCT_SHADOW(1,DTR),
+	E100_STRUCT_MASK(1,DTR),
+	E100_STRUCT_MASK(1,RI),
+	E100_STRUCT_MASK(1,DSR),
+	E100_STRUCT_MASK(1,CD)
 #else
-		&dummy_ser1, &dummy_ser1, &dummy_dir_ser1, 0, 1, 2, 3
-#endif
+	CONTROL_PINS_PORT_NOT_USED(1)
+#endif		
 	},
 
 	/* Ser 2 */
 	{
-#if defined(CONFIG_ETRAX_SER2_DTR_RI_DSR_CD_ON_PA)
-		R_PORT_PA_DATA, &port_pa_data_shadow, &port_pa_dir_shadow,
-		CONFIG_ETRAX_SER2_DTR_ON_PA_BIT,
-		CONFIG_ETRAX_SER2_RI_ON_PA_BIT,
-		CONFIG_ETRAX_SER2_DSR_ON_PA_BIT,
-		CONFIG_ETRAX_SER2_CD_ON_PA_BIT
+#ifdef CONFIG_ETRAX_SERIAL_PORT2	  
+	E100_STRUCT_PORT(2,DTR), E100_STRUCT_SHADOW(2,DTR),
+	E100_STRUCT_MASK(2,DTR),
+	E100_STRUCT_MASK(2,RI),
+	E100_STRUCT_MASK(2,DSR),
+	E100_STRUCT_MASK(2,CD)
 #else
-		&dummy_ser2, &dummy_ser2, &dummy_dir_ser2, 0, 1, 2, 3
-#endif
+	CONTROL_PINS_PORT_NOT_USED(2)
+#endif		
 	},
 
 	/* Ser 3 */
 	{
-		&dummy_ser3, &dummy_ser3, &dummy_dir_ser3, 0, 1, 2, 3
+#ifdef CONFIG_ETRAX_SERIAL_PORT3	  
+	E100_STRUCT_PORT(3,DTR), E100_STRUCT_SHADOW(3,DTR),
+	E100_STRUCT_MASK(3,DTR),
+	E100_STRUCT_MASK(3,RI),
+	E100_STRUCT_MASK(3,DSR),
+	E100_STRUCT_MASK(3,CD)
+#else
+	CONTROL_PINS_PORT_NOT_USED(3)
+#endif		
 	}
 };
+#endif /* !CONFIG_ETRAX_SERX_DTR_RI_DSR_CD_MIXED */
 
 #if defined(CONFIG_ETRAX_RS485) && defined(CONFIG_ETRAX_RS485_ON_PA)
 unsigned char rs485_pa_port = CONFIG_ETRAX_RS485_ON_PA_BIT;
@@ -655,19 +834,15 @@
 
 /* These are typically PA or PB and 0 means 0V, 1 means 3.3V */
 /* Is an output */
-#define E100_DTR_GET(info) ((*e100_modem_pins[(info)->line].shadow) & (1 << e100_modem_pins[(info)->line].dtr_bit))
+#define E100_DTR_GET(info) ((*e100_modem_pins[(info)->line].dtr_shadow) & e100_modem_pins[(info)->line].dtr_mask)
 
 /* Normally inputs */
-#define E100_RI_GET(info) ((*e100_modem_pins[(info)->line].port) & (1 << e100_modem_pins[(info)->line].ri_bit))
-#define E100_CD_GET(info) ((*e100_modem_pins[(info)->line].port) & (1 << e100_modem_pins[(info)->line].cd_bit))
+#define E100_RI_GET(info) ((*e100_modem_pins[(info)->line].ri_port) & e100_modem_pins[(info)->line].ri_mask)
+#define E100_CD_GET(info) ((*e100_modem_pins[(info)->line].cd_port) & e100_modem_pins[(info)->line].cd_mask)
 
 /* Input */
-#define E100_DSR_GET(info) ((*e100_modem_pins[(info)->line].port) & (1 << e100_modem_pins[(info)->line].dsr_bit))
-
+#define E100_DSR_GET(info) ((*e100_modem_pins[(info)->line].dsr_port) & e100_modem_pins[(info)->line].dsr_mask)
 
-#ifndef MIN
-#define MIN(a,b)	((a) < (b) ? (a) : (b))
-#endif
 
 /*
  * tmp_buf is used as a temporary buffer by serial_write.  We need to
@@ -802,16 +977,17 @@
  * any general port.
  */
 
+
 static inline void 
 e100_dtr(struct e100_serial *info, int set)
 {
 #ifndef CONFIG_SVINTO_SIM
-	unsigned char mask = (1 << e100_modem_pins[info->line].dtr_bit);
+	unsigned char mask = e100_modem_pins[info->line].dtr_mask;
 
 #ifdef SERIAL_DEBUG_IO  
 	printk("ser%i dtr %i mask: 0x%02X\n", info->line, set, mask);
 	printk("ser%i shadow before 0x%02X get: %i\n", 
-	       info->line, *e100_modem_pins[info->line].shadow,
+	       info->line, *e100_modem_pins[info->line].dtr_shadow,
 	       E100_DTR_GET(info));
 #endif
 	/* DTR is active low */
@@ -820,20 +996,15 @@
 
 		save_flags(flags);
 		cli();
-		*e100_modem_pins[info->line].shadow &= ~mask;
-		*e100_modem_pins[info->line].shadow |= (set ? 0 : mask); 
-		*e100_modem_pins[info->line].port = *e100_modem_pins[info->line].shadow;
+		*e100_modem_pins[info->line].dtr_shadow &= ~mask;
+		*e100_modem_pins[info->line].dtr_shadow |= (set ? 0 : mask); 
+		*e100_modem_pins[info->line].dtr_port = *e100_modem_pins[info->line].dtr_shadow;
 		restore_flags(flags);
 	}
 	
-#if 0
-	REG_SHADOW_SET(e100_modem_pins[info->line].port,
-		       *e100_modem_pins[info->line].shadow,
-		       e100_modem_pins[info->line].dtr_bit, !set);
-#endif
 #ifdef SERIAL_DEBUG_IO
 	printk("ser%i shadow after 0x%02X get: %i\n", 
-	       info->line, *e100_modem_pins[info->line].shadow, 
+	       info->line, *e100_modem_pins[info->line].dtr_shadow, 
 	       E100_DTR_GET(info));
 #endif
 #endif
@@ -855,6 +1026,7 @@
 #endif
 }
 
+
 /* If this behaves as a modem, RI and CD is an output */
 static inline void 
 e100_ri_out(struct e100_serial *info, int set)
@@ -862,21 +1034,16 @@
 #ifndef CONFIG_SVINTO_SIM
 	/* RI is active low */
 	{
-		unsigned char mask = (1 << e100_modem_pins[info->line].ri_bit);
+		unsigned char mask = e100_modem_pins[info->line].ri_mask;
 		unsigned long flags;
 
 		save_flags(flags);
 		cli();
-		*e100_modem_pins[info->line].shadow &= ~mask;
-		*e100_modem_pins[info->line].shadow |= (set ? 0 : mask); 
-		*e100_modem_pins[info->line].port = *e100_modem_pins[info->line].shadow;
+		*e100_modem_pins[info->line].ri_shadow &= ~mask;
+		*e100_modem_pins[info->line].ri_shadow |= (set ? 0 : mask); 
+		*e100_modem_pins[info->line].ri_port = *e100_modem_pins[info->line].ri_shadow;
 		restore_flags(flags);
 	}
-#if 0
-	REG_SHADOW_SET(e100_modem_pins[info->line].port,
-		       *e100_modem_pins[info->line].shadow,
-		       e100_modem_pins[info->line].ri_bit, !set);
-#endif
 #endif
 }
 static inline void 
@@ -885,21 +1052,16 @@
 #ifndef CONFIG_SVINTO_SIM
 	/* CD is active low */
 	{
-		unsigned char mask = (1 << e100_modem_pins[info->line].cd_bit);
+		unsigned char mask = e100_modem_pins[info->line].cd_mask;
 		unsigned long flags;
 
 		save_flags(flags);
 		cli();
-		*e100_modem_pins[info->line].shadow &= ~mask;
-		*e100_modem_pins[info->line].shadow |= (set ? 0 : mask); 
-		*e100_modem_pins[info->line].port = *e100_modem_pins[info->line].shadow;
+		*e100_modem_pins[info->line].cd_shadow &= ~mask;
+		*e100_modem_pins[info->line].cd_shadow |= (set ? 0 : mask); 
+		*e100_modem_pins[info->line].cd_port = *e100_modem_pins[info->line].cd_shadow;
 		restore_flags(flags);
 	}
-#if 0
-	REG_SHADOW_SET(e100_modem_pins[info->line].port,
-		       *e100_modem_pins[info->line].shadow,
-		       e100_modem_pins[info->line].cd_bit, !set);
-#endif
 #endif
 }
 
@@ -1014,7 +1176,7 @@
 }
 
 static int
-e100_write_rs485(struct tty_struct *tty, int from_user, 
+e100_write_rs485(struct tty_struct *tty, int from_user,
                  const unsigned char *buf, int count)
 {
 	struct e100_serial * info = (struct e100_serial *)tty->driver_data;
@@ -1031,7 +1193,22 @@
 	info->rs485.enabled = old_enabled;
 	return count;
 }
+
+#ifdef CONFIG_ETRAX_FAST_TIMER
+/* Timer function to toggle RTS when using FAST_TIMER */
+static void rs485_toggle_rts_timer_function(unsigned long data)
+{
+	struct e100_serial *info = (struct e100_serial *)data;
+
+	fast_timers_rs485[info->line].function = NULL;
+	e100_rts(info, info->rs485.rts_after_sent);
+#if defined(CONFIG_ETRAX_RS485_DISABLE_RECEIVER)
+	e100_enable_rx(info);
+	e100_enable_rxdma_irq(info);
+#endif
+}
 #endif
+#endif /* CONFIG_ETRAX_RS485 */
 
 /*
  * ------------------------------------------------------------
@@ -1174,6 +1351,16 @@
 		/* our job here is done, don't schedule any new DMA transfer */
 		info->tr_running = 0;
 
+#if defined(CONFIG_ETRAX_RS485) && defined(CONFIG_ETRAX_FAST_TIMER)
+		if (info->rs485.enabled) {
+			/* Set a short timer to toggle RTS */
+			start_one_shot_timer(&fast_timers_rs485[info->line],
+			                     rs485_toggle_rts_timer_function,
+			                     (unsigned long)info,
+			                     info->char_time_usec*2,
+			                     "RS-485");
+		}
+#endif /* RS485 */
 		return;
 	}
 
@@ -1189,7 +1376,7 @@
 	*info->ocmdadr = 1;       /* dma command start -> R_DMAx_CMD */
 	
 	/* DMA is now running (hopefully) */
-}
+} /* transmit_chars */
 
 static void 
 start_transmit(struct e100_serial *info)
@@ -1205,7 +1392,7 @@
 	info->tr_running = 1;
 
 	transmit_chars(info);
-}
+} /* start_transmit */
 
 #ifdef CONFIG_ETRAX_SERIAL_FAST_TIMER
 static int serial_fast_timer_started = 0;
@@ -1461,7 +1648,7 @@
 #endif
 
 	/* reset the input dma channel to be sure it works */
-	
+
 	*info->icmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, reset);
 	while (IO_EXTRACT(R_DMA_CH6_CMD, cmd, *info->icmdadr) ==
 	       IO_STATE_VALUE(R_DMA_CH6_CMD, cmd, reset));
@@ -1517,7 +1704,7 @@
 	
 	for (i = 0; i < NR_PORTS; i++) {
 		info = rs_table + i;
-		if (!info->uses_dma) 
+		if (!info->enabled || !info->uses_dma) 
 			continue; 
 		/* check for dma_descr (don't need to check for dma_eop in output dma for serial */
 		if (ireg & info->irq) {  
@@ -1563,7 +1750,7 @@
 	
 	for (i = 0; i < NR_PORTS; i++) {
 		info = rs_table + i;
-		if (!info->uses_dma) 
+		if (!info->enabled || !info->uses_dma) 
 			continue; 
 		/* check for both dma_eop and dma_descr for the input dma channel */
 		if (ireg & ((info->irq << 2) | (info->irq << 3))) {
@@ -1636,7 +1823,7 @@
 	cli();
 
 	length = tty->flip.count;
-	
+
 	while ((buffer = info->first_recv_buffer) && length < TTY_FLIPBUF_SIZE) {
 		unsigned int count = buffer->length;
 
@@ -1723,7 +1910,7 @@
 	
 	for (i = 0; i < NR_PORTS; i++) {
 		info = rs_table + i;
-		if (info->uses_dma) 
+		if (info->enabled && info->uses_dma) 
 			check_flush_timeout(info);
 	}
 } /* timeout_interrupt */
@@ -1889,7 +2076,7 @@
 			}
 			info->break_detected_cnt = 0;
 			DEBUG_LOG(info->line, "#iERR s d %04X\n",
-				  ((rstat & SER_ERROR_MASK) << 8) | data);
+			          ((rstat & SER_ERROR_MASK) << 8) | data);
 		}
 		PROCSTAT(ser_stat[info->line].early_errors_cnt++);
 	} else { /* It was a valid byte, now let the DMA do the rest */
@@ -1903,8 +2090,8 @@
 			 * previous interrupt we should discard it.
 			 */
 			long elapsed_usec = 
-				(curr_time - info->last_rx_active) * (1000000/HZ) + 
-				curr_time_u - info->last_rx_active_usec;
+			  (curr_time - info->last_rx_active) * (1000000/HZ) + 
+			  curr_time_u - info->last_rx_active_usec;
 			if (elapsed_usec < 2*info->char_time_usec) {
 				DEBUG_LOG(info->line, "FBRK %i\n", info->line);
 				/* Report as BREAK (error) and let
@@ -1942,7 +2129,7 @@
 	for (i = 0; i < NR_PORTS; i++) {
 		info = rs_table + i;
 
-		if (!info->uses_dma) 
+		if (!info->enabled || !info->uses_dma) 
 			continue; 
 
 		/* Which line caused the irq? */
@@ -1992,28 +2179,6 @@
 	}
 }
 
-/*
- * This routine is called from the scheduler tqueue when the interrupt
- * routine has signalled that a hangup has occurred.  The path of
- * hangup processing is:
- *
- * 	serial interrupt routine -> (scheduler tqueue) ->
- * 	do_serial_hangup() -> tty->hangup() -> rs_hangup()
- * 
- */
-static void 
-do_serial_hangup(void *private_)
-{
-	struct e100_serial	*info = (struct e100_serial *) private_;
-	struct tty_struct	*tty;
-
-	tty = info->tty;
-	if (!tty)
-		return;
-	
-	tty_hangup(tty);
-}
-
 static int 
 startup(struct e100_serial * info)
 {
@@ -2025,7 +2190,8 @@
 	if (!xmit_page)
 		return -ENOMEM;
 
-	save_flags(flags); cli();
+	save_flags(flags); 
+	cli();
 
 	/* if it was already initialized, skip this */
 
@@ -2322,7 +2488,7 @@
 
 static inline int 
 raw_write(struct tty_struct * tty, int from_user,
-	 const unsigned char *buf, int count)
+	  const unsigned char *buf, int count)
 {
 	int	c, ret = 0;
 	struct e100_serial *info = (struct e100_serial *)tty->driver_data;
@@ -2435,6 +2601,11 @@
 		/* If we are in RS-485 mode, we need to toggle RTS and disable
 		 * the receiver before initiating a DMA transfer
 		 */
+#ifdef CONFIG_ETRAX_FAST_TIMER
+		/* Abort any started timer */
+		fast_timers_rs485[info->line].function = NULL;
+		del_fast_timer(&fast_timers_rs485[info->line]);
+#endif
 		e100_rts(info, info->rs485.rts_on_send);
 #if defined(CONFIG_ETRAX_RS485_DISABLE_RECEIVER)
 		e100_disable_rx(info);
@@ -2463,7 +2634,7 @@
 
 		/* Sleep until all sent */
 		tty_wait_until_sent(tty, 0);
-#ifdef CONFIG_ETRAX_SERIAL_FAST_TIMER
+#ifdef CONFIG_ETRAX_FAST_TIMER
 		/* Now sleep a little more so that shift register is empty */
 		schedule_usleep(info->char_time_usec * 2);
 #endif
@@ -2482,7 +2653,7 @@
 #endif /* CONFIG_ETRAX_RS485 */
 
 	return count;
-}
+} /* rs_write */
 
 
 /* how much space is available in the xmit buffer? */
@@ -2563,16 +2734,16 @@
 	unsigned long flags;
 #ifdef SERIAL_DEBUG_THROTTLE
 	char	buf[64];
-	
+
 	printk("throttle %s: %d....\n", _tty_name(tty, buf),
 	       tty->ldisc.chars_in_buffer(tty));
 #endif
-	
+
 	if (I_IXOFF(tty))
 		info->x_char = STOP_CHAR(tty);
-	
+
 	/* Turn off RTS line (do this atomic) should here be an else ?? */
-	
+
 	save_flags(flags); 
 	cli();
 	e100_rts(info, 0);
@@ -2586,20 +2757,20 @@
 	unsigned long flags;
 #ifdef SERIAL_DEBUG_THROTTLE
 	char	buf[64];
-	
+
 	printk("unthrottle %s: %d....\n", _tty_name(tty, buf),
 	       tty->ldisc.chars_in_buffer(tty));
 #endif
-	
+
 	if (I_IXOFF(tty)) {
 		if (info->x_char)
 			info->x_char = 0;
 		else
 			info->x_char = START_CHAR(tty);
 	}
-	
+
 	/* Assert RTS line (do this atomic) */
-	
+
 	save_flags(flags); 
 	cli();
 	e100_rts(info, 1);
@@ -2722,8 +2893,8 @@
 #ifdef SERIAL_DEBUG_IO 
 struct state_str
 {
-  int state;
-  const char *str;
+	int state;
+	const char *str;
 };
 
 const struct state_str control_state_str[] = {
@@ -2771,14 +2942,15 @@
 	       E100_DSR_GET(info),
 	       E100_CTS_GET(info));
 #endif
+
 	result =  
 		(!E100_RTS_GET(info) ? TIOCM_RTS : 0)
 		| (!E100_DTR_GET(info) ? TIOCM_DTR : 0)
-		| (!E100_CD_GET(info) ? TIOCM_CAR : 0)
 		| (!E100_RI_GET(info) ? TIOCM_RNG : 0)
 		| (!E100_DSR_GET(info) ? TIOCM_DSR : 0)
+		| (!E100_CD_GET(info) ? TIOCM_CAR : 0)
 		| (!E100_CTS_GET(info) ? TIOCM_CTS : 0);
-	
+
 #ifdef SERIAL_DEBUG_IO 
 	printk("e100ser: modem state: %i 0x%08X\n", result, result);
 	{
@@ -3469,17 +3641,17 @@
 
 	stat_buf[0] = 0;
 	stat_buf[1] = 0;
-	if (E100_RTS_GET(info))
+	if (!E100_RTS_GET(info))
 		strcat(stat_buf, "|RTS");
-	if (E100_CTS_GET(info))
+	if (!E100_CTS_GET(info))
 		strcat(stat_buf, "|CTS");
-	if (E100_DTR_GET(info))
+	if (!E100_DTR_GET(info))
 		strcat(stat_buf, "|DTR");
-	if (E100_DSR_GET(info))
+	if (!E100_DSR_GET(info))
 		strcat(stat_buf, "|DSR");
-	if (E100_CD_GET(info))
+	if (!E100_CD_GET(info))
 		strcat(stat_buf, "|CD");
-	if (E100_RI_GET(info))
+	if (!E100_RI_GET(info))
 		strcat(stat_buf, "|RI");
 
 	ret += sprintf(buf+ret, " baud:%d", info->baud);
@@ -3678,6 +3850,15 @@
 			       serial_driver.name, info->line, (unsigned int)info->port);
 		}
 	}
+#ifdef CONFIG_ETRAX_FAST_TIMER
+#ifdef CONFIG_ETRAX_SERIAL_FAST_TIMER
+	memset(fast_timers, 0, sizeof(fast_timers));
+#endif
+#ifdef CONFIG_ETRAX_RS485
+	memset(fast_timers_rs485, 0, sizeof(fast_timers_rs485));
+#endif
+	fast_timer_init();
+#endif
 
 #ifndef CONFIG_SVINTO_SIM
 	/* Not needed in simulator.  May only complicate stuff. */
@@ -3689,7 +3870,7 @@
 		panic("irq23");
 #endif
 #ifdef SERIAL_HANDLE_EARLY_ERRORS
-	if (request_irq(SERIAL_IRQ_NBR, ser_interrupt, SA_INTERRUPT, "serial ", NULL))
+	if (request_irq(SERIAL_IRQ_NBR, ser_interrupt, SA_SHIRQ | SA_INTERRUPT, "serial ", NULL))
 		panic("irq8");
 #endif
 #ifdef CONFIG_ETRAX_SERIAL_PORT1
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/sync_serial.c ./arch/cris/drivers/sync_serial.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/drivers/sync_serial.c	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/drivers/sync_serial.c	Wed Oct 23 12:28:59 2002
@@ -64,13 +64,13 @@
 #define DEFAULT_FRAME_RATE 0
 #define DEFAULT_WORD_RATE 7
 
-#define DEBUG(x) 
+#define DEBUG(x)
 
 /* Define some macros to access ETRAX 100 registers */
-#define SETF(var, reg, field, val) var = (var & ~IO_MASK(##reg##, field)) | \
-					  IO_FIELD(##reg##, field, val)
-#define SETS(var, reg, field, val) var = (var & ~IO_MASK(##reg##, field)) | \
-					  IO_STATE(##reg##, field, val)
+#define SETF(var, reg, field, val) var = (var & ~IO_MASK_(reg##_, field##_)) | \
+					  IO_FIELD_(reg##_, field##_, val)
+#define SETS(var, reg, field, val) var = (var & ~IO_MASK_(reg##_, field##_)) | \
+					  IO_STATE_(reg##_, field##_, _##val)
 
 typedef struct sync_port
 {
@@ -107,8 +107,7 @@
 	char in_buffer[IN_BUFFER_SIZE];
 	volatile char* readp;  /* Next byte to be read by application */
 	volatile char* writep; /* Next byte to be written by etrax */
-	int odd_output; /* 1 if writing odd nible in 12 bit mode */
-	int odd_input;  /* 1 if reading odd nible in 12 bit mode */
+	int started; /* 1 if port has been started */
 } sync_port;
 
 
@@ -221,15 +220,13 @@
 	  IO_STATE(R_DMA_CH9_CLR_INTR, clr_descr, do); 
 	*R_IRQ_MASK2_SET =
 	  IO_STATE(R_IRQ_MASK2_SET, dma8_eop, set) |
-	  IO_STATE(R_IRQ_MASK2_SET, dma8_descr, set) |
           IO_STATE(R_IRQ_MASK2_SET, dma9_descr, set);
 	start_dma_in(&ports[0]);
 #else
 	ports[0].use_dma = 0;
 	initialize_port(0);
-	if (request_irq(8, manual_interrupt, SA_SHIRQ, "synchronous serial manual irq", &ports[0]))
+	if (request_irq(8, manual_interrupt, SA_SHIRQ | SA_INTERRUPT, "synchronous serial manual irq", &ports[0]))
 		panic("Can't allocate sync serial manual irq");
-	*R_IRQ_MASK1_SET = IO_STATE(R_IRQ_MASK1_SET, ser1_data, set);	 
 #endif
 #endif
 
@@ -252,18 +249,16 @@
 	  IO_STATE(R_DMA_CH5_CLR_INTR, clr_descr, do); 
 	*R_IRQ_MASK2_SET =
 	  IO_STATE(R_IRQ_MASK2_SET, dma4_eop, set) |
-	  IO_STATE(R_IRQ_MASK2_SET, dma4_descr, set) |
 	  IO_STATE(R_IRQ_MASK2_SET, dma5_descr, set);
 	start_dma_in(&ports[1]);
 #else
 	ports[1].use_dma = 0;	
 	initialize_port(1);
-	if (port[0].use_dma) /* Port 0 uses dma, we must manual allocate IRQ */
+	if (ports[0].use_dma) /* Port 0 uses dma, we must manual allocate IRQ */
 	{
-		if (request_irq(8, manual_interrupt, SA_SHIRQ, "synchronous serial manual irq", &ports[1]))
+		if (request_irq(8, manual_interrupt, SA_SHIRQ |SA_INTERRUPT, "synchronous serial manual irq", &ports[1]))
 			panic("Can't allocate sync serial manual irq");
 	}
-	*R_IRQ_MASK1_SET = IO_STATE(R_IRQ_MASK1_SET, ser3_data, set);	 
 #endif
 #endif
 
@@ -292,12 +287,12 @@
 	struct sync_port* port = &ports[portnbr];
 
 	DEBUG(printk("Init sync serial port %d\n", portnbr));
-    
+
+	port->started = 0;    
 	port->port_nbr = portnbr;	
 	port->busy = 0;		
 	port->readp = port->in_buffer;
-	port->writep = port->in_buffer + IN_BUFFER_SIZE/2;
-	port->odd_input = 0;
+	port->writep = port->in_buffer;
 
 	init_waitqueue_head(&port->out_wait_q);
 	init_waitqueue_head(&port->in_wait_q);
@@ -422,6 +417,10 @@
 		case SSP_MODE:
 			if (arg > 5)
 				return -EINVAL;
+			if (arg == MASTER_OUTPUT || arg == SLAVE_OUTPUT)
+				*R_IRQ_MASK1_CLR = 1 << port->data_avail_bit;
+			else
+				*R_IRQ_MASK1_SET = 1 << port->data_avail_bit;
 			SETF(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, mode, arg);
 			break;
 		case SSP_FRAME_SYNC:
@@ -466,8 +465,8 @@
 			if (arg & CLOCK_NOT_GATED)
 				SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, clk_mode, normal);
 			else if (arg & CLOCK_GATED)
-				SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, clk_mode, gated);
-    
+				SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, clk_mode, gated);    
+
 			break;
 		case SSP_IPOLARITY:
 			if (arg & CLOCK_NORMAL)
@@ -553,11 +552,10 @@
 	copy_from_user(port->out_buffer, buf, count);
 	port->outp = port->out_buffer;
 	port->out_count = count;
-	port->odd_output = 1;
 	add_wait_queue(&port->out_wait_q, &wait);
 	set_current_state(TASK_INTERRUPTIBLE);
-	*R_IRQ_MASK1_SET = 1 << port->ready_irq_bit; /* transmitter ready IRQ on */
 	send_word(port); /* Start sender by sending first word */
+	*R_IRQ_MASK1_SET = 1 << port->ready_irq_bit; /* transmitter ready IRQ on */
 	schedule();
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&port->out_wait_q, &wait);
@@ -586,9 +584,15 @@
 
 	count = count > OUT_BUFFER_SIZE ? OUT_BUFFER_SIZE : count;
 
-	/* Make sure transmitter is running */
-	SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, clk_halt, running);
-	SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, tr_enable, enable);
+	/* Make sure transmitter/receiver is running */
+	if (!port->started)
+	{
+		SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, clk_halt, running);
+		SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, tr_enable, enable);
+		SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, rec_enable, enable);
+		port->started = 1;
+	}
+
 	*port->ctrl_data = port->ctrl_data_shadow;
 
 	if (!port->use_dma)
@@ -629,9 +633,14 @@
 
 	DEBUG(printk("Read dev %d count %d\n", dev, count));
 
-	/* Make sure receiver is running */
-	SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, clk_halt, running);
-	SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, rec_enable, enable);
+	if (!port->started)
+	{
+		SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, clk_halt, running);
+		SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, tr_enable, enable);
+		SETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, rec_enable, enable);
+		port->started = 1;
+	}
+
 	*port->ctrl_data = port->ctrl_data_shadow;
 
 	/* Calculate number of available bytes */
@@ -680,13 +689,12 @@
 			*port->data_out = *port->outp++;
 			break;
 		case IO_STATE(R_SYNC_SERIAL1_CTRL, wordsize, size12bit):
-			port->out_count--;
-			if (port->odd_output)
-				*port->data_out = ((*port->outp) << 16) | (*(unsigned short *)(port->outp + 1));
-			else
-				*port->data_out = ((*(unsigned short *)port->outp) << 8) | (*(port->outp + 1));
-			port->odd_output = !port->odd_output;
-			port->outp++;
+			{
+				int data = (*port->outp++) << 8;
+				data |= *port->outp++;
+				port->out_count-=2;  
+				*port->data_out = data;
+			}
 			break;
 		case IO_STATE(R_SYNC_SERIAL1_CTRL, wordsize, size16bit):
 			port->out_count-=2;
@@ -710,7 +718,7 @@
 {
 	port->out_descr.hw_len = 0;
 	port->out_descr.next = 0;
-	port->out_descr.ctrl = d_int | d_eol | d_eop | d_wait;
+	port->out_descr.ctrl = d_eol | d_eop | d_wait;
 	port->out_descr.sw_len = count;
 	port->out_descr.buf = virt_to_phys(port->out_buffer);
 	port->out_descr.status = 0;
@@ -765,6 +773,9 @@
 	for (i = 0; i < NUMBER_OF_PORTS; i++) 
 	{
 		sync_port *port = &ports[i];
+		if (!port->enabled)
+			continue;
+
 		if (ireg & (1 << port->output_dma_bit)) /* IRQ active for the port? */
 		{
 			/* Clear IRQ */
@@ -783,19 +794,15 @@
 
 	for (i = 0; i < NUMBER_OF_PORTS; i++) 
 	{
-		int update = 0;
 		sync_port *port = &ports[i];
 
 		if (!port->enabled)
-		{
 			continue;
-		}    
 
 		if (ireg & (1 << port->input_dma_descr_bit)) /* Descriptor interrupt */
 		{
 			/* DMA has reached end of descriptor */
 			*port->input_dma_clr_irq = 
-			  IO_STATE(R_DMA_CH0_CLR_INTR, clr_eop, do) | 
 			  IO_STATE(R_DMA_CH0_CLR_INTR, clr_descr, do);
 
 			/* Find out which descriptor that is ready */
@@ -847,18 +854,9 @@
 				case IO_STATE(R_SYNC_SERIAL1_CTRL, wordsize, size12bit):
 				{
 					int data = *(unsigned short *)port->data_in;
-					if (port->odd_input)
-					{
-						*port->writep |= (data & 0x0f00) >> 8;
-						*(port->writep + 1) = data & 0xff;
-					}
-					else
-					{
-						*port->writep = (data & 0x0ff0) >> 4;
-						*(port->writep + 1) = (data & 0x0f) << 4;
-					}
-					port->odd_input = !port->odd_input;
-					port->writep+=1;
+					*port->writep = (data & 0x0ff0) >> 4;
+					*(port->writep + 1) = data & 0x0f;
+					port->writep+=2;
 				}
 				break;
 				case IO_STATE(R_SYNC_SERIAL1_CTRL, wordsize, size16bit):
@@ -875,14 +873,14 @@
 					break;
 			}
 
-			if (port->writep > port->in_buffer + IN_BUFFER_SIZE) /* Wrap? */
+			if (port->writep >= port->in_buffer + IN_BUFFER_SIZE) /* Wrap? */
 				port->writep = port->in_buffer;
 			wake_up_interruptible(&port->in_wait_q); /* Wake up application */
 		}
 
 		if (*R_IRQ_MASK1_RD & (1 << port->transmitter_ready_bit)) /* Transmitter ready? */
 		{
-			if (port->out_count) /* More data to send */
+			if (port->out_count > 0) /* More data to send */
 				send_word(port);
 			else /* transmission finished */
 			{
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/Makefile ./arch/cris/kernel/Makefile
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/Makefile	Fri Nov  9 22:58:02 2001
+++ ./arch/cris/kernel/Makefile	Wed Oct 23 12:28:59 2002
@@ -1,4 +1,4 @@
-# $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+# $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
 #
 # Makefile for the linux kernel.
 #
@@ -25,6 +25,7 @@
 
 obj-$(CONFIG_MODULES)    += ksyms.o
 obj-$(CONFIG_ETRAX_KGDB) += kgdb.o
+obj-$(CONFIG_ETRAX_FAST_TIMER) += fasttimer.o
 
 # This dependency isn't caught by mkdep.  See entry.S.
 entry.o: entryoffsets.s
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/fasttimer.c ./arch/cris/kernel/fasttimer.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/fasttimer.c	Thu Jan  1 01:00:00 1970
+++ ./arch/cris/kernel/fasttimer.c	Wed Oct 23 12:28:59 2002
@@ -0,0 +1,982 @@
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+ * linux/arch/cris/kernel/fasttimer.c
+ *
+ * Fast timers for ETRAX100/ETRAX100LX
+ * This may be useful in other OS than Linux so use 2 space indentation...
+ *
+ * $Log: update-2.4.19-axis.patch,v $
+ * Revision 1.1  2004/06/06 14:10:20  rpm
+ * Initial revision
+ *
+ * Revision 1.1  2004/01/02 15:11:03  pgerum
+ * Add Axis update to 2.4.19
+ *
+ * Revision 1.5  2002/10/15 06:21:39  starvik
+ * Added call to init_waitqueue_head
+ *
+ * Revision 1.4  2002/05/28 17:47:59  johana
+ * Added del_fast_timer()
+ *
+ * Revision 1.3  2002/05/28 16:16:07  johana
+ * Handle empty fast_timer_list
+ *
+ * Revision 1.2  2002/05/27 15:38:42  johana
+ * Made it compile without warnings on Linux 2.4.
+ * (includes, wait_queue, PROC_FS and snprintf)
+ *
+ * Revision 1.1  2002/05/27 15:32:25  johana
+ * arch/etrax100/kernel/fasttimer.c v1.8 from the elinux tree.
+ *
+ * Revision 1.8  2001/11/27 13:50:40  pkj
+ * Disable interrupts while stopping the timer and while modifying the
+ * list of active timers in timer1_handler() as it may be interrupted
+ * by other interrupts (e.g., the serial interrupt) which may add fast
+ * timers.
+ *
+ * Revision 1.7  2001/11/22 11:50:32  pkj
+ * * Only store information about the last 16 timers.
+ * * proc_fasttimer_read() now uses an allocated buffer, since it
+ *   requires more space than just a page even for only writing the
+ *   last 16 timers. The buffer is only allocated on request, so
+ *   unless /proc/fasttimer is read, it is never allocated.
+ * * Renamed fast_timer_started to fast_timers_started to match
+ *   fast_timers_added and fast_timers_expired.
+ * * Some clean-up.
+ *
+ * Revision 1.6  2000/12/13 14:02:08  johana
+ * Removed volatile for fast_timer_list
+ *
+ * Revision 1.5  2000/12/13 13:55:35  johana
+ * Added DEBUG_LOG, added som cli() and cleanup
+ *
+ * Revision 1.4  2000/12/05 13:48:50  johana
+ * Added range check when writing proc file, modified timer int handling
+ *
+ * Revision 1.3  2000/11/23 10:10:20  johana
+ * More debug/logging possibilities.
+ * Moved GET_JIFFIES_USEC() to timex.h and time.c
+ *
+ * Revision 1.2  2000/11/01 13:41:04  johana
+ * Clean up and bugfixes.
+ * Created new do_gettimeofday_fast() that gets a timeval struct
+ * with time based on jiffies and *R_TIMER0_DATA, uses a table
+ * for fast conversion of timer value to microseconds.
+ * (Much faster the standard do_gettimeofday() and we don't really
+ * wan't to use the true time - we wan't the "uptime" so timers don't screw up
+ * when we change the time.
+ * TODO: Add efficient support for continuous timers as well.
+ *
+ * Revision 1.1  2000/10/26 15:49:16  johana
+ * Added fasttimer, highresolution timers.
+ *
+ * Copyright (C) 2000,2001 2002 Axis Communications AB, Lund, Sweden
+ */
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+
+#include <asm/segment.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/delay.h>
+#include <asm/rtc.h>
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#include <asm/svinto.h>
+#include <asm/fasttimer.h>
+#include <linux/proc_fs.h>
+
+
+#define DEBUG_LOG_INCLUDED
+#define FAST_TIMER_LOG
+//#define FAST_TIMER_TEST
+
+#define FAST_TIMER_SANITY_CHECKS
+
+#ifdef FAST_TIMER_SANITY_CHECKS
+#define SANITYCHECK(x) x
+static int sanity_failed = 0;
+#else
+#define SANITYCHECK(x)
+#endif
+
+#define D1(x)
+#define D2(x)
+#define DP(x)
+
+#define __INLINE__ inline
+
+static int fast_timer_running = 0;
+static int fast_timers_added = 0;
+static int fast_timers_started = 0;
+static int fast_timers_expired = 0;
+static int fast_timers_deleted = 0;
+static int fast_timer_is_init = 0;
+static int fast_timer_ints = 0;
+
+static struct fast_timer *fast_timer_list = NULL;
+
+#ifdef DEBUG_LOG_INCLUDED
+#define DEBUG_LOG_MAX 128
+static const char * debug_log_string[DEBUG_LOG_MAX];
+static unsigned long debug_log_value[DEBUG_LOG_MAX];
+static int debug_log_cnt = 0;
+static int debug_log_cnt_wrapped = 0;
+
+#define DEBUG_LOG(string, value) \
+{ \
+  unsigned long log_flags; \
+  save_flags(log_flags); \
+  cli(); \
+  debug_log_string[debug_log_cnt] = (string); \
+  debug_log_value[debug_log_cnt] = (unsigned long)(value); \
+  if (++debug_log_cnt >= DEBUG_LOG_MAX) \
+  { \
+    debug_log_cnt = debug_log_cnt % DEBUG_LOG_MAX; \
+    debug_log_cnt_wrapped = 1; \
+  } \
+  restore_flags(log_flags); \
+}
+#else
+#define DEBUG_LOG(string, value)
+#endif
+
+
+/* The frequencies for index = clkselx number in R_TIMER_CTRL */
+#define NUM_TIMER_FREQ 15
+#define MAX_USABLE_TIMER_FREQ 7
+#define MAX_DELAY_US  853333L
+const unsigned long timer_freq_100[NUM_TIMER_FREQ] =
+{
+  3,   /* 0 3333 - 853333 us */
+  6,   /* 1 1666 - 426666 us */
+  12,  /* 2  833 - 213333 us */
+  24,  /* 3  416 - 106666 us */
+  48,  /* 4  208 -  53333 us */
+  96,  /* 5  104 -  26666 us */
+  192, /* 6   52 -  13333 us */
+  384, /* 7   26 -   6666 us */
+  576,
+  1152,
+  2304,
+  4608,
+  9216,
+  18432,
+  62500,
+  /* 15 = cascade */
+};
+#define NUM_TIMER_STATS 16
+#ifdef FAST_TIMER_LOG
+struct fast_timer timer_added_log[NUM_TIMER_STATS];
+struct fast_timer timer_started_log[NUM_TIMER_STATS];
+struct fast_timer timer_expired_log[NUM_TIMER_STATS];
+#endif
+
+int timer_div_settings[NUM_TIMER_STATS];
+int timer_freq_settings[NUM_TIMER_STATS];
+int timer_delay_settings[NUM_TIMER_STATS];
+
+/* Not true gettimeofday, only checks the jiffies (uptime) + useconds */
+void __INLINE__ do_gettimeofday_fast(struct timeval *tv)
+{
+  unsigned long sec = jiffies;
+  unsigned long usec = GET_JIFFIES_USEC();
+
+  usec += (sec % HZ) * (1000000 / HZ);
+  sec = sec / HZ;
+
+  if (usec > 1000000)
+  {
+    usec -= 1000000;
+    sec++;
+  }
+  tv->tv_sec = sec;
+  tv->tv_usec = usec;
+}
+
+int __INLINE__ timeval_cmp(struct timeval *t0, struct timeval *t1)
+{
+  if (t0->tv_sec < t1->tv_sec)
+  {
+    return -1;
+  }
+  else if (t0->tv_sec > t1->tv_sec)
+  {
+    return 1;
+  }
+  if (t0->tv_usec < t1->tv_usec)
+  {
+    return -1;
+  }
+  else if (t0->tv_usec > t1->tv_usec)
+  {
+    return 1;
+  }
+  return 0;
+}
+
+void __INLINE__ start_timer1(unsigned long delay_us)
+{
+  int freq_index = 0; /* This is the lowest resolution */
+  unsigned long upper_limit = MAX_DELAY_US;
+
+  unsigned long div;
+  /* Start/Restart the timer to the new shorter value */
+  /* t = 1/freq = 1/19200 = 53us
+   * T=div*t,  div = T/t = delay_us*freq/1000000
+   */
+#if 1 /* Adaptive timer settings */
+  while (delay_us < upper_limit && freq_index < MAX_USABLE_TIMER_FREQ)
+  {
+    freq_index++;
+    upper_limit >>= 1; /* Divide by 2 using shift */
+  }
+  if (freq_index > 0)
+  {
+    freq_index--;
+  }
+#else
+  freq_index = 6;
+#endif
+  div = delay_us * timer_freq_100[freq_index]/10000;
+  if (div < 2)
+  {
+    /* Maybe increase timer freq? */
+    div = 2;
+  }
+  if (div > 255)
+  {
+    div = 0; /* This means 256, the max the timer takes */
+    /* If a longer timeout than the timer can handle is used,
+     * then we must restart it when it goes off.
+     */
+  }
+
+  timer_div_settings[fast_timers_started % NUM_TIMER_STATS] = div;
+  timer_freq_settings[fast_timers_started % NUM_TIMER_STATS] = freq_index;
+  timer_delay_settings[fast_timers_started % NUM_TIMER_STATS] = delay_us;
+
+  D1(printk("start_timer1 : %d us freq: %i div: %i\n",
+            delay_us, freq_index, div));
+  /* Clear timer1 irq */
+  *R_IRQ_MASK0_CLR = IO_STATE(R_IRQ_MASK0_CLR, timer1, clr);
+
+  /* Set timer values */
+  *R_TIMER_CTRL = r_timer_ctrl_shadow =
+    (r_timer_ctrl_shadow &
+     ~IO_MASK(R_TIMER_CTRL, timerdiv1) &
+     ~IO_MASK(R_TIMER_CTRL, tm1) &
+     ~IO_MASK(R_TIMER_CTRL, clksel1)) |
+    IO_FIELD(R_TIMER_CTRL, timerdiv1, div) |
+    IO_STATE(R_TIMER_CTRL, tm1, stop_ld) |
+    IO_FIELD(R_TIMER_CTRL, clksel1, freq_index ); /* 6=c19k2Hz */
+
+  /* Ack interrupt */
+  *R_TIMER_CTRL =  r_timer_ctrl_shadow |
+    IO_STATE(R_TIMER_CTRL, i1, clr);
+
+  /* Start timer */
+  *R_TIMER_CTRL = r_timer_ctrl_shadow =
+    (r_timer_ctrl_shadow & ~IO_MASK(R_TIMER_CTRL, tm1)) |
+    IO_STATE(R_TIMER_CTRL, tm1, run);
+
+  /* Enable timer1 irq */
+  *R_IRQ_MASK0_SET = IO_STATE(R_IRQ_MASK0_SET, timer1, set);
+  fast_timers_started++;
+  fast_timer_running = 1;
+}
+
+/* In version 1.4 this function takes 27 - 50 us */
+void start_one_shot_timer(struct fast_timer *t,
+                          fast_timer_function_type *function,
+                          unsigned long data,
+                          unsigned long delay_us,
+                          const char *name)
+{
+  unsigned long flags;
+  struct fast_timer *tmp;
+
+  D1(printk("sft %s %d us\n", name, delay_us));
+
+  save_flags(flags);
+  cli();
+
+  do_gettimeofday_fast(&t->tv_set);
+  tmp = fast_timer_list;
+
+  SANITYCHECK({ /* Check so this is not in the list already... */
+    while (tmp != NULL)
+    {
+      if (tmp == t)
+      {
+        printk("timer name: %s data: 0x%08lX already in list!\n", name, data);
+        sanity_failed++;
+        return;
+      }
+      else
+      {
+        tmp = tmp->next;
+      }
+    }
+    tmp = fast_timer_list;
+  });
+
+  t->delay_us = delay_us;
+  t->function = function;
+  t->data = data;
+  t->name = name;
+
+  t->tv_expires.tv_usec = t->tv_set.tv_usec + delay_us % 1000000;
+  t->tv_expires.tv_sec  = t->tv_set.tv_sec  + delay_us / 1000000;
+  if (t->tv_expires.tv_usec > 1000000)
+  {
+    t->tv_expires.tv_usec -= 1000000;
+    t->tv_expires.tv_sec++;
+  }
+#ifdef FAST_TIMER_LOG
+  timer_added_log[fast_timers_added % NUM_TIMER_STATS] = *t;
+#endif
+  fast_timers_added++;
+
+  /* Check if this should timeout before anything else */
+  if (tmp == NULL || timeval_cmp(&t->tv_expires, &tmp->tv_expires) < 0)
+  {
+    /* Put first in list and modify the timer value */
+    t->prev = NULL;
+    t->next = fast_timer_list;
+    if (fast_timer_list)
+    {
+      fast_timer_list->prev = t;
+    }
+    fast_timer_list = t;
+#ifdef FAST_TIMER_LOG
+    timer_started_log[fast_timers_started % NUM_TIMER_STATS] = *t;
+#endif
+    start_timer1(delay_us);
+  } else {
+    /* Put in correct place in list */
+    while (tmp->next &&
+           timeval_cmp(&t->tv_expires, &tmp->next->tv_expires) > 0)
+    {
+      tmp = tmp->next;
+    }
+    /* Insert t after tmp */
+    t->prev = tmp;
+    t->next = tmp->next;
+    if (tmp->next)
+    {
+      tmp->next->prev = t;
+    }
+    tmp->next = t;
+  }
+
+  D2(printk("start_one_shot_timer: %d us done\n", delay_us));
+
+  restore_flags(flags);
+} /* start_one_shot_timer */
+
+static inline int fast_timer_pending (const struct fast_timer * t)
+{
+  return (t->next != NULL) || (t->prev != NULL) || (t == fast_timer_list);
+}
+
+static inline int detach_fast_timer (struct fast_timer *t)
+{
+  struct fast_timer *next, *prev;
+  if (!fast_timer_pending(t))
+    return 0;
+  next = t->next;
+  prev = t->prev;
+  if (next)
+    next->prev = prev;
+  if (prev)
+    prev->next = next;
+  else
+    fast_timer_list = next;
+  fast_timers_deleted++;
+  return 1;
+}
+
+int del_fast_timer(struct fast_timer * t)
+{
+  unsigned long flags;
+  int ret;
+  
+  save_flags(flags);
+  cli();
+  ret = detach_fast_timer(t);
+  t->next = t->prev = NULL;
+  restore_flags(flags);
+  return ret;
+} /* del_fast_timer */
+
+
+/* Interrupt routines or functions called in interrupt context */
+
+/* Timer 1 interrupt handler */
+
+static void
+timer1_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+  struct fast_timer *t;
+  unsigned long flags;
+
+  save_flags(flags);
+  cli();
+
+  /* Clear timer1 irq */
+  *R_IRQ_MASK0_CLR = IO_STATE(R_IRQ_MASK0_CLR, timer1, clr);
+
+  /* First stop timer, then ack interrupt */
+  /* Stop timer */
+  *R_TIMER_CTRL = r_timer_ctrl_shadow =
+    (r_timer_ctrl_shadow & ~IO_MASK(R_TIMER_CTRL, tm1)) |
+    IO_STATE(R_TIMER_CTRL, tm1, stop_ld);
+
+  /* Ack interrupt */
+  *R_TIMER_CTRL =  r_timer_ctrl_shadow | IO_STATE(R_TIMER_CTRL, i1, clr);
+
+  fast_timer_running = 0;
+  fast_timer_ints++;
+
+  restore_flags(flags);
+
+  t = fast_timer_list;
+  while (t)
+  {
+    struct timeval tv;
+
+    /* Has it really expired? */
+    do_gettimeofday_fast(&tv);
+    D1(printk("t: %is %06ius\n", tv.tv_sec, tv.tv_usec));
+
+    if (timeval_cmp(&t->tv_expires, &tv) <= 0)
+    {
+      /* Yes it has expired */
+#ifdef FAST_TIMER_LOG
+      timer_expired_log[fast_timers_expired % NUM_TIMER_STATS] = *t;
+#endif
+      fast_timers_expired++;
+
+      /* Remove this timer before call, since it may reuse the timer */
+      save_flags(flags);
+      cli();
+      if (t->prev)
+      {
+        t->prev->next = t->next;
+      }
+      else
+      {
+        fast_timer_list = t->next;
+      }
+      if (t->next)
+      {
+        t->next->prev = t->prev;
+      }
+      t->prev = NULL;
+      t->next = NULL;
+      restore_flags(flags);
+
+      if (t->function != NULL)
+      {
+        t->function(t->data);
+      }
+      else
+      {
+        DEBUG_LOG("!timer1 %i function==NULL!\n", fast_timer_ints);
+      }
+    }
+    else
+    {
+      /* Timer is to early, let's set it again using the normal routines */
+      D1(printk(".\n"));
+    }
+
+    save_flags(flags);
+    cli();
+    if ((t = fast_timer_list) != NULL)
+    {
+      /* Start next timer.. */
+      long us;
+      struct timeval tv;
+
+      do_gettimeofday_fast(&tv);
+      us = ((t->tv_expires.tv_sec - tv.tv_sec) * 1000000 +
+            t->tv_expires.tv_usec - tv.tv_usec);
+      if (us > 0)
+      {
+        if (!fast_timer_running)
+        {
+#ifdef FAST_TIMER_LOG
+          timer_started_log[fast_timers_started % NUM_TIMER_STATS] = *t;
+#endif
+          start_timer1(us);
+        }
+        restore_flags(flags);
+        break;
+      }
+      else
+      {
+        /* Timer already expired, let's handle it better late than never.
+         * The normal loop handles it
+         */
+        D1(printk("e! %d\n", us));
+      }
+    }
+    restore_flags(flags);
+  }
+
+  if (!t)
+  {
+    D1(printk("t1 stop!\n"));
+  }
+}
+
+static void wake_up_func(unsigned long data)
+{
+#ifdef DECLARE_WAITQUEUE
+  wait_queue_head_t  *sleep_wait_p = (wait_queue_head_t*)data;
+#else
+  struct wait_queue **sleep_wait_p = (struct wait_queue **)data;
+#endif
+  wake_up(sleep_wait_p);
+}
+
+
+/* Useful API */
+
+void schedule_usleep(unsigned long us)
+{
+  struct fast_timer t;
+#ifdef DECLARE_WAITQUEUE
+  wait_queue_head_t sleep_wait;
+  init_waitqueue_head(&sleep_wait);
+  {
+  DECLARE_WAITQUEUE(wait, current);
+#else
+  struct wait_queue *sleep_wait = NULL;
+  struct wait_queue wait = { current, NULL };
+#endif
+
+  D1(printk("schedule_usleep(%d)\n", us));
+  add_wait_queue(&sleep_wait, &wait);
+  set_current_state(TASK_INTERRUPTIBLE);
+  start_one_shot_timer(&t, wake_up_func, (unsigned long)&sleep_wait, us,
+                       "usleep");
+  schedule();
+  set_current_state(TASK_RUNNING);
+  remove_wait_queue(&sleep_wait, &wait);
+  D1(printk("done schedule_usleep(%d)\n", us));
+#ifdef DECLARE_WAITQUEUE
+  }
+#endif  
+}
+
+#ifdef CONFIG_PROC_FS
+static int proc_fasttimer_read(char *buf, char **start, off_t offset, int len
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+                       ,int *eof, void *data_unused
+#else
+                        ,int unused
+#endif
+                               );
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+static struct proc_dir_entry *fasttimer_proc_entry;
+#else
+static struct proc_dir_entry fasttimer_proc_entry =
+{
+  0, 9, "fasttimer",
+  S_IFREG | S_IRUGO, 1, 0, 0,
+  0, NULL /* ops -- default to array */,
+  &proc_fasttimer_read /* get_info */,
+};
+#endif
+#endif /* CONFIG_PROC_FS */
+
+#ifdef CONFIG_PROC_FS
+
+/* This value is very much based on testing */
+#define BIG_BUF_SIZE (500 + NUM_TIMER_STATS * 300)
+
+static int proc_fasttimer_read(char *buf, char **start, off_t offset, int len
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+                       ,int *eof, void *data_unused
+#else
+                        ,int unused
+#endif
+                               )
+{
+  unsigned long flags;
+  int i = 0;
+  int num_to_show;
+  struct timeval tv;
+  struct fast_timer *t, *nextt;
+  static char *bigbuf = NULL;
+  static unsigned long used;
+
+  if (!bigbuf && !(bigbuf = vmalloc(BIG_BUF_SIZE)))
+  {
+    used = 0;
+    bigbuf[0] = '\0';
+    return 0;
+  }
+
+  if (!offset || !used)
+  {
+    do_gettimeofday_fast(&tv);
+
+    used = 0;
+    used += sprintf(bigbuf + used, "Fast timers added:     %i\n",
+                    fast_timers_added);
+    used += sprintf(bigbuf + used, "Fast timers started:   %i\n",
+                    fast_timers_started);
+    used += sprintf(bigbuf + used, "Fast timer interrupts: %i\n",
+                    fast_timer_ints);
+    used += sprintf(bigbuf + used, "Fast timers expired:   %i\n",
+                    fast_timers_expired);
+    used += sprintf(bigbuf + used, "Fast timers deleted:   %i\n",
+                    fast_timers_deleted);
+    used += sprintf(bigbuf + used, "Fast timer running:    %s\n",
+                    fast_timer_running ? "yes" : "no");
+    used += sprintf(bigbuf + used, "Current time:          %lu.%06lu\n",
+                    (unsigned long)tv.tv_sec,
+                    (unsigned long)tv.tv_usec);
+#ifdef FAST_TIMER_SANITY_CHECKS
+    used += sprintf(bigbuf + used, "Sanity failed:         %i\n",
+                    sanity_failed);
+#endif
+    used += sprintf(bigbuf + used, "\n");
+
+#ifdef DEBUG_LOG_INCLUDED
+    {
+      int end_i = debug_log_cnt;
+      i = 0;
+
+      if (debug_log_cnt_wrapped)
+      {
+        i = debug_log_cnt;
+      }
+
+      while ((i != end_i || (debug_log_cnt_wrapped && !used)) &&
+             used+100 < BIG_BUF_SIZE)
+      {
+        used += sprintf(bigbuf + used, debug_log_string[i],
+                        debug_log_value[i]);
+        i = (i+1) % DEBUG_LOG_MAX;
+      }
+    }
+    used += sprintf(bigbuf + used, "\n");
+#endif
+
+    num_to_show = (fast_timers_started < NUM_TIMER_STATS ? fast_timers_started:
+                   NUM_TIMER_STATS);
+    used += sprintf(bigbuf + used, "Timers started: %i\n", fast_timers_started);
+    for (i = 0; i < num_to_show && (used+100 < BIG_BUF_SIZE) ; i++)
+    {
+      int cur = (fast_timers_started - i - 1) % NUM_TIMER_STATS;
+
+#if 1 //ndef FAST_TIMER_LOG
+      used += sprintf(bigbuf + used, "div: %i freq: %i delay: %i"
+                      "\n",
+                      timer_div_settings[cur],
+                      timer_freq_settings[cur],
+                      timer_delay_settings[cur]
+                      );
+#endif
+#ifdef FAST_TIMER_LOG
+      t = &timer_started_log[cur];
+      used += sprintf(bigbuf + used, "%-14s s: %6lu.%06lu e: %6lu.%06lu "
+                      "d: %6li us data: 0x%08lX"
+                      "\n",
+                      t->name,
+                      (unsigned long)t->tv_set.tv_sec,
+                      (unsigned long)t->tv_set.tv_usec,
+                      (unsigned long)t->tv_expires.tv_sec,
+                      (unsigned long)t->tv_expires.tv_usec,
+                      t->delay_us,
+                      t->data
+                      );
+#endif
+    }
+    used += sprintf(bigbuf + used, "\n");
+
+#ifdef FAST_TIMER_LOG
+    num_to_show = (fast_timers_added < NUM_TIMER_STATS ? fast_timers_added:
+                   NUM_TIMER_STATS);
+    used += sprintf(bigbuf + used, "Timers added: %i\n", fast_timers_added);
+    for (i = 0; i < num_to_show && (used+100 < BIG_BUF_SIZE); i++)
+    {
+      t = &timer_added_log[(fast_timers_added - i - 1) % NUM_TIMER_STATS];
+      used += sprintf(bigbuf + used, "%-14s s: %6lu.%06lu e: %6lu.%06lu "
+                      "d: %6li us data: 0x%08lX"
+                      "\n",
+                      t->name,
+                      (unsigned long)t->tv_set.tv_sec,
+                      (unsigned long)t->tv_set.tv_usec,
+                      (unsigned long)t->tv_expires.tv_sec,
+                      (unsigned long)t->tv_expires.tv_usec,
+                      t->delay_us,
+                      t->data
+                      );
+    }
+    used += sprintf(bigbuf + used, "\n");
+
+    num_to_show = (fast_timers_expired < NUM_TIMER_STATS ? fast_timers_expired:
+                   NUM_TIMER_STATS);
+    used += sprintf(bigbuf + used, "Timers expired: %i\n", fast_timers_expired);
+    for (i = 0; i < num_to_show && (used+100 < BIG_BUF_SIZE); i++)
+    {
+      t = &timer_expired_log[(fast_timers_expired - i - 1) % NUM_TIMER_STATS];
+      used += sprintf(bigbuf + used, "%-14s s: %6lu.%06lu e: %6lu.%06lu "
+                      "d: %6li us data: 0x%08lX"
+                      "\n",
+                      t->name,
+                      (unsigned long)t->tv_set.tv_sec,
+                      (unsigned long)t->tv_set.tv_usec,
+                      (unsigned long)t->tv_expires.tv_sec,
+                      (unsigned long)t->tv_expires.tv_usec,
+                      t->delay_us,
+                      t->data
+                      );
+    }
+    used += sprintf(bigbuf + used, "\n");
+#endif
+
+    used += sprintf(bigbuf + used, "Active timers:\n");
+    save_flags(flags);
+    cli();
+    t = fast_timer_list;
+    while (t != NULL && (used+100 < BIG_BUF_SIZE))
+    {
+      nextt = t->next;
+      restore_flags(flags);
+      used += sprintf(bigbuf + used, "%-14s s: %6lu.%06lu e: %6lu.%06lu "
+                      "d: %6li us data: 0x%08lX"
+/*                      " func: 0x%08lX" */
+                      "\n",
+                      t->name,
+                      (unsigned long)t->tv_set.tv_sec,
+                      (unsigned long)t->tv_set.tv_usec,
+                      (unsigned long)t->tv_expires.tv_sec,
+                      (unsigned long)t->tv_expires.tv_usec,
+                      t->delay_us,
+                      t->data
+/*                      , t->function */
+                      );
+      cli();
+      if (t->next != nextt)
+      {
+        printk("timer removed!\n");
+      }
+      t = nextt;
+    }
+    restore_flags(flags);
+  }
+
+  if (used - offset < len)
+  {
+    len = used - offset;
+  }
+
+  memcpy(buf, bigbuf + offset, len);
+  *start = buf;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+  *eof = 1;
+#endif
+
+  return len;
+}
+#endif /* PROC_FS */
+
+#ifdef FAST_TIMER_TEST
+static volatile unsigned long i = 0;
+static volatile int num_test_timeout = 0;
+static struct fast_timer tr[10];
+static int exp_num[10];
+
+static struct timeval tv_exp[100];
+
+static void test_timeout(unsigned long data)
+{
+  do_gettimeofday_fast(&tv_exp[data]);
+  exp_num[data] = num_test_timeout;
+
+  num_test_timeout++;
+}
+
+static void test_timeout1(unsigned long data)
+{
+  do_gettimeofday_fast(&tv_exp[data]);
+  exp_num[data] = num_test_timeout;
+  if (data < 7)
+  {
+    start_one_shot_timer(&tr[i], test_timeout1, i, 1000, "timeout1");
+    i++;
+  }
+  num_test_timeout++;
+}
+
+DP(
+static char buf0[2000];
+static char buf1[2000];
+static char buf2[2000];
+static char buf3[2000];
+static char buf4[2000];
+);
+
+static char buf5[6000];
+static int j_u[1000];
+
+static void fast_timer_test(void)
+{
+  int prev_num;
+  int j;
+
+  struct timeval tv, tv0, tv1, tv2;
+
+  printk("fast_timer_test() start\n");
+  do_gettimeofday_fast(&tv);
+
+  for (j = 0; j < 1000; j++)
+  {
+    j_u[j] = GET_JIFFIES_USEC();
+  }
+  for (j = 0; j < 100; j++)
+  {
+    do_gettimeofday_fast(&tv_exp[j]);
+  }
+  printk("fast_timer_test() %is %06i\n", tv.tv_sec, tv.tv_usec);
+
+  for (j = 0; j < 1000; j++)
+  {
+    printk("%i %i %i %i %i\n",j_u[j], j_u[j+1], j_u[j+2], j_u[j+3], j_u[j+4]);
+    j += 4;
+  }
+  for (j = 0; j < 100; j++)
+  {
+    printk("%i.%i %i.%i %i.%i %i.%i %i.%i\n",
+           tv_exp[j].tv_sec,tv_exp[j].tv_usec,
+           tv_exp[j+1].tv_sec,tv_exp[j+1].tv_usec,
+           tv_exp[j+2].tv_sec,tv_exp[j+2].tv_usec,
+           tv_exp[j+3].tv_sec,tv_exp[j+3].tv_usec,
+           tv_exp[j+4].tv_sec,tv_exp[j+4].tv_usec);
+    j += 4;
+  }
+  do_gettimeofday_fast(&tv0);
+  start_one_shot_timer(&tr[i], test_timeout, i, 50000, "test0");
+  DP(proc_fasttimer_read(buf0, NULL, 0, 0, 0));
+  i++;
+  start_one_shot_timer(&tr[i], test_timeout, i, 70000, "test1");
+  DP(proc_fasttimer_read(buf1, NULL, 0, 0, 0));
+  i++;
+  start_one_shot_timer(&tr[i], test_timeout, i, 40000, "test2");
+  DP(proc_fasttimer_read(buf2, NULL, 0, 0, 0));
+  i++;
+  start_one_shot_timer(&tr[i], test_timeout, i, 60000, "test3");
+  DP(proc_fasttimer_read(buf3, NULL, 0, 0, 0));
+  i++;
+  start_one_shot_timer(&tr[i], test_timeout1, i, 55000, "test4xx");
+  DP(proc_fasttimer_read(buf4, NULL, 0, 0, 0));
+  i++;
+  do_gettimeofday_fast(&tv1);
+
+  proc_fasttimer_read(buf5, NULL, 0, 0, 0);
+
+  prev_num = num_test_timeout;
+  while (num_test_timeout < i)
+  {
+    if (num_test_timeout != prev_num)
+    {
+      prev_num = num_test_timeout;
+    }
+  }
+  do_gettimeofday_fast(&tv2);
+  printk("Timers started    %is %06i\n", tv0.tv_sec, tv0.tv_usec);
+  printk("Timers started at %is %06i\n", tv1.tv_sec, tv1.tv_usec);
+  printk("Timers done       %is %06i\n", tv2.tv_sec, tv2.tv_usec);
+  DP(printk("buf0:\n");
+     printk(buf0);
+     printk("buf1:\n");
+     printk(buf1);
+     printk("buf2:\n");
+     printk(buf2);
+     printk("buf3:\n");
+     printk(buf3);
+     printk("buf4:\n");
+     printk(buf4);
+  );
+  printk("buf5:\n");
+  printk(buf5);
+
+  printk("timers set:\n");
+  for(j = 0; j<i; j++)
+  {
+    struct fast_timer *t = &tr[j];
+    printk("%-10s set: %6is %06ius exp: %6is %06ius "
+           "data: 0x%08X func: 0x%08X\n",
+           t->name,
+           t->tv_set.tv_sec,
+           t->tv_set.tv_usec,
+           t->tv_expires.tv_sec,
+           t->tv_expires.tv_usec,
+           t->data,
+           t->function
+           );
+
+    printk("           del: %6ius     did exp: %6is %06ius as #%i error: %6li\n",
+           t->delay_us,
+           tv_exp[j].tv_sec,
+           tv_exp[j].tv_usec,
+           exp_num[j],
+           (tv_exp[j].tv_sec - t->tv_expires.tv_sec)*1000000 + tv_exp[j].tv_usec - t->tv_expires.tv_usec);
+  }
+  proc_fasttimer_read(buf5, NULL, 0, 0, 0);
+  printk("buf5 after all done:\n");
+  printk(buf5);
+  printk("fast_timer_test() done\n");
+}
+#endif
+
+
+void fast_timer_init(void)
+{
+  /* For some reason, request_irq() hangs when called froom time_init() */
+  if (!fast_timer_is_init)
+  {
+#if 0 && defined(FAST_TIMER_TEST)
+    int i;
+#endif
+
+    printk("fast_timer_init()\n");
+
+#if 0 && defined(FAST_TIMER_TEST)
+    for (i = 0; i <= TIMER0_DIV; i++)
+    {
+      /* We must be careful not to get overflow... */
+      printk("%3i %6u\n", i, timer0_value_us[i]);
+    }
+#endif
+#ifdef CONFIG_PROC_FS
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+   if ((fasttimer_proc_entry = create_proc_entry( "fasttimer", 0, 0 )))
+     fasttimer_proc_entry->read_proc = proc_fasttimer_read;
+#else
+    proc_register_dynamic(&proc_root, &fasttimer_proc_entry);
+#endif
+#endif /* PROC_FS */
+    if(request_irq(TIMER1_IRQ_NBR, timer1_handler, SA_SHIRQ,
+                   "fast timer int", NULL))
+    {
+      printk("err: timer1 irq\n");
+    }
+    fast_timer_is_init = 1;
+#ifdef FAST_TIMER_TEST
+    printk("do test\n");
+    fast_timer_test();
+#endif
+  }
+}
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/kgdb.c ./arch/cris/kernel/kgdb.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/kgdb.c	Fri Nov  9 22:58:02 2001
+++ ./arch/cris/kernel/kgdb.c	Wed Oct 23 12:28:59 2002
@@ -18,6 +18,9 @@
 *! Jul 21 1999  Bjorn Wesen     eLinux port
 *!
 *! $Log: update-2.4.19-axis.patch,v $
 *! Revision 1.1  2004/06/06 14:10:20  rpm
 *! Initial revision
 *!
 *! Revision 1.1  2004/01/02 15:11:03  pgerum
 *! Add Axis update to 2.4.19
 *!
+*! Revision 1.7  2002/07/12 09:14:56  bjornw
+*! Corrected typo
+*!
 *! Revision 1.6  2001/10/09 13:10:03  matsfg
 *! Added $ on registers and removed some underscores
 *!
@@ -55,7 +58,7 @@
 *!
 *!---------------------------------------------------------------------------
 *!
-*! $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+*! $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
 *!
 *! (C) Copyright 1999, Axis Communications AB, LUND, SWEDEN
 *!
@@ -1064,7 +1067,7 @@
 					int regno = gdb_cris_strtol (&remcomInBuffer[1], &suffix, 16);
 					int status;
 #ifdef PROCESS_SUPPORT
-					if (current_thread_g =! executing_task)
+					if (current_thread_g != executing_task)
 						status = write_stack_register (current_thread_g, regno, suffix+1);
 					else
 #endif
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/ksyms.c ./arch/cris/kernel/ksyms.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/ksyms.c	Mon Feb 25 20:37:52 2002
+++ ./arch/cris/kernel/ksyms.c	Wed Oct 23 12:28:59 2002
@@ -24,6 +24,7 @@
 extern void dump_thread(struct pt_regs *, struct user *);
 extern unsigned long get_cmos_time(void);
 extern void __Udiv(void);
+extern void __Umod(void);
 extern void __ashrdi3(void);
 extern void iounmap(void *addr);
 
@@ -47,9 +48,11 @@
 EXPORT_SYMBOL(strlen);
 EXPORT_SYMBOL(strncat);
 EXPORT_SYMBOL(strncmp);
+EXPORT_SYMBOL(strncpy);
 
 /* Math functions */
 EXPORT_SYMBOL(__Udiv);
+EXPORT_SYMBOL(__Umod);
 EXPORT_SYMBOL(__ashrdi3);
 
 /* Memory functions */
@@ -78,6 +81,10 @@
 EXPORT_SYMBOL(__copy_user_zeroing);
 EXPORT_SYMBOL(__copy_user);
 
+/* Cache flush functions */
+EXPORT_SYMBOL(flush_etrax_cache);
+EXPORT_SYMBOL(prepare_rx_descriptor);
+
 #undef memcpy
 #undef memset
 extern void * memset(void *, int, __kernel_size_t);
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/process.c ./arch/cris/kernel/process.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/process.c	Mon Feb 25 20:37:52 2002
+++ ./arch/cris/kernel/process.c	Wed Oct 23 12:28:59 2002
@@ -1,4 +1,4 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
  * 
  *  linux/arch/cris/kernel/process.c
  *
@@ -8,6 +8,10 @@
  *  Authors:   Bjorn Wesen (bjornw@axis.com)
  *
  *  $Log: update-2.4.19-axis.patch,v $
  *  Revision 1.1  2004/06/06 14:10:20  rpm
  *  Initial revision
  *
  *  Revision 1.1  2004/01/02 15:11:03  pgerum
  *  Add Axis update to 2.4.19
  *
+ *  Revision 1.23  2002/10/14 18:29:27  johana
+ *  Call etrax_gpio_wake_up_check() from cpu_idle() to reduce gpio latency
+ *  from ~15 ms to ~6 ms.
+ *
  *  Revision 1.22  2001/11/13 09:40:43  orjanf
  *  Added dump_fpu (needed for core dumps).
  *
@@ -121,11 +125,18 @@
 {
 	hlt_counter--;
 }
- 
+#ifdef CONFIG_ETRAX_GPIO
+void etrax_gpio_wake_up_check(void); /* drivers/gpio.c */
+#endif
+
 int cpu_idle(void *unused)
 {
 	while(1) {
 		current->counter = -100;
+#ifdef CONFIG_ETRAX_GPIO
+		/* This can reduce latency from 15 ms to 6 ms */
+		etrax_gpio_wake_up_check(); /* drivers/gpio.c */
+#endif
 		schedule();
 	}
 }
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/setup.c ./arch/cris/kernel/setup.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/setup.c	Mon Feb 25 20:37:52 2002
+++ ./arch/cris/kernel/setup.c	Wed Oct 23 12:28:59 2002
@@ -1,4 +1,4 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
  *
  *  linux/arch/cris/kernel/setup.c
  *
@@ -169,20 +169,18 @@
 
 	*cmdline_p = command_line;
 
-	if (romfs_in_flash) {
-		strncpy(command_line, "root=", COMMAND_LINE_SIZE);
-		strncpy(command_line+5, CONFIG_ETRAX_ROOT_DEVICE,
+	strncpy(command_line, "root=", COMMAND_LINE_SIZE);
+	strncpy(command_line+5, CONFIG_ETRAX_ROOT_DEVICE,
 			COMMAND_LINE_SIZE-5);
 
-		/* Save command line copy for /proc/cmdline */
-
-		memcpy(saved_command_line, command_line, COMMAND_LINE_SIZE);
-		saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
-	}
+	/* Save command line copy for /proc/cmdline */
+	
+	memcpy(saved_command_line, command_line, COMMAND_LINE_SIZE);
+	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
 
 	/* give credit for the CRIS port */
 
-	printk("Linux/CRIS port on ETRAX 100LX (c) 2001 Axis Communications AB\n");
+	printk("Linux/CRIS port on ETRAX 100LX (c) 2001, 2002 Axis Communications AB\n");
 
 }
 
@@ -234,33 +232,34 @@
 		info = &cpu_info[revision];
 
 	return seq_printf(m,
-		       "cpu\t\t: CRIS\n"
-		       "cpu revision\t: %lu\n"
-		       "cpu model\t: %s\n"
-		       "cache size\t: %d kB\n"
-		       "fpu\t\t: %s\n"
-		       "mmu\t\t: %s\n"
-		       "mmu DMA bug\t: %s\n"
-		       "ethernet\t: %s Mbps\n"
-		       "token ring\t: %s\n"
-		       "scsi\t\t: %s\n"
-		       "ata\t\t: %s\n"
-		       "usb\t\t: %s\n"
-		       "bogomips\t: %lu.%02lu\n",
-
-		       revision,
-		       info->model,
-		       info->cache,
-		       info->flags & HAS_FPU ? "yes" : "no",
-		       info->flags & HAS_MMU ? "yes" : "no",
-		       info->flags & HAS_MMU_BUG ? "yes" : "no",
-		       info->flags & HAS_ETHERNET100 ? "10/100" : "10",
-		       info->flags & HAS_TOKENRING ? "4/16 Mbps" : "no",
-		       info->flags & HAS_SCSI ? "yes" : "no",
-		       info->flags & HAS_ATA ? "yes" : "no",
-		       info->flags & HAS_USB ? "yes" : "no",
-		       (loops_per_jiffy * HZ + 500) / 500000,
-		       ((loops_per_jiffy * HZ + 500) / 5000) % 100);
+			  "processor\t: 0\n"
+			  "cpu\t\t: CRIS\n"
+			  "cpu revision\t: %lu\n"
+			  "cpu model\t: %s\n"
+			  "cache size\t: %d kB\n"
+			  "fpu\t\t: %s\n"
+			  "mmu\t\t: %s\n"
+			  "mmu DMA bug\t: %s\n"
+			  "ethernet\t: %s Mbps\n"
+			  "token ring\t: %s\n"
+			  "scsi\t\t: %s\n"
+			  "ata\t\t: %s\n"
+			  "usb\t\t: %s\n"
+			  "bogomips\t: %lu.%02lu\n",
+
+			  revision,
+			  info->model,
+			  info->cache,
+			  info->flags & HAS_FPU ? "yes" : "no",
+			  info->flags & HAS_MMU ? "yes" : "no",
+			  info->flags & HAS_MMU_BUG ? "yes" : "no",
+			  info->flags & HAS_ETHERNET100 ? "10/100" : "10",
+			  info->flags & HAS_TOKENRING ? "4/16 Mbps" : "no",
+			  info->flags & HAS_SCSI ? "yes" : "no",
+			  info->flags & HAS_ATA ? "yes" : "no",
+			  info->flags & HAS_USB ? "yes" : "no",
+			  (loops_per_jiffy * HZ + 500) / 500000,
+			  ((loops_per_jiffy * HZ + 500) / 5000) % 100);
 }
 
 static void *c_start(struct seq_file *m, loff_t *pos)
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/time.c ./arch/cris/kernel/time.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/kernel/time.c	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/kernel/time.c	Wed Oct 23 12:28:59 2002
@@ -1,9 +1,9 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
  *
  *  linux/arch/cris/kernel/time.c
  *
  *  Copyright (C) 1991, 1992, 1995  Linus Torvalds
- *  Copyright (C) 1999, 2000, 2001 Axis Communications AB
+ *  Copyright (C) 1999, 2000, 2001, 2002 Axis Communications AB
  *
  * 1994-07-02    Alan Modra
  *	fixed set_rtc_mmss, fixed time.year for >= 2000, new mktime
@@ -25,6 +25,9 @@
  *      resolution within a jiffie as well.
  * 2002-03-05    Johan Adolfsson
  *      Use prescaler in do_slow_gettimeoffset() to get 1 us resolution (40ns)
+ * 2002-09-06    Johan Adolfsson
+ *      Handle lost ticks by checking wall_jiffies, more efficient code 
+ *      by using local vars and not the pointer argument.
  *
  */
 
@@ -62,6 +65,8 @@
 
 #define TICK_SIZE tick
 
+extern unsigned long wall_jiffies;
+
 /* The timers count from their initial value down to 1 
  * The R_TIMER0_DATA counts down when R_TIM_PRESC_STATUS reaches halv
  * of the divider value.
@@ -171,10 +176,8 @@
 
 	/*
 	 * avoiding timer inconsistencies (they are rare, but they happen)...
-	 * there are three kinds of problems that must be avoided here:
+	 * there are one problem that must be avoided here:
 	 *  1. the timer counter underflows
-	 *  2. we are after the timer interrupt, but the bottom half handler
-	 *     hasn't executed yet.
 	 */
 	if( jiffies_t == jiffies_p ) {
 		if( count > count_p ) {
@@ -198,7 +201,8 @@
 	return usec_count;
 }
 
-static unsigned long (*do_gettimeoffset)(void) = do_slow_gettimeoffset;
+
+#define do_gettimeoffset() do_slow_gettimeoffset()
 
 /*
  * This version of gettimeofday has near microsecond resolution.
@@ -206,20 +210,33 @@
 void do_gettimeofday(struct timeval *tv)
 {
 	unsigned long flags;
-
+	unsigned long usec, sec;
 	save_flags(flags);
 	cli();
-	*tv = xtime;
-	tv->tv_usec += do_gettimeoffset();
+	usec = do_gettimeoffset();
+	{
+		unsigned long lost = jiffies - wall_jiffies;
+		if (lost)
+			usec += lost * (1000000 / HZ);
+	}
+	sec = xtime.tv_sec;
+	usec += xtime.tv_usec;
 	restore_flags(flags);
-	while (tv->tv_usec >= 1000000) {
-		tv->tv_usec -= 1000000;
-		tv->tv_sec++;
+
+	while (usec >= 1000000) {
+		usec -= 1000000;
+		sec++;
 	}
+
+	tv->tv_sec = sec;
+	tv->tv_usec = usec;
 }
 
 void do_settimeofday(struct timeval *tv)
 {
+	unsigned long flags;
+	signed long new_usec, new_sec;
+	save_flags(flags);  
 	cli();
 	/* This is revolting. We need to set the xtime.tv_usec
 	 * correctly. However, the value in this location is
@@ -227,20 +244,23 @@
 	 * Discover what correction gettimeofday
 	 * would have done, and then undo it!
 	 */
-	tv->tv_usec -= do_gettimeoffset();
-
-	if (tv->tv_usec < 0) {
-		tv->tv_usec += 1000000;
-		tv->tv_sec--;
+	new_usec = tv->tv_usec;
+	new_usec -= do_gettimeoffset();
+	new_usec -= (jiffies - wall_jiffies) * (1000000 / HZ);
+	new_sec = tv->tv_sec;
+	while (new_usec < 0) {
+		new_usec += 1000000;
+		new_sec--;
 	}
+	xtime.tv_sec = new_sec;
+	xtime.tv_usec = new_usec;
 
-	xtime = *tv;
 	time_adjust = 0;		/* stop active adjtime() */
 	time_status |= STA_UNSYNC;
 	time_state = TIME_ERROR;	/* p. 24, (a) */
 	time_maxerror = NTP_PHASE_LIMIT;
 	time_esterror = NTP_PHASE_LIMIT;
-	sti();
+	restore_flags(flags);
 }
 
 
@@ -479,7 +499,13 @@
 void __init
 time_init(void)
 {	
-	/* probe for the RTC and read it if it exists */
+	/* Probe for the RTC and read it if it exists 
+	 * Before the RTC can be probed the loops_per_usec variable needs 
+	 * to be initialized to make usleep work. A better value for 
+	 * loops_per_usec is calculated by the kernel later once the 
+	 * clock has started.  
+	 */
+	loops_per_usec = 50;
 
 	if(RTC_INIT() < 0) {
 		/* no RTC, start at 1980 */
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/lib/dram_init.S ./arch/cris/lib/dram_init.S
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/lib/dram_init.S	Mon Oct  8 20:43:54 2001
+++ ./arch/cris/lib/dram_init.S	Wed Oct 23 12:28:59 2002
@@ -1,4 +1,4 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
  * 
  * DRAM/SDRAM initialization - alter with care
  * This file is intended to be included from other assembler files
@@ -11,6 +11,12 @@
  * Authors:  Mikael Starvik (starvik@axis.com)	
  * 
  * $Log: update-2.4.19-axis.patch,v $
  * Revision 1.1  2004/06/06 14:10:20  rpm
  * Initial revision
  *
  * Revision 1.1  2004/01/02 15:11:03  pgerum
  * Add Axis update to 2.4.19
  *
+ * Revision 1.12  2002/08/09 11:37:37  orjanf
+ * Added double initialization work-around for Samsung SDRAMs.
+ *
+ * Revision 1.11  2002/06/04 11:43:21  starvik
+ * Check if mrs_data is specified in kernelconfig (necessary for MCM)
+ *
  * Revision 1.10  2001/10/04 12:00:21  martinnn
  * Added missing underscores.
  *
@@ -70,7 +76,11 @@
 
 	move.d   CONFIG_ETRAX_DEF_R_DRAM_TIMING, $r0
 	move.d   $r0, [R_DRAM_TIMING]
-#else	
+#else
+	;; Samsung SDRAMs seem to require to be initialized twice to work properly.
+	moveq    2, $r6	
+_sdram_init:
+	
 	; Refer to ETRAX 100LX Designers Reference for a description of SDRAM initialization
 	
 	; Bank configuration
@@ -82,6 +92,12 @@
 	; CAS latency = 3 && bus_width = 32 => 0x60
 	; CAS latency = 2 && bus_width = 16 => 0x20
 	; CAS latency = 3 && bus_width = 16 => 0x30
+
+	; Check if value is already supplied in kernel config
+	move.d   CONFIG_ETRAX_DEF_R_SDRAM_TIMING, $r2
+	and.d    0x00ff0000, $r2
+	bne	 _set_timing
+	lsrq     16, $r2
 	
 	move.d   0x40, $r2       ; Assume 32 bits and CAS latency = 2
 	move.d   CONFIG_ETRAX_DEF_R_SDRAM_TIMING, $r1
@@ -142,6 +158,9 @@
 	bne      1b
 	nop
 	move.d   $r5, [R_SDRAM_TIMING]
+	subq     1, $r6
+	bne      _sdram_init
+	nop
 	ba       _sdram_commands_end
 	nop
 
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/lib/hw_settings.S ./arch/cris/lib/hw_settings.S
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/lib/hw_settings.S	Wed Jul  4 20:50:39 2001
+++ ./arch/cris/lib/hw_settings.S	Wed Oct 23 12:28:59 2002
@@ -1,11 +1,11 @@
 /*
- * $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+ * $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
  * 
  * This table is used by some tools to extract hardware parameters.
  * The table should be included in the kernel and the decompressor.
  * Don't forget to update the tools if you change this table.
  *
- * Copyright (C) 2001 Axis Communications AB
+ * Copyright (C) 2001, 2002 Axis Communications AB
  *
  * Authors:  Mikael Starvik (starvik@axis.com)	
  */
@@ -16,8 +16,8 @@
 		(CONFIG_ETRAX_DEF_R_PORT_PB_DIR << 8) | \
 		(CONFIG_ETRAX_DEF_R_PORT_PB_DATA))
 	
-	.ascii "HW_PARAM_MAGIC" ; Magic number
-	.dword 0xc0004000	; Kernel start address
+	.ascii "HW_PARAM_MAGIC"	; Magic number
+	.dword 0xc0004000	; Where to load the kernel image (physical!)
 
 	; Debug port
 #ifdef CONFIG_ETRAX_DEBUG_PORT0
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/lib/usercopy.c ./arch/cris/lib/usercopy.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/lib/usercopy.c	Mon Oct  8 20:43:54 2001
+++ ./arch/cris/lib/usercopy.c	Wed Oct 23 12:28:59 2002
@@ -88,11 +88,11 @@
        If you want to check that the allocation was right; then
        check the equalities in the first comment.  It should say
        "r13=r13, r11=r11, r12=r12".  */
-    __asm__ volatile ("
-	;; Check that the following is true (same register names on
-	;; both sides of equal sign, as in r8=r8):
-	;; %0=r13, %1=r11, %2=r12 %3=r10
-	;;
+    __asm__ volatile ("\
+	.ifnc %0%1%2%3,$r13$r11$r12$r10					\n\
+	.err								\n\
+	.endif								\n\
+
 	;; Save the registers we'll use in the movem process
 	;; on the stack.
 	subq	11*4,$sp
@@ -189,7 +189,8 @@
 }
 
 /* Copy from user to kernel, zeroing the bytes that were inaccessible in
-   userland.  */
+   userland.  The return-value is the number of bytes that were
+   inaccessible.  */
 
 unsigned long
 __copy_user_zeroing (void *pdst, const void *psrc, unsigned long pn)
@@ -207,30 +208,34 @@
   register int n __asm__ ("r12") = pn;
   register int retn __asm__ ("r10") = 0;
 
-  /* When src is aligned but not dst, this makes a few extra needless
-     cycles.  I believe it would take as many to check that the
-     re-alignment was unnecessary.  */
-  if (((unsigned long) dst & 3) != 0
-      /* Don't align if we wouldn't copy more than a few bytes; so we
-	 don't have to check further for overflows.  */
-      && n >= 3)
+  /* The best reason to align src is that we then know that a read-fault
+     was for aligned bytes; there's no 1..3 remaining good bytes to
+     pickle.  */
+  if (((unsigned long) src & 3) != 0)
   {
-    if ((unsigned long) dst & 1)
+    if (((unsigned long) src & 1) && n != 0)
     {
       __asm_copy_from_user_1 (dst, src, retn);
       n--;
     }
 
-    if ((unsigned long) dst & 2)
+    if (((unsigned long) src & 2) && n >= 2)
     {
       __asm_copy_from_user_2 (dst, src, retn);
       n -= 2;
     }
+
+    /* We only need one check after the unalignment-adjustments, because
+       if both adjustments were done, either both or neither reference
+       had an exception.  */
+    if (retn != 0)
+      goto copy_exception_bytes;
   }
 
   /* Decide which copying method to use. */
   if (n >= 44*2)		/* Break even between movem and
-				   move16 is at 38.7*2, but modulo 44. */
+				   move16 is at 38.7*2, but modulo 44.
+				   FIXME: We use move4 now.  */
   {
     /* For large copies we use 'movem' */
 
@@ -249,10 +254,10 @@
        check the equalities in the first comment.  It should say
        "r13=r13, r11=r11, r12=r12" */
     __asm__ volatile ("
-	;; Check that the following is true (same register names on
-	;; both sides of equal sign, as in r8=r8):
-	;; %0=r13, %1=r11, %2=r12 %3=r10
-	;;
+	.ifnc %0%1%2%3,$r13$r11$r12$r10					\n\
+	.err								\n\
+	.endif								\n\
+
 	;; Save the registers we'll use in the movem process
 	;; on the stack.
 	subq	11*4,$sp
@@ -273,73 +278,30 @@
 	movem	$r10,[$r13+]
 
 	addq   44,$r12  ;; compensate for last loop underflowing n
-8:
+
 	;; Restore registers from stack
 	movem [$sp+],$r10
-
+4:
 	.section .fixup,\"ax\"
 
 ;; Do not jump back into the loop if we fail.  For some uses, we get a
-;; page fault but for performance reasons we care to not get further
-;; faults.  For example, fs/super.c at one time did
+;; page fault somewhere on the line.  Without checking for page limits,
+;; we don't know where, but we need to copy accurately and keep an
+;; accurate count; not just clear the whole line.  To do that, we fall
+;; down in the code below, proceeding with smaller amounts.  It should
+;; be kept in mind that we have to cater to code like what at one time
+;; was in fs/super.c:
 ;;  i = size - copy_from_user((void *)page, data, size);
 ;; which would cause repeated faults while clearing the remainder of
 ;; the SIZE bytes at PAGE after the first fault.
+;; A caveat here is that we must not fall through from a failing page
+;; to a valid page.
 
 3:
-	move.d [$sp],$r10
-
-;; Number of remaining bytes, cleared but not copied, is r12 + 44.
-
-	add.d $r12,$r10
-	addq 44,$r10
-
-	move.d $r10,[$sp]
-	clear.d $r0
-	clear.d $r1
-	clear.d $r2
-	clear.d $r3
-	clear.d $r4
-	clear.d $r5
-	clear.d $r6
-	clear.d $r7
-	clear.d $r8
-	clear.d $r9
-	clear.d $r10
-
-;; Perform clear similar to the copy-loop.
-
-4:
-	subq 44,$r12
-	bge 4b
-	movem $r10,[$r13+]
-
-;; Clear by four for the remaining multiples.
-
-	addq 40,$r12
-	bmi 6f
-	nop
-5:
-	subq 4,$r12
-	bpl 5b
-	clear.d [$r13+]
-6:
-	addq 4,$r12
-	beq 7f
-	nop
-
-	subq 1,$r12
-	beq 7f
-	clear.b [$r13+]
-
-	subq 1,$r12
-	beq 7f
-	clear.b [$r13+]
-
-	clear.d $r12
-	clear.b [$r13+]
-7:
-	jump 8b
+	movem  [$sp+],$r10
+	addq	44,$r12 ;; Get back count before faulting point.
+	subq	44,$r11 ;; Get back pointer to faulting movem-line.
+	jump	4b	;; Fall through, pretending the fault didn't happen.
 
 	.previous
 	.section __ex_table,\"a\"
@@ -354,25 +316,30 @@
   /* Either we directly start copying here, using dword copying in a loop,
      or we copy as much as possible with 'movem' and then the last block
      (<44 bytes) is copied here.  This will work since 'movem' will have
-     updated src, dst and n. */
+     updated src, dst and n.  (Except with failing src.)
 
-  while (n >= 16)
-  {
-    __asm_copy_from_user_16 (dst, src, retn);
-    n -= 16;
-  }
+     Since we want to keep src accurate, we can't use
+     __asm_copy_from_user_N with N != (1, 2, 4); it updates dst and
+     retn, but not src (by design; it's value is ignored elsewhere).  */
 
-  /* Having a separate by-four loops cuts down on cache footprint.
-     FIXME:  Test with and without; increasing switch to be 0..15.  */
   while (n >= 4)
   {
     __asm_copy_from_user_4 (dst, src, retn);
     n -= 4;
+
+    if (retn)
+      goto copy_exception_bytes;
   }
 
+  /* If we get here, there were no memory read faults.  */
   switch (n)
   {
+    /* These copies are at least "naturally aligned" (so we don't have
+       to check each byte), due to the src alignment code before the
+       movem loop.  The *_3 case *will* get the correct count for retn.  */
     case 0:
+      /* This case deliberately left in (if you have doubts check the
+	 generated assembly code).  */
       break;
     case 1:
       __asm_copy_from_user_1 (dst, src, retn);
@@ -385,7 +352,22 @@
       break;
   }
 
+  /* If we get here, retn correctly reflects the number of failing
+     bytes.  */
   return retn;
+
+copy_exception_bytes:
+  /* We already have "retn" bytes cleared, and need to clear the
+     remaining "n" bytes.  A non-optimized simple byte-for-byte in-line
+     memset is preferred here, since this isn't speed-critical code and
+     we'd rather have this a leaf-function than calling memset.  */
+  {
+    char *endp;
+    for (endp = dst + n; dst < endp; dst++)
+      *dst = 0;
+  }
+
+  return retn + n;
 }
 
 /* Zero userspace.  */
@@ -444,10 +426,10 @@
       check the equalities in the first comment.  It should say
       something like "r13=r13, r11=r11, r12=r12". */
     __asm__ volatile ("
-	;; Check that the following is true (same register names on
-	;; both sides of equal sign, as in r8=r8):
-	;; %0=r13, %1=r12 %2=r10
-	;;
+	.ifnc %0%1%2,$r13$r12$r10					\n\
+	.err								\n\
+	.endif								\n\
+
 	;; Save the registers we'll clobber in the movem process
 	;; on the stack.  Don't mention them to gcc, it will only be
 	;; upset.
diff -Nur /home/starvik/download/kernel/linux-2.4.19/arch/cris/mm/fault.c ./arch/cris/mm/fault.c
--- /home/starvik/download/kernel/linux-2.4.19/arch/cris/mm/fault.c	Sat Aug  3 02:39:42 2002
+++ ./arch/cris/mm/fault.c	Wed Oct 23 12:28:59 2002
@@ -6,6 +6,9 @@
  *  Authors:  Bjorn Wesen 
  * 
  *  $Log: update-2.4.19-axis.patch,v $
  *  Revision 1.1  2004/06/06 14:10:20  rpm
  *  Initial revision
  *
  *  Revision 1.1  2004/01/02 15:11:03  pgerum
  *  Add Axis update to 2.4.19
  *
+ *  Revision 1.21  2002/05/28 14:24:56  bjornw
+ *  Corrected typo
+ *
  *  Revision 1.20  2001/11/22 13:34:06  bjornw
  *  * Bug workaround (LX TR89): force a rerun of the whole of an interrupted
  *    unaligned write, because the second half of the write will be corrupted
diff -Nur /home/starvik/download/kernel/linux-2.4.19/drivers/ide/ide-geometry.c ./drivers/ide/ide-geometry.c
--- /home/starvik/download/kernel/linux-2.4.19/drivers/ide/ide-geometry.c	Sat Aug  3 02:39:44 2002
+++ ./drivers/ide/ide-geometry.c	Wed Oct 23 12:29:00 2002
@@ -3,7 +3,9 @@
  */
 #include <linux/config.h>
 #include <linux/ide.h>
+#ifdef __i386__
 #include <linux/mc146818rtc.h>
+#endif
 #include <asm/io.h>
 
 #ifdef CONFIG_BLK_DEV_IDE
diff -Nur /home/starvik/download/kernel/linux-2.4.19/drivers/mtd/devices/mtdram.c ./drivers/mtd/devices/mtdram.c
--- /home/starvik/download/kernel/linux-2.4.19/drivers/mtd/devices/mtdram.c	Sat Aug  3 02:39:44 2002
+++ ./drivers/mtd/devices/mtdram.c	Wed Oct 23 12:29:00 2002
@@ -108,65 +108,119 @@
 {
   if (mtd_info) {
     del_mtd_device(mtd_info);
+#if CONFIG_MTDRAM_TOTAL_SIZE > 0
     if (mtd_info->priv)
 #if CONFIG_MTDRAM_ABS_POS > 0
       iounmap(mtd_info->priv);
 #else
       vfree(mtd_info->priv);
 #endif	
+#endif
     kfree(mtd_info);
   }
 }
 
+int mtdram_init_device(struct mtd_info *mtd, void *mapped_address, 
+                       unsigned long size, char *name)
+{
+   memset(mtd, 0, sizeof(*mtd));
+
+   /* Setup the MTD structure */
+   mtd->name = name;
+   mtd->type = MTD_RAM;
+   mtd->flags = MTD_CAP_RAM;
+   mtd->size = size;
+   mtd->erasesize = MTDRAM_ERASE_SIZE;
+   mtd->priv = mapped_address;
+
+   mtd->module = THIS_MODULE;
+   mtd->erase = ram_erase;
+   mtd->point = ram_point;
+   mtd->unpoint = ram_unpoint;
+   mtd->read = ram_read;
+   mtd->write = ram_write;
+
+   if (add_mtd_device(mtd)) {
+     return -EIO;
+   }
+   
+   return 0;
+}
+
+#if CONFIG_MTDRAM_TOTAL_SIZE > 0
+#if CONFIG_MTDRAM_ABS_POS > 0
 int __init init_mtdram(void)
 {
-   // Allocate some memory
+  void *addr;
+  int err;
+  /* Allocate some memory */
    mtd_info = (struct mtd_info *)kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
    if (!mtd_info)
-      return -ENOMEM;
+     return -ENOMEM;
    
-   memset(mtd_info, 0, sizeof(*mtd_info));
+  addr = ioremap(CONFIG_MTDRAM_ABS_POS, MTDRAM_TOTAL_SIZE);
+  if (!addr) {
+    DEBUG(MTD_DEBUG_LEVEL1, 
+          "Failed to ioremap) memory region of size %ld at ABS_POS:%ld\n", 
+          (long)MTDRAM_TOTAL_SIZE, (long)CONFIG_MTDRAM_ABS_POS);
+    kfree(mtd_info);
+    mtd_info = NULL;
+    return -ENOMEM;
+  }
+  err = mtdram_init_device(mtd_info, addr, 
+                           MTDRAM_TOTAL_SIZE, "mtdram test device");
+  if (err) 
+  {
+    iounmap(addr);
+    kfree(mtd_info);
+    mtd_info = NULL;
+    return err;
+  }
+  memset(mtd_info->priv, 0xff, MTDRAM_TOTAL_SIZE);
+  return err;
+}
 
-   // Setup the MTD structure
-   mtd_info->name = "mtdram test device";
-   mtd_info->type = MTD_RAM;
-   mtd_info->flags = MTD_CAP_RAM;
-   mtd_info->size = MTDRAM_TOTAL_SIZE;
-   mtd_info->erasesize = MTDRAM_ERASE_SIZE;
-#if CONFIG_MTDRAM_ABS_POS > 0
-   mtd_info->priv = ioremap(CONFIG_MTDRAM_ABS_POS, MTDRAM_TOTAL_SIZE);
-#else
-   mtd_info->priv = vmalloc(MTDRAM_TOTAL_SIZE);
-#endif
+#else /* CONFIG_MTDRAM_ABS_POS > 0 */
 
-   if (!mtd_info->priv) {
-     DEBUG(MTD_DEBUG_LEVEL1, "Failed to vmalloc(/ioremap) memory region of size %ld (ABS_POS:%ld)\n", (long)MTDRAM_TOTAL_SIZE, (long)CONFIG_MTDRAM_ABS_POS);
-     kfree(mtd_info);
-     mtd_info = NULL;
+int __init init_mtdram(void)
+{
+  void *addr;
+  int err;
+  /* Allocate some memory */
+   mtd_info = (struct mtd_info *)kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+   if (!mtd_info)
      return -ENOMEM;
-   }
-   memset(mtd_info->priv, 0xff, MTDRAM_TOTAL_SIZE);
 
-   mtd_info->module = THIS_MODULE;			
-   mtd_info->erase = ram_erase;
-   mtd_info->point = ram_point;
-   mtd_info->unpoint = ram_unpoint;
-   mtd_info->read = ram_read;
-   mtd_info->write = ram_write;
+  addr = vmalloc(MTDRAM_TOTAL_SIZE);
+  if (!addr) {
+    DEBUG(MTD_DEBUG_LEVEL1, 
+          "Failed to vmalloc memory region of size %ld\n", 
+          (long)MTDRAM_TOTAL_SIZE);
+    kfree(mtd_info);
+    mtd_info = NULL;
+    return -ENOMEM;
+  }
+  err = mtdram_init_device(mtd_info, addr, 
+                           MTDRAM_TOTAL_SIZE, "mtdram test device");
+  if (err) 
+  {
+    vfree(addr);
+    kfree(mtd_info);
+    mtd_info = NULL;
+    return err;
+  }
+  memset(mtd_info->priv, 0xff, MTDRAM_TOTAL_SIZE);
+  return err;
+}
+#endif /* !(CONFIG_MTDRAM_ABS_POS > 0) */
+
+#else /* CONFIG_MTDRAM_TOTAL_SIZE > 0 */
 
-   if (add_mtd_device(mtd_info)) {
-#if CONFIG_MTDRAM_ABS_POS > 0
-     iounmap(mtd_info->priv);
-#else
-     vfree(mtd_info->priv);
-#endif	
-     kfree(mtd_info);
-     mtd_info = NULL;
-     return -EIO;
-   }
-   
-   return 0;
+int __init init_mtdram(void)
+{
+  return 0;
 }
+#endif /* !(CONFIG_MTDRAM_TOTAL_SIZE > 0) */
 
 module_init(init_mtdram);
 module_exit(cleanup_mtdram);
diff -Nur /home/starvik/download/kernel/linux-2.4.19/drivers/net/bnep.c ./drivers/net/bnep.c
--- /home/starvik/download/kernel/linux-2.4.19/drivers/net/bnep.c	Thu Jan  1 01:00:00 1970
+++ ./drivers/net/bnep.c	Wed Oct 23 12:29:00 2002
@@ -0,0 +1,1654 @@
+/*
+ * bnep.c -- Implementation of Bluetooth BNEP 
+ *           
+ *
+ * Copyright (C) 2001  Axis Communications AB
+ *
+ * Author: Willy Sagefalk <willy.sagefalk@axis.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * Exceptionally, Axis Communications AB grants discretionary and
+ * conditional permissions for additional use of the text contained
+ * in the company's release of the AXIS OpenBT Stack under the
+ * provisions set forth hereunder.
+ *
+ * Provided that, if you use the AXIS OpenBT Stack with other files,
+ * that do not implement functionality as specified in the Bluetooth
+ * System specification, to produce an executable, this does not by
+ * itself cause the resulting executable to be covered by the GNU
+ * General Public License. Your use of that executable is in no way
+ * restricted on account of using the AXIS OpenBT Stack code with it.
+ *
+ * This exception does not however invalidate any other reasons why
+ * the executable file might be covered by the provisions of the GNU
+ * General Public License.
+ *
+ *
+ */
+
+/****************** INCLUDE FILES SECTION ***********************************/
+
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/socket.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/in.h>
+#include <linux/init.h>
+
+#include <linux/inet.h>
+#include <linux/ioctl.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/malloc.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_ether.h>
+
+#include <linux/ip.h>
+#include <linux/udp.h>
+
+#include <linux/bluetooth/btdebug.h>
+#include <linux/bluetooth/btcommon.h>
+#include <linux/bluetooth/btmem.h>
+#include <linux/bluetooth/l2cap.h>
+#include <linux/bluetooth/hci.h>
+#include "bnep.h"
+
+/****************** DEBUG CONSTANT AND MACRO SECTION ************************/
+
+
+/* Defines for the debug macros */
+
+#if BNEP_DEBUG_XMIT
+#define D_XMIT(fmt, args...) printk(BNEP_DBG_STR fmt, ## args)
+#else
+#define D_XMIT(fmt, args...)
+#endif
+
+#if BNEP_DEBUG_REC
+#define D_REC(fmt, args...) printk(BNEP_DBG_STR fmt, ## args)
+#else
+#define D_REC(fmt, args...)
+#endif
+
+#if BNEP_DEBUG_MISC
+#define D_MISC(fmt, args...) printk(BNEP_DBG_STR fmt, ## args)
+#else
+#define D_MISC(fmt, args...)
+#endif
+
+#if BNEP_DEBUG_DATA
+#define PRINTPKT(str, data, len) print_data(str, data, len)
+#else
+#define PRINTPKT(str, data, len)
+#endif
+
+/****************** CONSTANT AND MACRO SECTION ******************************/
+
+
+#define BNEP_MAX_CON        7
+#define BNEP_FLUSH_TIMEOUT  0
+#define BNEP_MAX_MULTI     16
+
+/****************** TYPE DEFINITION SECTION *********************************/
+
+/****************** LOCAL FUNCTION DECLARATION SECTION **********************/
+
+/****************** GLOBAL VARIABLE DECLARATION SECTION *********************/
+
+/****************** LOCAL VARIABLE DECLARATION SECTION **********************/
+
+static const char* cardname = "BNEP ethernet encapsulation";
+
+/* A default ethernet address. Highlevel SW will set the real one later */
+
+static struct sockaddr default_mac = {
+	0,
+        { 0x00, 0x40, 0x8C, 0xCD, 0x00, 0x00 }
+};
+
+struct macaddr
+{
+	unsigned char addr[ETH_ALEN];
+};
+
+/* Information that need to be kept for each board. */
+struct net_local {
+	struct net_device_stats stats;
+        l2cap_con *l2cap;
+        int promiscuous;
+        int allmulti;
+        int mc_count;
+        u16 filter_list[BNEP_MAX_FILTER * 2];
+        struct macaddr mc_list[BNEP_MAX_MULTI];
+};
+
+static struct net_device dev_bnep[7];  /* Got 7 Interfaces */
+static char bnep_dev_name[16];
+static protocol_layer this_layer;
+
+struct arprequest
+{
+	unsigned short ar_hrd;  /* format of hardware address	*/
+	unsigned short ar_pro;  /* format of protocol address	*/
+	unsigned char	ar_hln;	  /* length of hardware address	*/
+	unsigned char	ar_pln;	  /* length of protocol address	*/
+	unsigned short ar_op;   /* ARP opcode (command)*/	
+	unsigned char	ar_sha[ETH_ALEN]; /* sender hardware address	*/
+	unsigned char	ar_sip[4];	  /* sender IP address		*/
+	unsigned char	ar_tha[ETH_ALEN]; /* target hardware address	*/
+	unsigned char	ar_tip[4];	  /* target IP address		*/
+};
+
+
+/****************** LOCAL FUNCTION DECLARATION SECTION **********************/
+
+void bnep_init(void);
+void bnep_receive_packet(l2cap_con *l2cap, u8 *data, u32 len);
+static int  bnep_open(struct net_device *dev);
+static int  bnep_send_packet(struct sk_buff *skb, struct net_device *dev);
+static int  bnep_close(struct net_device *dev);
+static int  bnep_set_mac_address(struct net_device *dev, void *p);
+static void bnep_set_multicast_list(struct net_device *dev);
+static struct net_device_stats *bnep_get_stats(struct net_device *dev);
+
+
+
+/****************** FUNCTION DEFINITION SECTION *****************************/
+
+static print_ip_packet(char *data, u16 proto)
+{
+	struct iphdr      *ip;
+	struct arphdr     *arp;
+	if (proto ==  ETH_P_IP)
+	{
+		ip = (struct iphdr *)data;
+		
+		printk("IP: tos %02x tot_len %04x ID %04x \n frag_off %04x ttl %02x protocol %02x check %04x \n saddr %08x daddr %08x\n", ip->tos, be16_to_cpu(ip->tot_len) , be16_to_cpu(ip->id) , be16_to_cpu(ip->frag_off), ip->ttl, ip->protocol, be16_to_cpu(ip->check), ip->saddr , ip->daddr);
+	}
+	else if (proto ==  ETH_P_ARP)
+	{
+		struct arprequest *arpr;
+		arpr = (struct arprequest *)data; 
+		printk("ARP:");
+		switch (arpr->ar_op)
+		{
+		case 1:
+			printk("Request\n");
+			break;
+		case 2:
+			printk("Reply\n");
+			break;
+		default:
+			printk(" %i ",arpr->ar_op);
+		}
+		printk("Sender %02x:%02x:%02x:%02x:%02x:%02x\n ",arpr->ar_sha[0],arpr->ar_sha[1],arpr->ar_sha[2],arpr->ar_sha[3],arpr->ar_sha[4],arpr->ar_sha[5]);
+		printk("Sender IP %i.%i.%i.%i\n",arpr->ar_sip[0],arpr->ar_sip[1],arpr->ar_sip[2],arpr->ar_sip[3]);
+		printk("Target %02x:%02x:%02x:%02x:%02x:%02x\n ",arpr->ar_tha[0],arpr->ar_tha[1],arpr->ar_tha[2],arpr->ar_tha[3],arpr->ar_tha[4],arpr->ar_tha[5]);
+		printk("Target IP %i.%i.%i.%i\n",arpr->ar_tip[0],arpr->ar_tip[1],arpr->ar_tip[2],arpr->ar_tip[3]);
+	} 
+	else 
+	{ 
+		D_REC("Proto %04x \n",proto);
+	}
+}  
+
+static int __init
+bnep_init_driver(struct net_device *dev)
+{
+        struct net_local  *local;
+        
+        printk("BNEP driver v0.1 (c) 2001 Axis Communications AB\n");
+	printk("%s initialized\n", dev->name);
+	
+        if (!dev) {  
+                D_ERR("dev == NULL. Should this happen?\n"); 
+  		dev = init_etherdev(dev, sizeof(struct net_local)); 
+  	} 
+	
+  	/* setup generic handlers and stuff in the dev struct */ 
+  	ether_setup(dev); 
+	
+	/* make room for the local structure containing stats etc */
+        dev->priv = kmalloc(sizeof(struct net_local), GFP_KERNEL);
+	
+	if (dev->priv == NULL)
+		return -ENOMEM;
+	
+	
+	
+        /* Reset private structure and accept all packet types */
+        memset(dev->priv, 0, sizeof(struct net_local));
+        local = dev->priv;
+        local->filter_list[0] = 0x0000;
+        local->filter_list[1] = 0xffff;
+	
+        dev->irq = 0;
+        dev->dma = 1;
+	
+        dev->open               = bnep_open;
+        dev->hard_start_xmit    = bnep_send_packet;
+        dev->stop               = bnep_close;
+        dev->get_stats          = bnep_get_stats;
+        dev->set_multicast_list = bnep_set_multicast_list;
+        dev->set_mac_address    = bnep_set_mac_address;
+	
+        return 0;
+}
+
+static int
+bnep_set_mac_address(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = p;
+	
+	int i;  
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+	
+	D_MISC("%s: changed MAC to ",dev->name);
+	D_MISC("%02X:%02x:%02x:%02x:%02x:%02x\n", dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2], dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+	return 0;
+}
+
+/*
+ * Open/initialize the board. This is called (in the current kernel)
+ * sometime after booting when the 'ifconfig' program is run.
+ *
+ * This routine should set everything up anew at each open, even
+ * registers that "should" only need to be set once at boot, so that
+ * there is non-reboot way to recover if something goes wrong.
+ */
+
+static int
+bnep_open(struct net_device *dev)
+{
+	D_MISC("open device\n");
+	netif_start_queue(dev);
+	return 0;
+}
+
+int
+bnep_close(struct net_device *dev)
+{
+	D_MISC("close device\n"); 
+	netif_stop_queue(dev);
+	return 0;
+}
+
+/* Send a packet without building a BNEP header  */
+
+static int
+bnep_send_raw_packet(struct sk_buff *skb, struct net_device *dev)
+{
+	bt_tx_buf         *tx_buf;
+	struct net_local  *local;
+	struct ethhdr     *eth;
+	int i,bhdrlen,ethhdrlen;
+	struct bnep_general_ethernet bnep;
+	
+	
+	D_XMIT("bnep_send_packet: transmitting %d bytes\n", skb->len);
+	PRINTPKT("bnep_send_packet:",skb->data,skb->len);
+	
+	local = dev->priv;
+	
+	if (local->l2cap == NULL) {
+		/* no connection; drop the packet */
+		D_XMIT("bnep send packet: no connection exists\n");
+		local->stats.tx_dropped++;
+	}
+	else
+	{
+		/* check whether the we have room for the bt_tx_buf */
+		if (buf_write_room() < (skb->len)) {
+			D_XMIT("bnep send packet: not enough room for a %d byte bt_tx_buf\n", skb->len);
+			/* don't necessarily need to discard the buffer; could set dev->tbusy = 1
+			   and then start a timer to check for free buffer space */
+			local->stats.tx_dropped++;
+		}
+		else
+		{
+			/* subscribe to a bt_tx_buf */
+			D_XMIT("New bt buf length %i \n",skb->len + sizeof(bnep_tx_buf));
+			if ((tx_buf = subscribe_bt_buf(skb->len + sizeof(bnep_tx_buf)  )) == NULL) {
+				D_ERR("bnep send packet: failed to subscribe to a %d byte bt_tx_buf\n", skb->len);
+				local->stats.tx_dropped++;
+			}
+			else
+			{
+				
+				/* copy the frame into the bt_tx_buf */
+				/*  printk("Copy frame into bt_tx_buf\n");*/
+				memcpy(tx_buf->data + sizeof(bnep_tx_buf), skb->data, skb->len);
+				tx_buf->cur_len = skb->len;
+				
+				/* transmit the packet */
+				printk("bnep: tx packet\n");
+				l2cap_send_data(tx_buf, local->l2cap);
+				
+				
+				/* update the device statistics */
+				local->stats.tx_packets++;
+				local->stats.tx_bytes += skb->len;
+			}
+		}
+	}
+	/* free the sk_buff */
+	dev_kfree_skb(skb); 
+	return 0;
+}
+/*********************************************************/
+/* PAN Test cases and some home made tests               */
+/*********************************************************/
+
+u32
+bnep_test(u8 *p)
+{
+	int test,i;
+	struct net_device *dev;
+	struct net_local  *local;
+	struct l2cap_con *l2cap;
+	char temp_addr[6];
+	u8 destip[4];
+	test = p[0];
+	destip[0] = p[1];
+	destip[1] = p[2];
+	destip[2] = p[3];
+	destip[3] = p[4];
+	
+	
+	printk("BNEP:test %i \n",test);
+	
+	dev = &dev_bnep[0];
+	local = dev->priv;
+	l2cap = local->l2cap;
+	
+	switch (test)
+	{
+	case 1:
+	case 7:
+	case 9:
+		printk("Test Case %i -- TX for BNEP Type 0x00 general\n",test);
+		{
+			struct sk_buff *skb;
+			struct bnep_general_ethernet bnep;
+			struct iphdr ip;
+			struct udphdr udp;
+			
+			int len,u,i,pos;
+			
+			bnep.bnep_type = BNEP_GENERAL_ETHERNET;
+			for ( i=0; i<6; i++) {
+				if( test == 7) {
+					bnep.daddr[i] = 0xff;
+				} 
+				else if( test == 1)  {
+					bnep.daddr[i] = l2cap->remote_bd[5-i];
+				}
+				else if( test == 9)  {
+					bnep.daddr[0] = 0x01;
+					bnep.daddr[1] = 0x00;
+					bnep.daddr[2] = 0x5e;
+					bnep.daddr[3] = 0x00;
+					bnep.daddr[4] = 0x00;
+					bnep.daddr[5] = 0x00;
+				}
+			} 
+			for ( i=0; i<6; i++) {
+				bnep.saddr[i] = dev->dev_addr[i];
+			}    
+			bnep.type = cpu_to_be16( 0x0800 );
+			ip.version   = 4;
+			ip.ihl       = 5;
+			ip.frag_off  = 0;
+			ip.ttl       = 15;
+			ip.tot_len   = 0x5dc;
+			ip.protocol  = 0x11;
+			if (test == 7) {
+				ip.saddr     = 0xffffffff;
+			} 
+			else if (test == 1) {
+				ip.saddr     = 0;
+			}
+			else if (test == 9) {
+				ip.saddr     = 0;
+			}
+			ip.daddr     = 0;
+			
+			udp.source = 0x00;
+			udp.dest   = 0x07;
+			udp.len    = 0x5c8;
+			
+			len = sizeof(struct bnep_general_ethernet) + sizeof(struct iphdr) + sizeof(struct udphdr) + 0x5c0;
+			printk("Allocate %i bytes\n",len);
+			
+			if ((skb = dev_alloc_skb(len)) == NULL) {
+				printk("Alloc skb failed \n");
+				return 0;
+			}
+			pos = 0;
+			skb_put(skb,len);
+			memcpy(skb->data , (void*)&bnep, sizeof(struct bnep_general_ethernet));
+			pos += sizeof(struct bnep_general_ethernet);
+			memcpy(skb->data + pos, (void*)&ip, sizeof(struct iphdr));
+			pos += sizeof(struct iphdr);
+			memcpy(skb->data + pos, (void*)&udp, sizeof(struct udphdr));
+			pos += sizeof(struct udphdr);
+			i = 0;
+			while (pos < len)
+			{ 
+				skb->data[pos] = i;
+				printk("%02x",i);
+				i++;
+				pos++;
+				if (i>0xff) i = 0;
+			} 
+			printk("\nSend raw packet.....");
+			bnep_send_raw_packet(skb,&dev_bnep[0]);
+		}
+		break;
+	case 2:
+		printk("Test Case 2 -- TX for BNEP Type 0x02 compressed\n");
+		{
+			struct sk_buff *skb;
+			struct bnep_compressed_ethernet bnep;
+			struct iphdr ip;
+			struct udphdr udp;
+			int len,u,i,pos;
+			
+			bnep.bnep_type = BNEP_COMPRESSED_ETHERNET;
+			bnep.type =  cpu_to_be16(0x0800);
+			ip.tot_len = 0x5dc;
+			ip.protocol = 0x11;
+			ip.saddr = 0;
+			ip.daddr = 0;
+			
+			udp.source = 00;
+			udp.dest = 0x07;
+			udp.len = 0x5c8;
+			
+			len = sizeof(struct bnep_compressed_ethernet) + sizeof(struct iphdr) + sizeof(struct udphdr) + 0x5c0;
+			printk("Allocate %i bytes\n",len);
+			
+			if ((skb = dev_alloc_skb(len)) == NULL) {
+				printk("Alloc skb failed \n");
+				return 0;
+			}
+			pos = 0;
+			skb_put(skb,len);
+			memcpy(skb->data , (void*)&bnep, sizeof(struct bnep_compressed_ethernet));
+			pos += sizeof(struct bnep_compressed_ethernet);
+			memcpy(skb->data + pos, (void*)&ip, sizeof(struct iphdr));
+			pos += sizeof(struct iphdr);
+			memcpy(skb->data + pos, (void*)&udp, sizeof(struct udphdr));
+			pos += sizeof(struct udphdr);
+			i = 0;
+			while (pos < len)
+			{ 
+				skb->data[pos] = i;
+				printk("%02x",i);
+				i++;
+				pos++;
+				if (i>0xff) i = 0;
+			} 
+			printk("\nSend packet.....");
+			bnep_send_raw_packet(skb,&dev_bnep[0]);
+		}
+		break;
+	case 3:
+		printk("Test Case 3 -- TX for BNEP Type 0x03 Source only\n");
+		{
+			struct sk_buff *skb;
+			struct bnep_compressed_ethernet_source_only bnep;
+			struct iphdr ip;
+			struct udphdr udp;
+			
+			int len,u,i,pos;
+			
+			bnep.bnep_type = BNEP_COMPRESSED_ETHERNET_SOURCE_ONLY;
+			for ( i=0; i<6; i++) {
+				bnep.saddr[i] = dev->dev_addr[i];
+			}   
+			bnep.type =  cpu_to_be16(0x0800);
+			ip.tot_len = 0x5dc;
+			ip.protocol = 0x11;
+			ip.saddr = 0;
+			ip.daddr = 0;
+			
+			udp.source = 00;
+			udp.dest = 0x07;
+			udp.len = 0x5c8;
+			
+			len = sizeof(struct bnep_compressed_ethernet_source_only) + sizeof(struct iphdr) + sizeof(struct udphdr) + 0x5c0;
+			printk("Allocate %i bytes\n",len);
+			
+			if ((skb = dev_alloc_skb(len)) == NULL) {
+				printk("Alloc skb failed \n");
+				return 0;
+			}
+			pos = 0;
+			skb_put(skb,len);
+			memcpy(skb->data , (void*)&bnep, sizeof(struct bnep_compressed_ethernet_source_only));
+			pos += sizeof(struct bnep_compressed_ethernet_source_only);
+			memcpy(skb->data + pos, (void*)&ip, sizeof(struct iphdr));
+			pos += sizeof(struct iphdr);
+			memcpy(skb->data + pos, (void*)&udp, sizeof(struct udphdr));
+			pos += sizeof(struct udphdr);
+			i = 0;
+			while (pos < len)
+			{ 
+				skb->data[pos] = i;
+				printk("%02x",i);
+				i++;
+				pos++;
+				if (i>0xff) i = 0;
+			} 
+			printk("\nSend raw packet.....");
+			bnep_send_raw_packet(skb,&dev_bnep[0]);
+		}
+		break;
+	case 4:
+	case 8:
+	case 10:
+		printk("Test Case %i -- TX for BNEP Type 0x04 Dest Only\n",test);
+		{
+			struct sk_buff *skb;
+			struct bnep_compressed_ethernet_dest_only bnep;
+			struct iphdr ip;
+			struct udphdr udp;
+			int len,u,i,pos;
+			
+			bnep.bnep_type = BNEP_COMPRESSED_ETHERNET_DEST_ONLY;
+			for ( i=0; i<6; i++) {
+				if( test == 8) {
+					bnep.daddr[i] = 0xff;
+				} else {
+					bnep.daddr[i] = l2cap->remote_bd[5-i];
+				}
+			} 
+			bnep.type =  cpu_to_be16(0x0800);
+			ip.tot_len = 0x5dc;
+			ip.protocol = 0x11;
+			ip.saddr = 0;
+			if( test == 8) {
+				ip.daddr = 0xffffffff;
+			}
+			else if( test == 10)  {
+				bnep.daddr[0] = 0x01;
+				bnep.daddr[1] = 0x00;
+				bnep.daddr[2] = 0x5e;
+				bnep.daddr[3] = 0x00;
+				bnep.daddr[4] = 0x00;
+				bnep.daddr[5] = 0x00;
+			}
+			else if (test == 4) {
+				ip.daddr = 0;
+			}
+			udp.source = 00;
+			udp.dest = 0x07;
+			udp.len = 0x5c8;
+			
+			len = sizeof(struct bnep_compressed_ethernet_dest_only) + sizeof(struct iphdr) + sizeof(struct udphdr) + 0x5c0;
+			printk("Allocate %i bytes\n",len);
+			
+			if ((skb = dev_alloc_skb(len)) == NULL) {
+				printk("Alloc skb failed \n");
+				return 0;
+			}
+			pos = 0;
+			skb_put(skb,len);
+			memcpy(skb->data , (void*)&bnep, sizeof(struct bnep_compressed_ethernet_dest_only));
+			pos += sizeof(struct bnep_compressed_ethernet_dest_only);
+			memcpy(skb->data + pos, (void*)&ip, sizeof(struct iphdr));
+			pos += sizeof(struct iphdr);
+			memcpy(skb->data + pos, (void*)&udp, sizeof(struct udphdr));
+			pos += sizeof(struct udphdr);
+			i = 0;
+			while (pos < len)
+			{ 
+				skb->data[pos] = i;
+				printk("%02x",i);
+				i++;
+				pos++;
+				if (i>0xff) i = 0;
+			} 
+			printk("\nSend raw packet.....");
+			bnep_send_raw_packet(skb,&dev_bnep[0]);
+		}
+		break;
+	case 5:
+		printk("Test Case 5 -- Broadcast from Bluetooth network to wired\n");
+		{
+			
+			struct bnep_compressed_ethernet_dest_only bnep;
+			struct iphdr ip;
+			struct udphdr udp;
+			struct sk_buff *skb;
+			int len,pos;
+			
+			bnep.bnep_type=BNEP_COMPRESSED_ETHERNET_DEST_ONLY;
+			
+			for ( i=0; i<6; i++) 
+				bnep.daddr[i] = 0xff;
+			
+			bnep.type =  cpu_to_be16(0x0800);
+			ip.tot_len = 0x5dc;
+			ip.protocol = 0x11;
+			ip.saddr = 0; 
+			ip.daddr = 0xffffffff;
+			
+			udp.source = 00;
+			udp.dest = 0x07;
+			udp.len = 0x5c8;
+			
+			len = sizeof(struct bnep_compressed_ethernet_dest_only) + sizeof(struct iphdr) + sizeof(struct udphdr) + 0x5c0;
+			printk("Allocate %i bytes\n",len);
+			
+			if ((skb = dev_alloc_skb(len)) == NULL) {
+				printk("Alloc skb failed \n");
+				return 0;
+			}
+			pos = 0;
+			skb_put(skb,len);
+			memcpy(skb->data , (void*)&bnep, sizeof(struct bnep_compressed_ethernet_dest_only));
+			pos += sizeof(struct bnep_compressed_ethernet_dest_only);
+			memcpy(skb->data + pos, (void*)&ip, sizeof(struct iphdr));
+			pos += sizeof(struct iphdr);
+			memcpy(skb->data + pos, (void*)&udp, sizeof(struct udphdr));
+			pos += sizeof(struct udphdr);
+			i = 0;
+			while (pos < len)
+			{ 
+				skb->data[pos] = i;
+				printk("%02x",i);
+				i++;
+				pos++;
+				if (i>0xff) i = 0;
+			} 
+			printk("\nSend raw packet.....");
+			bnep_send_raw_packet(skb,&dev_bnep[0]);
+		}
+		
+		break;
+		
+	case 6:
+	case 61:
+	case 62:
+	case 63:
+		printk("Set filter \n");
+		{
+			struct sk_buff *skb;
+			struct bnep_filter_set bnep;
+			u16 filter[20];
+			int len,u,i,pos,n;
+			
+			bnep.bnep_type        = BNEP_FILTER_CONTROL;
+			bnep.bnep_filter_type = BNEP_FILTER_SET;
+			if (test == 61) {
+				printk("Send 2 filters \n");
+				n = 2;
+				filter[0] = cpu_to_be16(0x0800);
+				filter[1] = cpu_to_be16(0x1000);
+				filter[2] = cpu_to_be16(0x1100);
+				filter[3] = cpu_to_be16(0x1200);
+			}
+			else if (test == 62) {
+				printk("Send 2 overlapping filters \n");
+				n = 2;
+				filter[0] = cpu_to_be16(0x0800);
+				filter[1] = cpu_to_be16(0x1100);
+				filter[2] = cpu_to_be16(0x1000);
+				filter[3] = cpu_to_be16(0x1200);
+			}
+			else if (test == 63) {
+				printk("Send 2 invalid filters \n");
+				n = 2;
+				filter[0] = cpu_to_be16(0x1000);
+				filter[1] = cpu_to_be16(0x0800);
+				filter[2] = cpu_to_be16(0x1201);
+				filter[3] = cpu_to_be16(0x1200);
+			}
+			else if (test == 64) {
+				printk("Send 10 filters of which 9 is identical \n");
+				n = 10;
+				filter[0] = cpu_to_be16(0x0800);
+				filter[1] = cpu_to_be16(0x1000);
+				filter[2] = cpu_to_be16(0x0002);
+				filter[3] = cpu_to_be16(0x0002);
+				filter[4] = cpu_to_be16(0x0002);
+				filter[5] = cpu_to_be16(0x0002);
+				filter[6] = cpu_to_be16(0x0002);
+				filter[7] = cpu_to_be16(0x0002);
+				filter[8] = cpu_to_be16(0x0002);
+				filter[9] = cpu_to_be16(0x0002);  
+				filter[10] = cpu_to_be16(0x0002);
+				filter[11] = cpu_to_be16(0x0002);
+				filter[12] = cpu_to_be16(0x0002);
+				filter[13] = cpu_to_be16(0x0002);
+				filter[14] = cpu_to_be16(0x0002);
+				filter[15] = cpu_to_be16(0x0002);
+				filter[16] = cpu_to_be16(0x0002);
+				filter[17] = cpu_to_be16(0x0002);
+				filter[18] = cpu_to_be16(0x0002);
+				filter[19] = cpu_to_be16(0x0002);       
+			}
+			else if (test == 6) {
+				printk("Send 5 filters of which 4 is identical \n");
+				n = 5;
+				filter[0] = cpu_to_be16(0x0800);
+				filter[1] = cpu_to_be16(0x1000);
+				filter[2] = cpu_to_be16(0x0000);
+				filter[3] = cpu_to_be16(0x0000);
+				filter[4] = cpu_to_be16(0x0000);
+				filter[5] = cpu_to_be16(0x0000);
+				filter[6] = cpu_to_be16(0x0000);
+				filter[7] = cpu_to_be16(0x0000);
+				filter[8] = cpu_to_be16(0x0000);
+				filter[9] = cpu_to_be16(0x0000);       
+			}
+			
+			
+			len = sizeof(struct bnep_filter_set) + n*4;
+			pos = 0;
+			printk("Allocate %i bytes\n",len);
+			
+			if ((skb = dev_alloc_skb(len)) == NULL) {
+				printk("Alloc skb failed \n");
+				return 0;
+			}
+			
+			skb_put(skb,len);
+			memcpy(skb->data , (void*)&bnep, sizeof(struct bnep_filter_set));
+			pos += sizeof(struct bnep_filter_set);
+			memcpy(skb->data + pos, (void*)&filter[0], n*4);
+			pos += n*4;
+			
+			bnep_send_raw_packet(skb,&dev_bnep[0]);
+		}
+		break;
+	default:
+		break;
+	}  
+}
+
+/* Test function to set a remote filter   */
+
+bnep_set_remote_filter(u16 *filter)
+{
+	D_MISC("Set remote filter \n");
+	{
+		struct sk_buff *skb;
+		struct bnep_filter_set bnep;
+		
+		int len,pos;
+		
+		bnep.bnep_type        = BNEP_FILTER_CONTROL;
+		bnep.bnep_filter_type = BNEP_FILTER_SET;
+		
+		len = sizeof(struct bnep_filter_set) + 20;
+		D_MISC("Allocate %i bytes\n",len);
+		
+		if ((skb = dev_alloc_skb(len)) == NULL) {
+			D_ERR("Alloc skb failed \n");
+			return 0;
+		}
+		pos = 0;
+		skb_put(skb,len);
+		memcpy(skb->data , (void*)&bnep, sizeof(struct bnep_filter_set));
+		pos += sizeof(struct bnep_filter_set);
+		*(u16 *)(skb->data + pos) = filter[0];
+		pos += 2;
+		*(u16 *)(skb->data + pos) =
+			
+			filter[1];
+		pos += 2;
+		bnep_send_raw_packet(skb,&dev_bnep[0]);
+	}
+}
+
+static int
+bnep_send_packet(struct sk_buff *skb, struct net_device *dev)
+{
+	bt_tx_buf         *tx_buf;
+	struct net_local  *local;
+	struct ethhdr     *eth;
+	struct bnep_compressed_ethernet_dest_only   bnep_c_d;
+	struct bnep_general_ethernet                bnep_g; 
+	struct bnep_compressed_ethernet_source_only bnep_c_s;
+	struct bnep_compressed_ethernet             bnep_c;
+	void              *bhdr;
+	int i,bhdrlen,ethhdrlen,buflen;
+	
+	u16 proto; 
+	int send_packet;
+	int dest = 1;
+	int source = 1;
+	
+	eth = (struct ethhdr *)skb->data;
+	proto = be16_to_cpu(eth->h_proto);
+	local = dev->priv;
+	
+	/* Check for multicast packets */
+#if 0
+	if (eth->h_dest[0] == 1) {
+		/* Fixme, filter multicast traffic ?? How */
+		/* Discard for now......    */
+		D_XMIT("Discard multicast packet \n");
+		/* free the sk_buff */
+		dev_kfree_skb(skb); 
+		return 0;
+	}
+#endif  
+	if (local->l2cap == NULL)
+	{
+		D_XMIT("No l2cap. Discard packet.....\n");
+		/* free the sk_buff */
+		dev_kfree_skb(skb); 
+		return 0;
+	}
+	
+	/* Build BNEP header */
+	D_XMIT("Build BNEP header\n");
+	
+	for ( i=0; i<6; i++) {
+		if( eth->h_dest[i] != local->l2cap->remote_bd[5-i]) {
+			dest = 0;
+		}
+	} 
+	for ( i=0; i<6; i++) {
+		if( eth->h_source[i] != dev->dev_addr[i]) {
+			source = 0; 
+		}
+	}    
+	if (( dest == 0 ) && ( source == 0)) {
+		
+		bnep_g.bnep_type = BNEP_GENERAL_ETHERNET;
+		bnep_g.type = cpu_to_be16(proto);
+		for ( i=0; i<6; i++) {
+			bnep_g.daddr[i] = eth->h_dest[i];
+		} 
+		for ( i=0; i<6; i++) {
+			bnep_g.saddr[i] = eth->h_source[i];
+		} 
+		bhdrlen = sizeof(struct bnep_general_ethernet);
+		bhdr = (void*)&bnep_g;
+		D_XMIT("General ethernet saddr %02x.%02x.%02x.%02x.%02x.%02x ",bnep_g.saddr[0],bnep_g.saddr[1],bnep_g.saddr[2],bnep_g.saddr[3],bnep_g.saddr[4],bnep_g.saddr[5]);
+		D_XMIT("daddr %02x.%02x.%02x.%02x.%02x.%02x",bnep_g.daddr[0],bnep_g.daddr[1],bnep_g.daddr[2],bnep_g.daddr[3],bnep_g.daddr[4],bnep_g.daddr[5]);
+	}
+	else if (( dest == 1 ) && ( source == 0)) {
+		
+		bnep_c_s.bnep_type = BNEP_COMPRESSED_ETHERNET_SOURCE_ONLY;
+		bnep_c_s.type = cpu_to_be16(proto);
+		for ( i=0; i<6; i++) {
+			bnep_c_s.saddr[i] = eth->h_source[i];
+		}
+		bhdrlen = sizeof(struct bnep_compressed_ethernet_source_only);   
+		bhdr = (void*)&bnep_c_s;
+		D_XMIT("Compressed ethernet source only saddr %02x.%02x.%02x.%02x.%02x.%02x\n",bnep_c_s.saddr[0],bnep_c_s.saddr[1],bnep_c_s.saddr[2],bnep_c_s.saddr[3],bnep_c_s.saddr[4],bnep_c_s.saddr[5]);
+	}
+	else if (( dest == 0 ) && ( source == 1)) {
+		bnep_c_d.bnep_type = BNEP_COMPRESSED_ETHERNET_DEST_ONLY;
+		for ( i=0; i<6; i++) {
+			bnep_c_d.daddr[i] = eth->h_dest[i];
+		} 
+		bnep_c_d.type = cpu_to_be16(proto);
+		bhdrlen = sizeof(struct bnep_compressed_ethernet_dest_only);
+		bhdr = (void*)&bnep_c_d;
+		D_XMIT("Compressed ethernet dest only daddr %02x.%02x.%02x.%02x.%02x.%02x\n",bnep_c_d.daddr[0],bnep_c_d.daddr[1],bnep_c_d.daddr[2],bnep_c_d.daddr[3],bnep_c_d.daddr[4],bnep_c_d.daddr[5]);
+	}
+	else if (( dest == 1 ) && ( source == 1)) {
+		
+		bnep_c.bnep_type = BNEP_COMPRESSED_ETHERNET;
+		bnep_c.type = cpu_to_be16(proto);
+		bhdrlen = sizeof(struct bnep_compressed_ethernet);
+		bhdr = (void*)&bnep_c;
+		D_XMIT("Compressed ethernet\n");
+	}
+	
+	ethhdrlen = sizeof(struct ethhdr);
+	
+	D_XMIT("send proto %04x bnep header len %i eth header len %i eth packet len %i\n",proto,bhdrlen,ethhdrlen,skb->len);
+	
+	PRINTPKT("bnep_send_packet:",skb->data,skb->len);
+	
+	print_ip_packet(skb->data + ethhdrlen,proto);  
+	
+	send_packet = 0;
+	/* Check filters */
+	for (i=0;i<BNEP_MAX_FILTER;i++)  {
+		D_XMIT("Filter %04x - %04x\n",local->filter_list[i*2],local->filter_list[i*2+1]);
+		if ((local->filter_list[i*2] <= proto) && ((local->filter_list[i*2+1] >= proto))) {
+			send_packet = 1;
+			D_XMIT("Send packet ok\n");
+		}
+	}
+	
+	if (send_packet == 0) {
+		local->stats.tx_dropped++;
+	}
+	else {
+		if (local->l2cap == NULL) {
+			/* no connection; drop the packet */
+			D_ERR("bnep send packet: no connection exists\n");
+			local->stats.tx_dropped++;
+		}
+		else {
+			/* check whether the we have room for the bt_tx_buf */
+			buflen = skb->len + sizeof(bnep_tx_buf) - ethhdrlen + bhdrlen - 4;
+			D_XMIT("buflen %i\n",buflen);
+			if (buf_write_room() < buflen) {
+				D_ERR("bnep send packet: not enough room for a %d byte bt_tx_buf\n", skb->len);
+				/* don't necessarily need to discard the buffer; could set dev->tbusy = 1
+				   and then start a timer to check for free buffer space */
+				local->stats.tx_dropped++;
+			}
+			else
+			{
+				/* subscribe to a bt_tx_buf */
+				D_XMIT("New bt buf length %i \n", buflen );
+				if ((tx_buf = subscribe_bt_buf( buflen  )) == NULL) {
+					D_ERR("bnep send packet: failed to subscribe to a %d byte bt_tx_buf buflen %d\n", skb->len, buflen);
+					local->stats.tx_dropped++;
+				}
+				else
+				{
+					
+					/* copy the frame into the bt_tx_buf */
+					/*  printk("Copy frame into bt_tx_buf\n");*/
+					memcpy(tx_buf->data + sizeof(bnep_tx_buf),bhdr,bhdrlen);
+					memcpy(tx_buf->data + sizeof(bnep_tx_buf) + bhdrlen, skb->data + ethhdrlen, buflen - bhdrlen - sizeof(bnep_tx_buf));
+					tx_buf->cur_len = skb->len - ethhdrlen + bhdrlen - 4;
+					
+					/* transmit the packet */
+					D_XMIT("bnep: tx packet\n");
+					l2cap_send_data(tx_buf, local->l2cap);
+					
+					
+					/* update the device statistics */
+					local->stats.tx_packets++;
+					local->stats.tx_bytes += skb->len - 4;
+				}
+			}
+		}
+	}
+	/* free the sk_buff */
+	dev_kfree_skb(skb); 
+	return 0;
+}
+
+void 
+bnep_filter_control(l2cap_con *l2cap, u8 *data, u32 len,u8 bnep_filter_type)
+{
+	struct net_device *dev;
+	struct net_local  *local;
+	struct ethhdr     *eth;
+	struct bnep_filter_set *bnep;
+	struct bnep_filter_response_msg rsp;  
+	
+	u8  type;
+	u8  eheaders;
+	int blen,skblen;
+	int n,i;
+	bt_tx_buf *tx_buf;
+	u16 *filter;
+	
+	dev = (struct net_device *)l2cap->upper_con;
+	local = (struct net_local *)(dev->priv);  
+	
+	switch (bnep_filter_type) {
+	case BNEP_FILTER_SET: {
+		
+		n = len / 4;
+		rsp.bnep_response_msg = cpu_to_be16(SUCCESS);
+		D_MISC("Len = %i n = %i \n",len,n);
+		if (n == 0) {
+			/* Reset filter */
+			D_MISC("Reset filter\n");
+			for (i=0;i<BNEP_MAX_FILTER;i++)  {
+				local->filter_list[i*2]   = 0;
+				local->filter_list[i*2+1] = 0;
+			}
+			/* Accept all packet types */
+			local->filter_list[0] = 0x0000;
+			local->filter_list[1] = 0xffff;
+			
+		}
+		else {
+			D_MISC("Reset filter before setting new\n");
+			for (i=0;i<BNEP_MAX_FILTER;i++)  {
+				local->filter_list[i*2]   = 0;
+				local->filter_list[i*2+1] = 0;
+			}
+			/* Set filter */
+			/* If more filters than BNEP_MAX_FILTERS discard some */
+			if (n > BNEP_MAX_FILTER) {
+				rsp.bnep_response_msg = cpu_to_be16(MAX_FILTER);
+				n = BNEP_MAX_FILTER;
+			}
+			filter = (u16*)&data[0];
+			for (i=0; i<n; i++) {
+				if (filter[i] > filter[i+1]) {
+					rsp.bnep_response_msg = cpu_to_be16(INVALID_PROTOCOL_ID);
+				}
+				local->filter_list[i*2] = be16_to_cpu(filter[i*2]);
+				local->filter_list[i*2+1] = be16_to_cpu(filter[i*2+1]);
+				D_MISC("Setting filter %04x - %04x \n",local->filter_list[i*2],local->filter_list[i*2+1]);
+			}
+		}
+		
+		rsp.bnep_type         = BNEP_FILTER_CONTROL;
+		rsp.bnep_filter_type  = BNEP_FILTER_RESPONSE_MSG;
+		
+		/* subscribe to a bt_tx_buf */
+		if ((tx_buf = subscribe_bt_buf(sizeof(struct bnep_filter_response_msg) + sizeof(bnep_tx_buf))) == NULL) {
+			D_ERR("bnep send packet: failed to subscribe to a %d byte bt_tx_buf\n", 4);
+		}
+		else {
+			/* copy the frame into the bt_tx_buf */
+			
+			memcpy(tx_buf->data + sizeof(bnep_tx_buf),(void*)&rsp,sizeof(struct bnep_filter_response_msg));
+			tx_buf->cur_len = sizeof(struct bnep_filter_response_msg);
+			D_MISC("BNEP send filter response msg\n");
+			l2cap_send_data(tx_buf, local->l2cap);
+		}
+	}
+	break;
+	case BNEP_FILTER_RESPONSE_MSG:    {
+		u16 bnep_filter_response_msg = be16_to_cpu(*(u16*)(&data[0]));
+		switch (bnep_filter_response_msg) {
+		case SUCCESS:
+			D_MISC("BNEP filter response: Success\n");
+			break;
+		case UNSUPPORTED:
+			D_MISC("BNEP filter response: Unsupported\n");
+			break;
+		case INVALID_PROTOCOL_ID:
+			D_MISC("BNEP filter response: Invalid Protocol ID\n");
+			break;
+		case MAX_FILTER:
+			D_MISC("BNEP filter response: Max filter\n");
+			break;
+		case SECURITY_FAILURE:
+			D_MISC("BNEP filter response: Security Failure\n");
+			break;
+		default:
+			D_MISC("BNEP filter response: Unknown message %04\n",bnep_filter_response_msg);
+			break;
+		}            
+	}
+	break;
+	default:
+		D_MISC("Unknown filter type value\n");
+		break;
+	}
+}
+
+void 
+bnep_receive_packet(l2cap_con *l2cap, u8 *data, u32 len) 
+{
+	struct sk_buff    *skb;
+	struct net_device *dev;
+	struct net_local  *local;
+	struct ethhdr     *eth,eth_header;
+	
+	
+	
+	u8  type;
+	u8  eheaders;
+	int blen,skblen;
+	bt_tx_buf *tx_buf;
+	int eth_frame = 0;
+	int i;
+	int pos = 0;
+	u16 proto = 0;
+	
+	
+	
+	eth = &eth_header;
+	
+	dev = (struct net_device *)l2cap->upper_con;
+	local = (struct net_local *)(dev->priv);
+	
+	type = data[0] & 0x7f;
+	eheaders = ((data[0] & 0x80) >> 7);  
+	
+	D_REC("bnep_receive_data: receiving %d bytes : device %s : Type %02x : Extension headers %i \n", len,dev->name, type ,eheaders);
+	PRINTPKT("bnep_receive_data:", data, len);
+	
+	/* Check for multicast packets */
+	if (eth->h_dest[0] & 1) {
+		D_REC("Multicast packet\n");
+		if (!local->promiscuous && !local->allmulti) {
+			int i, hit=0;
+			D_REC("Check multicast list\n");
+			for (i=0; i<local->mc_count; i++) {
+				if(memcmp((void*)&local->mc_list[i],eth->h_dest, sizeof(struct macaddr)) == 1) {
+					hit = 1;
+				}
+			}
+			if (!hit) {
+				D_REC("Discard packet\n"); 
+				return;
+			}
+		}
+		local->allmulti = 0;
+		local->mc_count = dev->mc_count;
+	}
+	
+	switch (type)
+	{
+	case  BNEP_GENERAL_ETHERNET:
+        {  
+		struct bnep_general_ethernet *bnep;
+		
+		bnep = (struct bnep_general_ethernet *)&data[0];
+		D_REC("BNEP_GENERAL_ETHERNET\n");         
+		for ( i=0; i<6; i++) {
+			eth->h_source[i] = bnep->saddr[i];
+		}  
+		for ( i=0; i<6; i++) {
+			eth->h_dest[i] = bnep->daddr[i];
+		}   
+		proto = be16_to_cpu(bnep->type);
+		eth->h_proto = cpu_to_be16(proto);
+		
+		blen = sizeof(struct bnep_general_ethernet);
+		eth_frame = 1;
+        }
+	break;
+	case  BNEP_FILTER_CONTROL:
+        {
+		D_REC("BNEP_FILTER_CONTROL\n");
+		bnep_filter_control(l2cap,data+2,len-2,data[1]);
+        }
+        break;                  
+	
+	case  BNEP_COMPRESSED_ETHERNET:
+        {
+		struct bnep_compressed_ethernet *bnep;
+		D_REC("BNEP_COMPRESSED_ETHERNET\n");
+		bnep = (struct bnep_compressed_ethernet *)&data[0];
+		for ( i=0; i<6; i++) {
+			eth->h_source[i] = l2cap->remote_bd[5-i];
+		}  
+		for ( i=0; i<6; i++) {
+			eth->h_dest[i] = dev->dev_addr[i];
+		}     
+		proto =  be16_to_cpu(bnep->type);
+		eth->h_proto = cpu_to_be16(proto);
+		blen = sizeof(struct bnep_compressed_ethernet);
+		eth_frame = 1;
+        }
+        break;             
+	case  BNEP_COMPRESSED_ETHERNET_SOURCE_ONLY:
+        {
+		struct bnep_compressed_ethernet_source_only *bnep;  
+		D_REC("BNEP_COMPRESSED_ETHERNET_SOURCE_ONLY\n");
+		bnep = (struct bnep_compressed_ethernet_source_only *)&data[0];
+		for ( i=0; i<6; i++) {
+			eth->h_source[i] = bnep->saddr[i];
+		}  
+		for ( i=0; i<6; i++) {
+			eth->h_dest[i] = dev->dev_addr[i];
+		}     
+		
+		proto = be16_to_cpu(bnep->type);
+		eth->h_proto = cpu_to_be16(proto);
+		blen = sizeof(struct bnep_compressed_ethernet_source_only);
+		eth_frame = 1;
+        }
+        break; 
+	case  BNEP_COMPRESSED_ETHERNET_DEST_ONLY:
+        {
+		struct bnep_compressed_ethernet_dest_only *bnep;
+		D_REC("BNEP_COMPRESSED_ETHERNET_DEST_ONLY\n");
+		bnep = (struct bnep_compressed_ethernet_dest_only *)&data[0];
+		for ( i=0; i<6; i++) {
+			eth->h_source[i] = l2cap->remote_bd[5-i];
+		}  
+		for ( i=0; i<6; i++) {
+			eth->h_dest[i] = bnep->daddr[i];
+		}     
+		proto = be16_to_cpu(bnep->type);
+		eth->h_proto = cpu_to_be16(proto);
+		blen = sizeof(struct bnep_compressed_ethernet_dest_only);
+		eth_frame = 1;
+        }
+        break;   
+	case  BNEP_802_2:                           
+		break;
+	default:
+		D_ERR("Unknown type !!!!!!!!!!!!!\n");
+		break;
+	}
+	
+	print_ip_packet(data + blen,proto);  
+	
+	/* Jump to eheader */
+	pos = blen;
+	D_REC("Change pos to after bnep header pos = %i\n",pos);
+	
+	while (eheaders == 1) {
+		struct bnep_eheader *eheader;
+		eheader = (struct bnep_eheader *)&data[pos];
+		type = eheader->bnep_type & 0x7f;
+		eheaders = ((eheader->bnep_type & 0x80) >> 7);
+		D_REC("Parse extension header type=%02x eheader=%i pos=%08x\n",type,eheaders,pos);
+		switch(type) {
+		case BNEP_EXTENSION_FILTER_CONTROL:
+			D_REC("Extension header filter control length %i \n",eheader->length);
+			bnep_filter_control(l2cap,data+pos+2,eheader->length,type);
+			break;
+		default:
+			D_REC("Unknown extension header %02x length %i\n",type,eheader->length);
+			break;
+		}
+		pos += eheader->length + 2;
+		if (pos > len) {
+			D_ERR("Error: pos > len\n");
+			break;
+		} 
+	}
+	
+	if (eth_frame == 1 ) {
+		D_REC("BNEP: eth hdr src %02x.%02x.%02x.%02x.%02x.%02x dst %02x.%02x.%02x.%02x.%02x.%02x type %04x\n", eth->h_source[0],eth->h_source[1],eth->h_source[2],eth->h_source[3],eth->h_source[4],eth->h_source[5],eth->h_dest[0],eth->h_dest[1],eth->h_dest[2],eth->h_dest[3],eth->h_dest[4],eth->h_dest[5],eth->h_proto);
+		
+		/* Calculate new packet size */
+		skblen = len - pos + sizeof(struct ethhdr);
+		
+		D_REC("len:%i pos:%i blen:%i skblen:%i ethlan:%i \n",len,pos,blen,skblen,sizeof(struct ethhdr)); 
+		
+		/* allocate a sk_buff to hold the received frame */
+		if ((skb = dev_alloc_skb(skblen)) == NULL) {
+			D_ERR("bnep_receive_data: allocation of a %d byte sk_buff failed\n", skblen);
+			
+			local->stats.rx_dropped++;
+			return;
+		}
+		
+		/* copy the received frame into skb */
+		skb_put(skb, skblen);
+		memcpy(skb->data, (void *)eth, sizeof(struct ethhdr));
+		memcpy(skb->data + sizeof(struct ethhdr), &data[pos] , len - pos);
+		
+		/* initialize skb members */
+		skb->dev = dev;
+		skb->protocol = eth_type_trans(skb,dev);
+		
+		/* Send the packet to the upper layers */
+		D_REC("Send packet to upper layers\n");
+		netif_rx(skb);
+		
+		/* update the device statistics */
+		
+		((struct net_local *)(dev->priv))->stats.rx_packets++;
+		((struct net_local *)(dev->priv))->stats.rx_bytes += len; 
+	} else {
+		D_MISC("No ethernet fram in this packet\n");
+	}
+}
+
+void
+bnep_init(void)
+{
+	int i,j;
+	char bd_addr[6],temp[8];
+        /* Set the confirm and indication functions for the L2CAP-layer */
+        this_layer.con_ind = bnep_connect_ind;
+	this_layer.con_pnd = bnep_connect_pnd;
+	this_layer.conf_ind = bnep_config_ind;
+	this_layer.disc_ind = bnep_disconnect_ind;
+	this_layer.con_cfm = bnep_connect_cfm;
+	this_layer.conf_cfm = bnep_config_cfm;
+	this_layer.disc_cfm = bnep_disconnect_cfm;
+	this_layer.receive_data = bnep_receive_packet;
+	
+	/* Register BNEP in the L2CAP layer*/
+	l2cap_register_upper(BNEP_LAYER, &this_layer);
+	
+        /* Allocate name for netdev  */
+        /* register netdev */
+	/*     if ((register_netdev(&bnep_dev)) != 0)
+	       { 
+	       D_ERR("bnep_init: register_netdev failed\n");
+	       return;
+	       }*/
+	
+        /* assign hardware address (converting to big endian) */
+        D_MISC("Read local BD\n");
+        hci_read_local_bd(bd_addr);
+        for (i = 0; i < 6; i++) 
+		temp[7-i]=bd_addr[i];
+	
+        for (j=0;j<7;j++) {
+		bnep_set_mac_address(&dev_bnep[j], &temp);
+        }
+        DSYS("BNEP Initialized \n");
+	
+}
+
+static struct net_device_stats *
+bnep_get_stats(struct net_device *dev)
+{
+        return (struct net_device_stats *)dev->priv;
+}
+
+static void 
+bnep_set_multicast_list(struct net_device *dev)
+{
+	struct net_local *local;
+	struct dev_mc_list *dmi;
+	
+	local = (struct net_local *) dev->priv;
+	
+	D_MISC("%s Set multicast list Rx mode %02x to %d addresses \n",dev->name, dev->flags, dev->mc_count);
+	
+	if ((dev->flags & IFF_PROMISC) || (dev->mc_count > BNEP_MAX_MULTI)) {
+		D_MISC("Receive all packets \n");
+		local->promiscuous = 1;
+		local->allmulti = 0;
+		dev->flags |= IFF_PROMISC;
+	} else 
+		if (dev->flags & IFF_ALLMULTI) {
+			D_MISC("Receive all multicast packets\n");
+			local->promiscuous = 0;
+			local->allmulti = 1;
+		} else
+			if (dev->mc_list != (struct dev_mc_list *) NULL) {
+				int i = 0; 
+				D_MISC("Receive all packets in multicast list\n");
+				local->promiscuous = 0;
+				local->allmulti = 0;
+				local->mc_count = dev->mc_count;
+				for (dmi = dev->mc_list; dmi; dmi = dmi->next) {
+					D_MISC(" %02x:%02x:%02x:%02x:%02x:%02x\n",
+					       dmi->dmi_addr[0], dmi->dmi_addr[1],
+					       dmi->dmi_addr[2], dmi->dmi_addr[3],
+					       dmi->dmi_addr[4], dmi->dmi_addr[5]);
+					memcpy((void*)&(local->mc_list[i++]),dmi->dmi_addr, sizeof(struct macaddr));
+				}
+				
+			} else {
+				D_MISC("Switch to normal mode \n");
+				local->promiscuous = 0;
+				local->allmulti = 0;
+				local->mc_count = 0;
+			}
+}
+
+
+static int
+bnep_init_module(void)
+{
+        int i;
+        struct net_device *d;
+        char name[16];
+        DSYS("BNEP: Init Modules \n");
+        for (i=0; i<7 ; i++) {
+                d = &dev_bnep[i];
+                d->init = bnep_init_driver;
+                sprintf(name , "bnep%i",i);
+                if (dev_alloc_name(d->name, name) < 0)         {
+			D_ERR("bnep_init: dev_alloc_name %s failed\n",name);
+			break;
+		}
+                D_MISC("Register netdev %s \n",d->name);
+                if (register_netdev(d) != 0)
+		        return -ENODEV;
+        }                
+        return 0;
+}
+
+
+module_init(bnep_init_module);
+
+/*  L2cap interface  */
+
+
+u32
+bnep_connect_req(u8 *bd_addr) {
+	D_MISC("BNEP: Connect request  %.2x:%.2x:%.2x:%.2x:%.2x:%.2x \n", bd_addr[0], bd_addr[1], bd_addr[2], bd_addr[3], bd_addr[4], bd_addr[5]);
+	
+	if (l2ca_connect_req(bd_addr, BNEP_LAYER)) {
+		D_ERR("bnep_connect_req: l2ca_connect_req failed\n");
+		return -1;
+	}
+	
+	return 0;
+}
+
+void 
+bnep_connect_ind(l2cap_con *l2cap) {
+	int i;
+	struct net_local *local;
+	D_MISC("bnep_connect_ind: remote cid %d\n", l2cap->remote_cid);
+	
+	if (l2ca_connect_rsp(l2cap, RES_SUCCESS, STAT_NOINFO)) {
+		D_ERR("bnep_connect_ind: l2ca_connect_rsp failed\n");
+		return;
+	}
+	/* Find free interface */
+	for (i=0;i<BNEP_MAX_CON;i++) {
+		local = dev_bnep[i].priv;       
+		if (local->l2cap == NULL) {
+			D_MISC("bnep_connect_ind: Connection index %i, Interface %s\n",i,dev_bnep[i].name);
+			local->l2cap = l2cap;
+			//      l2cap->dev = &dev_bnep[i];
+			l2cap->upper_con = (void *)&dev_bnep[i];
+			break;
+		}
+	}
+	
+	if (i == BNEP_MAX_CON) {
+		D_ERR("bnep_connect_cfm: No more connections\n");
+		
+	}
+	
+	return;
+}
+
+
+void bnep_connect_pnd(l2cap_con *l2cap, s32 status) {
+	D_MISC("bnep_connect_pnd: status=%d\n", status);
+}
+
+/* Confirms that a connection request has been accepted */
+void bnep_connect_cfm(l2cap_con *l2cap, s32 status) {
+
+#if 0
+	int i;
+	struct net_local *local;
+	printk("bnep_connect_cfm: remote cid %d\n", l2cap->remote_cid);
+	
+	/* did the connection fail? */
+	if (status) {
+		DSYS("bnep_connect_cfm: connection failed\n");
+		 return;
+	}
+	/* Multipoint support */
+	for (i=0;i<BNEP_MAX_CON;i++) {
+		local = dev_bnep[i].priv;
+		if (local->l2cap == NULL) {
+			D_MISC("bnep_connect_cfm: Connection index %i, Interface %s\n",
+			       i , dev_bnep[i].name);
+			local->l2cap = l2cap;
+			l2cap->upper_con = (void *)&dev_bnep[i];
+			break;
+		} 
+	}
+	
+	if (i == BNEP_MAX_CON) {
+		D_ERR("bnep_connect_cfm: No more connections\n");
+		
+	} 
+	else {
+		if (!l2ca_local_conf_done(l2cap))
+		{
+			/* still haven't sent config request yet */
+			/* Zero indicates that default values will be used */
+			if (l2ca_config_req(l2cap, BNEP_MTU, NULL, BNEP_FLUSH_TIMEOUT, 0)) {
+				D_ERR("bnep_connect_cfm: l2ca_config_req failed\n");
+			}
+		} else {
+			DSYS("already sent back a pos response\n");  
+		}
+	}
+#endif
+	
+	int i;
+	struct net_local *local;
+	printk("bnep_connect_cfm: remote cid %d\n", l2cap->remote_cid);
+	
+	/* did the connection fail? */
+	if (status) {
+		DSYS("bnep_connect_cfm: connection failed\n");
+		return;
+	}
+	/* Multipoint support Willy */
+	for (i=0;i<BNEP_MAX_CON;i++) {
+		local = dev_bnep[i].priv;
+		if (local->l2cap == NULL) {
+			printk("bnep_connect_cfm: Connection index %i, Interface %s\n",i,dev_bnep[i].name);
+			local->l2cap = l2cap;
+			l2cap->upper_con = (void *)&dev_bnep[i];
+			break;
+		} 
+	}
+	
+	if (i == BNEP_MAX_CON) {
+		D_ERR("bnep_connect_cfm: No more connections\n");    
+	}
+	else {
+		if (l2ca_config_req(l2cap, BNEP_MTU, NULL, BNEP_FLUSH_TIMEOUT, 0)) {
+			D_ERR("bnep_connect_cfm: l2ca_config_req failed\n");
+		}
+	}
+}
+
+void 
+bnep_config_ind(l2cap_con *l2cap) {
+#define FNC "bnep_config_ind: "
+#if 0
+	D_MISC("bnep_config_ind: remote cid %d\n", l2cap->remote_cid);
+	
+	/* check if we have sent a pos response yet */
+	if (!l2ca_remote_conf_done(l2cap)){
+                /* still haven't sent a pos configure response*/
+		/* send a positive response */
+		if (l2ca_config_rsp(l2cap, BNEP_MTU, NULL, CONF_SUCCESS)) {
+			D_ERR("bnep_config_ind: l2ca_config_rsp failed\n");
+		}
+	} else {
+		DSYS("Already sent back positive response\n");
+	}
+	
+	/* check if we received a pos response on a previous conf req */
+	/* if we weren't the initiator, we now send our configuration request. */
+	/* Fix l2cap->remote_mtu should be max BNEP_MTU???  */
+	if (!l2cap->initiator) {
+		/* check if we received a pos response on a 
+                   previous config req */ 
+		if (!l2ca_local_conf_done(l2cap)) {
+			l2cap->local_mtu = BNEP_MTU;
+			
+			DSYS("Local l2cap mtu set to %d\n", 
+			     l2cap->local_mtu);
+			
+			if (l2ca_config_req(l2cap, BNEP_MTU, NULL, 
+					    BNEP_FLUSH_TIMEOUT, CONF_SUCCESS))   {
+				D_ERR("bnep_config_ind: l2ca_config_req failed\n");
+			}
+		} else {
+			DSYS("Already done with config req\n");
+		}
+	}
+#endif
+	
+	D_MISC("bnep_config_ind: remote cid %d\n", l2cap->remote_cid);
+	
+	/* check if we have sent a pos response yet */
+	if (!l2ca_remote_conf_done(l2cap)) {
+		/* send a positive response */
+		if (l2ca_config_rsp(l2cap, l2cap->remote_mtu, NULL, CONF_SUCCESS)) {
+			D_ERR("bnep_config_ind: l2ca_config_rsp failed\n");
+		}
+	} 
+	else 
+		DSYS(FNC"already have sent back a pos response\n");
+	
+	/* if we weren't the initiator, we now send our configuration request. */
+	/* Fix l2cap->remote_mtu should be max BNEP_MTU???  */
+	if (!l2cap->initiator) {
+		if (!l2ca_local_conf_done(l2cap)) {
+			if (l2ca_config_req(l2cap, l2cap->remote_mtu, 
+					    NULL, BNEP_FLUSH_TIMEOUT, 0))   {
+				D_ERR("bnep_config_ind: l2ca_config_req failed\n");
+			}
+		}
+		else
+			DSYS(FNC"already ready with config req\n");
+		
+	}
+}
+
+
+void bnep_config_cfm(l2cap_con *l2cap, s32 status) {
+	struct net_device *d;
+	D_MISC("bnep_config_cfm: remote cid %d\n", l2cap->remote_cid);
+	DSYS("bnep_config_cfm: bnep channel opened\n");
+	d = l2cap->upper_con;
+	D_MISC("Interface %s\n", d->name);
+} 
+
+
+/* ether_disconnect_ind - called by l2cap to notify us that the peer
+ *                        disconnected.
+ */
+void bnep_disconnect_ind(l2cap_con *l2cap) {
+	struct net_device *dev;
+	struct net_local *local;
+	D_MISC("bnep_disconnect_ind: remote cid %d\n", l2cap->remote_cid);
+	
+	dev = (struct net_device *) l2cap->upper_con;
+	
+	/* acknowledge the disconnect */
+	if (l2ca_disconnect_rsp(l2cap)) {
+		D_ERR("ether_disconnect_ind: l2ca_disconnect_rsp failed\n");
+		return;
+	}
+	local = dev->priv;
+	local->l2cap = NULL;
+}
+
+void 
+bnep_disconnect_cfm(l2cap_con *l2cap) {
+	struct net_device *d;
+	struct net_local *l;
+	
+	D_MISC("bnep_disconnect_cfm: remote cid %d\n", l2cap->remote_cid);
+	
+	d = (struct net_device *)l2cap->upper_con;
+	l = d->priv;
+	l->l2cap = NULL;
+	
+	DSYS("bnep_disconnect_cfm: disconnected\n");
+}
diff -Nur /home/starvik/download/kernel/linux-2.4.19/drivers/net/bnep.h ./drivers/net/bnep.h
--- /home/starvik/download/kernel/linux-2.4.19/drivers/net/bnep.h	Thu Jan  1 01:00:00 1970
+++ ./drivers/net/bnep.h	Wed Oct 23 12:29:00 2002
@@ -0,0 +1,95 @@
+/* BNEP Type Values */
+
+#define BNEP_GENERAL_ETHERNET                0x00
+#define BNEP_FILTER_CONTROL                  0x01
+#define BNEP_COMPRESSED_ETHERNET             0x02
+#define BNEP_COMPRESSED_ETHERNET_SOURCE_ONLY 0x03
+#define BNEP_COMPRESSED_ETHERNET_DEST_ONLY   0x04
+#define BNEP_802_2                           0x7e
+
+/* BNEP Extension Type Values */
+
+#define BNEP_EXTENSION_FILTER_CONTROL        0x00
+
+/* BNEP Filter Type Values */
+
+#define BNEP_FILTER_SET             0x00
+#define BNEP_FILTER_RESPONSE_MSG    0x01
+
+/* BNEP Response Messages */
+
+#define SUCCESS              0x0000
+#define UNSUPPORTED          0x0001
+#define INVALID_PROTOCOL_ID  0x0002
+#define MAX_FILTER           0x0003
+#define SECURITY_FAILURE     0x0004
+
+#define BNEP_MTU 1691
+
+/* Max number of filter ranges for Network Protocol Types */
+#define BNEP_MAX_FILTER 5
+
+/* structure used to reserve space in at bt_tx_buf for hci and l2cap headers */
+typedef struct bnep_tx_buf {
+  u8 hci_hdr[5];
+  u8 l2cap_hdr[4];
+  u8 frame[0];
+} bnep_tx_buf;
+
+typedef struct bnep_general_ethernet {
+  u8 bnep_type;
+  u8 daddr[6];
+  u8 saddr[6];
+  u16 type;
+} bnep_general_ethernet;
+
+typedef struct bnep_compressed_ethernet {
+  u8 bnep_type;
+  u16 type;
+} bnep_compressed_ethernet;
+
+typedef struct bnep_compressed_ethernet_source_only {
+  u8 bnep_type;
+  u8 saddr[6];
+  u16 type;
+} bnep_compressed_ethernet_source_only;
+
+typedef struct bnep_compressed_ethernet_dest_only {
+  u8 bnep_type;
+  u8 daddr[6];
+  u16 type;
+} bnep_compressed_ethernet_dest_only;
+
+typedef struct bnep_eheader {
+  u8 bnep_type;
+  u8 length;
+} bnep_eheader;
+
+typedef struct bnep_filter_set {
+  u8 bnep_type;
+  u8 bnep_filter_type;
+} bnep_filter_set;
+
+typedef struct bnep_filter_response_msg {
+  u8 bnep_type;
+  u8 bnep_filter_type;
+  u16 bnep_response_msg;
+} bnep_filter_response_msg;
+
+/****************** EXPORTED FUNCTION DECLARATION SECTION *******************/
+static int __init bnep_init_driver(struct net_device *dev);
+
+
+u32 bnep_connect_req(u8* bd_addr);
+void bnep_connect_ind(l2cap_con *l2cap);
+void bnep_connect_pnd(l2cap_con *l2cap, int status);
+void bnep_connect_cfm(l2cap_con *l2cap, s32 status);
+void bnep_config_ind(l2cap_con* l2cap);
+void bnep_config_cfm(l2cap_con *l2cap, s32 status);
+void bnep_disconnect_ind(l2cap_con *l2cap);
+void bnep_disconnect_cfm(l2cap_con *l2cap);
+void bnep_receive_data(l2cap_con *l2cap, u8 *data, u32 len);
+s32 bnep_send_data(u32 con_id, u8 *data, u32 count);
+void bnep_disconnect_req(u8 line);
+
+u32 bnep_test(u8 *p);
diff -Nur /home/starvik/download/kernel/linux-2.4.19/drivers/parport/init.c ./drivers/parport/init.c
--- /home/starvik/download/kernel/linux-2.4.19/drivers/parport/init.c	Wed Jul 11 01:07:46 2001
+++ ./drivers/parport/init.c	Wed Oct 23 12:29:00 2002
@@ -31,6 +31,7 @@
 extern int parport_sunbpp_init(void);
 extern int parport_amiga_init(void);
 extern int parport_mfc3_init(void);
+extern int parport_etrax_init(void);
 
 static int parport_setup_ptr __initdata = 0;
 
@@ -163,6 +164,9 @@
 #ifdef CONFIG_PARPORT_SUNBPP
 	parport_sunbpp_init();
 #endif
+#ifdef CONFIG_ETRAX_PARPORT
+	parport_etrax_init();
+#endif
 	return 0;
 }
 
diff -Nur /home/starvik/download/kernel/linux-2.4.19/fs/cramfs/inode.c ./fs/cramfs/inode.c
--- /home/starvik/download/kernel/linux-2.4.19/fs/cramfs/inode.c	Sat Aug  3 02:39:45 2002
+++ ./fs/cramfs/inode.c	Wed Oct 23 12:29:00 2002
@@ -28,6 +28,7 @@
 #define CRAMFS_SB_BLOCKS u.cramfs_sb.blocks
 #define CRAMFS_SB_FILES u.cramfs_sb.files
 #define CRAMFS_SB_FLAGS u.cramfs_sb.flags
+#define CRAMFS_SB_FSTIME u.cramfs_sb.fstime
 
 static struct super_operations cramfs_ops;
 static struct inode_operations cramfs_dir_inode_operations;
@@ -54,6 +55,8 @@
 		inode->i_blksize = PAGE_CACHE_SIZE;
 		inode->i_gid = cramfs_inode->gid;
 		inode->i_ino = CRAMINO(cramfs_inode);
+		inode->i_mtime = sb->CRAMFS_SB_FSTIME;
+		inode->i_ctime = sb->CRAMFS_SB_FSTIME;
 		/* inode->i_nlink is left 1 - arguably wrong for directories,
 		   but it's the best we can do without reading the directory
 	           contents.  1 yields the right result in GNU find, even
@@ -144,7 +147,7 @@
 	minor = MINOR(sb->s_dev);
 
 	if (blk_size[major])
-		devsize = blk_size[major][minor] >> 2;
+		devsize = blk_size[major][minor] / (PAGE_CACHE_SIZE / 1024);
 
 	/* Ok, read in BLKS_PER_BUF pages completely first. */
 	unread = 0;
@@ -187,7 +190,6 @@
 	return read_buffers[buffer] + offset;
 }
 
-
 static struct super_block * cramfs_read_super(struct super_block *sb, void *data, int silent)
 {
 	int i;
@@ -230,10 +232,13 @@
 		goto out;
 	}
 	root_offset = super.root.offset << 2;
+	sb->CRAMFS_SB_FSTIME = 0;
 	if (super.flags & CRAMFS_FLAG_FSID_VERSION_2) {
 		sb->CRAMFS_SB_SIZE=super.size;
 		sb->CRAMFS_SB_BLOCKS=super.fsid.blocks;
 		sb->CRAMFS_SB_FILES=super.fsid.files;
+		if (super.flags & CRAMFS_FLAG_EDITION_TIMESTAMP)
+			sb->CRAMFS_SB_FSTIME=super.fsid.edition;
 	} else {
 		sb->CRAMFS_SB_SIZE=1<<28;
 		sb->CRAMFS_SB_BLOCKS=0;
diff -Nur /home/starvik/download/kernel/linux-2.4.19/fs/ext3/acl.c ./fs/ext3/acl.c
--- /home/starvik/download/kernel/linux-2.4.19/fs/ext3/acl.c	Thu Jan  1 01:00:00 1970
+++ ./fs/ext3/acl.c	Wed Oct 23 12:29:00 2002
@@ -0,0 +1,17 @@
+/*
+ * linux/fs/ext3/acl.c
+ *
+ * Copyright (C) 1993, 1994, 1995
+ * Remy Card (card@masi.ibp.fr)
+ * Laboratoire MASI - Institut Blaise Pascal
+ * Universite Pierre et Marie Curie (Paris VI)
+ */
+
+#include <linux/fs.h>
+#include <linux/sched.h>
+
+
+/*
+ * This file will contain the Access Control Lists management for the
+ * second extended file system.
+ */
diff -Nur /home/starvik/download/kernel/linux-2.4.19/fs/jffs/jffs_fm.c ./fs/jffs/jffs_fm.c
--- /home/starvik/download/kernel/linux-2.4.19/fs/jffs/jffs_fm.c	Fri Oct  5 00:13:18 2001
+++ ./fs/jffs/jffs_fm.c	Wed Oct 23 12:29:00 2002
@@ -75,7 +75,7 @@
 	           we don't know why. This scares me - I want formal proof
 		   of correctness of whatever number we put here. dwmw2.
 	*/
-	fmc->min_free_size = fmc->sector_size << 2;
+	fmc->min_free_size = fmc->sector_size << 1;
 	fmc->mtd = mtd;
 	fmc->c = c;
 	fmc->head = 0;
diff -Nur /home/starvik/download/kernel/linux-2.4.19/fs/jffs2/nodelist.h ./fs/jffs2/nodelist.h
--- /home/starvik/download/kernel/linux-2.4.19/fs/jffs2/nodelist.h	Sat Aug  3 02:39:45 2002
+++ ./fs/jffs2/nodelist.h	Wed Oct 23 12:29:00 2002
@@ -223,13 +223,21 @@
 #define ALLOC_DELETION	1	/* Deletion node. Best to allow it */
 #define ALLOC_GC	2	/* Space requested for GC. Give it or die */
 
+#ifdef __CRIS__
+#define JFFS2_RESERVED_BLOCKS_BASE 0						/* Number of free blocks there must be before we... */
+#define JFFS2_RESERVED_BLOCKS_WRITE (JFFS2_RESERVED_BLOCKS_BASE + 1)		/* ... allow a normal filesystem write */
+#define JFFS2_RESERVED_BLOCKS_DELETION (JFFS2_RESERVED_BLOCKS_BASE + 1)		/* ... allow a normal filesystem deletion */
+#define JFFS2_RESERVED_BLOCKS_GCTRIGGER (JFFS2_RESERVED_BLOCKS_BASE + 1)	/* ... wake up the GC thread */
+#define JFFS2_RESERVED_BLOCKS_GCBAD (JFFS2_RESERVED_BLOCKS_BASE + 1)		/* ... pick a block from the bad_list to GC */
+#define JFFS2_RESERVED_BLOCKS_GCMERGE (JFFS2_RESERVED_BLOCKS_BASE)		/* ... merge pages when garbage collecting */
+#else
 #define JFFS2_RESERVED_BLOCKS_BASE 3						/* Number of free blocks there must be before we... */
 #define JFFS2_RESERVED_BLOCKS_WRITE (JFFS2_RESERVED_BLOCKS_BASE + 2)		/* ... allow a normal filesystem write */
 #define JFFS2_RESERVED_BLOCKS_DELETION (JFFS2_RESERVED_BLOCKS_BASE + 1)		/* ... allow a normal filesystem deletion */
 #define JFFS2_RESERVED_BLOCKS_GCTRIGGER (JFFS2_RESERVED_BLOCKS_BASE + 3)	/* ... wake up the GC thread */
 #define JFFS2_RESERVED_BLOCKS_GCBAD (JFFS2_RESERVED_BLOCKS_BASE + 1)		/* ... pick a block from the bad_list to GC */
 #define JFFS2_RESERVED_BLOCKS_GCMERGE (JFFS2_RESERVED_BLOCKS_BASE)		/* ... merge pages when garbage collecting */
-
+#endif /* __CRIS__ */
 
 #define PAD(x) (((x)+3)&~3)
 
diff -Nur /home/starvik/download/kernel/linux-2.4.19/fs/partitions/Config.in ./fs/partitions/Config.in
--- /home/starvik/download/kernel/linux-2.4.19/fs/partitions/Config.in	Sun Aug 12 20:13:59 2001
+++ ./fs/partitions/Config.in	Wed Oct 23 12:29:00 2002
@@ -38,7 +38,7 @@
    fi
    if [ "$CONFIG_AMIGA" != "y" -a "$CONFIG_ATARI" != "y" -a \
         "$CONFIG_MAC" != "y" -a "$CONFIG_SGI_IP22" != "y" -a \
-	"$CONFIG_SGI_IP27" != "y" ]; then
+	"$CONFIG_SGI_IP27" != "y" -a "$ARCH" != "cris" ]; then
       define_bool CONFIG_MSDOS_PARTITION y
    fi
    if [ "$CONFIG_AMIGA" = "y" -o "$CONFIG_AFFS_FS" = "y" ]; then
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/etraxgpio.h ./include/asm-cris/etraxgpio.h
--- /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/etraxgpio.h	Sat Aug  3 02:39:45 2002
+++ ./include/asm-cris/etraxgpio.h	Wed Oct 23 12:29:00 2002
@@ -1,4 +1,4 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $ */
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $ */
 /*
  * The following devices are accessable using this driver using
  * GPIO_MAJOR (120) and a couple of minor numbers:
@@ -25,7 +25,7 @@
 
 /* supported ioctl _IOC_NR's */
 
-#define IO_READBITS  0x1  /* read and return current port bits */
+#define IO_READBITS  0x1  /* read and return current port bits (obsolete) */
 #define IO_SETBITS   0x2  /* set the bits marked by 1 in the argument */
 #define IO_CLRBITS   0x3  /* clear the bits marked by 1 in the argument */
 
@@ -40,11 +40,11 @@
                               * 0=off, 1=green, 2=red, 3=yellow */
 
 /* GPIO direction ioctl's */
-#define IO_READDIR    0x8  /* Read direction 0=input 1=output */
+#define IO_READDIR    0x8  /* Read direction 0=input 1=output  (obsolete) */
 #define IO_SETINPUT   0x9  /* Set direction for bits set, 0=unchanged 1=input, 
-                              returns mask with current inputs */
+                              returns mask with current inputs (obsolete) */
 #define IO_SETOUTPUT  0xA  /* Set direction for bits set, 0=unchanged 1=output,
-                              returns mask with current outputs */
+                              returns mask with current outputs (obsolete)*/
 
 /* LED ioctl extended */
 #define IO_LED_SETBIT 0xB
@@ -63,5 +63,19 @@
 #define IO_CFG_WRITE_MODE_VALUE(msb, data_mask, clk_mask) \
   ( (((msb)&1) << 16) | (((data_mask) &0xFF) << 8) | ((clk_mask) & 0xFF) )
 
+/* The following 4 ioctl's take a pointer as argument and handles
+ * 32 bit ports (port G) properly.
+ * These replaces IO_READBITS,IO_SETINPUT AND IO_SETOUTPUT
+ */
+#define IO_READ_INBITS   0x10 /* *arg is result of reading the input pins */
+#define IO_READ_OUTBITS  0x11 /* *arg is result of reading the output shadow */
+#define IO_SETGET_INPUT  0x12 /* bits set in *arg is set to input,
+                               * *arg updated with current input pins.
+                               */
+#define IO_SETGET_OUTPUT 0x13 /* bits set in *arg is set to output,
+                               * *arg updated with current output pins.
+                               */
+
+
 
 #endif
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/fasttimer.h ./include/asm-cris/fasttimer.h
--- /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/fasttimer.h	Thu Jan  1 01:00:00 1970
+++ ./include/asm-cris/fasttimer.h	Wed Oct 23 12:29:00 2002
@@ -0,0 +1,47 @@
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+ * linux/include/asm-cris/fasttimer.h
+ *
+ * Fast timers for ETRAX100LX
+ * This may be useful in other OS than Linux so use 2 space indentation...
+ * Copyright (C) 2000, 2002 Axis Communications AB
+ */
+#include <linux/config.h>
+#include <linux/time.h> /* struct timeval */
+#include <linux/timex.h>
+
+/* The timer0 values gives 52us resolution (1/19200) or higher 
+ * but interrupts at HZ 
+ */
+/* We use timer1 to generate interrupts at desired times. */
+
+#ifdef CONFIG_ETRAX_FAST_TIMER
+
+typedef void fast_timer_function_type(unsigned long);
+
+struct fast_timer{ /* Close to timer_list */
+  struct fast_timer *next;
+  struct fast_timer *prev;
+  struct timeval tv_set;
+  struct timeval tv_expires;
+  unsigned long delay_us;
+  fast_timer_function_type *function;
+  unsigned long data;
+  const char *name;
+};
+
+void start_one_shot_timer(struct fast_timer *t,
+                          fast_timer_function_type *function,
+                          unsigned long data,
+                          unsigned long delay_us,
+                          const char *name);
+
+int del_fast_timer(struct fast_timer * t);
+/* return 1 if deleted */
+
+
+void schedule_usleep(unsigned long us);
+
+
+void fast_timer_init(void);
+
+#endif
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/ide.h ./include/asm-cris/ide.h
--- /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/ide.h	Sat Aug  3 02:39:45 2002
+++ ./include/asm-cris/ide.h	Wed Oct 23 12:29:00 2002
@@ -144,6 +144,7 @@
 /* the drive addressing is done through a controller register on the Etrax CPU */
 void OUT_BYTE(unsigned char data, ide_ioreg_t reg);
 unsigned char IN_BYTE(ide_ioreg_t reg);
+unsigned short IN_WORD(ide_ioreg_t reg);
 
 /* this tells ide.h not to define the standard macros */
 #define HAVE_ARCH_OUT_BYTE
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/io.h ./include/asm-cris/io.h
--- /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/io.h	Mon Oct  8 20:43:54 2001
+++ ./include/asm-cris/io.h	Wed Oct 23 12:29:00 2002
@@ -216,6 +216,8 @@
 	return __ioremap(offset, size, 0);
 }
 
+extern void iounmap(void *addr);
+
 /*
  * IO bus memory addresses are also 1:1 with the physical address
  */
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/posix_types.h ./include/asm-cris/posix_types.h
--- /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/posix_types.h	Fri Feb  9 01:32:44 2001
+++ ./include/asm-cris/posix_types.h	Wed Oct 23 12:29:00 2002
@@ -1,4 +1,4 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $ */
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $ */
 
 /* We cheat a bit and use our C-coded bitops functions from asm/bitops.h */
 /* I guess we should write these in assembler because they are used often. */
@@ -23,7 +23,7 @@
 typedef unsigned short  __kernel_ipc_pid_t;
 typedef unsigned short	__kernel_uid_t;
 typedef unsigned short	__kernel_gid_t;
-typedef unsigned long	__kernel_size_t;
+typedef __SIZE_TYPE__	__kernel_size_t;
 typedef long		__kernel_ssize_t;
 typedef int		__kernel_ptrdiff_t;
 typedef long		__kernel_time_t;
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/rtc.h ./include/asm-cris/rtc.h
--- /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/rtc.h	Wed May  2 01:05:00 2001
+++ ./include/asm-cris/rtc.h	Wed Oct 23 12:29:00 2002
@@ -1,55 +1,92 @@
-/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $ */
+/* $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $ */
+
+#ifndef __RTC_H__
+#define __RTC_H__
 
-#ifndef RTC_H
-#define RTC_H
 
 #include <linux/config.h>
 
-/* Dallas DS1302 clock/calendar register numbers */
+#ifdef CONFIG_ETRAX_DS1302
+   /* Dallas DS1302 clock/calendar register numbers. */
+#  define RTC_SECONDS      0
+#  define RTC_MINUTES      1
+#  define RTC_HOURS        2
+#  define RTC_DAY_OF_MONTH 3
+#  define RTC_MONTH        4
+#  define RTC_WEEKDAY      5
+#  define RTC_YEAR         6
+#  define RTC_CONTROL      7
+
+   /* Bits in CONTROL register. */
+#  define RTC_CONTROL_WRITEPROTECT 	0x80
+#  define RTC_TRICKLECHARGER 		8
+  
+  /* Bits in TRICKLECHARGER register TCS TCS TCS TCS DS DS RS RS. */
+#  define RTC_TCR_PATTERN 	0xA0	/* 1010xxxx */
+#  define RTC_TCR_1DIOD 	0x04	/* xxxx01xx */
+#  define RTC_TCR_2DIOD 	0x08	/* xxxx10xx */
+#  define RTC_TCR_DISABLED 	0x00	/* xxxxxx00 Disabled */
+#  define RTC_TCR_2KOHM 	0x01	/* xxxxxx01 2KOhm */
+#  define RTC_TCR_4KOHM 	0x02	/* xxxxxx10 4kOhm */
+#  define RTC_TCR_8KOHM 	0x03	/* xxxxxx11 8kOhm */
+
+#elif defined(CONFIG_ETRAX_PCF8563)
+   /* I2C bus slave registers. */
+#  define RTC_I2C_READ		0xa3
+#  define RTC_I2C_WRITE		0xa2
+
+   /* Phillips PCF8563 registers. */
+#  define RTC_CONTROL1		0x00		/* Control/Status register 1. */
+#  define RTC_CONTROL2		0x01		/* Control/Status register 2. */
+#  define RTC_CLOCKOUT_FREQ	0x0d		/* CLKOUT frequency. */
+#  define RTC_TIMER_CONTROL	0x0e		/* Timer control. */
+#  define RTC_TIMER_CNTDOWN	0x0f		/* Timer countdown. */
+
+   /* BCD encoded clock registers. */
+#  define RTC_SECONDS		0x02
+#  define RTC_MINUTES		0x03
+#  define RTC_HOURS		0x04
+#  define RTC_DAY_OF_MONTH	0x05
+#  define RTC_WEEKDAY		0x06	/* Not coded in BCD! */
+#  define RTC_MONTH		0x07
+#  define RTC_YEAR		0x08
+#  define RTC_MINUTE_ALARM	0x09
+#  define RTC_HOUR_ALARM	0x0a
+#  define RTC_DAY_ALARM		0x0b
+#  define RTC_WEEKDAY_ALARM 0x0c
 
-#define RTC_SECONDS 0
-#define RTC_MINUTES 1
-#define RTC_HOURS 2
-#define RTC_DAY_OF_MONTH 3
-#define RTC_MONTH 4
-#define RTC_WEEKDAY 5
-#define RTC_YEAR 6
-#define RTC_CONTROL 7
-
-/* Bits in CONTROL register */
-#define RTC_CONTROL_WRITEPROTECT 0x80
-#define RTC_TRICKLECHARGER 8
-/* Bits in TRICKLECHARGER register TCS TCS TCS TCS DS DS RS RS */
-#define   RTC_TCR_PATTERN 0xA0 /* 1010xxxx */
-#define   RTC_TCR_1DIOD 0x04 /* xxxx01xx */
-#define   RTC_TCR_2DIOD 0x08 /* xxxx10xx */
-#define   RTC_TCR_DISABLED 0x00 /* xxxxxx00 Disabled */
-#define   RTC_TCR_2KOHM 0x01      /* xxxxxx01 2KOhm */
-#define   RTC_TCR_4KOHM 0x02      /* xxxxxx10 4kOhm */
-#define   RTC_TCR_8KOHM 0x03      /* xxxxxx11 8kOhm */
+#endif
 
 #ifdef CONFIG_ETRAX_DS1302
-#define CMOS_READ(x) ds1302_readreg(x)
-#define CMOS_WRITE(val,reg) ds1302_writereg(reg,val)
-#define RTC_INIT() ds1302_init()
+extern unsigned char ds1302_readreg(int reg);
+extern void ds1302_writereg(int reg, unsigned char val);
+extern int ds1302_init(void);
+#  define CMOS_READ(x) ds1302_readreg(x)
+#  define CMOS_WRITE(val,reg) ds1302_writereg(reg,val)
+#  define RTC_INIT() ds1302_init()
+#elif defined(CONFIG_ETRAX_PCF8563)
+extern unsigned char pcf8563_readreg(int reg);
+extern void pcf8563_writereg(int reg, unsigned char val);
+extern int pcf8563_init(void);
+#  define CMOS_READ(x) pcf8563_readreg(x)
+#  define CMOS_WRITE(val,reg) pcf8563_writereg(reg,val)
+#  define RTC_INIT() pcf8563_init()
 #else
-/* no RTC configured so we shouldn't try to access any */
-#define CMOS_READ(x) 42
-#define CMOS_WRITE(x,y)
-#define RTC_INIT() (-1)
+  /* No RTC configured so we shouldn't try to access any. */
+#  define CMOS_READ(x) 42
+#  define CMOS_WRITE(x,y)
+#  define RTC_INIT() (-1)
 #endif
 
-/* conversions to and from the stupid RTC internal format */
-
-#define BCD_TO_BIN(x) x = (((x & 0xf0) >> 3) * 5 + (x & 0xf))
-#define BIN_TO_BCD(x) x = (x % 10) | ((x / 10) << 4) 
+/* Conversions to and from the RTC BCD encoded format. */
+#define BCD_TO_BIN(x) ((x)=((x)&15) + ((x)>>4)*10)
+#define BIN_TO_BCD(x) ((x)=(((x)/10)<<4) + (x)%10)
 
 /*
  * The struct used to pass data via the following ioctl. Similar to the
  * struct tm in <time.h>, but it needs to be here so that the kernel 
  * source is self contained, allowing cross-compiles, etc. etc.
  */
-
 struct rtc_time {
 	int tm_sec;
 	int tm_min;
@@ -62,14 +99,11 @@
 	int tm_isdst;
 };
 
-/*
- * ioctl calls that are permitted to the /dev/rtc interface
- */
-
-#define RTC_RD_TIME	_IOR('p', 0x09, struct rtc_time) /* Read RTC time   */
-#define RTC_SET_TIME	_IOW('p', 0x0a, struct rtc_time) /* Set RTC time    */
-#define RTC_SET_CHARGE  _IOW('p', 0x0b, int) /* Set CHARGE mode    */
-
-#endif
-
+/* ioctl() calls that are permitted to the /dev/rtc interface. */
+#define RTC_MAGIC 'T'
+#define RTC_RD_TIME		_IOR(RTC_MAGIC, 0x01, struct rtc_time)	/* Read RTC time. */
+#define RTC_SET_TIME		_IOW(RTC_MAGIC, 0x02, struct rtc_time)	/* Set RTC time. */
+#define RTC_SET_CHARGE  	_IOW(RTC_MAGIC, 0x03, int) 		
+#define RTC_MAX_IOCTL 3
 
+#endif /* __RTC_H__ */
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/sv_addr_ag.h ./include/asm-cris/sv_addr_ag.h
--- /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/sv_addr_ag.h	Fri Feb  9 01:32:44 2001
+++ ./include/asm-cris/sv_addr_ag.h	Wed Oct 23 12:29:00 2002
@@ -25,33 +25,41 @@
 
 /* IO_MASK returns a mask for a specified bitfield in a register.
    Note that this macro doesn't work when field width is 32 bits. */
-#define IO_MASK(reg,field) \
-    ( ( ( 1 << reg##__##field##__WIDTH ) - 1 ) << reg##__##field##__BITNR )
+#define IO_MASK(reg, field) IO_MASK_ (reg##_, field##_)
+#define IO_MASK_(reg_, field_) \
+    ( ( ( 1 << reg_##_##field_##_WIDTH ) - 1 ) << reg_##_##field_##_BITNR )
 
 /* IO_STATE returns a constant corresponding to a one of the symbolic
    states that the bitfield can have. (Shifted to correct position)  */
-#define IO_STATE(reg,field,state) \
-    ( reg##__##field##__##state << reg##__##field##__BITNR )
+#define IO_STATE(reg, field, state) IO_STATE_ (reg##_, field##_, _##state)
+#define IO_STATE_(reg_, field_, _state) \
+    ( reg_##_##field_##_state << reg_##_##field_##_BITNR )
 
 /* IO_EXTRACT returns the masked and shifted value corresponding to the
    bitfield can have. */
-#define IO_EXTRACT(reg,field,val) ( (( ( ( 1 << reg##__##field##__WIDTH ) \
-     - 1 ) << reg##__##field##__BITNR ) & (val)) >> reg##__##field##__BITNR )
+#define IO_EXTRACT(reg, field, val) IO_EXTRACT_ (reg##_, field##_, val)
+#define IO_EXTRACT_(reg_, field_, val) ( (( ( ( 1 << reg_##_##field_##_WIDTH ) \
+     - 1 ) << reg_##_##field_##_BITNR ) & (val)) >> reg_##_##field_##_BITNR )
 
 /* IO_STATE_VALUE returns a constant corresponding to a one of the symbolic
    states that the bitfield can have. (Not shifted)  */
-#define IO_STATE_VALUE(reg,field,state) ( reg##__##field##__##state )
+#define IO_STATE_VALUE(reg, field, state) \
+    IO_STATE_VALUE_ (reg##_, field##_, _##state)
+#define IO_STATE_VALUE_(reg_, field_, _state) ( reg_##_##field_##_state )
 
 /* IO_FIELD shifts the val parameter to be aligned with the bitfield
    specified. */
-#define IO_FIELD(reg,field,val) ((val) << reg##__##field##__BITNR)
+#define IO_FIELD(reg, field, val) IO_FIELD_ (reg##_, field##_, val)
+#define IO_FIELD_(reg_, field_, val) ((val) << reg_##_##field_##_BITNR)
 
 /* IO_BITNR returns the starting bitnumber of a bitfield. Bit 0 is
    LSB and the returned bitnumber is LSB of the field. */
-#define IO_BITNR(reg,field) (reg##__##field##__BITNR)
+#define IO_BITNR(reg, field) IO_BITNR_ (reg##_, field##_)
+#define IO_BITNR_(reg_, field_) (reg_##_##field_##_BITNR)
 
 /* IO_WIDTH returns the width, in bits, of a bitfield. */
-#define IO_WIDTH(reg,field) (reg##__##field##__WIDTH)
+#define IO_WIDTH(reg, field) IO_WIDTH_ (reg##_, field##_)
+#define IO_WIDTH_(reg_, field_) (reg_##_##field_##_WIDTH)
 
 /*--- Obsolete. Kept for backw compatibility. ---*/
 /* Reads (or writes) a byte/uword/udword from the specified mode
@@ -66,7 +74,9 @@
 !*-----------------------------------------------------------*/
 
 #define MEM_CSE0_START (0x00000000)
+#define MEM_CSE0_SIZE (0x04000000)
 #define MEM_CSE1_START (0x04000000)
+#define MEM_CSE1_SIZE (0x04000000)
 #define MEM_CSR0_START (0x08000000)
 #define MEM_CSR1_START (0x0c000000)
 #define MEM_CSP0_START (0x10000000)
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/unistd.h ./include/asm-cris/unistd.h
--- /home/starvik/download/kernel/linux-2.4.19/include/asm-cris/unistd.h	Sat Aug  3 02:39:45 2002
+++ ./include/asm-cris/unistd.h	Wed Oct 23 12:29:00 2002
@@ -233,15 +233,22 @@
 #define __NR_tkill              226
 
 /* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
+/*
+ * Don't remove the .ifnc tests; they are an insurance against
+ * any hard-to-spot gcc register allocation bugs.
+ */
 #define _syscall0(type,name) \
 type name(void) \
 { \
   register long __a __asm__ ("r10"); \
-  __asm__ __volatile__ ("movu.w %1,$r9\n\tbreak 13" \
+  register long __n_ __asm__ ("r9") = (__NR_##name); \
+  __asm__ __volatile__ (".ifnc %0%1,$r10$r9\n\t" \
+			".err\n\t" \
+			".endif\n\t" \
+			"break 13" \
 			: "=r" (__a) \
-			: "g" (__NR_##name) \
-			: "r10", "r9"); \
-  if(__a >= 0) \
+			: "r" (__n_)); \
+  if (__a >= 0) \
      return (type) __a; \
   errno = -__a; \
   return (type) -1; \
@@ -251,11 +258,14 @@
 type name(type1 arg1) \
 { \
   register long __a __asm__ ("r10") = (long) arg1; \
-  __asm__ __volatile__ ("movu.w %1,$r9\n\tbreak 13" \
+  register long __n_ __asm__ ("r9") = (__NR_##name); \
+  __asm__ __volatile__ (".ifnc %0%1,$r10$r9\n\t" \
+			".err\n\t" \
+			".endif\n\t" \
+			"break 13" \
 			: "=r" (__a) \
-			: "g" (__NR_##name), "0" (__a) \
-			: "r10", "r9"); \
-  if(__a >= 0) \
+			: "r" (__n_), "0" (__a)); \
+  if (__a >= 0) \
      return (type) __a; \
   errno = -__a; \
   return (type) -1; \
@@ -266,11 +276,14 @@
 { \
   register long __a __asm__ ("r10") = (long) arg1; \
   register long __b __asm__ ("r11") = (long) arg2; \
-  __asm__ __volatile__ ("movu.w %1,$r9\n\tbreak 13" \
+  register long __n_ __asm__ ("r9") = (__NR_##name); \
+  __asm__ __volatile__ (".ifnc %0%1%3,$r10$r9$r11\n\t" \
+			".err\n\t" \
+			".endif\n\t" \
+			"break 13" \
 			: "=r" (__a) \
-			: "g" (__NR_##name), "0" (__a), "r" (__b) \
-			: "r10", "r9"); \
-  if(__a >= 0) \
+			: "r" (__n_), "0" (__a), "r" (__b)); \
+  if (__a >= 0) \
      return (type) __a; \
   errno = -__a; \
   return (type) -1; \
@@ -282,11 +295,14 @@
   register long __a __asm__ ("r10") = (long) arg1; \
   register long __b __asm__ ("r11") = (long) arg2; \
   register long __c __asm__ ("r12") = (long) arg3; \
-  __asm__ __volatile__ ("movu.w %1,$r9\n\tbreak 13" \
+  register long __n_ __asm__ ("r9") = (__NR_##name); \
+  __asm__ __volatile__ (".ifnc %0%1%3%4,$r10$r9$r11$r12\n\t" \
+			".err\n\t" \
+			".endif\n\t" \
+			"break 13" \
 			: "=r" (__a) \
-			: "g" (__NR_##name), "0" (__a), "r" (__b), "r" (__c) \
-			: "r10", "r9"); \
-  if(__a >= 0) \
+			: "r" (__n_), "0" (__a), "r" (__b), "r" (__c)); \
+  if (__a >= 0) \
      return (type) __a; \
   errno = -__a; \
   return (type) -1; \
@@ -299,12 +315,15 @@
   register long __b __asm__ ("r11") = (long) arg2; \
   register long __c __asm__ ("r12") = (long) arg3; \
   register long __d __asm__ ("r13") = (long) arg4; \
-  __asm__ __volatile__ ("movu.w %1,$r9\n\tbreak 13" \
-			: "=r" (__a) \
-			: "g" (__NR_##name), "0" (__a), "r" (__b), \
-			  "r" (__c), "r" (__d) \
-			: "r10", "r9"); \
-  if(__a >= 0) \
+  register long __n_ __asm__ ("r9") = (__NR_##name); \
+  __asm__ __volatile__ (".ifnc %0%1%3%4%5,$r10$r9$r11$r12$r13\n\t" \
+			".err\n\t" \
+			".endif\n\t" \
+			"break 13" \
+			: "=r" (__a) \
+			: "r" (__n_), "0" (__a), "r" (__b), \
+			  "r" (__c), "r" (__d)); \
+  if (__a >= 0) \
      return (type) __a; \
   errno = -__a; \
   return (type) -1; \
@@ -318,13 +337,16 @@
   register long __b __asm__ ("r11") = (long) arg2; \
   register long __c __asm__ ("r12") = (long) arg3; \
   register long __d __asm__ ("r13") = (long) arg4; \
-  __asm__ __volatile__ ("move %6,$mof\n\t" \
-			"movu.w %1,$r9\n\tbreak 13" \
-			: "=r" (__a) \
-			: "g" (__NR_##name), "0" (__a), "r" (__b), \
-			  "r" (__c), "r" (__d), "g" (arg5) \
-			: "r10", "r9"); \
-  if(__a >= 0) \
+  register long __n_ __asm__ ("r9") = (__NR_##name); \
+  __asm__ __volatile__ (".ifnc %0%1%3%4%5,$r10$r9$r11$r12$r13\n\t" \
+			".err\n\t" \
+			".endif\n\t" \
+			"move %6,$mof\n\t" \
+			"break 13" \
+			: "=r" (__a) \
+			: "r" (__n_), "0" (__a), "r" (__b), \
+			  "r" (__c), "r" (__d), "g" (arg5)); \
+  if (__a >= 0) \
      return (type) __a; \
   errno = -__a; \
   return (type) -1; \
@@ -338,13 +360,17 @@
   register long __b __asm__ ("r11") = (long) arg2; \
   register long __c __asm__ ("r12") = (long) arg3; \
   register long __d __asm__ ("r13") = (long) arg4; \
-  __asm__ __volatile__ ("move %6,$mof\n\tmove %7,$srp\n\t" \
-			"movu.w %1,$r9\n\tbreak 13" \
+  register long __n_ __asm__ ("r9") = (__NR_##name); \
+  __asm__ __volatile__ (".ifnc %0%1%3%4%5,$r10$r9$r11$r12$r13\n\t" \
+			".err\n\t" \
+			".endif\n\t" \
+			"move %6,$mof\n\tmove %7,$srp\n\t" \
+			"break 13" \
 			: "=r" (__a) \
-			: "g" (__NR_##name), "0" (__a), "r" (__b), \
+			: "r" (__n_), "0" (__a), "r" (__b), \
 			  "r" (__c), "r" (__d), "g" (arg5), "g" (arg6)\
-			: "r10", "r9", "srp"); \
-  if(__a >= 0) \
+			: "srp"); \
+  if (__a >= 0) \
      return (type) __a; \
   errno = -__a; \
   return (type) -1; \
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/linux/cramfs_fs.h ./include/linux/cramfs_fs.h
--- /home/starvik/download/kernel/linux-2.4.19/include/linux/cramfs_fs.h	Sat Aug  3 02:39:45 2002
+++ ./include/linux/cramfs_fs.h	Wed Oct 23 12:29:20 2002
@@ -49,7 +49,7 @@
 
 struct cramfs_info {
 	u32 crc;
-	u32 edition;
+	u32 edition;	/* contains timestamp if EDITION_TIMESTAMP flag set */
 	u32 blocks;
 	u32 files;
 };
@@ -76,6 +76,7 @@
  */
 #define CRAMFS_FLAG_FSID_VERSION_2	0x00000001	/* fsid version #2 */
 #define CRAMFS_FLAG_SORTED_DIRS		0x00000002	/* sorted dirs */
+#define CRAMFS_FLAG_EDITION_TIMESTAMP	0x00000004	/* fstime in edition */
 #define CRAMFS_FLAG_HOLES		0x00000100	/* support for holes */
 #define CRAMFS_FLAG_WRONG_SIGNATURE	0x00000200	/* reserved */
 #define CRAMFS_FLAG_SHIFTED_ROOT_OFFSET	0x00000400	/* shifted root fs */
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/linux/cramfs_fs_sb.h ./include/linux/cramfs_fs_sb.h
--- /home/starvik/download/kernel/linux-2.4.19/include/linux/cramfs_fs_sb.h	Fri Jul 20 01:14:53 2001
+++ ./include/linux/cramfs_fs_sb.h	Wed Oct 23 12:29:00 2002
@@ -5,11 +5,12 @@
  * cramfs super-block data in memory
  */
 struct cramfs_sb_info {
-			unsigned long magic;
-			unsigned long size;
-			unsigned long blocks;
-			unsigned long files;
-			unsigned long flags;
+	unsigned long magic;
+	unsigned long size;
+	unsigned long blocks;
+	unsigned long files;
+	unsigned long flags;
+	time_t        fstime; /* From the edition field if EDITION_TIMESTAMP */
 };
 
 #endif
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/linux/mtd/mtdram.h ./include/linux/mtd/mtdram.h
--- /home/starvik/download/kernel/linux-2.4.19/include/linux/mtd/mtdram.h	Thu Jan  1 01:00:00 1970
+++ ./include/linux/mtd/mtdram.h	Wed Oct 23 12:29:00 2002
@@ -0,0 +1,10 @@
+#ifndef __MTD_MTDRAM_H__
+#define __MTD_MTDRAM_H__
+
+#ifdef __KERNEL__
+#include <linux/mtd/mtd.h>
+int mtdram_init_device(struct mtd_info *mtd, void *mapped_address, 
+                       unsigned long size, char *name);
+
+#endif /* __KERNEL__ */
+#endif /* __MTD_MTDRAM_H__ */
diff -Nur /home/starvik/download/kernel/linux-2.4.19/include/net/bluetooth/hci_emu.h ./include/net/bluetooth/hci_emu.h
--- /home/starvik/download/kernel/linux-2.4.19/include/net/bluetooth/hci_emu.h	Thu Jan  1 01:00:00 1970
+++ ./include/net/bluetooth/hci_emu.h	Wed Oct 23 12:29:00 2002
@@ -0,0 +1,52 @@
+/* 
+   BlueZ - Bluetooth protocol stack for Linux
+   Copyright (C) 2000-2001 Qualcomm Incorporated
+
+   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES 
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, 
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS 
+   SOFTWARE IS DISCLAIMED.
+*/
+
+/*
+ * $Id: update-2.4.19-axis.patch,v 1.1 2004/06/06 14:10:20 rpm Exp $
+ */
+
+#ifndef __IF_HCI_EMU_H
+#define __IF_HCI_EMU_H
+
+#ifdef __KERNEL__
+
+struct hci_emu_struct {
+	struct hci_dev       hdev;
+	__u32                flags;
+	wait_queue_head_t    read_wait;
+	struct sk_buff_head  readq;
+	struct fasync_struct *fasync;
+};
+
+#endif /* __KERNEL__ */
+
+#define HCI_EMU_MINOR		250
+
+/* Max frame size */
+#define HCI_EMU_MAX_FRAME	4096
+
+/* HCI_EMU device flags */
+#define HCI_EMU_FASYNC		0x0010
+
+#endif /* __IF_HCI_EMU_H */
diff -Nur /home/starvik/download/kernel/linux-2.4.19/init/main.c ./init/main.c
--- /home/starvik/download/kernel/linux-2.4.19/init/main.c	Sat Aug  3 02:39:46 2002
+++ ./init/main.c	Wed Oct 23 12:29:00 2002
@@ -161,7 +161,9 @@
 {
 	unsigned long ticks, loopbit;
 	int lps_precision = LPS_PREC;
-
+#ifdef CONFIG_SVINTO_SIM
+	loops_per_jiffy = 33 * 5000;
+#else
 	loops_per_jiffy = (1<<12);
 
 	printk("Calibrating delay loop... ");
@@ -191,7 +193,7 @@
 		if (jiffies != ticks)	/* longer than 1 tick */
 			loops_per_jiffy &= ~loopbit;
 	}
-
+#endif
 /* Round the value and print it */	
 	printk("%lu.%02lu BogoMIPS\n",
 		loops_per_jiffy/(500000/HZ),
@@ -442,10 +444,10 @@
 	initcall_t *call;
 
 	call = &__initcall_start;
-	do {
+	while (call < &__initcall_end) {
 		(*call)();
 		call++;
-	} while (call < &__initcall_end);
+	}
 
 	/* Make sure there is no pending stuff from the initcall sequence */
 	flush_scheduled_tasks();
diff -Nur /home/starvik/download/kernel/linux-2.4.19/lboot ./lboot
--- /home/starvik/download/kernel/linux-2.4.19/lboot	Thu Jan  1 01:00:00 1970
+++ ./lboot	Wed Oct 23 12:29:00 2002
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+svinto_boot --setreg b000002c 0 --setreg b0000000 000095f8 --setreg b0000004 104 --setreg b0000008 5611 --setreg b000000c 1a000040 --bootfile DBG1 --file timage c0004000 --jump 40004000
+
+
diff -Nur /home/starvik/download/kernel/linux-2.4.19/net/ipv4/tcp_diag.c ./net/ipv4/tcp_diag.c
--- /home/starvik/download/kernel/linux-2.4.19/net/ipv4/tcp_diag.c	Fri Dec 21 18:42:05 2001
+++ ./net/ipv4/tcp_diag.c	Wed Oct 23 12:29:00 2002
@@ -18,6 +18,7 @@
 #include <linux/random.h>
 #include <linux/cache.h>
 #include <linux/init.h>
+#include <linux/kernel.h>
 
 #include <net/icmp.h>
 #include <net/tcp.h>
diff -Nur /home/starvik/download/kernel/linux-2.4.19/sboot ./sboot
--- /home/starvik/download/kernel/linux-2.4.19/sboot	Thu Jan  1 01:00:00 1970
+++ ./sboot	Wed Oct 23 12:29:00 2002
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+svinto_boot --setreg b0000000 000095a6 --setreg b0000004 f4 --setreg b0000008 5611 --setreg b000000c dbbb9980 --bootfile DBG0 --file timage c0004000 --jump 40004000
+
+
diff -Nur /home/starvik/download/kernel/linux-2.4.19/scripts/Configure ./scripts/Configure
--- /home/starvik/download/kernel/linux-2.4.19/scripts/Configure	Mon Jul  2 22:56:40 2001
+++ ./scripts/Configure	Wed Oct 23 12:29:00 2002
@@ -48,6 +48,10 @@
 #
 # 24 January 1999, Michael Elizabeth Chastain, <mec@shout.net>
 # - Improve the exit message (Jeff Ronne).
+#
+#  5 April 2000, Johan Adolfsson <Johan.Adolfsson@axis.com>
+# - Support for arch/$ARCH/Configure.help as well.
+
 
 #
 # Make sure we're really running bash.
@@ -81,6 +85,26 @@
 #       help variable
 #
 function help () {
+  if [ -f arch/$ARCH/Configure.help ]
+  then
+     #first escape regexp special characters in the argument:
+     var=$(echo "$1"|sed 's/[][\/.^$*]/\\&/g')
+     #now pick out the right help text:
+     text=$(sed -n "/^$var[ 	]*\$/,\${
+			/^$var[ 	]*\$/c\\
+${var}:\\
+
+			/^#/b
+			/^[^ 	]/q
+			p
+		    }" arch/$ARCH/Configure.help)
+     if [ -n "$text" ]
+     then
+	  (echo; echo "$text") | ${PAGER:-more}
+	  return
+     fi
+  fi
+
   if [ -f Documentation/Configure.help ]
   then
      #first escape regexp special characters in the argument:
diff -Nur /home/starvik/download/kernel/linux-2.4.19/scripts/Menuconfig ./scripts/Menuconfig
--- /home/starvik/download/kernel/linux-2.4.19/scripts/Menuconfig	Sat Aug  3 02:39:46 2002
+++ ./scripts/Menuconfig	Wed Oct 23 12:29:00 2002
@@ -54,7 +54,7 @@
 # Change a lot of places to call set_x_info uniformly.
 # Take out message about preparing version (old sound driver cruft).
 #
-# 13 Dec 1998, Riley H Williams <Riley@Williams.Name>
+# 13 Dec 1998, Riley H Williams <rhw@memalpha.cx>
 # When an error occurs, actually display the error message as well as
 # our comments thereon.
 #
@@ -73,10 +73,6 @@
 # - Support for multiple conditions in dep_tristate().
 # - Implemented new functions: define_tristate(), define_int(), define_hex(),
 #   define_string(), dep_bool().
-#
-# 12 November 2001, Keith Owens <kaos@ocs.com.au>
-# Escape double quotes on eval so the quotes are still there on the second
-# evaluation, required to handle strings with special characters.
 # 
 
 
@@ -109,11 +105,11 @@
     eval x=\$$1
     if [ -z "$x" ]; then
 	eval `sed -n -e 's/# \(.*\) is not set.*/\1=n/' -e "/^$1=/p" arch/$ARCH/defconfig`
-	eval x=\${$1:-\"$2\"}
+	eval x=\${$1:-"$2"}
 	eval $1=$x
 	eval INFO_$1="' (NEW)'"
     fi
-    eval info=\"\$INFO_$1\"
+    eval info="\$INFO_$1"
 }
 
 #
@@ -155,7 +151,7 @@
 }
 
 function define_string () {
-	eval $1=\"$2\"
+	eval $1="$2"
 }
 
 #
@@ -337,7 +333,7 @@
 
 	while [ -n "$2" ]
 	do
-		if eval [ \"_\$$2\" = \"_y\" ]
+		if eval [ "_\$$2" = "_y" ]
 		then
 			current=$1
 			break
@@ -552,9 +548,9 @@
 			# we avoid them:
 			if expr "$answer" : '0$' '|' "$answer" : '[1-9][0-9]*$' '|' "$answer" : '-[1-9][0-9]*$' >/dev/null
 			then
-				eval $2=\"$answer\"
+				eval $2="$answer"
 			else
-				eval $2=\"$3\"
+				eval $2="$3"
 				echo -en "\007"
 				${DIALOG} --backtitle "$backtitle" \
 					--infobox "You have made an invalid entry." 3 43
@@ -585,9 +581,9 @@
 
 			if expr "$answer" : '[0-9a-fA-F][0-9a-fA-F]*$' >/dev/null
 			then
-				eval $2=\"$answer\"
+				eval $2="$answer"
 			else
-				eval $2=\"$3\"
+				eval $2="$3"
 				echo -en "\007"
 				${DIALOG} --backtitle "$backtitle" \
 					--infobox "You have made an invalid entry." 3 43
@@ -685,9 +681,9 @@
 	do
 		if [ "$2" = "$choice" ]
 		then
-			eval $2=\"y\"
+			eval $2="y"
 		else
-			eval $2=\"n\"
+			eval $2="n"
 		fi
 		
 		shift ; shift
@@ -950,9 +946,9 @@
 
 			[ "_" = "_$ALT_CONFIG" ] && break
 
-			if eval [ -r \"$ALT_CONFIG\" ]
+			if eval [ -r "$ALT_CONFIG" ]
 			then
-				eval load_config_file \"$ALT_CONFIG\"
+				eval load_config_file "$ALT_CONFIG"
 				break
 			else
 				echo -ne "\007"
@@ -1076,12 +1072,12 @@
 	#
 	function bool () {
 		set_x_info "$2" "n"
-		eval define_bool \"$2\" \"$x\"
+		eval define_bool "$2" "$x"
 	}
 
 	function tristate () {
 		set_x_info "$2" "n"
-		eval define_tristate \"$2\" \"$x\"
+		eval define_tristate "$2" "$x"
 	}
 
 	function dep_tristate () {
@@ -1147,19 +1143,19 @@
 	}
 
 	function define_hex () {
-		eval $1=\"$2\"
+		eval $1="$2"
                	echo "$1=$2"			>>$CONFIG
 		echo "#define $1 0x${2##*[x,X]}"	>>$CONFIG_H
 	}
 
 	function define_int () {
-		eval $1=\"$2\"
+		eval $1="$2"
 		echo "$1=$2" 			>>$CONFIG
 		echo "#define $1 ($2)"		>>$CONFIG_H
 	}
 
 	function define_string () {
-		eval $1=\"$2\"
+		eval $1="$2"
 		echo "$1=\"$2\""		>>$CONFIG
 		echo "#define $1 \"$2\""	>>$CONFIG_H
 	}
@@ -1169,7 +1165,7 @@
 	}
 
 	function define_tristate () {
-		eval $1=\"$2\"
+		eval $1="$2"
 
    		case "$2" in
          	y)
@@ -1208,7 +1204,7 @@
 		set -- $choices
 		while [ -n "$2" ]
 		do
-			if eval [ \"_\$$2\" = \"_y\" ]
+			if eval [ "_\$$2" = "_y" ]
 			then
 				current=$1
 				break
diff -Nur /home/starvik/download/kernel/linux-2.4.19/scripts/cramfs/GNUmakefile ./scripts/cramfs/GNUmakefile
--- /home/starvik/download/kernel/linux-2.4.19/scripts/cramfs/GNUmakefile	Thu Jan  1 01:00:00 1970
+++ ./scripts/cramfs/GNUmakefile	Wed Oct 23 12:29:00 2002
@@ -0,0 +1,16 @@
+CC = gcc
+CFLAGS = -W -Wall -O2 -g
+CPPFLAGS = -I../../include
+LDLIBS = -lz
+PROGS = mkcramfs cramfsck
+BINDIR = /usr/local/bin
+
+all: $(PROGS)
+
+distclean clean:
+	rm -f $(PROGS)
+
+install: $(PROGS)
+	install -m 0755 $(PROGS) $(BINDIR)
+
+.PHONY: all clean
diff -Nur /home/starvik/download/kernel/linux-2.4.19/scripts/cramfs/cramfsck.c ./scripts/cramfs/cramfsck.c
--- /home/starvik/download/kernel/linux-2.4.19/scripts/cramfs/cramfsck.c	Thu Jan  1 01:00:00 1970
+++ ./scripts/cramfs/cramfsck.c	Wed Oct 23 12:29:00 2002
@@ -0,0 +1,588 @@
+/*
+ * cramfsck - check a cramfs file system
+ *
+ * Copyright (C) 2000-2001 Transmeta Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * 1999/12/03: Linus Torvalds (cramfs tester and unarchive program)
+ * 2000/06/03: Daniel Quinlan (CRC and length checking program)
+ * 2000/06/04: Daniel Quinlan (merged programs, added options, support
+ *                            for special files, preserve permissions and
+ *                            ownership, cramfs superblock v2, bogus mode
+ *                            test, pathname length test, etc.)
+ * 2000/06/06: Daniel Quinlan (support for holes, pretty-printing,
+ *                            symlink size test)
+ * 2000/07/11: Daniel Quinlan (file length tests, start at offset 0 or 512,
+ *                            fsck-compatible exit codes)
+ * 2000/07/15: Daniel Quinlan (initial support for block devices)
+ */
+
+/* compile-time options */
+#define INCLUDE_FS_TESTS	/* include cramfs checking and extraction */
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/fcntl.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <assert.h>
+#include <getopt.h>
+#include <sys/sysmacros.h>
+#include <utime.h>
+#include <sys/ioctl.h>
+#define _LINUX_STRING_H_
+#include <linux/fs.h>
+#include <linux/cramfs_fs.h>
+#include <zlib.h>
+
+static const char *progname = "cramfsck";
+
+static int fd;			/* ROM image file descriptor */
+static char *filename;		/* ROM image filename */
+struct cramfs_super *super;	/* just find the cramfs superblock once */
+static int opt_verbose = 0;	/* 1 = verbose (-v), 2+ = very verbose (-vv) */
+#ifdef INCLUDE_FS_TESTS
+static int opt_extract = 0;	/* extract cramfs (-x) */
+char *extract_dir = NULL;	/* extraction directory (-x) */
+
+unsigned long start_inode = 1 << 28;	/* start of first non-root inode */
+unsigned long end_inode = 0;		/* end of the directory structure */
+unsigned long start_data = 1 << 28;	/* start of the data (256 MB = max) */
+unsigned long end_data = 0;		/* end of the data */
+/* true?  cramfs_super < start_inode < end_inode <= start_data <= end_data */
+static uid_t euid;			/* effective UID */
+
+#define PAD_SIZE 512
+#define PAGE_CACHE_SIZE (4096)
+
+/* Guarantee access to at least 8kB at a time */
+#define ROMBUFFER_BITS	13
+#define ROMBUFFERSIZE	(1 << ROMBUFFER_BITS)
+#define ROMBUFFERMASK	(ROMBUFFERSIZE-1)
+static char read_buffer[ROMBUFFERSIZE * 2];
+static unsigned long read_buffer_block = ~0UL;
+
+/* Uncompressing data structures... */
+static char outbuffer[PAGE_CACHE_SIZE*2];
+z_stream stream;
+
+#endif /* INCLUDE_FS_TESTS */
+
+/* Input status of 0 to print help and exit without an error. */
+static void usage(int status)
+{
+	FILE *stream = status ? stderr : stdout;
+
+	fprintf(stream, "usage: %s [-hv] [-x dir] file\n"
+		" -h         print this help\n"
+		" -x dir     extract into dir\n"
+		" -v         be more verbose\n"
+		" file       file to test\n", progname);
+
+	exit(status);
+}
+
+#ifdef INCLUDE_FS_TESTS
+void print_node(char type, struct cramfs_inode *i, char *name)
+{
+	char info[10];
+
+	if (S_ISCHR(i->mode) || (S_ISBLK(i->mode))) {
+		/* major/minor numbers can be as high as 2^12 or 4096 */
+		snprintf(info, 10, "%4d,%4d", major(i->size), minor(i->size));
+	}
+	else {
+		/* size be as high as 2^24 or 16777216 */
+		snprintf(info, 10, "%9d", i->size);
+	}
+
+	printf("%c %04o %s %5d:%-3d %s\n",
+	       type, i->mode & ~S_IFMT, info, i->uid, i->gid, name);
+}
+
+/*
+ * Create a fake "blocked" access
+ */
+static void *romfs_read(unsigned long offset)
+{
+	unsigned int block = offset >> ROMBUFFER_BITS;
+	if (block != read_buffer_block) {
+		read_buffer_block = block;
+		lseek(fd, block << ROMBUFFER_BITS, SEEK_SET);
+		read(fd, read_buffer, ROMBUFFERSIZE * 2);
+	}
+	return read_buffer + (offset & ROMBUFFERMASK);
+}
+
+static struct cramfs_inode *cramfs_iget(struct cramfs_inode * i)
+{
+	struct cramfs_inode *inode = malloc(sizeof(struct cramfs_inode));
+	*inode = *i;
+	return inode;
+}
+
+static struct cramfs_inode *iget(unsigned int ino)
+{
+	return cramfs_iget(romfs_read(ino));
+}
+
+void iput(struct cramfs_inode *inode)
+{
+	free(inode);
+}
+
+/*
+ * Return the offset of the root directory,
+ * or 0 if none.
+ */
+static struct cramfs_inode *read_super(void)
+{
+	unsigned long offset;
+
+	offset = super->root.offset << 2;
+	if (super->magic != CRAMFS_MAGIC)
+		return NULL;
+	if (memcmp(super->signature, CRAMFS_SIGNATURE, sizeof(super->signature)) != 0)
+		return NULL;
+	if (offset < sizeof(super))
+		return NULL;
+	return cramfs_iget(&super->root);
+}
+
+static int uncompress_block(void *src, int len)
+{
+	int err;
+
+	stream.next_in = src;
+	stream.avail_in = len;
+
+	stream.next_out = (unsigned char *) outbuffer;
+	stream.avail_out = PAGE_CACHE_SIZE*2;
+
+	inflateReset(&stream);
+
+	err = inflate(&stream, Z_FINISH);
+	if (err != Z_STREAM_END) {
+		fprintf(stderr, "%s: error %d while decompressing! %p(%d)\n",
+			filename, err, src, len);
+		exit(4);
+	}
+	return stream.total_out;
+}
+
+static void change_file_status(char *path, struct cramfs_inode *i)
+{
+	struct utimbuf epoch = { 0, 0 };
+
+	if (euid == 0) {
+		if (lchown(path, i->uid, i->gid) < 0) {
+			perror(path);
+			exit(8);
+		}
+		if (S_ISLNK(i->mode))
+			return;
+		if ((S_ISUID | S_ISGID) & i->mode) {
+			if (chmod(path, i->mode) < 0) {
+				perror(path);
+				exit(8);
+			}
+		}
+	}
+	if (S_ISLNK(i->mode))
+		return;
+	if (utime(path, &epoch) < 0) {
+		perror(path);
+		exit(8);
+	}
+}
+
+static void do_symlink(char *path, struct cramfs_inode *i)
+{
+	unsigned long offset = i->offset << 2;
+	unsigned long curr = offset + 4;
+	unsigned long next = *(u32 *) romfs_read(offset);
+	unsigned long size;
+
+	if (next > end_data) {
+		end_data = next;
+	}
+
+	size = uncompress_block(romfs_read(curr), next - curr);
+	if (size != i->size) {
+		fprintf(stderr, "%s: size error in symlink `%s'\n",
+			filename, path);
+		exit(4);
+	}
+	outbuffer[size] = 0;
+	if (opt_verbose) {
+		char *str;
+
+		str = malloc(strlen(outbuffer) + strlen(path) + 5);
+		strcpy(str, path);
+		strncat(str, " -> ", 4);
+		strncat(str, outbuffer, size);
+
+		print_node('l', i, str);
+		if (opt_verbose > 1) {
+			printf("  uncompressing block at %ld to %ld (%ld)\n", curr, next, next - curr);
+		}
+	}
+	if (opt_extract) {
+		symlink(outbuffer, path);
+		change_file_status(path, i);
+	}
+}
+
+static void do_special_inode(char *path, struct cramfs_inode *i)
+{
+	dev_t devtype = 0;
+	char type;
+
+	if (S_ISCHR(i->mode)) {
+		devtype = i->size;
+		type = 'c';
+	}
+	else if (S_ISBLK(i->mode)) {
+		devtype = i->size;
+		type = 'b';
+	}
+	else if (S_ISFIFO(i->mode))
+		type = 'p';
+	else if (S_ISSOCK(i->mode))
+		type = 's';
+	else {
+		fprintf(stderr, "%s: bogus mode on `%s' (%o)\n", filename, path, i->mode);
+		exit(4);
+	}
+
+	if (opt_verbose) {
+		print_node(type, i, path);
+	}
+
+	if (opt_extract) {
+		if (mknod(path, i->mode, devtype) < 0) {
+			perror(path);
+			exit(8);
+		}
+		change_file_status(path, i);
+	}
+}
+
+static void do_uncompress(int fd, unsigned long offset, unsigned long size)
+{
+	unsigned long curr = offset + 4 * ((size + PAGE_CACHE_SIZE - 1) / PAGE_CACHE_SIZE);
+
+	do {
+		unsigned long out = PAGE_CACHE_SIZE;
+		unsigned long next = *(u32 *) romfs_read(offset);
+
+		if (next > end_data) {
+			end_data = next;
+		}
+
+		offset += 4;
+		if (curr == next) {
+			if (opt_verbose > 1) {
+				printf("  hole at %ld (%d)\n", curr, PAGE_CACHE_SIZE);
+			}
+			if (size < PAGE_CACHE_SIZE)
+				out = size;
+			memset(outbuffer, 0x00, out);
+		}
+		else {
+			if (opt_verbose > 1) {
+				printf("  uncompressing block at %ld to %ld (%ld)\n", curr, next, next - curr);
+			}
+			out = uncompress_block(romfs_read(curr), next - curr);
+		}
+		if (size >= PAGE_CACHE_SIZE) {
+			if (out != PAGE_CACHE_SIZE) {
+				fprintf(stderr, "%s: Non-block (%ld) bytes\n", filename, out);
+				exit(4);
+			}
+		} else {
+			if (out != size) {
+				fprintf(stderr, "%s: Non-size (%ld vs %ld) bytes\n", filename, out, size);
+				exit(4);
+			}
+		}
+		size -= out;
+		if (opt_extract) {
+			write(fd, outbuffer, out);
+		}
+		curr = next;
+	} while (size);
+}
+
+static void expand_fs(int pathlen, char *path, struct cramfs_inode *inode)
+{
+	if (S_ISDIR(inode->mode)) {
+		int count = inode->size;
+		unsigned long offset = inode->offset << 2;
+		char *newpath = malloc(pathlen + 256);
+
+		if (count > 0 && offset < start_inode) {
+			start_inode = offset;
+		}
+		/* XXX - need to check end_inode for empty case? */
+		memcpy(newpath, path, pathlen);
+		newpath[pathlen] = '/';
+		pathlen++;
+		if (opt_verbose) {
+			print_node('d', inode, path);
+		}
+		if (opt_extract) {
+			mkdir(path, inode->mode);
+			change_file_status(path, inode);
+		}
+		while (count > 0) {
+			struct cramfs_inode *child = iget(offset);
+			int size;
+			int newlen = child->namelen << 2;
+
+			size = sizeof(struct cramfs_inode) + newlen;
+			count -= size;
+
+			offset += sizeof(struct cramfs_inode);
+
+			memcpy(newpath + pathlen, romfs_read(offset), newlen);
+			newpath[pathlen + newlen] = 0;
+			if ((pathlen + newlen) - strlen(newpath) > 3) {
+				fprintf(stderr, "%s: invalid cramfs--bad path length\n", filename);
+				exit(4);
+			}
+			expand_fs(strlen(newpath), newpath, child);
+
+			offset += newlen;
+
+			if (offset > end_inode) {
+				end_inode = offset;
+			}
+		}
+		return;
+	}
+	if (S_ISREG(inode->mode)) {
+		int fd = 0;
+		unsigned long offset = inode->offset << 2;
+
+		if (offset > 0 && offset < start_data) {
+			start_data = offset;
+		}
+		if (opt_verbose) {
+			print_node('f', inode, path);
+		}
+		if (opt_extract) {
+			fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, inode->mode);
+		}
+		if (inode->size) {
+			do_uncompress(fd, offset, inode->size);
+		}
+		if (opt_extract) {
+			close(fd);
+			change_file_status(path, inode);
+		}
+		return;
+	}
+	if (S_ISLNK(inode->mode)) {
+		unsigned long offset = inode->offset << 2;
+
+		if (offset < start_data) {
+			start_data = offset;
+		}
+		do_symlink(path, inode);
+		return;
+	}
+	else {
+		do_special_inode(path, inode);
+		return;
+	}
+}
+#endif /* INCLUDE_FS_TESTS */
+
+int main(int argc, char **argv)
+{
+	void *buf;
+	size_t length;
+	struct stat st;
+	u32 crc_old, crc_new;
+#ifdef INCLUDE_FS_TESTS
+	struct cramfs_inode *root;
+#endif /* INCLUDE_FS_TESTS */
+	int c;			/* for getopt */
+	int start = 0;
+
+	if (argc)
+		progname = argv[0];
+
+	/* command line options */
+	while ((c = getopt(argc, argv, "hx:v")) != EOF) {
+		switch (c) {
+		case 'h':
+			usage(0);
+		case 'x':
+#ifdef INCLUDE_FS_TESTS
+			opt_extract = 1;
+			extract_dir = malloc(strlen(optarg) + 1);
+			strcpy(extract_dir, optarg);
+			break;
+#else /*  not INCLUDE_FS_TESTS */
+			fprintf(stderr, "%s: compiled without -x support\n",
+				progname);
+			exit(16);
+#endif /* not INCLUDE_FS_TESTS */
+		case 'v':
+			opt_verbose++;
+			break;
+		}
+	}
+
+	if ((argc - optind) != 1)
+		usage(16);
+	filename = argv[optind];
+
+	/* find the physical size of the file or block device */
+	if (lstat(filename, &st) < 0) {
+		perror(filename);
+		exit(8);
+	}
+	fd = open(filename, O_RDONLY);
+	if (fd < 0) {
+		perror(filename);
+		exit(8);
+	}
+	if (S_ISBLK(st.st_mode)) {
+		if (ioctl(fd, BLKGETSIZE, &length) < 0) {
+			fprintf(stderr, "%s: warning--unable to determine filesystem size \n", filename);
+			exit(4);
+		}
+		length = length * 512;
+	}
+	else if (S_ISREG(st.st_mode)) {
+		length = st.st_size;
+	}
+	else {
+		fprintf(stderr, "%s is not a block device or file\n", filename);
+		exit(8);
+	}
+
+	if (length < sizeof(struct cramfs_super)) {
+		fprintf(stderr, "%s: invalid cramfs--file length too short\n", filename);
+		exit(4);
+	}
+
+	if (S_ISBLK(st.st_mode)) {
+		/* nasty because mmap of block devices fails */
+		buf = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+		read(fd, buf, length);
+	}
+	else {
+		/* nice and easy */
+		buf = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
+	}
+
+	/* XXX - this could be cleaner... */
+	if (((struct cramfs_super *) buf)->magic == CRAMFS_MAGIC) {
+		start = 0;
+		super = (struct cramfs_super *) buf;
+	}
+	else if (length >= (PAD_SIZE + sizeof(struct cramfs_super)) &&
+		 ((((struct cramfs_super *) (buf + PAD_SIZE))->magic == CRAMFS_MAGIC)))
+	{
+		start = PAD_SIZE;
+		super = (struct cramfs_super *) (buf + PAD_SIZE);
+	}
+	else {
+		fprintf(stderr, "%s: invalid cramfs--wrong magic\n", filename);
+		exit(4);
+	}
+
+	if (super->flags & CRAMFS_FLAG_FSID_VERSION_2) {
+		/* length test */
+		if (length < super->size) {
+			fprintf(stderr, "%s: invalid cramfs--file length too short\n", filename);
+			exit(4);
+		}
+		else if (length > super->size) {
+			fprintf(stderr, "%s: warning--file length too long, padded image?\n", filename);
+		}
+
+		/* CRC test */
+		crc_old = super->fsid.crc;
+		super->fsid.crc = crc32(0L, Z_NULL, 0);
+		crc_new = crc32(0L, Z_NULL, 0);
+		crc_new = crc32(crc_new, (unsigned char *) buf+start, super->size - start);
+		if (crc_new != crc_old) {
+			fprintf(stderr, "%s: invalid cramfs--crc error\n", filename);
+			exit(4);
+		}
+	}
+	else {
+		fprintf(stderr, "%s: warning--old cramfs image, no CRC\n",
+			filename);
+	}
+
+#ifdef INCLUDE_FS_TESTS
+	super = (struct cramfs_super *) malloc(sizeof(struct cramfs_super));
+	if (((struct cramfs_super *) buf)->magic == CRAMFS_MAGIC) {
+		memcpy(super, buf, sizeof(struct cramfs_super));
+	}
+	else if (length >= (PAD_SIZE + sizeof(struct cramfs_super)) &&
+		 ((((struct cramfs_super *) (buf + PAD_SIZE))->magic == CRAMFS_MAGIC)))
+	{
+		memcpy(super, (buf + PAD_SIZE), sizeof(struct cramfs_super));
+	}
+
+	munmap(buf, length);
+
+	/* file format test, uses fake "blocked" accesses */
+	root = read_super();
+	umask(0);
+	euid = geteuid();
+	if (!root) {
+		fprintf(stderr, "%s: invalid cramfs--bad superblock\n",
+			filename);
+		exit(4);
+	}
+	stream.next_in = NULL;
+	stream.avail_in = 0;
+	inflateInit(&stream);
+
+	if (!extract_dir) {
+		extract_dir = "root";
+	}
+
+	expand_fs(strlen(extract_dir), extract_dir, root);
+	inflateEnd(&stream);
+
+	if (start_data != 1 << 28  && end_inode != start_data) {
+		fprintf(stderr, "%s: invalid cramfs--directory data end (%ld) != file data start (%ld)\n", filename, end_inode, start_data);
+		exit(4);
+	}
+	if (super->flags & CRAMFS_FLAG_FSID_VERSION_2) {
+		if (end_data > super->size) {
+			fprintf(stderr, "%s: invalid cramfs--invalid file data offset\n", filename);
+			exit(4);
+		}
+	}
+#endif /* INCLUDE_FS_TESTS */
+
+	exit(0);
+}
diff -Nur /home/starvik/download/kernel/linux-2.4.19/scripts/cramfs/mkcramfs.c ./scripts/cramfs/mkcramfs.c
--- /home/starvik/download/kernel/linux-2.4.19/scripts/cramfs/mkcramfs.c	Thu Jan  1 01:00:00 1970
+++ ./scripts/cramfs/mkcramfs.c	Wed Oct 23 12:29:00 2002
@@ -0,0 +1,1189 @@
+/*
+ * mkcramfs - make a cramfs file system
+ *
+ * Copyright (C) 1999-2001 Transmeta Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/fcntl.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <assert.h>
+#include <ctype.h>
+#include <limits.h>
+#include <getopt.h>
+#include <linux/cramfs_fs.h>
+#include <zlib.h>
+
+#define PAD_SIZE 512		/* only 0 and 512 supported by kernel */
+
+static const char *progname = "mkcramfs";
+static const char *meta_file_name = NULL; /* NULL means ignore meta file */
+
+/* N.B. If you change the disk format of cramfs, please update fs/cramfs/README. */
+
+/* Input status of 0 to print help and exit without an error. */
+static void usage(int status)
+{
+	FILE *stream = status ? stderr : stdout;
+
+	fprintf(stream, "usage: %s [-h] [-b blocksize] [-e edition] [-i file] [-m filename]\n"
+			"       [-n name] dirname outfile\n"
+		" -h           print this help\n"
+		" -E           make all warnings errors (non-zero exit status)\n"
+		" -b blocksize the page-size (default is 4096)\n"
+		" -e edition   set edition number (part of fsid)\n"
+		" -i file      insert a file image into the filesystem (requires >= 2.4.0)\n"
+		" -m filename  look for meta files with this name in each subdir\n"
+		" -n name      set name of cramfs filesystem\n"
+		" -p           pad by %d bytes for boot code\n"
+		" -s           sort directory entries (old option, ignored)\n"
+		" -z           make explicit holes (requires >= 2.3.39)\n"
+		" dirname      root of the filesystem to be compressed\n"
+		" outfile      output file\n", progname, PAD_SIZE);
+
+	exit(status);
+}
+
+#define DEFAULT_PAGE_CACHE_SIZE (4096)
+/* The kernel assumes PAGE_CACHE_SIZE as block size. */
+static unsigned int blksize = DEFAULT_PAGE_CACHE_SIZE;
+static long total_blocks = 0, total_nodes = 1; /* pre-count the root node */
+static int image_length = 0;
+
+/*
+ * If opt_holes is set, then mkcramfs can create explicit holes in the
+ * data, which saves 26 bytes per hole (which is a lot smaller a
+ * saving than most most filesystems).
+ *
+ * Note that kernels up to at least 2.3.39 don't support cramfs holes,
+ * which is why this is turned off by default.
+ */
+static int opt_edition = 0;
+static int opt_errors = 0;
+static int opt_holes = 0;
+static int opt_pad = 0;
+static char *opt_image = NULL;
+static char *opt_name = NULL;
+
+static int warn_dev, warn_gid, warn_namelen, warn_skip, warn_size, warn_uid;
+static int name_offset;	/* For removing directory name in output */
+
+#ifndef MIN
+# define MIN(_a,_b) ((_a) < (_b) ? (_a) : (_b))
+#endif
+
+/* In-core version of inode / directory entry. */
+struct entry {
+	/* stats */
+	char *name;
+	unsigned int mode, size, uid, gid;
+
+	/* FS data */
+	void *uncompressed;
+        /* points to other identical file */
+        struct entry *same;
+        unsigned int offset;            /* pointer to compressed data in archive */
+	unsigned int dir_offset;	/* Where in the archive is the directory entry? */
+
+	/* organization */
+	struct entry *child; /* null for non-directories and empty directories */
+	struct entry *next;
+};
+
+/*
+ * The longest file name component to allow for in the input directory tree.
+ * Ext2fs (and many others) allow up to 255 bytes.  A couple of filesystems
+ * allow longer (e.g. smbfs 1024), but there isn't much use in supporting
+ * >255-byte names in the input directory tree given that such names get
+ * truncated to 255 bytes when written to cramfs.
+ */
+#define MAX_INPUT_NAMELEN 255
+
+static int find_identical_file(struct entry *orig,struct entry *newfile)
+{
+        if(orig==newfile) return 1;
+        if(!orig) return 0;
+        if(orig->size==newfile->size && orig->uncompressed && !memcmp(orig->uncompressed,newfile->uncompressed,orig->size)) {
+                newfile->same=orig;
+                return 1;
+        }
+        return find_identical_file(orig->child,newfile) ||
+                   find_identical_file(orig->next,newfile);
+}
+
+static void eliminate_doubles(struct entry *root,struct entry *orig) {
+        if(orig) {
+                if(orig->size && orig->uncompressed)
+			find_identical_file(root,orig);
+                eliminate_doubles(root,orig->child);
+                eliminate_doubles(root,orig->next);
+        }
+}
+
+/*****************************************************************/
+
+/* Meta types */
+
+#define META_IGNORE          1
+#define META_IGNORE_CONTENTS 2
+#define META_DEVICE          3
+#define META_INCLUDE         4
+#define META_UID             5
+#define META_GID             6
+
+#define ID_NONE UINT_MAX	/* for ignoring default_uid and default_gid */
+
+struct metadata {
+	struct metadata *next;	/* next node in linked list */
+	int type;		/* meta type */
+	char *name;		/* entry name */
+	unsigned int id;	/* for type META_UID and META_GID */
+	char dev_type;		/* for type META_DEVICE */
+	unsigned char major;	/* for type META_DEVICE */
+	unsigned char minor;	/* for type META_DEVICE */
+};
+
+#define BUFFERLENGTH 256
+
+/* Meta data functions */
+
+struct metadata *create_meta_ignore(char *line, struct metadata *meta, int ignoretype)
+{
+	struct metadata *new_meta;
+	char *end = &line[strlen(line)];
+
+	while (isspace(*line)) {
+		line++;
+	}
+
+	for (end--; end > line && isspace(*end); end--) {
+		*end = '\0';
+	}
+
+	if (end > line && *line == '"' && *end == '"') {
+		line++;
+		*end = '\0';
+	}
+
+	/* Can't ignore the . and .. directories */
+	if (strlen(line) && strcmp(line, ".") && strcmp(line, "..")) {
+		if ((new_meta = malloc(sizeof(struct metadata)))) {
+			new_meta->next = meta;
+			new_meta->type = ignoretype;
+			new_meta->name = strdup(line);
+			return new_meta;
+		} else {
+			fprintf(stderr,"out of memory\n");
+			exit(1);
+		}
+	}
+
+	return meta;
+}
+
+struct metadata *create_meta_include(char *line, struct metadata *meta)
+{
+	struct metadata *new_meta;
+	char *end = &line[strlen(line)];
+
+	while (isspace(*line)) {
+		line++;
+	}
+
+	for (end--; end > line && isspace(*end); end--) {
+		*end = '\0';
+	}
+
+	if (end > line && *line == '"' && *end == '"') {
+		line++;
+		*end = '\0';
+	}
+
+	if ((new_meta = malloc(sizeof(struct metadata)))) {
+		new_meta->next = meta;
+		new_meta->type = META_INCLUDE;
+		new_meta->name = strdup(line);
+		return new_meta;
+	} else {
+		fprintf(stderr,"out of memory\n");
+		exit(1);
+	}
+
+	return meta;
+}
+
+struct metadata *create_meta_device(char *line, struct metadata *meta)
+{
+	struct metadata *new_meta;
+	char name[MAX_INPUT_NAMELEN + 1];
+	char dev_type;
+	unsigned int major = 0;
+	unsigned int minor = 0;
+	int found;
+
+	found = sscanf(line, "%s %c %u %u", name, &dev_type, &major, &minor);
+	
+	if ((found == 2 || found == 4) &&
+	    (dev_type == 'b' || dev_type == 'c' || dev_type == 'p') &&
+	    major < 256 && minor < 256) {
+		if ((new_meta = malloc(sizeof(struct metadata)))) {
+			new_meta->next = meta;
+			new_meta->type = META_DEVICE;
+			new_meta->name = strdup(name);
+			new_meta->dev_type = dev_type;
+			if (dev_type == 'b' || dev_type == 'c') {
+				new_meta->major = (unsigned char)major;
+				new_meta->minor = (unsigned char)minor;
+			}
+			return new_meta;
+		} else {
+			fprintf(stderr,"out of memory\n");
+			exit(1);
+		}
+	} else
+		fprintf(stderr, "Illegal device file specification: %s", line);
+
+	return meta;
+}
+
+struct metadata *create_meta_uid(char *line, struct metadata *meta)
+{
+	struct metadata *new_meta;
+	char name[MAX_INPUT_NAMELEN + 1];
+	unsigned int uid;
+	int found;
+
+	found = sscanf(line, "%s %u", name, &uid);
+	
+	if (found == 2) {
+		if ((new_meta = malloc(sizeof(struct metadata)))) {
+			new_meta->next = meta;
+			new_meta->type = META_UID;
+			new_meta->name = strdup(name);
+			new_meta->id = uid;
+
+			return new_meta;
+		} else {
+			fprintf(stderr,"out of memory\n");
+			exit(1);
+		}
+	} else
+		fprintf(stderr, "Illegal uid specification: %s", line);
+
+	return meta;
+}
+
+struct metadata *create_meta_gid(char *line, struct metadata *meta)
+{
+	struct metadata *new_meta;
+	char name[MAX_INPUT_NAMELEN + 1];
+	unsigned int gid;
+	int found;
+
+	found = sscanf(line, "%s %u", name, &gid);
+	
+	if (found == 2) {
+		if ((new_meta = malloc(sizeof(struct metadata)))) {
+			new_meta->next = meta;
+			new_meta->type = META_GID;
+			new_meta->name = strdup(name);
+			new_meta->id = gid;
+
+			return new_meta;
+		} else {
+			fprintf(stderr,"out of memory\n");
+			exit(1);
+		}
+	} else
+		fprintf(stderr, "Illegal gid specification: %s", line);
+
+	return meta;
+}
+
+struct metadata *read_meta_data(const char *dir_name, unsigned int *default_uid_ptr, unsigned int *default_gid_ptr)
+{
+	FILE *meta_file;
+	char *file_name;
+	struct metadata *meta = 0;
+	char line[BUFFERLENGTH];
+
+	if (!meta_file_name)
+		return NULL;
+
+	if (!(file_name = malloc(strlen(dir_name) + strlen(meta_file_name) + 2))) {
+		fprintf(stderr,"out of memory\n");
+		return 0;
+	}
+
+	strcpy(file_name, dir_name);
+	strcat(file_name, "/");
+	strcat(file_name, meta_file_name);
+
+	if (!(meta_file = fopen(file_name, "r"))) {
+		return 0;
+	}
+
+	while (!feof(meta_file)) {
+		if (fgets(line, BUFFERLENGTH - 1, meta_file)) {
+			if (!strncasecmp("Ignore:", line, 7)) {
+				meta = create_meta_ignore(line + 7, meta, META_IGNORE);
+			} else if (!strncasecmp("IgnoreContents:", line, 15)) {
+				meta = create_meta_ignore(line + 15, meta,
+							  META_IGNORE_CONTENTS);
+			} else if (!strncasecmp("Include:", line, 8)) {
+				meta = create_meta_include(line + 8, meta);
+			} else if (!strncasecmp("Device:", line, 7)) {
+				meta = create_meta_device(line + 7, meta);
+			} else if (!strncasecmp("UserId:", line, 7)) {
+				meta = create_meta_uid(line + 7, meta);
+			} else if (!strncasecmp("GroupId:", line, 8)) {
+				meta = create_meta_gid(line + 8, meta);
+			} else if (!strncasecmp("DefaultUserId:", line, 14)) {
+				int count = sscanf(line + 14, "%u", default_uid_ptr);
+				if (count < 1)
+					fprintf(stderr, "Illegal default uid specification: %s", line);
+			} else if (!strncasecmp("DefaultGroupId:", line, 15)) {
+				int count = sscanf(line + 15, "%u", default_gid_ptr);
+				if (count < 1)
+					fprintf(stderr, "Illegal default gid specification: %s", line);
+			} else {
+				fprintf(stderr, "Illegal meta specification: %s", line);
+			}
+		}
+	}
+	
+	fclose(meta_file);
+	free(file_name);
+
+	return meta;
+}
+
+void free_meta_data(struct metadata *meta)
+{
+	struct metadata *next;
+
+	for (; meta; meta = next) {
+		next = meta->next;
+		free(meta->name);
+		free(meta);
+	}
+}
+
+int meta_ignore(struct metadata *meta, char *name)
+{
+	for (; meta; meta = meta->next) {
+		if (meta->type == META_IGNORE && !strcmp(name, meta->name)) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+int meta_ignore_contents(struct metadata *meta, char *name)
+{
+	for (; meta; meta = meta->next) {
+		if (meta->type == META_IGNORE_CONTENTS && !strcmp(name, meta->name)) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+int meta_include(struct metadata *meta, char *name)
+{
+	int found = 0;
+
+	/* Always include . and .. */
+	if (!strcmp(name, ".") || !strcmp(name, ".."))
+		return 1;  
+
+	for (; meta; meta = meta->next) {
+		if (meta->type == META_INCLUDE) {
+			found = 1;
+			if (!strcmp(name, meta->name)) {
+				return 1;
+			}
+		}
+	}
+
+	return !found;
+}
+
+int meta_handle_device(struct metadata *meta, struct entry *entry)
+{
+	for (; meta; meta = meta->next) {
+		if (meta->type == META_DEVICE &&
+		    !strcmp(entry->name, meta->name)) {
+			if (meta->dev_type == 'b') {
+				entry->mode = (entry->mode & ~S_IFMT) | S_IFBLK;
+				entry->size = makedev(meta->major, meta->minor);
+			} else if (meta->dev_type == 'c') {
+				entry->mode = (entry->mode & ~S_IFMT) | S_IFCHR;
+				entry->size = makedev(meta->major, meta->minor);
+			} else {
+				entry->mode = (entry->mode & ~S_IFMT) | S_IFIFO;
+			}
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+int meta_handle_uid(struct metadata *meta, struct entry *entry)
+{
+	for (; meta; meta = meta->next) {
+		if (meta->type == META_UID) {
+			if (!strcmp(entry->name, meta->name)) {
+				entry->uid = meta->id;
+				return 1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int meta_handle_gid(struct metadata *meta, struct entry *entry)
+{
+	for (; meta; meta = meta->next) {
+		if (meta->type == META_GID) {
+			if (!strcmp(entry->name, meta->name)) {
+				entry->gid = meta->id;
+				return 1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*****************************************************************/
+
+/*
+ * We define our own sorting function instead of using alphasort which
+ * uses strcoll and changes ordering based on locale information.
+ */
+static int cramsort (const void *a, const void *b)
+{
+	return strcmp ((*(const struct dirent **) a)->d_name,
+		       (*(const struct dirent **) b)->d_name);
+}
+
+static unsigned int parse_directory(struct entry *root_entry, const char *name, struct entry **prev, loff_t *fslen_ub, int ignore_contents, unsigned int default_uid, unsigned int default_gid)
+{
+	struct dirent **dirlist;
+	int totalsize = 0, dircount, dirindex;
+	char *path, *endpath;
+	size_t len = strlen(name);
+	struct metadata *meta;
+
+	meta = read_meta_data(name, &default_uid, &default_gid);
+
+	/* Set up the path. */
+	/* TODO: Reuse the parent's buffer to save memcpy'ing and duplication. */
+	path = malloc(len + 1 + MAX_INPUT_NAMELEN + 1);
+	if (!path) {
+		perror(NULL);
+		exit(8);
+	}
+	memcpy(path, name, len);
+	endpath = path + len;
+	*endpath = '/';
+	endpath++;
+
+        /* read in the directory and sort */
+        dircount = scandir(name, &dirlist, 0, cramsort);
+
+	if (dircount < 0) {
+		perror(name);
+		exit(8);
+	}
+
+	/* process directory */
+	for (dirindex = 0; dirindex < dircount; dirindex++) {
+		struct dirent *dirent;
+		struct entry *entry;
+		struct stat st;
+		int size;
+		size_t namelen;
+
+		dirent = dirlist[dirindex];
+
+		/* Ignore "." and ".." - we won't be adding them to the archive */
+		if (dirent->d_name[0] == '.') {
+			if (dirent->d_name[1] == '\0')
+				continue;
+			if (dirent->d_name[1] == '.') {
+				if (dirent->d_name[2] == '\0')
+					continue;
+			}
+		}
+
+		/* Ignore files according to meta data */
+		if (ignore_contents) {
+			printf("Meta: ignoring content %s/%s\n", name + name_offset, dirent->d_name);
+			continue;
+		}
+		if (meta_file_name && !strcmp(dirent->d_name, meta_file_name)) {
+			printf("Meta: ignoring meta file %s/%s\n", name + name_offset, dirent->d_name);
+			continue; /* don't include the meta data file */
+		}
+		if (!meta_include(meta, dirent->d_name)) {
+			printf("Meta: not including %s/%s\n", name + name_offset, dirent->d_name);
+			continue; /* include files according to the meta data */
+		}
+		if (meta_ignore(meta, dirent->d_name)) {
+			printf("Meta: ignoring %s/%s\n", name + name_offset, dirent->d_name);
+			continue; /* ignore files according to the meta data */
+		}
+
+		namelen = strlen(dirent->d_name);
+		if (namelen > MAX_INPUT_NAMELEN) {
+			fprintf(stderr,
+				"Very long (%u bytes) filename `%s' found.\n"
+				" Please increase MAX_INPUT_NAMELEN in mkcramfs.c and recompile.  Exiting.\n",
+				namelen, dirent->d_name);
+			exit(8);
+		}
+		memcpy(endpath, dirent->d_name, namelen + 1);
+
+		if (lstat(path, &st) < 0) {
+			perror(endpath);
+			warn_skip = 1;
+			continue;
+		}
+		entry = calloc(1, sizeof(struct entry));
+		if (!entry) {
+			perror(NULL);
+			exit(8);
+		}
+		entry->name = strdup(dirent->d_name);
+		if (!entry->name) {
+			perror(NULL);
+			exit(8);
+		}
+		if (namelen > 255) {
+			/* Can't happen when reading from ext2fs. */
+
+			/* TODO: we ought to avoid chopping in half
+			   multi-byte UTF8 characters. */
+			entry->name[namelen = 255] = '\0';
+			warn_namelen = 1;
+		}
+		entry->mode = st.st_mode;
+		entry->size = st.st_size;
+		entry->uid = st.st_uid;
+		if (entry->uid >= 1 << CRAMFS_UID_WIDTH)
+			warn_uid = 1;
+		entry->gid = st.st_gid;
+		if (entry->gid >= 1 << CRAMFS_GID_WIDTH)
+			/* TODO: We ought to replace with a default
+                           gid instead of truncating; otherwise there
+                           are security problems.  Maybe mode should
+                           be &= ~070.  Same goes for uid once Linux
+                           supports >16-bit uids. */
+			warn_gid = 1;
+		size = sizeof(struct cramfs_inode) + ((namelen + 3) & ~3);
+		*fslen_ub += size;
+		if (S_ISDIR(st.st_mode)) {
+			entry->size = parse_directory(root_entry, path, &entry->child, fslen_ub, meta_ignore_contents(meta, dirent->d_name), default_uid, default_gid);
+		} else if (S_ISREG(st.st_mode)) {
+			/* TODO: We ought to open files in do_compress, one
+			   at a time, instead of amassing all these memory
+			   maps during parse_directory (which don't get used
+			   until do_compress anyway).  As it is, we tend to
+			   get EMFILE errors (especially if mkcramfs is run
+			   by non-root).
+
+			   While we're at it, do analagously for symlinks
+			   (which would just save a little memory). */
+			if (meta_handle_device(meta, entry)) {
+				if (entry->size & -(1 << CRAMFS_SIZE_WIDTH))
+					warn_dev = 1;
+				printf("Meta: device (%c %d %d) %s/%s\n", (S_ISBLK(entry->mode))? 'b' : 'c', major(entry->size), minor(entry->size), name + name_offset, dirent->d_name);
+			} else {
+			int fd = open(path, O_RDONLY);
+			if (fd < 0) {
+				perror(path);
+				warn_skip = 1;
+				continue;
+			}
+			if (entry->size) {
+				if ((entry->size >= 1 << CRAMFS_SIZE_WIDTH)) {
+					warn_size = 1;
+					entry->size = (1 << CRAMFS_SIZE_WIDTH) - 1;
+				}
+
+				entry->uncompressed = mmap(NULL, entry->size, PROT_READ, MAP_PRIVATE, fd, 0);
+				if (-1 == (int) (long) entry->uncompressed) {
+					perror("mmap");
+					exit(8);
+				}
+			}
+			close(fd);
+			}
+		} else if (S_ISLNK(st.st_mode)) {
+			entry->uncompressed = malloc(entry->size);
+			if (!entry->uncompressed) {
+				perror(NULL);
+				exit(8);
+			}
+			if (readlink(path, entry->uncompressed, entry->size) < 0) {
+				perror(path);
+				warn_skip = 1;
+				continue;
+			}
+		} else if (S_ISFIFO(st.st_mode) || S_ISSOCK(st.st_mode)) {
+			/* maybe we should skip sockets */
+			entry->size = 0;
+		} else {
+			entry->size = st.st_rdev;
+			if (entry->size & -(1<<CRAMFS_SIZE_WIDTH))
+				warn_dev = 1;
+		}
+
+		if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
+			int blocks = ((entry->size - 1) / blksize + 1);
+
+			/* block pointers & data expansion allowance + data */
+			if(entry->size)
+				*fslen_ub += (4+26)*blocks + entry->size + 3;
+                }
+
+		if (meta_handle_uid(meta, entry)) {
+			printf("Meta: uid (%u) %s/%s\n", entry->uid, name + name_offset, dirent->d_name);
+		} else if (default_uid != ID_NONE) {
+			entry->uid = default_uid;
+			printf("Meta: default uid (%u) %s/%s\n", entry->uid, name + name_offset, dirent->d_name);
+		}
+
+		if (meta_handle_gid(meta, entry)) {
+			printf("Meta: gid (%u) %s/%s\n", entry->gid, name + name_offset, dirent->d_name);
+		} else if (default_gid != ID_NONE) {
+			entry->gid = default_gid;
+			printf("Meta: default gid (%u) %s/%s\n", entry->gid, name + name_offset, dirent->d_name);
+		}
+
+		/* Link it into the list */
+		*prev = entry;
+		prev = &entry->next;
+		totalsize += size;
+	}
+	free_meta_data(meta);
+	free(path);
+	free(dirlist);		/* allocated by scandir() with malloc() */
+	return totalsize;
+}
+
+/* Returns sizeof(struct cramfs_super), which includes the root inode. */
+static unsigned int write_superblock(struct entry *root, char *base, int size)
+{
+	struct cramfs_super *super = (struct cramfs_super *) base;
+	unsigned int offset = sizeof(struct cramfs_super) + image_length;
+
+	if (opt_pad) {
+		offset += opt_pad;
+	}
+
+	super->magic = CRAMFS_MAGIC;
+	super->flags = CRAMFS_FLAG_FSID_VERSION_2 | CRAMFS_FLAG_SORTED_DIRS;
+	if (opt_holes)
+		super->flags |= CRAMFS_FLAG_HOLES;
+	if (image_length > 0)
+		super->flags |= CRAMFS_FLAG_SHIFTED_ROOT_OFFSET;
+	super->size = size;
+	memcpy(super->signature, CRAMFS_SIGNATURE, sizeof(super->signature));
+
+	super->fsid.crc = crc32(0L, Z_NULL, 0);
+	super->fsid.edition = opt_edition;
+	super->fsid.blocks = total_blocks;
+	super->fsid.files = total_nodes;
+
+	memset(super->name, 0x00, sizeof(super->name));
+	if (opt_name)
+		strncpy(super->name, opt_name, sizeof(super->name));
+	else
+		strncpy(super->name, "Compressed", sizeof(super->name));
+
+	super->root.mode = root->mode;
+	super->root.uid = root->uid;
+	super->root.gid = root->gid;
+	super->root.size = root->size;
+	super->root.offset = offset >> 2;
+
+	return offset;
+}
+
+static void set_data_offset(struct entry *entry, char *base, unsigned long offset)
+{
+	struct cramfs_inode *inode = (struct cramfs_inode *) (base + entry->dir_offset);
+#ifdef DEBUG
+	assert ((offset & 3) == 0);
+#endif /* DEBUG */
+	if (offset >= (1 << (2 + CRAMFS_OFFSET_WIDTH))) {
+		fprintf(stderr, "filesystem too big.  Exiting.\n");
+		exit(8);
+	}
+	inode->offset = (offset >> 2);
+}
+
+
+/*
+ * We do a width-first printout of the directory
+ * entries, using a stack to remember the directories
+ * we've seen.
+ */
+#define MAXENTRIES (100)
+static unsigned int write_directory_structure(struct entry *entry, char *base, unsigned int offset)
+{
+	int stack_entries = 0;
+	struct entry *entry_stack[MAXENTRIES];
+
+	for (;;) {
+		int dir_start = stack_entries;
+		while (entry) {
+			struct cramfs_inode *inode = (struct cramfs_inode *) (base + offset);
+			size_t len = strlen(entry->name);
+
+			entry->dir_offset = offset;
+
+			inode->mode = entry->mode;
+			inode->uid = entry->uid;
+			inode->gid = entry->gid;
+			inode->size = entry->size;
+			inode->offset = 0;
+			/* Non-empty directories, regfiles and symlinks will
+			   write over inode->offset later. */
+
+			offset += sizeof(struct cramfs_inode);
+			total_nodes++;	/* another node */
+			memcpy(base + offset, entry->name, len);
+			/* Pad up the name to a 4-byte boundary */
+			while (len & 3) {
+				*(base + offset + len) = '\0';
+				len++;
+			}
+			inode->namelen = len >> 2;
+			offset += len;
+
+			/* TODO: this may get it wrong for chars >= 0x80.
+			   Most filesystems use UTF8 encoding for filenames,
+			   whereas the console is a single-byte character
+			   set like iso-latin-1. */
+			printf("  %s\n", entry->name);
+			if (entry->child) {
+				if (stack_entries >= MAXENTRIES) {
+					fprintf(stderr, "Exceeded MAXENTRIES.  Raise this value in mkcramfs.c and recompile.  Exiting.\n");
+					exit(8);
+				}
+				entry_stack[stack_entries] = entry;
+				stack_entries++;
+			}
+			entry = entry->next;
+		}
+
+		/*
+		 * Reverse the order the stack entries pushed during
+                 * this directory, for a small optimization of disk
+                 * access in the created fs.  This change makes things
+                 * `ls -UR' order.
+		 */
+		{
+			struct entry **lo = entry_stack + dir_start;
+			struct entry **hi = entry_stack + stack_entries;
+			struct entry *tmp;
+
+			while (lo < --hi) {
+				tmp = *lo;
+				*lo++ = *hi;
+				*hi = tmp;
+			}
+		}
+
+		/* Pop a subdirectory entry from the stack, and recurse. */
+		if (!stack_entries)
+			break;
+		stack_entries--;
+		entry = entry_stack[stack_entries];
+
+		set_data_offset(entry, base, offset);
+		printf("'%s':\n", entry->name);
+		entry = entry->child;
+	}
+	return offset;
+}
+
+static int is_zero(char const *begin, unsigned len)
+{
+	if (opt_holes)
+		/* Returns non-zero iff the first LEN bytes from BEGIN are
+		   all NULs. */
+		return (len-- == 0 ||
+			(begin[0] == '\0' &&
+			 (len-- == 0 ||
+			  (begin[1] == '\0' &&
+			   (len-- == 0 ||
+			    (begin[2] == '\0' &&
+			     (len-- == 0 ||
+			      (begin[3] == '\0' &&
+			       memcmp(begin, begin + 4, len) == 0))))))));
+	else
+		/* Never create holes. */
+		return 0;
+}
+
+/*
+ * One 4-byte pointer per block and then the actual blocked
+ * output. The first block does not need an offset pointer,
+ * as it will start immediately after the pointer block;
+ * so the i'th pointer points to the end of the i'th block
+ * (i.e. the start of the (i+1)'th block or past EOF).
+ *
+ * Note that size > 0, as a zero-sized file wouldn't ever
+ * have gotten here in the first place.
+ */
+static unsigned int do_compress(char *base, unsigned int offset, char const *name, char *uncompressed, unsigned int size)
+{
+	unsigned long original_size = size;
+	unsigned long original_offset = offset;
+	unsigned long new_size;
+	unsigned long blocks = (size - 1) / blksize + 1;
+	unsigned long curr = offset + 4 * blocks;
+	int change;
+
+	total_blocks += blocks;
+
+	do {
+		unsigned long len = 2 * blksize;
+		unsigned int input = size;
+		if (input > blksize)
+			input = blksize;
+		size -= input;
+		if (!is_zero (uncompressed, input)) {
+			compress(base + curr, &len, uncompressed, input);
+			curr += len;
+		}
+		uncompressed += input;
+
+		if (len > blksize*2) {
+			/* (I don't think this can happen with zlib.) */
+			printf("AIEEE: block \"compressed\" to > 2*blocklength (%ld)\n", len);
+			exit(8);
+		}
+
+		*(u32 *) (base + offset) = curr;
+		offset += 4;
+	} while (size);
+
+	curr = (curr + 3) & ~3;
+	new_size = curr - original_offset;
+	/* TODO: Arguably, original_size in these 2 lines should be
+	   st_blocks * 512.  But if you say that then perhaps
+	   administrative data should also be included in both. */
+	change = new_size - original_size;
+	printf("%6.2f%% (%+d bytes)\t%s\n",
+	       (change * 100) / (double) original_size, change, name);
+
+	return curr;
+}
+
+
+/*
+ * Traverse the entry tree, writing data for every item that has
+ * non-null entry->compressed (i.e. every symlink and non-empty
+ * regfile).
+ */
+static unsigned int write_data(struct entry *entry, char *base, unsigned int offset)
+{
+	do {
+		if (entry->uncompressed) {
+                        if(entry->same) {
+                                set_data_offset(entry, base, entry->same->offset);
+                                entry->offset=entry->same->offset;
+                        } else {
+                                set_data_offset(entry, base, offset);
+                                entry->offset=offset;
+                                offset = do_compress(base, offset, entry->name, entry->uncompressed, entry->size);
+                        }
+		}
+		else if (entry->child)
+			offset = write_data(entry->child, base, offset);
+                entry=entry->next;
+	} while (entry);
+	return offset;
+}
+
+static unsigned int write_file(char *file, char *base, unsigned int offset)
+{
+	int fd;
+	char *buf;
+
+	fd = open(file, O_RDONLY);
+	if (fd < 0) {
+		perror(file);
+		exit(8);
+	}
+	buf = mmap(NULL, image_length, PROT_READ, MAP_PRIVATE, fd, 0);
+	memcpy(base + offset, buf, image_length);
+	munmap(buf, image_length);
+	close (fd);
+	/* Pad up the image_length to a 4-byte boundary */
+	while (image_length & 3) {
+		*(base + offset + image_length) = '\0';
+		image_length++;
+	}
+	return (offset + image_length);
+}
+
+/*
+ * Maximum size fs you can create is roughly 256MB.  (The last file's
+ * data must begin within 256MB boundary but can extend beyond that.)
+ *
+ * Note that if you want it to fit in a ROM then you're limited to what the
+ * hardware and kernel can support (64MB?).
+ */
+#define MAXFSLEN ((((1 << CRAMFS_OFFSET_WIDTH) - 1) << 2) /* offset */ \
+		  + (1 << CRAMFS_SIZE_WIDTH) - 1 /* filesize */ \
+		  + (1 << CRAMFS_SIZE_WIDTH) * 4 / blksize /* block pointers */ )
+
+
+/*
+ * Usage:
+ *
+ *      mkcramfs [options] directory output-file
+ *
+ * where "directory-name" is simply the root of the directory
+ * tree that we want to generate a compressed filesystem out
+ * of.
+ *
+ * Options can currently be -b XXX where XXX is the blocksize to use and
+ * -m filename, where filename is the name of meta files to be used.
+ * This allows the building of filesystems on one host to be used on another
+ * with a different blocksize (just beware that endianess needs to be the same).
+ */
+int main(int argc, char **argv)
+{
+	struct stat st;		/* used twice... */
+	struct entry *root_entry;
+	char *rom_image;
+	ssize_t offset, written;
+	int fd;
+	/* initial guess (upper-bound) of required filesystem size */
+	loff_t fslen_ub = sizeof(struct cramfs_super);
+	char const *dirname, *outfile;
+	u32 crc = crc32(0L, Z_NULL, 0);
+	int c;			/* for getopt */
+
+	total_blocks = 0;
+
+	if (argc)
+		progname = argv[0];
+
+	/* command line options */
+	while ((c = getopt(argc, argv, "hEe:i:b:m:n:psz")) != EOF) {
+		switch (c) {
+		case 'h':
+			usage(0);
+		case 'E':
+			opt_errors = 1;
+			break;
+		case 'e':
+			opt_edition = atoi(optarg);
+			break;
+		case 'i':
+			opt_image = optarg;
+			if (lstat(opt_image, &st) < 0) {
+				perror(opt_image);
+				exit(16);
+			}
+			image_length = st.st_size; /* may be padded later */
+			fslen_ub += (image_length + 3); /* 3 is for padding */
+			break;
+		case 'b':
+			blksize = atoi(optarg);
+			if (blksize <= 0) {
+				fprintf(stderr, "%s: wrong block size\n",
+					progname);
+				usage(0);
+			}
+			break;
+		case 'm':
+			meta_file_name = optarg;
+			break;
+		case 'n':
+			opt_name = optarg;
+			break;
+		case 'p':
+			opt_pad = PAD_SIZE;
+			fslen_ub += PAD_SIZE;
+			break;
+		case 's':
+			/* old option, ignored */
+			break;
+		case 'z':
+			opt_holes = 1;
+			break;
+		}
+	}
+
+	if ((argc - optind) != 2)
+		usage(16);
+	dirname = argv[optind];
+	outfile = argv[optind + 1];
+
+	printf("Using a blocksize of %d bytes.\n", blksize);
+	if (meta_file_name)
+		printf("Using meta file(s) named \"%s\".\n", meta_file_name);
+
+	if (stat(dirname, &st) < 0) {
+		perror(dirname);
+		exit(16);
+	}
+	fd = open(outfile, O_WRONLY | O_CREAT | O_TRUNC, 0666);
+
+	root_entry = calloc(1, sizeof(struct entry));
+	if (!root_entry) {
+		perror(NULL);
+		exit(8);
+	}
+	root_entry->mode = st.st_mode;
+	root_entry->uid = st.st_uid;
+	root_entry->gid = st.st_gid;
+
+	name_offset = strlen(dirname);
+	root_entry->size = parse_directory(root_entry, dirname, &root_entry->child, &fslen_ub, 0, ID_NONE, ID_NONE);
+
+	/* always allocate a multiple of blksize bytes because that's
+           what we're going to write later on */
+	fslen_ub = ((fslen_ub - 1) | (blksize - 1)) + 1;
+
+	if (fslen_ub > MAXFSLEN) {
+		fprintf(stderr,
+			"warning: guestimate of required size (upper bound) is %LdMB, but maximum image size is %uMB.  We might die prematurely.\n",
+			fslen_ub >> 20,
+			MAXFSLEN >> 20);
+		fslen_ub = MAXFSLEN;
+	}
+
+        /* find duplicate files. TODO: uses the most inefficient algorithm
+           possible. */
+        eliminate_doubles(root_entry,root_entry);
+
+	/* TODO: Why do we use a private/anonymous mapping here
+           followed by a write below, instead of just a shared mapping
+           and a couple of ftruncate calls?  Is it just to save us
+           having to deal with removing the file afterwards?  If we
+           really need this huge anonymous mapping, we ought to mmap
+           in smaller chunks, so that the user doesn't need nn MB of
+           RAM free.  If the reason is to be able to write to
+           un-mmappable block devices, then we could try shared mmap
+           and revert to anonymous mmap if the shared mmap fails. */
+	rom_image = mmap(NULL, fslen_ub?fslen_ub:1, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+
+	if (-1 == (int) (long) rom_image) {
+		perror("ROM image map");
+		exit(8);
+	}
+
+	/* Skip the first opt_pad bytes for boot loader code */
+	offset = opt_pad;
+	memset(rom_image, 0x00, opt_pad);
+
+	/* Skip the superblock and come back to write it later. */
+	offset += sizeof(struct cramfs_super);
+
+	/* Insert a file image. */
+	if (opt_image) {
+		printf("Including: %s\n", opt_image);
+		offset = write_file(opt_image, rom_image, offset);
+	}
+
+	offset = write_directory_structure(root_entry->child, rom_image, offset);
+	printf("Directory data: %d bytes\n", offset);
+
+	offset = write_data(root_entry, rom_image, offset);
+
+	/* We always write a multiple of blksize bytes, so that
+           losetup works. */
+	offset = ((offset - 1) | (blksize - 1)) + 1;
+	printf("Everything: %d kilobytes\n", offset >> 10);
+
+	/* Write the superblock now that we can fill in all of the fields. */
+	write_superblock(root_entry, rom_image+opt_pad, offset);
+	printf("Super block: %d bytes\n", sizeof(struct cramfs_super));
+
+	/* Put the checksum in. */
+	crc = crc32(crc, (rom_image+opt_pad), (offset-opt_pad));
+	((struct cramfs_super *) (rom_image+opt_pad))->fsid.crc = crc;
+	printf("CRC: %x\n", crc);
+
+	/* Check to make sure we allocated enough space. */
+	if (fslen_ub < offset) {
+		fprintf(stderr, "not enough space allocated for ROM image (%Ld allocated, %d used)\n",
+			fslen_ub, offset);
+		exit(8);
+	}
+
+	written = write(fd, rom_image, offset);
+	if (written < 0) {
+		perror("ROM image");
+		exit(8);
+	}
+	if (offset != written) {
+		fprintf(stderr, "ROM image write failed (%d %d)\n", written, offset);
+		exit(8);
+	}
+
+	/* (These warnings used to come at the start, but they scroll off the
+           screen too quickly.) */
+	if (warn_namelen) /* (can't happen when reading from ext2fs) */
+		fprintf(stderr, /* bytes, not chars: think UTF8. */
+			"warning: filenames truncated to 255 bytes.\n");
+	if (warn_skip)
+		fprintf(stderr, "warning: files were skipped due to errors.\n");
+	if (warn_size)
+		fprintf(stderr,
+			"warning: file sizes truncated to %luMB (minus 1 byte).\n",
+			1L << (CRAMFS_SIZE_WIDTH - 20));
+	if (warn_uid) /* (not possible with current Linux versions) */
+		fprintf(stderr,
+			"warning: uids truncated to %u bits.  (This may be a security concern.)\n",
+			CRAMFS_UID_WIDTH);
+	if (warn_gid)
+		fprintf(stderr,
+			"warning: gids truncated to %u bits.  (This may be a security concern.)\n",
+			CRAMFS_GID_WIDTH);
+	if (warn_dev)
+		fprintf(stderr,
+			"WARNING: device numbers truncated to %u bits.  This almost certainly means\n"
+			"that some device files will be wrong.\n",
+			CRAMFS_OFFSET_WIDTH);
+	if (opt_errors &&
+	    (warn_namelen||warn_skip||warn_size||warn_uid||warn_gid||warn_dev))
+		exit(8);
+	return 0;
+}
diff -Nur /home/starvik/download/kernel/linux-2.4.19/scripts/kernel-doc ./scripts/kernel-doc
--- /home/starvik/download/kernel/linux-2.4.19/scripts/kernel-doc	Sat Aug  3 02:39:46 2002
+++ ./scripts/kernel-doc	Wed Oct 23 12:29:00 2002
@@ -233,17 +233,9 @@
 # CAVEAT EMPTOR!  Some of the others I localised may not want to be which
 # could cause "use of undefined value" or other bugs.
 my ($function, %function_table,%parametertypes,$declaration_purpose);
-my ($type,$declaration_name,$return_type);
+my ($type,$file,$declaration_name,$return_type);
 my ($newsection,$newcontents,$prototype,$filelist, $brcount, %source_map);
 
-# Generated docbook code is inserted in a template at a point where 
-# docbook v3.1 requires a non-zero sequence of RefEntry's; see:
-# http://www.oasis-open.org/docbook/documentation/reference/html/refentry.html
-# We keep track of number of generated entries and generate a dummy
-# if needs be to ensure the expanded template can be postprocessed
-# into html.
-my $section_counter = 0;
-
 my $lineprefix="";
 
 # states
@@ -1166,7 +1158,6 @@
 	( $function_only == 2 && !defined($function_table{$name})))
     {
         &$func(@_);
-	$section_counter++;
     }
 }
 
@@ -1177,7 +1168,6 @@
     no strict 'refs';
     my $func = "output_intro_".$output_mode;
     &$func(@_);
-    $section_counter++;
 }
 
 ##
@@ -1205,7 +1195,7 @@
 	# ignore embedded structs or unions
 	$members =~ s/{.*}//g;
 
-	create_parameterlist($members, ';', $file);
+	create_parameterlist($members, ';');
 
 	output_declaration($declaration_name,
 			   'struct',
@@ -1221,8 +1211,7 @@
 			   });
     }
     else {
-        print STDERR "Error(${file}:$.): Cannot parse struct or union!\n";
-	++$errors;
+        print STDERR "Cannot parse struct or union!\n";
     }
 }
 
@@ -1239,8 +1228,8 @@
 	    push @parameterlist, $arg;
 	    if (!$parameterdescs{$arg}) {
 	        $parameterdescs{$arg} = $undescribed;
-	        print STDERR "Warning(${file}:$.): Enum value '$arg' ".
-		    "not described in enum '$declaration_name'\n";
+	        print STDERR "Warning($file:$.): Enum value '$arg' ".
+		    "described in enum '$declaration_name'\n";
 	    }
 
 	}
@@ -1257,8 +1246,7 @@
 			   });
     }
     else {
-        print STDERR "Error(${file}:$.): Cannot parse enum!\n";
-	++$errors;
+        print STDERR "Cannot parse enum!\n";
     }
 }
 
@@ -1284,15 +1272,13 @@
 			   });
     }
     else {
-        print STDERR "Error(${file}:$.): Cannot parse typedef!\n";
-	++$errors;
+        print STDERR "Cannot parse typedef!\n";
     }
 }
 
-sub create_parameterlist($$$) {
+sub create_parameterlist($$) {
     my $args = shift;
     my $splitter = shift;
-    my $file = shift;
     my $type;
     my $param;
 
@@ -1346,7 +1332,7 @@
 	    $parameterdescs{$param} = $undescribed;
 
 	    if (($type eq 'function') || ($type eq 'enum')) {
-	        print STDERR "Warning(${file}:$.): Function parameter ".
+	        print STDERR "Warning($file:$.): Function parameter ".
 		    "or member '$param' not " .
 		    "described in '$declaration_name'\n";
 	    }
@@ -1406,9 +1392,9 @@
 	$declaration_name = $2;
 	my $args = $3;
 
-	create_parameterlist($args, ',', $file);
+	create_parameterlist($args, ',');
     } else {
-	print STDERR "Error(${file}:$.): cannot understand prototype: '$prototype'\n";
+	print STDERR "Error($.): cannot understand prototype: '$prototype'\n";
 	++$errors;
 	return;
     }
@@ -1470,9 +1456,8 @@
     $state = 0;
 }
 
-sub process_state3_function($$) { 
+sub process_state3_function($) { 
     my $x = shift;
-    my $file = shift;
 
     if ($x =~ m#\s*/\*\s+MACDOC\s*#io) {
 	# do nothing
@@ -1489,9 +1474,8 @@
     }
 }
 
-sub process_state3_type($$) { 
+sub process_state3_type($) { 
     my $x = shift;
-    my $file = shift;
 
     $x =~ s@/\*.*?\*/@@gos;	# strip comments.
     $x =~ s@[\r\n]+@ @gos; # strip newlines/cr's.
@@ -1520,7 +1504,6 @@
     my ($file) = @_;
     my $identifier;
     my $func;
-    my $initial_section_counter = $section_counter;
 
     if (defined($source_map{$file})) {
 	$file = $source_map{$file};
@@ -1532,7 +1515,6 @@
 	return;
     }
 
-    $section_counter = 0;
     while (<IN>) {
 	if ($state == 0) {
 	    if (/$doc_start/o) {
@@ -1573,10 +1555,10 @@
 		}
 
 		if ($verbose) {
-		    print STDERR "Info(${file}:$.): Scanning doc for $identifier\n";
+		    print STDERR "Info($.): Scanning doc for $identifier\n";
 		}
 	    } else {
-		print STDERR "Warning(${file}:$.): Cannot understand $_ on line $.",
+		print STDERR "WARN($.): Cannot understand $_ on line $.",
 		" - I thought it was a doc line\n";
 		++$errors;
 		$state = 0;
@@ -1630,14 +1612,14 @@
 		}
 	    } else {
 		# i dont know - bad line?  ignore.
-		print STDERR "Warning(${file}:$.): bad line: $_"; 
+		print STDERR "WARNING($.): bad line: $_"; 
 		++$errors;
 	    }
 	} elsif ($state == 3) {	# scanning for function { (end of prototype)
 	    if ($decl_type eq 'function') {
-	        process_state3_function($_, $file);
+	        process_state3_function($_);
 	    } else {
-	        process_state3_type($_, $file);
+	        process_state3_type($_);
 	    }
 	} elsif ($state == 4) {
 		# Documentation block
@@ -1689,35 +1671,5 @@
         	}
           }
     }
-    if ($initial_section_counter == $section_counter) {
-	print STDERR "Warning(${file}): no structured comments found\n";
-	if ($output_mode eq "sgml") {
-	    # The template wants at least one RefEntry here; make one.
-	    print "<refentry>\n";
-	    print " <refnamediv>\n";
-	    print "  <refname>\n";
-	    print "   ${file}\n";
-	    print "  </refname>\n";
-	    print "  <refpurpose>\n";
-	    print "   Document generation inconsistency\n";
-	    print "  </refpurpose>\n";
-	    print " </refnamediv>\n";
-	    print " <refsect1>\n";
-	    print "  <title>\n";
-	    print "   Oops\n";
-	    print "  </title>\n";
-	    print "  <warning>\n";
-	    print "   <para>\n";
-	    print "    The template for this document tried to insert\n";
-	    print "    the structured comment from the file\n";
-	    print "    <filename>${file}</filename> at this point,\n";
-	    print "    but none was found.\n";
-	    print "    This dummy section is inserted to allow\n";
-	    print "    generation to continue.\n";
-	    print "   </para>\n";
-	    print "  </warning>\n";
-	    print " </refsect1>\n";
-	    print "</refentry>\n";
-	}
-    }
 }
+
diff -Nur /home/starvik/download/kernel/linux-2.4.19/scripts/mkdep.c ./scripts/mkdep.c
--- /home/starvik/download/kernel/linux-2.4.19/scripts/mkdep.c	Sat Aug  3 02:39:46 2002
+++ ./scripts/mkdep.c	Wed Oct 23 12:29:00 2002
@@ -268,7 +268,7 @@
 
 	for (i = 0; i < len; i++) {
 	    char c = name[i];
-	    if (isupper((int)c)) c = tolower((int)c);
+	    if (isupper(c)) c = tolower(c);
 	    if (c == '_')   c = '/';
 	    pc[i] = c;
 	}
@@ -496,7 +496,7 @@
 
 /* \<CONFIG_(\w*) */
 cee:
-	if (next >= map+2 && (isalnum((int)next[-2]) || next[-2] == '_'))
+	if (next >= map+2 && (isalnum(next[-2]) || next[-2] == '_'))
 		goto start;
 	GETNEXT NOTCASE('O', __start);
 	GETNEXT NOTCASE('N', __start);
diff -Nur /home/starvik/download/kernel/linux-2.4.19/scripts/patch-kernel ./scripts/patch-kernel
--- /home/starvik/download/kernel/linux-2.4.19/scripts/patch-kernel	Sat Aug  3 02:39:46 2002
+++ ./scripts/patch-kernel	Wed Oct 23 12:29:00 2002
@@ -68,7 +68,7 @@
 # ---------------------------------------------------------------------------
 # Find a file, first parameter is basename of file
 # it tries many compression mechanisms and sets variables to say how to get it
-findFile () {
+function findFile {
   filebase=$1;
 
   if [ -r ${filebase}.gz ]; then
@@ -106,7 +106,7 @@
 # Apply a patch and check it goes in cleanly
 # First param is patch name (e.g. patch-2.4.9-ac5) - without path or extension
 
-applyPatch () {
+function applyPatch {
   echo -n "Applying $1 (${name})... "
   if $uncomp ${patchdir}/$1${ext} | patch -p1 -s -N -E -d $sourcedir
   then
diff -Nur /home/starvik/download/kernel/linux-2.4.19/scripts/split-include.c ./scripts/split-include.c
--- /home/starvik/download/kernel/linux-2.4.19/scripts/split-include.c	Sat Aug  3 02:39:46 2002
+++ ./scripts/split-include.c	Wed Oct 23 12:29:00 2002
@@ -115,10 +115,10 @@
 
 	/* Make the output file name. */
 	str_config += sizeof("CONFIG_") - 1;
-	for (itarget = 0; !isspace((int)str_config[itarget]); itarget++)
+	for (itarget = 0; !isspace(str_config[itarget]); itarget++)
 	{
 	    char c = str_config[itarget];
-	    if (isupper((int)c)) c = tolower((int)c);
+	    if (isupper(c)) c = tolower(c);
 	    if (c == '_')   c = '/';
 	    ptarget[itarget] = c;
 	}
diff -Nur /home/starvik/download/kernel/linux-2.4.19/scripts/tkparse.c ./scripts/tkparse.c
--- /home/starvik/download/kernel/linux-2.4.19/scripts/tkparse.c	Sat Aug  3 02:39:46 2002
+++ ./scripts/tkparse.c	Wed Oct 23 12:29:00 2002
@@ -74,12 +74,12 @@
 
 
 /*
- * Find index of a specific variable in the symbol table.
+ * Find index of a specyfic variable in the symbol table.
  * Create a new entry if it does not exist yet.
  */
-struct variable *vartable;
+#define VARTABLE_SIZE 2048
+struct variable vartable[VARTABLE_SIZE];
 int max_varnum = 0;
-static int vartable_size = 0;
 
 int get_varnum( char * name )
 {
@@ -88,13 +88,8 @@
     for ( i = 1; i <= max_varnum; i++ )
 	if ( strcmp( vartable[i].name, name ) == 0 )
 	    return i;
-    while (max_varnum+1 >= vartable_size) {
-	vartable = realloc(vartable, (vartable_size += 1000)*sizeof(*vartable));
-	if (!vartable) {
-	    fprintf(stderr, "tkparse realloc vartable failed\n");
-	    exit(1);
-	}
-    }
+    if (max_varnum > VARTABLE_SIZE-1)
+	syntax_error( "Too many variables defined." );
     vartable[++max_varnum].name = malloc( strlen( name )+1 );
     strcpy( vartable[max_varnum].name, name );
     return max_varnum;
@@ -823,6 +818,5 @@
     do_source        ( "-"         );
     fix_conditionals ( config_list );
     dump_tk_script   ( config_list );
-    free(vartable);
     return 0;
 }
diff -Nur /home/starvik/download/kernel/linux-2.4.19/scripts/tkparse.h ./scripts/tkparse.h
--- /home/starvik/download/kernel/linux-2.4.19/scripts/tkparse.h	Sat Aug  3 02:39:46 2002
+++ ./scripts/tkparse.h	Wed Oct 23 12:29:00 2002
@@ -115,7 +115,7 @@
     char	global_written;
 };
 
-extern struct variable *vartable;
+extern struct variable vartable[];
 extern int max_varnum;
 
 /*
