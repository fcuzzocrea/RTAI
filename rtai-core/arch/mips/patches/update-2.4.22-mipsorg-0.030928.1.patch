diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/au1000/common/pci_ops.c linux-2.4.22/arch/mips/au1000/common/pci_ops.c
--- linux-2.4.22.clean/arch/mips/au1000/common/pci_ops.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/au1000/common/pci_ops.c	2003-09-27 14:07:03.000000000 +0200
@@ -6,7 +6,8 @@
  * Author: MontaVista Software, Inc.
  *         	ppopov@mvista.com or source@mvista.com
  *
- *  Support for all devices (greater than 16) added by David Gathright.
+ *  - Support for all devices (greater than 16) added by David Gathright.
+ *  - Wired tlb fix for ioremap calls in interrupt routines by Embedded Edge.
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -36,6 +37,7 @@
 #include <linux/pci.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/vmalloc.h>
 
 #include <asm/au1000.h>
 #ifdef CONFIG_MIPS_PB1000
@@ -53,6 +55,8 @@
 #define	DBG(x...)	
 #endif
 
+int (*board_pci_idsel)(unsigned int devsel, int assert);
+
 /* TBD */
 static struct resource pci_io_resource = {
 	"pci IO space", 
@@ -120,6 +124,41 @@
 
 #else
 
+
+/* CP0 hazard avoidance. */
+#define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
+				     "nop; nop; nop; nop;\t" \
+				     ".set reorder\n\t")
+
+void mod_wired_entry(int entry, unsigned long entrylo0, 
+		unsigned long entrylo1, unsigned long entryhi, 
+		unsigned long pagemask)
+{
+	unsigned long old_pagemask;
+	unsigned long old_ctx;
+
+	/* Save old context and create impossible VPN2 value */
+	old_ctx = read_c0_entryhi() & 0xff;
+	old_pagemask = read_c0_pagemask();
+	write_c0_index(entry);
+	BARRIER;
+	write_c0_pagemask(pagemask);
+	write_c0_entryhi(entryhi);
+	write_c0_entrylo0(entrylo0);
+	write_c0_entrylo1(entrylo1);
+	BARRIER;
+	tlb_write_indexed();
+	BARRIER;
+	write_c0_entryhi(old_ctx);
+	BARRIER;
+	write_c0_pagemask(old_pagemask);
+}
+
+struct vm_struct *pci_cfg_vm;
+static int pci_cfg_wired_entry;
+static int first_cfg = 1;
+unsigned long last_entryLo0, last_entryLo1;
+
 static int config_access(unsigned char access_type, struct pci_dev *dev, 
 			 unsigned char where, u32 * data)
 {
@@ -128,68 +167,107 @@
 	unsigned int dev_fn = dev->devfn;
 	unsigned int device = PCI_SLOT(dev_fn);
 	unsigned int function = PCI_FUNC(dev_fn);
-	unsigned long config, status;
-        unsigned long cfg_addr;
+	unsigned long offset, status;
+	unsigned long cfg_base;
+	unsigned long flags;
+	int error = PCIBIOS_SUCCESSFUL;
+	unsigned long entryLo0, entryLo1;
 
 	if (device > 19) {
 		*data = 0xffffffff;
 		return -1;
 	}
 
+	local_irq_save(flags);
 	au_writel(((0x2000 << 16) | (au_readl(Au1500_PCI_STATCMD) & 0xffff)), 
 			Au1500_PCI_STATCMD);
-	//au_writel(au_readl(Au1500_PCI_CFG) & ~PCI_ERROR, Au1500_PCI_CFG);
 	au_sync_udelay(1);
 
+	/*
+	 * We can't ioremap the entire pci config space because it's 
+	 * too large. Nor can we call ioremap dynamically because some 
+	 * device drivers use the pci config routines from within 
+	 * interrupt handlers and that becomes a problem in get_vm_area().
+	 * We use one wired tlb to handle all config accesses for all 
+	 * busses. To improve performance, if the current device
+	 * is the same as the last device accessed, we don't touch the
+	 * tlb.
+	 */
+	if (first_cfg) {
+		/* reserve a wired entry for pci config accesses */
+		first_cfg = 0;
+		pci_cfg_vm = get_vm_area(0x1000, 0);
+		if (!pci_cfg_vm) 
+			panic (KERN_ERR "PCI unable to get vm area\n");
+		pci_cfg_wired_entry = read_c0_wired();
+		add_wired_entry(0, 0, (unsigned long)pci_cfg_vm->addr, 
+				PM_4K);
+		last_entryLo0  = last_entryLo1 = 0xffffffff;
+	}
+
+	/* Since the Au1xxx doesn't do the idsel timing exactly to spec,
+	 * many board vendors implement their own off-chip idsel, so call
+	 * it now.  If it doesn't succeed, may as well bail out at this point.
+	 */
+	if (board_pci_idsel) {
+		if (board_pci_idsel(device, 1) == 0) {
+			*data = 0xffffffff;
+			local_irq_restore(flags);
+			return -1;
+		}
+	}
+
         /* setup the config window */
         if (bus == 0) {
-                cfg_addr = ioremap( Au1500_EXT_CFG | ((1<<device)<<11) , 
-				0x00100000);
+                cfg_base = ((1<<device)<<11);
         } else {
-                cfg_addr = ioremap( Au1500_EXT_CFG_TYPE1 | (bus<<16) | 
-				(device<<11), 0x00100000);
+                cfg_base = 0x80000000 | (bus<<16) | (device<<11);
         }
-
-        if (!cfg_addr)
-                panic (KERN_ERR "PCI unable to ioremap cfg space\n");
+	cfg_base &= ~0xfff;
 
         /* setup the lower bits of the 36 bit address */
-        config = cfg_addr | (function << 8) | (where & ~0x3);
+        offset = (function << 8) | (where & ~0x3);
 
-#if 0
-	printk("cfg access: config %x, dev_fn %x, device %x function %x\n",
-			config, dev_fn, device, function);
-#endif
+	entryLo0 = (6 << 26)  | (cfg_base >> 6) | (2 << 3) | 7;
+	entryLo1 = (6 << 26)  | (cfg_base >> 6) | (0x1000 >> 6) | (2 << 3) | 7;
+
+	if ((entryLo0 != last_entryLo0) || (entryLo1 != last_entryLo1)) {
+		mod_wired_entry(pci_cfg_wired_entry, entryLo0, entryLo1, 
+				(unsigned long)pci_cfg_vm->addr, PM_4K);
+		last_entryLo0 = entryLo0;
+		last_entryLo1 = entryLo1;
+	}
 
 	if (access_type == PCI_ACCESS_WRITE) {
-		au_writel(*data, config);
+		au_writel(*data, (int)(pci_cfg_vm->addr + offset));
 	} else {
-		*data = au_readl(config);
+		*data = au_readl((int)(pci_cfg_vm->addr + offset));
 	}
 	au_sync_udelay(2);
 
-
 	DBG("config_access: %d bus %d device %d at %x *data %x, conf %x\n", 
-			access_type, bus, device, where, *data, config);
-
-        /* unmap io space */
-        iounmap( cfg_addr );
+			access_type, bus, device, where, *data, offset);
 
 	/* check master abort */
 	status = au_readl(Au1500_PCI_STATCMD);
-#if 0
-printk("cfg access: status %x, data %x\n", status, *data );
-#endif
+
 	if (status & (1<<29)) { 
 		*data = 0xffffffff;
-		return -1;
+		error = -1;
 	} else if ((status >> 28) & 0xf) {
 		DBG("PCI ERR detected: status %x\n", status);
 		*data = 0xffffffff;
-		return -1;
-	} else {
-		return PCIBIOS_SUCCESSFUL;
+		error = -1;
+	} 
+	
+	/* Take away the idsel.
+	*/
+	if (board_pci_idsel) {
+		(void)board_pci_idsel(device, 0);
 	}
+
+	local_irq_restore(flags);
+	return error;
 #endif
 }
 #endif
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/au1000/common/power.c linux-2.4.22/arch/mips/au1000/common/power.c
--- linux-2.4.22.clean/arch/mips/au1000/common/power.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/au1000/common/power.c	2003-09-27 14:07:03.000000000 +0200
@@ -34,7 +34,6 @@
 #include <linux/pm.h>
 #include <linux/slab.h>
 #include <linux/sysctl.h>
-#include <linux/acpi.h>
 
 #include <asm/string.h>
 #include <asm/uaccess.h>
@@ -52,10 +51,10 @@
 extern void au1k_wait(void);
 static void calibrate_delay(void);
 
-extern void set_au1000_speed(unsigned int new_freq);
-extern unsigned int get_au1000_speed(void);
-extern unsigned long get_au1000_uart_baud_base(void);
-extern void set_au1000_uart_baud_base(unsigned long new_baud_base);
+extern void set_au1x00_speed(unsigned int new_freq);
+extern unsigned int get_au1x00_speed(void);
+extern unsigned long get_au1x00_uart_baud_base(void);
+extern void set_au1x00_uart_baud_base(unsigned long new_baud_base);
 extern unsigned long save_local_and_disable(int controller);
 extern void restore_local_and_enable(int controller, unsigned long mask);
 extern void local_enable_irq(unsigned int irq_nr);
@@ -188,13 +187,13 @@
 			return -EFAULT;
 		}
 
-		old_baud_base = get_au1000_uart_baud_base();
-		old_cpu_freq = get_au1000_speed();
+		old_baud_base = get_au1x00_uart_baud_base();
+		old_cpu_freq = get_au1x00_speed();
 
 		new_cpu_freq = pll * 12 * 1000000;
 		new_baud_base = (new_cpu_freq / 4) / 16;
-		set_au1000_speed(new_cpu_freq);
-		set_au1000_uart_baud_base(new_baud_base);
+		set_au1x00_speed(new_cpu_freq);
+		set_au1x00_uart_baud_base(new_baud_base);
 
 		old_refresh = au_readl(MEM_SDREFCFG) & 0x1ffffff;
 		new_refresh =
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/au1000/common/setup.c linux-2.4.22/arch/mips/au1000/common/setup.c
--- linux-2.4.22.clean/arch/mips/au1000/common/setup.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/au1000/common/setup.c	2003-09-27 14:07:03.000000000 +0200
@@ -44,6 +44,7 @@
 #include <asm/reboot.h>
 #include <asm/pgtable.h>
 #include <asm/au1000.h>
+#include <asm/time.h>
 
 #if defined(CONFIG_AU1X00_SERIAL_CONSOLE)
 extern void console_setup(char *, int *);
@@ -72,6 +73,8 @@
 extern phys_t (*fixup_bigphys_addr)(phys_t phys_addr, phys_t size);
 static phys_t au1500_fixup_bigphys_addr(phys_t phys_addr, phys_t size);
 #endif
+extern void au1xxx_time_init(void);
+extern void au1xxx_timer_setup(void);
 
 void __init au1x00_setup(void)
 {
@@ -126,6 +129,9 @@
 	fixup_bigphys_addr = au1500_fixup_bigphys_addr;
 #endif
 
+	board_time_init = au1xxx_time_init;
+	board_timer_setup = au1xxx_timer_setup;
+
 	// IO/MEM resources. 
 	set_io_port_base(0);
 	ioport_resource.start = IOPORT_RESOURCE_START;
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/au1000/common/time.c linux-2.4.22/arch/mips/au1000/common/time.c
--- linux-2.4.22.clean/arch/mips/au1000/common/time.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/au1000/common/time.c	2003-09-27 14:07:03.000000000 +0200
@@ -25,6 +25,11 @@
  *
  * Setting up the clock on the MIPS boards.
  *
+ * Update.  Always configure the kernel with CONFIG_NEW_TIME_C.  This
+ * will use the user interface gettimeofday() functions from the
+ * arch/mips/kernel/time.c, and we provide the clock interrupt processing
+ * and the timer offset compute functions.  If CONFIG_PM is selected,
+ * we also ensure the 32KHz timer is available.   -- Dan
  */
 
 #include <linux/types.h>
@@ -44,6 +49,10 @@
 #include <linux/mc146818rtc.h>
 #include <linux/timex.h>
 
+#if !defined(CONFIG_NEW_TIME_C)
+#error "Alchemy processors need CONFIG_NEW_TIME_C defined"
+#endif
+
 extern void startup_match20_interrupt(void);
 extern void do_softirq(void);
 extern volatile unsigned long wall_jiffies;
@@ -52,7 +61,8 @@
 static unsigned long r4k_offset; /* Amount to increment compare reg each time */
 static unsigned long r4k_cur;    /* What counter should be at next timer irq */
 extern rwlock_t xtime_lock;
-unsigned int mips_counter_frequency = 0;
+int	no_au1xxx_32khz;
+void	(*au1k_wait_ptr)(void);
 
 /* Cycle counter value at the previous timer interrupt.. */
 static unsigned int timerhi = 0, timerlo = 0;
@@ -160,6 +170,57 @@
 		do_timer(regs); /* increment jiffies by one */
 	}
 }
+
+/* When we wakeup from sleep, we have to "catch up" on all of the
+ * timer ticks we have missed.
+ */
+void
+wakeup_counter0_adjust(void)
+{
+	unsigned long pc0;
+	int time_elapsed;
+
+	pc0 = au_readl(SYS_TOYREAD);
+	if (pc0 < last_match20) {
+		/* counter overflowed */
+		time_elapsed = (0xffffffff - last_match20) + pc0;
+	}
+	else {
+		time_elapsed = pc0 - last_match20;
+	}
+
+	while (time_elapsed > 0) {
+		time_elapsed -= MATCH20_INC;
+		last_match20 += MATCH20_INC;
+	}
+
+	last_pc0 = pc0;
+	au_writel(last_match20 + MATCH20_INC, SYS_TOYMATCH2);
+	au_sync();
+
+}
+
+/* This is just for debugging to set the timer for a sleep delay.
+*/
+void
+wakeup_counter0_set(int ticks)
+{
+	unsigned long pc0;
+
+	pc0 = au_readl(SYS_TOYREAD);
+	last_pc0 = pc0;
+	au_writel(last_match20 + (MATCH20_INC * ticks), SYS_TOYMATCH2);
+	au_sync();
+}
+#endif
+
+/* I haven't found anyone that doesn't use a 12 MHz source clock,
+ * but just in case.....
+ */
+#ifdef CONFIG_AU1000_SRC_CLK
+#define AU1000_SRC_CLK	CONFIG_AU1000_SRC_CLK
+#else
+#define AU1000_SRC_CLK	12
 #endif
 
 /*
@@ -171,104 +232,72 @@
 {
 	unsigned long count;
 	unsigned long cpu_speed;
-	unsigned long start, end;
-	unsigned long counter;
-	int trim_divide = 16;
 	unsigned long flags;
 
 	spin_lock_irqsave(&time_lock, flags);
-
+#ifdef CONFIG_AU1000_USE32K
 	counter = au_readl(SYS_COUNTER_CNTRL);
-	au_writel(counter | SYS_CNTRL_EN1, SYS_COUNTER_CNTRL);
-
-	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_T1S);
-	au_writel(trim_divide-1, SYS_RTCTRIM); /* RTC now ticks at 32.768/16 kHz */
-	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_T1S);
-
-	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C1S);
-	au_writel (0, SYS_TOYWRITE);
-	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C1S);
-
-	start = au_readl(SYS_RTCREAD);
-	start += 2;
-	/* wait for the beginning of a new tick */
-	while (au_readl(SYS_RTCREAD) < start);
-
-	/* Start r4k counter. */
-	write_c0_count(0);
-	end = start + (32768 / trim_divide)/2; /* wait 0.5 seconds */
-
-	while (end > au_readl(SYS_RTCREAD));
-
-	count = read_c0_count();
-	cpu_speed = count * 2;
-	mips_counter_frequency = count;
-	set_au1x00_uart_baud_base(((cpu_speed) / 4) / 16);
-	spin_unlock_irqrestore(&time_lock, flags);
-	return (cpu_speed / HZ);
-}
-
-
-void __init time_init(void)
-{
-        unsigned int est_freq;
+	if (counter & SYS_CNTRL_E0) {
+		unsigned long start, end;
+		unsigned long counter;
+		int trim_divide = 16;
+
+		au_writel(counter | SYS_CNTRL_EN1, SYS_COUNTER_CNTRL);
+
+		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_T1S);
+		au_writel(trim_divide-1, SYS_RTCTRIM); /* RTC now ticks at 32.768/16 kHz */
+		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_T1S);
+
+		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C1S);
+		au_writel (0, SYS_TOYWRITE);
+		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C1S);
+
+		start = au_readl(SYS_RTCREAD);
+		start += 2;
+		/* wait for the beginning of a new tick */
+		while (au_readl(SYS_RTCREAD) < start);
+
+		/* Start r4k counter. */
+		write_c0_count(0);
+		end = start + (32768 / trim_divide)/2; /* wait 0.5 seconds */
 
-	printk("calculating r4koff... ");
-	r4k_offset = cal_r4koff();
-	printk("%08lx(%d)\n", r4k_offset, (int) r4k_offset);
+		while (end > au_readl(SYS_RTCREAD));
 
-	//est_freq = 2*r4k_offset*HZ;
-	est_freq = r4k_offset*HZ;
-	est_freq += 5000;    /* round */
-	est_freq -= est_freq%10000;
-	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000,
-	       (est_freq%1000000)*100/1000000);
- 	set_au1x00_speed(est_freq);
- 	set_au1x00_lcd_clock(); // program the LCD clock
-	r4k_cur = (read_c0_count() + r4k_offset);
-
-	write_c0_compare(r4k_cur);
-
-	/* no RTC on the pb1000 */
-	xtime.tv_sec = 0;
-	xtime.tv_usec = 0;
-
-#ifdef CONFIG_PM
-	/*
-	 * setup counter 0, since it keeps ticking after a
-	 * 'wait' instruction has been executed. The CP0 timer and
-	 * counter 1 do NOT continue running after 'wait'
-	 *
-	 * It's too early to call request_irq() here, so we handle
-	 * counter 0 interrupt as a special irq and it doesn't show
-	 * up under /proc/interrupts.
+		count = read_c0_count();
+		cpu_speed = count * 2;
+	}
+	else {
+		/* The 32KHz oscillator isn't running, so assume there
+		 * isn't one and grab the processor speed from the PLL.
+		 * NOTE: some old silicon doesn't allow reading the PLL.
+		 */
+		cpu_speed = (au_readl(SYS_CPUPLL) & 0x0000003f) * 1000000 * AU1000_SRC_CLK;
+		count = cpu_speed / 2;
+		no_au1xxx_32khz = 1;
+	}
+#else
+	/* Always read the processor speed from the PLL.  Guessing this
+	 * value by using a 32KHz clock doesn't provide the accurate
+	 * clock speed.  This causes problems for peripheral clock dividers
+	 * because their clocks are not accurate, either.
+	 * NOTE: some old silicon doesn't allow reading the PLL.
 	 */
-	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C0S);
-	au_writel(0, SYS_TOYWRITE);
-	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C0S);
-
-	au_writel(au_readl(SYS_WAKEMSK) | (1<<8), SYS_WAKEMSK);
-	au_writel(~0, SYS_WAKESRC);
-	au_sync();
-	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20);
-
-	/* setup match20 to interrupt once every 10ms */
-	last_pc0 = last_match20 = au_readl(SYS_TOYREAD);
-	au_writel(last_match20 + MATCH20_INC, SYS_TOYMATCH2);
-	au_sync();
-	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20);
-	startup_match20_interrupt();
+	cpu_speed = (au_readl(SYS_CPUPLL) & 0x0000003f) * 1000000 * 12;
+	count = cpu_speed / 2;
+	no_au1xxx_32khz = 1;
 #endif
-
-	//set_c0_status(ALLINTS);
-	au_sync();
+	mips_hpt_frequency = count;
+	// Equation: Baudrate = CPU / (SD * 2 * CLKDIV * 16)
+	set_au1x00_uart_baud_base(cpu_speed / (2 * ((int)(au_readl(SYS_POWERCTRL)&0x03) + 2) * 16));
+	spin_unlock_irqrestore(&time_lock, flags);
+	return (cpu_speed / HZ);
 }
 
 /* This is for machines which generate the exact clock. */
 #define USECS_PER_JIFFY (1000000/HZ)
 #define USECS_PER_JIFFY_FRAC (0x100000000*1000000/HZ&0xffffffff)
 
-#ifndef CONFIG_PM
+
 static unsigned long
 div64_32(unsigned long v1, unsigned long v2, unsigned long v3)
 {
@@ -276,30 +305,9 @@
 	do_div64_32(r0, v1, v2, v3);
 	return r0;
 }
-#endif
 
-static unsigned long do_fast_gettimeoffset(void)
+static unsigned long do_fast_cp0_gettimeoffset(void)
 {
-#ifdef CONFIG_PM
-	unsigned long pc0;
-	unsigned long offset;
-
-	pc0 = au_readl(SYS_TOYREAD);
-	if (pc0 < last_pc0) {
-		offset = 0xffffffff - last_pc0 + pc0;
-		printk("offset over: %x\n", (unsigned)offset);
-	}
-	else {
-		offset = (unsigned long)(((pc0 - last_pc0) * 305) / 10);
-	}
-	if ((pc0-last_pc0) > 2*MATCH20_INC) {
-		printk("huge offset %x, last_pc0 %x last_match20 %x pc0 %x\n",
-				(unsigned)offset, (unsigned)last_pc0,
-				(unsigned)last_match20, (unsigned)pc0);
-	}
-	au_sync();
-	return offset;
-#else
 	u32 count;
 	unsigned long res, tmp;
 	unsigned long r0;
@@ -340,60 +348,114 @@
 		 "r" (quotient));
 
 	/*
- 	 * Due to possible jiffies inconsistencies, we need to check
+ 	 * Due to possible jiffies inconsistencies, we need to check 
 	 * the result so that we'll get a timer that is monotonic.
 	 */
 	if (res >= USECS_PER_JIFFY)
 		res = USECS_PER_JIFFY-1;
 
 	return res;
-#endif
 }
 
-void do_gettimeofday(struct timeval *tv)
+#ifdef CONFIG_PM
+static unsigned long do_fast_pm_gettimeoffset(void)
 {
-	unsigned long flags;
-
-	read_lock_irqsave (&xtime_lock, flags);
-	*tv = xtime;
-	tv->tv_usec += do_fast_gettimeoffset();
-
-	/*
-	 * xtime is atomically updated in timer_bh. jiffies - wall_jiffies
-	 * is nonzero if the timer bottom half hasnt executed yet.
-	 */
-	if (jiffies - wall_jiffies)
-		tv->tv_usec += USECS_PER_JIFFY;
-
-	read_unlock_irqrestore (&xtime_lock, flags);
+	unsigned long pc0;
+	unsigned long offset;
 
-	if (tv->tv_usec >= 1000000) {
-		tv->tv_usec -= 1000000;
-		tv->tv_sec++;
+	pc0 = au_readl(SYS_TOYREAD);
+	au_sync();
+	offset = pc0 - last_pc0;
+	if (offset > 2*MATCH20_INC) {
+		printk("huge offset %x, last_pc0 %x last_match20 %x pc0 %x\n", 
+				(unsigned)offset, (unsigned)last_pc0, 
+				(unsigned)last_match20, (unsigned)pc0);
 	}
+	offset = (unsigned long)((offset * 305) / 10);
+	return offset;
 }
+#endif
 
-void do_settimeofday(struct timeval *tv)
+void __init au1xxx_timer_setup(void)
 {
-	write_lock_irq (&xtime_lock);
+        unsigned int est_freq;
+	extern unsigned long (*do_gettimeoffset)(void);
+	extern void r4k_wait(void);
 
-	/* This is revolting. We need to set the xtime.tv_usec correctly.
-	 * However, the value in this location is value at the last tick.
-	 * Discover what correction gettimeofday would have done, and then
-	 * undo it!
-	 */
-	tv->tv_usec -= do_fast_gettimeoffset();
+	printk("calculating r4koff... ");
+	r4k_offset = cal_r4koff();
+	printk("%08lx(%d)\n", r4k_offset, (int) r4k_offset);
+
+	//est_freq = 2*r4k_offset*HZ;	
+	est_freq = r4k_offset*HZ;	
+	est_freq += 5000;    /* round */
+	est_freq -= est_freq%10000;
+	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000, 
+	       (est_freq%1000000)*100/1000000);
+ 	set_au1x00_speed(est_freq);
+ 	set_au1x00_lcd_clock(); // program the LCD clock
+
+	r4k_cur = (read_c0_count() + r4k_offset);
+	write_c0_compare(r4k_cur);
 
-	if (tv->tv_usec < 0) {
-		tv->tv_usec += 1000000;
-		tv->tv_sec--;
+	/* no RTC on the pb1000 */
+	xtime.tv_sec = 0;
+	xtime.tv_usec = 0;
+
+#ifdef CONFIG_PM
+	/*
+	 * setup counter 0, since it keeps ticking after a
+	 * 'wait' instruction has been executed. The CP0 timer and
+	 * counter 1 do NOT continue running after 'wait'
+	 *
+	 * It's too early to call request_irq() here, so we handle
+	 * counter 0 interrupt as a special irq and it doesn't show
+	 * up under /proc/interrupts.
+	 *
+	 * Check to ensure we really have a 32KHz oscillator before
+	 * we do this.
+	 */
+	if (no_au1xxx_32khz) {
+		printk("WARNING: no 32KHz clock found.\n");
+		do_gettimeoffset = do_fast_cp0_gettimeoffset;
+
+		/* Ensure we get CPO_COUNTER interrupts.
+		*/
+		change_cp0_status(IE_IRQ5, IE_IRQ5);
+	}
+	else {
+		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C0S);
+		au_writel(0, SYS_TOYWRITE);
+		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C0S);
+
+		au_writel(au_readl(SYS_WAKEMSK) | (1<<8), SYS_WAKEMSK);
+		au_writel(~0, SYS_WAKESRC);
+		au_sync();
+		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20);
+
+		/* setup match20 to interrupt once every 10ms */
+		last_pc0 = last_match20 = au_readl(SYS_TOYREAD);
+		au_writel(last_match20 + MATCH20_INC, SYS_TOYMATCH2);
+		au_sync();
+		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20);
+		startup_match20_interrupt();
+
+		do_gettimeoffset = do_fast_pm_gettimeoffset;
+
+		/* We can use the real 'wait' instruction.
+		*/
+		au1k_wait_ptr = r4k_wait;
 	}
 
-	xtime = *tv;
-	time_adjust = 0;		/* stop active adjtime() */
-	time_status |= STA_UNSYNC;
-	time_maxerror = NTP_PHASE_LIMIT;
-	time_esterror = NTP_PHASE_LIMIT;
+#else
+	/* We have to do this here instead of in timer_init because
+	 * the generic code in arch/mips/kernel/time.c will write
+	 * over our function pointer.
+	 */
+	do_gettimeoffset = do_fast_cp0_gettimeoffset;
+#endif
+}
 
-	write_unlock_irq (&xtime_lock);
+void __init au1xxx_time_init(void)
+{
 }
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/au1000/csb250/board_setup.c linux-2.4.22/arch/mips/au1000/csb250/board_setup.c
--- linux-2.4.22.clean/arch/mips/au1000/csb250/board_setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/arch/mips/au1000/csb250/board_setup.c	2003-09-08 02:05:46.000000000 +0200
@@ -0,0 +1,250 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Cogent CSB250 board setup.
+ *
+ * Copyright 2002 Cogent Computer Systems, Inc.
+ *	dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/mc146818rtc.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/keyboard.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/au1000.h>
+#include <asm/csb250.h>
+
+#ifdef CONFIG_USB_OHCI
+// Enable the workaround for the OHCI DoneHead
+// register corruption problem.
+#define CONFIG_AU1000_OHCI_FIX
+#endif
+
+#ifdef CONFIG_RTC
+extern struct rtc_ops csb250_rtc_ops;
+#endif
+
+extern int (*board_pci_idsel)(unsigned int devsel, int assert);
+int	csb250_pci_idsel(unsigned int devsel, int assert);
+
+void __init board_setup(void)
+{
+	u32 pin_func, pin_val;
+	u32 sys_freqctrl, sys_clksrc;
+
+
+	// set AUX clock to 12MHz * 8 = 96 MHz
+	au_writel(8, SYS_AUXPLL);
+	au_writel(0, SYS_PINSTATERD);
+	udelay(100);
+
+#if defined (CONFIG_USB_OHCI) || defined (CONFIG_AU1X00_USB_DEVICE)
+
+	/* GPIO201 is input for PCMCIA card detect */
+	/* GPIO203 is input for PCMCIA interrupt request */
+	au_writel(au_readl(GPIO2_DIR) & (u32)(~((1<<1)|(1<<3))), GPIO2_DIR);
+
+	/* zero and disable FREQ2 */
+	sys_freqctrl = au_readl(SYS_FREQCTRL0);
+	sys_freqctrl &= ~0xFFF00000;
+	au_writel(sys_freqctrl, SYS_FREQCTRL0);
+
+	/* zero and disable USBH/USBD clocks */
+	sys_clksrc = au_readl(SYS_CLKSRC);
+	sys_clksrc &= ~0x00007FE0;
+	au_writel(sys_clksrc, SYS_CLKSRC);
+
+	sys_freqctrl = au_readl(SYS_FREQCTRL0);
+	sys_freqctrl &= ~0xFFF00000;
+
+	sys_clksrc = au_readl(SYS_CLKSRC);
+	sys_clksrc &= ~0x00007FE0;
+
+	// FREQ2 = aux/2 = 48 MHz
+	sys_freqctrl |= ((0<<22) | (1<<21) | (1<<20));
+	au_writel(sys_freqctrl, SYS_FREQCTRL0);
+
+	/*
+	 * Route 48MHz FREQ2 into USB Host and/or Device
+	 */
+#ifdef CONFIG_USB_OHCI
+	sys_clksrc |= ((4<<12) | (0<<11) | (0<<10));
+#endif
+#ifdef CONFIG_AU1X00_USB_DEVICE
+	sys_clksrc |= ((4<<7) | (0<<6) | (0<<5));
+#endif
+	au_writel(sys_clksrc, SYS_CLKSRC);
+
+
+	pin_func = au_readl(SYS_PINFUNC) & (u32)(~0x8000);
+#ifndef CONFIG_AU1X00_USB_DEVICE
+	// 2nd USB port is USB host
+	pin_func |= 0x8000;
+#endif
+	au_writel(pin_func, SYS_PINFUNC);
+#endif // defined (CONFIG_USB_OHCI) || defined (CONFIG_AU1X00_USB_DEVICE)
+
+	/* Configure GPIO2....it's used by PCI among other things.
+	*/
+
+	/* Make everything but GP200 (PCI RST) an input until we get
+	 * the pins set correctly.
+	 */
+	au_writel(0x00000001, GPIO2_DIR);
+
+	/* Set the pins used for output.
+	 * A zero bit will leave PCI reset, LEDs off, power up USB,
+	 * IDSEL disabled.
+	 */
+	pin_val = ((3 << 30) | (7 << 19) | (1 << 17) | (1 << 16));
+	au_writel(pin_val, GPIO2_OUTPUT);
+
+	/* Set the output direction.
+	*/
+	pin_val = ((3 << 14) | (7 << 3) | (1 << 1) | (1 << 0));
+	au_writel(pin_val, GPIO2_DIR);
+
+#ifdef CONFIG_PCI
+	/* Use FREQ1 for the PCI output clock.  We use the
+	 * CPU clock of 384 MHz divided by 12 to get 32 MHz PCI.
+	 * If Michael changes the CPU speed, we need to adjust
+	 * that here as well :-).
+	 */
+
+	/* zero and disable FREQ1
+	*/
+	sys_freqctrl = au_readl(SYS_FREQCTRL0);
+	sys_freqctrl &= ~0x000ffc00;
+	au_writel(sys_freqctrl, SYS_FREQCTRL0);
+
+	/* zero and disable PCI clock
+	*/
+	sys_clksrc = au_readl(SYS_CLKSRC);
+	sys_clksrc &= ~0x000f8000;
+	au_writel(sys_clksrc, SYS_CLKSRC);
+
+	/* Get current values (which really should match above).
+	*/
+	sys_freqctrl = au_readl(SYS_FREQCTRL0);
+	sys_freqctrl &= ~0x000ffc00;
+
+	sys_clksrc = au_readl(SYS_CLKSRC);
+	sys_clksrc &= ~0x000f8000;
+
+	/* FREQ1 = cpu/12 = 32 MHz
+	*/
+	sys_freqctrl |= ((5<<12) | (1<<11) | (0<<10));
+	au_writel(sys_freqctrl, SYS_FREQCTRL0);
+
+	/* Just connect the clock without further dividing.
+	*/
+	sys_clksrc |= ((3<<17) | (0<<16) | (0<<15));
+	au_writel(sys_clksrc, SYS_CLKSRC);
+
+	udelay(1);
+
+	/* Now that clocks should be running, take PCI out of reset.
+	*/
+	pin_val = au_readl(GPIO2_OUTPUT);
+	pin_val |= ((1 << 16) | 1);
+	au_writel(pin_val, GPIO2_OUTPUT);
+
+	// Setup PCI bus controller
+	au_writel(0, Au1500_PCI_CMEM);
+	au_writel(0x00003fff, Au1500_CFG_BASE);
+
+	/* We run big endian without any of the software byte swapping,
+	 * so configure the PCI bridge to help us out.
+	 */
+	au_writel(0xf | (2<<6) | (1<<5) | (1<<4), Au1500_PCI_CFG);
+
+	au_writel(0xf0000000, Au1500_PCI_MWMASK_DEV);
+	au_writel(0, Au1500_PCI_MWBASE_REV_CCL);
+	au_writel(0x02a00356, Au1500_PCI_STATCMD);
+	au_writel(0x00003c04, Au1500_PCI_HDRTYPE);	
+	au_writel(0x00000008, Au1500_PCI_MBAR);
+	au_sync();
+
+	board_pci_idsel = csb250_pci_idsel;
+#endif
+
+	/* Enable BCLK switching */
+	au_writel(0x00000060, 0xb190003c);
+
+#ifdef CONFIG_RTC
+	rtc_ops = &csb250_rtc_ops;
+	// Enable the RTC if not already enabled
+	if (!(au_readl(0xac000028) & 0x20)) {
+		printk("enabling clock ...\n");
+		au_writel((au_readl(0xac000028) | 0x20), 0xac000028);
+	}
+	// Put the clock in BCD mode
+	if (readl(0xac00002C) & 0x4) { /* reg B */
+		au_writel(au_readl(0xac00002c) & ~0x4, 0xac00002c);
+		au_sync();
+	}
+#endif
+}
+
+/* The IDSEL is selected in the GPIO2 register.  We will make device
+ * 12 appear in slot 0 and device 13 appear in slot 1.
+ */
+int
+csb250_pci_idsel(unsigned int devsel, int assert)
+{
+	int		retval;
+	unsigned int	gpio2_pins;
+
+	retval = 1;
+	
+	/* First, disable both selects, then assert the one requested.
+	*/
+	au_writel(0xc000c000, GPIO2_OUTPUT);
+	au_sync();
+
+	if (assert) {
+		if (devsel == 12)
+			gpio2_pins = 0x40000000;
+		else if (devsel == 13)
+			gpio2_pins = 0x80000000;
+		else {
+			gpio2_pins = 0xc000c000;
+			retval = 0;
+		}
+		au_writel(gpio2_pins, GPIO2_OUTPUT);
+	}
+	au_sync();
+
+	return retval;
+}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/au1000/csb250/init.c linux-2.4.22/arch/mips/au1000/csb250/init.c
--- linux-2.4.22.clean/arch/mips/au1000/csb250/init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/arch/mips/au1000/csb250/init.c	2003-09-08 02:05:46.000000000 +0200
@@ -0,0 +1,95 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Cogent CSB250 board setup
+ *
+ * Copyright 2002 Cogent Computer Systems, Inc.
+ * 	dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+extern void  __init prom_init_cmdline(void);
+extern char *prom_getenv(char *envname);
+
+/* When we get initrd working someday.........
+*/
+int	my_initrd_start, my_initrd_size;
+
+/* Start arguments and environment.
+*/
+static char	*csb_env[2];
+static char	*csb_arg[4];
+static char	*arg1 = "console=ttyS3,38400";
+static char	*arg2 = "root=/dev/nfs rw ip=any";
+static char	*env1 = "ethaddr=00:30:23:50:00:00";
+
+const char *get_system_type(void)
+{
+	return "Cogent CSB250";
+}
+
+int __init prom_init(int argc, char **argv, char **envp, int *prom_vec)
+{
+	unsigned char *memsize_str;
+	unsigned long memsize;
+
+	/* We use a0 and a1 to pass initrd start and size.
+	*/
+	if (((uint) argc > 0) && ((uint)argv > 0)) {
+		my_initrd_start = (uint)argc;
+		my_initrd_size = (uint)argv;
+	}
+
+	/* First argv is ignored.
+	*/
+	prom_argc = 3;
+	prom_argv = csb_arg;
+	prom_envp = csb_env;
+	csb_arg[1] = arg1;
+	csb_arg[2] = arg2;
+	csb_env[0] = env1;
+
+	mips_machgroup = MACH_GROUP_ALCHEMY;
+	mips_machtype = MACH_CSB250;  
+
+	prom_init_cmdline();
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x02000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+	return 0;
+}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/au1000/csb250/irqmap.c linux-2.4.22/arch/mips/au1000/csb250/irqmap.c
--- linux-2.4.22.clean/arch/mips/au1000/csb250/irqmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/arch/mips/au1000/csb250/irqmap.c	2003-09-08 02:05:46.000000000 +0200
@@ -0,0 +1,100 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1xxx irq map table
+ *
+ * Copyright 2003 Embedded Edge, LLC
+ *		dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/au1000.h>
+
+au1xxx_irq_map_t au1xxx_irq_map[] = {
+	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
+
+	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
+
+	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
+
+	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
+
+	{ AU1000_PCI_INTA, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1000_PCI_INTB, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1000_PCI_INTC, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1000_PCI_INTD, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1500_GPIO_202, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1500_GPIO_203, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1500_GPIO_205, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1500_GPIO_207, INTC_INT_LOW_LEVEL, 0 },
+
+	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_USB_DEV_REQ_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+
+	/* Careful if you change match 2 request!
+	 * The interrupt handler is called directly
+	 * from the low level dispatch code.
+	 */
+	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+};
+
+int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/au1000/csb250/Makefile linux-2.4.22/arch/mips/au1000/csb250/Makefile
--- linux-2.4.22.clean/arch/mips/au1000/csb250/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/arch/mips/au1000/csb250/Makefile	2003-09-08 02:05:46.000000000 +0200
@@ -0,0 +1,18 @@
+#
+#  Copyright 2002 Cogent Computer Systems
+#     	dan@embeddededge.com
+#
+# Makefile for the Cogent CSB250 Au1500 board.  Copied from Pb1500.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+USE_STANDARD_AS_RULE := true
+
+O_TARGET := csb250.o
+
+obj-y := init.o board_setup.o irqmap.o
+
+include $(TOPDIR)/Rules.make
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/au1000/db1x00/board_setup.c linux-2.4.22/arch/mips/au1000/db1x00/board_setup.c
--- linux-2.4.22.clean/arch/mips/au1000/db1x00/board_setup.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/au1000/db1x00/board_setup.c	2003-09-27 14:07:03.000000000 +0200
@@ -62,7 +62,7 @@
 	au_writel(pin_func, SYS_PINFUNC);
 #endif
 
-#if defined(CONFIG_IRDA) && (defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1000))
+#if defined(CONFIG_IRDA) && (defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1100))
 	/* set IRFIRSEL instead of GPIO15 */
 	pin_func = au_readl(SYS_PINFUNC) | (u32)((1<<8));
 	au_writel(pin_func, SYS_PINFUNC);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/boot/addinitrd.c linux-2.4.22/arch/mips/boot/addinitrd.c
--- linux-2.4.22.clean/arch/mips/boot/addinitrd.c	2002-11-29 00:53:09.000000000 +0100
+++ linux-2.4.22/arch/mips/boot/addinitrd.c	2003-09-21 03:08:49.000000000 +0200
@@ -2,6 +2,8 @@
  * addinitrd - program to add a initrd image to an ecoff kernel
  *
  * (C) 1999 Thomas Bogendoerfer
+ * minor modifications, cleanup: Guido Guenther <agx@sigxcpu.org>
+ *
  */
 
 #include <sys/types.h>
@@ -54,7 +56,7 @@
 		exit (1);
 	}
 
-	if ((fd_vmlinux = open (argv[1],O_RDWR)) < 0)
+	if ((fd_vmlinux = open (argv[1],O_RDONLY)) < 0)
 		 die ("open vmlinux");
 	if (read (fd_vmlinux, &efile, sizeof efile) != sizeof efile)
 		die ("read file header");
@@ -78,6 +80,11 @@
 			swab = 1;
 	}
 
+	/* make sure we have an empty data segment for the initrd */
+	if( eaout.dsize || esecs[1].s_size ) {
+		fprintf(2,"Data segment not empty. Giving up!");
+		exit(1);
+	}
 	if ((fd_initrd = open (argv[2], O_RDONLY)) < 0)
 		die ("open initrd");
 	if (fstat (fd_initrd, &st) < 0)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/boot/Makefile linux-2.4.22/arch/mips/boot/Makefile
--- linux-2.4.22.clean/arch/mips/boot/Makefile	2002-11-29 00:53:09.000000000 +0100
+++ linux-2.4.22/arch/mips/boot/Makefile	2003-09-27 14:07:03.000000000 +0200
@@ -24,7 +24,7 @@
 drop-sections	= .reginfo .mdebug
 strip-flags	= $(addprefix --remove-section=,$(drop-sections))
 
-all: vmlinux.ecoff addinitrd
+all: vmlinux.ecoff vmlinux.srec addinitrd
 
 vmlinux.ecoff:	$(CONFIGURE) elf2ecoff $(TOPDIR)/vmlinux
 	./elf2ecoff $(TOPDIR)/vmlinux vmlinux.ecoff $(E2EFLAGS)
@@ -32,6 +32,9 @@
 elf2ecoff: elf2ecoff.c
 	$(HOSTCC) -o $@ $^
 
+vmlinux.srec: $(CONFIGURE) $(TOPDIR)/vmlinux
+	$(OBJCOPY) -S -O srec $(strip-flags) $(TOPDIR)/vmlinux vmlinux.srec
+
 addinitrd: addinitrd.c
 	$(HOSTCC) -o $@ $^
 
@@ -40,10 +43,12 @@
 
 clean:
 	rm -f vmlinux.ecoff
+	rm -f vmlinux.srec
 	rm -f zImage zImage.tmp
 
 mrproper:
 	rm -f vmlinux.ecoff
+	rm -f vmlinux.srec
 	rm -f addinitrd
 	rm -f elf2ecoff
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/config-shared.in linux-2.4.22/arch/mips/config-shared.in
--- linux-2.4.22.clean/arch/mips/config-shared.in	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/config-shared.in	2003-09-27 14:07:02.000000000 +0200
@@ -33,6 +33,7 @@
 dep_bool 'Support for Alchemy PB1500 board' CONFIG_MIPS_PB1500 $CONFIG_MIPS32
 dep_bool 'Support for MyCable XXS1500 board' CONFIG_MIPS_XXS1500 $CONFIG_MIPS32
 dep_bool 'Support for 4G Systems MTX-1 board' CONFIG_MIPS_MTX1 $CONFIG_MIPS32
+dep_bool 'Support for Cogent CSB250 board' CONFIG_COGENT_CSB250 $CONFIG_MIPS32
 dep_bool 'Support for BAGET MIPS series (EXPERIMENTAL)' CONFIG_BAGET_MIPS $CONFIG_MIPS32 $CONFIG_EXPERIMENTAL
 bool 'Support for CASIO CASSIOPEIA E-10/15/55/65' CONFIG_CASIO_E55
 dep_bool 'Support for Cobalt Server (EXPERIMENTAL)' CONFIG_MIPS_COBALT $CONFIG_EXPERIMENTAL
@@ -117,10 +118,10 @@
 
    if [ "$CONFIG_SIBYTE_UNKNOWN" = "y" ]; then
       choice '   BCM1xxx SOC Type' \
-          "BCM91250     CONFIG_SIBYTE_SB1250 \
-           BCM91120     CONFIG_SIBYTE_BCM1120 \
-           BCM91125     CONFIG_SIBYTE_BCM1125 \
-           BCM91125H    CONFIG_SIBYTE_BCM1125H" CONFIG_SIBYTE_SB1250
+          "BCM1250     CONFIG_SIBYTE_SB1250 \
+           BCM1120     CONFIG_SIBYTE_BCM1120 \
+           BCM1125     CONFIG_SIBYTE_BCM1125 \
+           BCM1125H    CONFIG_SIBYTE_BCM1125H" CONFIG_SIBYTE_SB1250
       unset CONFIG_SIBYTE_BOARD
    else
       define_bool CONFIG_SIBYTE_BOARD y
@@ -246,6 +247,7 @@
 if [ "$CONFIG_MIPS_MIRAGE" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_PC_KEYB y
    define_bool CONFIG_PCI y
    define_bool CONFIG_NEW_PCI y
@@ -255,6 +257,7 @@
 if [ "$CONFIG_MIPS_BOSPORUS" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_PC_KEYB y
    define_bool CONFIG_PCI y
    define_bool CONFIG_NEW_PCI y
@@ -264,6 +267,7 @@
 if [ "$CONFIG_MIPS_PB1000" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1000 y
+   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_PCI y
    define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_NONCOHERENT_IO y
@@ -274,6 +278,7 @@
 if [ "$CONFIG_MIPS_PB1100" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1100 y
+   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_PCI y
    define_bool CONFIG_PCI_AUTO n
    define_bool CONFIG_NEW_PCI y
@@ -285,6 +290,7 @@
 if [ "$CONFIG_MIPS_PB1500" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_PCI y
    define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_PCI_AUTO y
@@ -294,6 +300,7 @@
 if [ "$CONFIG_MIPS_DB1000" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1000 y
+   define_bool CONFIG_NEW_TIME_C y
    # CONFIG_PCI needed for USB
    define_bool CONFIG_PCI y
    define_bool CONFIG_NEW_PCI y
@@ -305,6 +312,7 @@
 if [ "$CONFIG_MIPS_DB1500" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_PCI y
    define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_PCI_AUTO y
@@ -314,6 +322,7 @@
 if [ "$CONFIG_MIPS_DB1100" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1100 y
+   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_PCI y
    define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_NONCOHERENT_IO y
@@ -323,6 +332,7 @@
 if [ "$CONFIG_MIPS_XXS1500" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_PCI y
    define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_PCI_AUTO y
@@ -332,11 +342,22 @@
 if [ "$CONFIG_MIPS_MTX1" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_PCI y
    define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_NONCOHERENT_IO y
 fi
+if [ "$CONFIG_COGENT_CSB250" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NEW_TIME_C y
+   define_bool CONFIG_PCI y
+   define_bool CONFIG_NEW_PCI y
+   define_bool CONFIG_PCI_AUTO y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
 if [ "$CONFIG_MIPS_COBALT" = "y" ]; then
    define_bool CONFIG_COBALT_LCD y
    define_bool CONFIG_I8259 y
@@ -1033,8 +1054,13 @@
 bool 'Enable run-time debugging' CONFIG_RUNTIME_DEBUG
 bool 'Remote GDB kernel debugging' CONFIG_KGDB
 dep_bool '  Console output to GDB' CONFIG_GDB_CONSOLE $CONFIG_KGDB
+if [ "$CONFIG_KGDB" = "y" ]; then
+   define_bool CONFIG_DEBUG_INFO y
+else
+   bool 'Debugging symbols' CONFIG_DEBUG_INFO
+fi
 if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
-   bool 'Compile for Corelis Debugger' CONFIG_SB1XXX_CORELIS
+   dep_bool 'Compile for Corelis Debugger' CONFIG_SB1XXX_CORELIS $CONFIG_DEBUG_INFO
 fi
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 if [ "$CONFIG_SMP" != "y" ]; then
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/ddb5xxx/ddb5476/setup.c linux-2.4.22/arch/mips/ddb5xxx/ddb5476/setup.c
--- linux-2.4.22.clean/arch/mips/ddb5xxx/ddb5476/setup.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/ddb5xxx/ddb5476/setup.c	2003-09-27 14:07:03.000000000 +0200
@@ -84,7 +84,7 @@
 static void __init ddb_time_init(void)
 {
 #if defined(USE_CPU_COUNTER_TIMER)
-	mips_counter_frequency = CPU_COUNTER_FREQUENCY;
+	mips_hpt_frequency = CPU_COUNTER_FREQUENCY;
 #endif
 
 	/* we have ds1396 RTC chip */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/ddb5xxx/ddb5477/setup.c linux-2.4.22/arch/mips/ddb5xxx/ddb5477/setup.c
--- linux-2.4.22.clean/arch/mips/ddb5xxx/ddb5477/setup.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/ddb5xxx/ddb5477/setup.c	2003-09-27 14:07:03.000000000 +0200
@@ -138,11 +138,11 @@
 		bus_frequency = detect_bus_frequency(rtc_base);
 	}
 
-	/* mips_counter_frequency is 1/2 of the cpu core freq */
+	/* mips_hpt_frequency is 1/2 of the cpu core freq */
 	i =  (read_c0_config() >> 28 ) & 7;
 	if ((current_cpu_data.cputype == CPU_R5432) && (i == 3))
 		i = 4;
-	mips_counter_frequency = bus_frequency*(i+4)/4;
+	mips_hpt_frequency = bus_frequency*(i+4)/4;
 }
 
 extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/dec/setup.c linux-2.4.22/arch/mips/dec/setup.c
--- linux-2.4.22.clean/arch/mips/dec/setup.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/dec/setup.c	2003-09-28 02:52:17.000000000 +0200
@@ -48,6 +48,11 @@
 
 extern asmlinkage void decstation_handle_int(void);
 
+#ifdef CONFIG_BLK_DEV_INITRD
+extern unsigned long initrd_start, initrd_end;
+extern void *__rd_start, *__rd_end;
+#endif
+
 spinlock_t ioasic_ssr_lock;
 
 volatile u32 *ioasic_base;
@@ -131,6 +136,12 @@
 
 void __init decstation_setup(void)
 {
+#ifdef CONFIG_BLK_DEV_INITRD
+	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
+	initrd_start = (unsigned long)&__rd_start;
+	initrd_end = (unsigned long)&__rd_end;
+#endif
+
 	board_be_init = dec_be_init;
 	board_time_init = dec_time_init;
 	board_timer_setup = dec_timer_setup;
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/dec/time.c linux-2.4.22/arch/mips/dec/time.c
--- linux-2.4.22.clean/arch/mips/dec/time.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/dec/time.c	2003-09-27 14:07:03.000000000 +0200
@@ -144,6 +144,11 @@
 }
 
 
+static int dec_timer_state(void)
+{
+	return (CMOS_READ(RTC_REG_C) & RTC_PF) != 0;
+}
+
 static void dec_timer_ack(void)
 {
 	CMOS_READ(RTC_REG_C);			/* Ack the RTC interrupt.  */
@@ -169,19 +174,23 @@
 	rtc_get_time = dec_rtc_get_time;
 	rtc_set_mmss = dec_rtc_set_mmss;
 
+	mips_timer_state = dec_timer_state;
 	mips_timer_ack = dec_timer_ack;
+
 	if (!cpu_has_counter && IOASIC) {
 		/* For pre-R4k systems we use the I/O ASIC's counter.  */
 		mips_hpt_read = dec_ioasic_hpt_read;
 		mips_hpt_init = dec_ioasic_hpt_init;
 	}
+
+	/* Set up the rate of periodic DS1287 interrupts.  */
+	CMOS_WRITE(RTC_REF_CLCK_32KHZ | (16 - LOG_2_HZ), RTC_REG_A);
 }
 
 void __init dec_timer_setup(struct irqaction *irq)
 {
+	setup_irq(dec_interrupt[DEC_IRQ_RTC], irq);
+
 	/* Enable periodic DS1287 interrupts.  */
-	CMOS_WRITE(RTC_REF_CLCK_32KHZ | (16 - LOG_2_HZ), RTC_REG_A);
 	CMOS_WRITE(CMOS_READ(RTC_REG_B) | RTC_PIE, RTC_REG_B);
-
-	setup_irq(dec_interrupt[DEC_IRQ_RTC], irq);
 }
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig linux-2.4.22/arch/mips/defconfig
--- linux-2.4.22.clean/arch/mips/defconfig	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig	2003-09-27 14:07:02.000000000 +0200
@@ -674,6 +674,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-atlas linux-2.4.22/arch/mips/defconfig-atlas
--- linux-2.4.22.clean/arch/mips/defconfig-atlas	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-atlas	2003-09-27 14:07:02.000000000 +0200
@@ -665,6 +665,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-bosporus linux-2.4.22/arch/mips/defconfig-bosporus
--- linux-2.4.22.clean/arch/mips/defconfig-bosporus	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-bosporus	2003-09-27 14:07:02.000000000 +0200
@@ -71,6 +71,7 @@
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
+CONFIG_NEW_TIME_C=y
 CONFIG_PC_KEYB=y
 CONFIG_PCI=y
 CONFIG_NEW_PCI=y
@@ -680,6 +681,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -915,6 +917,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-capcella linux-2.4.22/arch/mips/defconfig-capcella
--- linux-2.4.22.clean/arch/mips/defconfig-capcella	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-capcella	2003-09-27 14:07:02.000000000 +0200
@@ -654,6 +654,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-cobalt linux-2.4.22/arch/mips/defconfig-cobalt
--- linux-2.4.22.clean/arch/mips/defconfig-cobalt	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-cobalt	2003-09-27 14:07:02.000000000 +0200
@@ -648,6 +648,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-csb250 linux-2.4.22/arch/mips/defconfig-csb250
--- linux-2.4.22.clean/arch/mips/defconfig-csb250	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/arch/mips/defconfig-csb250	2003-09-08 02:05:46.000000000 +0200
@@ -0,0 +1,854 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_MIPS=y
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Machine selection
+#
+# CONFIG_ACER_PICA_61 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_MIPS_MTX1 is not set
+CONFIG_COGENT_CSB250=y
+# CONFIG_BAGET_MIPS is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_HP_LASERJET is not set
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MAGNUM_4000 is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_NEC_OSPREY is not set
+# CONFIG_NEC_EAGLE is not set
+# CONFIG_OLIVETTI_M700 is not set
+# CONFIG_NINO is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TANBAC_TB0226 is not set
+# CONFIG_TANBAC_TB0229 is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_SOC_AU1X00=y
+CONFIG_SOC_AU1500=y
+CONFIG_NEW_TIME_C=y
+CONFIG_PCI=y
+CONFIG_NEW_PCI=y
+CONFIG_PCI_AUTO=y
+CONFIG_NONCOHERENT_IO=y
+CONFIG_PC_KEYB=y
+# CONFIG_MIPS_AU1000 is not set
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32=y
+# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_VTAG_ICACHE is not set
+CONFIG_64BIT_PHYS_ADDR=y
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+# CONFIG_CPU_HAS_LLDSCD is not set
+# CONFIG_CPU_HAS_WB is not set
+CONFIG_CPU_HAS_SYNC=y
+
+#
+# General setup
+#
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+# CONFIG_BINFMT_IRIX is not set
+CONFIG_NET=y
+# CONFIG_PCI_NAMES is not set
+# CONFIG_ISA is not set
+# CONFIG_EISA is not set
+# CONFIG_TC is not set
+# CONFIG_MCA is not set
+# CONFIG_SBUS is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=m
+# CONFIG_CARDBUS is not set
+# CONFIG_TCIC is not set
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+CONFIG_PCMCIA_AU1X00=m
+# CONFIG_PCMCIA_PB1X00 is not set
+CONFIG_PCMCIA_DB1X00=y
+# CONFIG_PCMCIA_XXS1500 is not set
+# CONFIG_PCMCIA_VRC4173 is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_MIPS32_COMPAT is not set
+# CONFIG_MIPS32_O32 is not set
+# CONFIG_MIPS32_N32 is not set
+# CONFIG_BINFMT_ELF32 is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_PM is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_FILTER is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+
+#
+#   IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+# CONFIG_PHONE_IXJ is not set
+# CONFIG_PHONE_IXJ_PCMCIA is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_IDEDISK_STROKE is not set
+CONFIG_BLK_DEV_IDECS=m
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_IDEPCI_SHARE_IRQ is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_ONLYDISK is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_PCI_WIP is not set
+# CONFIG_BLK_DEV_ADMA100 is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_WDC_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_HPT34X_AUTODMA is not set
+CONFIG_BLK_DEV_HPT366=y
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_PDC202XX_BURST is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_CHIPSETS is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_IDEDMA_IVB is not set
+# CONFIG_DMA_NONPCI is not set
+CONFIG_BLK_DEV_IDE_MODES=y
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_SII is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_PCI is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MIPS_AU1X00_ENET=y
+# CONFIG_BCM5222_DUAL_PHY is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=m
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+CONFIG_PPPOE=m
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input core support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_KEYBDEV=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_ESPSERIAL is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+# CONFIG_SERIAL_TX3912 is not set
+# CONFIG_SERIAL_TX3912_CONSOLE is not set
+# CONFIG_SERIAL_TXX9 is not set
+# CONFIG_SERIAL_TXX9_CONSOLE is not set
+CONFIG_AU1X00_UART=y
+CONFIG_AU1X00_SERIAL_CONSOLE=y
+# CONFIG_AU1X00_USB_TTY is not set
+# CONFIG_AU1X00_USB_RAW is not set
+# CONFIG_TXX927_SERIAL is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_MIPS_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_PCMCIA_SERIAL_CS is not set
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_AU1X00_GPIO is not set
+# CONFIG_TS_AU1X00_ADS7846 is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_AUTOFS_FS=y
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Console drivers
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+
+#
+# Frame-buffer support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_UHCI is not set
+# CONFIG_USB_UHCI_ALT is not set
+CONFIG_USB_OHCI=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_MIDI is not set
+
+#
+#   SCSI support is needed for USB Storage
+#
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_DC2XX is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_SCANNER is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+
+#
+#   Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_AX8817X is not set
+# CONFIG_USB_CDCETHER is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_USS720 is not set
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_BRLVGER is not set
+# CONFIG_USB_LCD is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Kernel hacking
+#
+CONFIG_CROSSCOMPILE=y
+# CONFIG_RUNTIME_DEBUG is not set
+# CONFIG_KGDB is not set
+# CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_MIPS_UNCACHED is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-db1000 linux-2.4.22/arch/mips/defconfig-db1000
--- linux-2.4.22.clean/arch/mips/defconfig-db1000	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-db1000	2003-09-27 14:07:02.000000000 +0200
@@ -71,6 +71,7 @@
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1000=y
+CONFIG_NEW_TIME_C=y
 CONFIG_PCI=y
 CONFIG_NEW_PCI=y
 # CONFIG_PCI_AUTO is not set
@@ -652,6 +653,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -964,6 +966,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-db1100 linux-2.4.22/arch/mips/defconfig-db1100
--- linux-2.4.22.clean/arch/mips/defconfig-db1100	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-db1100	2003-09-27 14:07:02.000000000 +0200
@@ -71,6 +71,7 @@
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1100=y
+CONFIG_NEW_TIME_C=y
 CONFIG_PCI=y
 CONFIG_NEW_PCI=y
 CONFIG_NONCOHERENT_IO=y
@@ -651,6 +652,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -1003,6 +1005,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-db1500 linux-2.4.22/arch/mips/defconfig-db1500
--- linux-2.4.22.clean/arch/mips/defconfig-db1500	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-db1500	2003-09-27 14:07:02.000000000 +0200
@@ -71,6 +71,7 @@
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
+CONFIG_NEW_TIME_C=y
 CONFIG_PCI=y
 CONFIG_NEW_PCI=y
 CONFIG_PCI_AUTO=y
@@ -574,6 +575,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -843,6 +845,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-ddb5476 linux-2.4.22/arch/mips/defconfig-ddb5476
--- linux-2.4.22.clean/arch/mips/defconfig-ddb5476	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-ddb5476	2003-09-27 14:07:02.000000000 +0200
@@ -690,6 +690,7 @@
 CONFIG_RUNTIME_DEBUG=y
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-ddb5477 linux-2.4.22/arch/mips/defconfig-ddb5477
--- linux-2.4.22.clean/arch/mips/defconfig-ddb5477	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-ddb5477	2003-09-27 14:07:02.000000000 +0200
@@ -594,6 +594,7 @@
 CONFIG_RUNTIME_DEBUG=y
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-decstation linux-2.4.22/arch/mips/defconfig-decstation
--- linux-2.4.22.clean/arch/mips/defconfig-decstation	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-decstation	2003-09-27 14:07:02.000000000 +0200
@@ -622,6 +622,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-e55 linux-2.4.22/arch/mips/defconfig-e55
--- linux-2.4.22.clean/arch/mips/defconfig-e55	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-e55	2003-09-27 14:07:02.000000000 +0200
@@ -613,6 +613,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-eagle linux-2.4.22/arch/mips/defconfig-eagle
--- linux-2.4.22.clean/arch/mips/defconfig-eagle	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-eagle	2003-09-27 14:07:02.000000000 +0200
@@ -878,6 +878,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-ev64120 linux-2.4.22/arch/mips/defconfig-ev64120
--- linux-2.4.22.clean/arch/mips/defconfig-ev64120	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-ev64120	2003-09-27 14:07:02.000000000 +0200
@@ -577,6 +577,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-ev96100 linux-2.4.22/arch/mips/defconfig-ev96100
--- linux-2.4.22.clean/arch/mips/defconfig-ev96100	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-ev96100	2003-09-27 14:07:02.000000000 +0200
@@ -574,6 +574,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-hp-lj linux-2.4.22/arch/mips/defconfig-hp-lj
--- linux-2.4.22.clean/arch/mips/defconfig-hp-lj	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-hp-lj	2003-09-27 14:07:03.000000000 +0200
@@ -727,6 +727,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-ip22 linux-2.4.22/arch/mips/defconfig-ip22
--- linux-2.4.22.clean/arch/mips/defconfig-ip22	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-ip22	2003-09-27 14:07:03.000000000 +0200
@@ -697,6 +697,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-it8172 linux-2.4.22/arch/mips/defconfig-it8172
--- linux-2.4.22.clean/arch/mips/defconfig-it8172	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-it8172	2003-09-27 14:07:03.000000000 +0200
@@ -591,7 +591,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-CONFIG_MIPS_RTC=y
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -747,6 +747,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-ivr linux-2.4.22/arch/mips/defconfig-ivr
--- linux-2.4.22.clean/arch/mips/defconfig-ivr	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-ivr	2003-09-27 14:07:03.000000000 +0200
@@ -778,6 +778,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-jmr3927 linux-2.4.22/arch/mips/defconfig-jmr3927
--- linux-2.4.22.clean/arch/mips/defconfig-jmr3927	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-jmr3927	2003-09-27 14:07:03.000000000 +0200
@@ -642,6 +642,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-lasat linux-2.4.22/arch/mips/defconfig-lasat
--- linux-2.4.22.clean/arch/mips/defconfig-lasat	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-lasat	2003-09-27 14:07:03.000000000 +0200
@@ -725,6 +725,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 CONFIG_MAGIC_SYSRQ=y
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-malta linux-2.4.22/arch/mips/defconfig-malta
--- linux-2.4.22.clean/arch/mips/defconfig-malta	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-malta	2003-09-27 14:07:03.000000000 +0200
@@ -647,6 +647,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-mirage linux-2.4.22/arch/mips/defconfig-mirage
--- linux-2.4.22.clean/arch/mips/defconfig-mirage	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-mirage	2003-09-27 14:07:03.000000000 +0200
@@ -71,6 +71,7 @@
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
+CONFIG_NEW_TIME_C=y
 CONFIG_PC_KEYB=y
 CONFIG_PCI=y
 CONFIG_NEW_PCI=y
@@ -489,6 +490,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -752,6 +754,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-mpc30x linux-2.4.22/arch/mips/defconfig-mpc30x
--- linux-2.4.22.clean/arch/mips/defconfig-mpc30x	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-mpc30x	2003-09-27 14:07:03.000000000 +0200
@@ -668,6 +668,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-mtx-1 linux-2.4.22/arch/mips/defconfig-mtx-1
--- linux-2.4.22.clean/arch/mips/defconfig-mtx-1	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-mtx-1	2003-09-27 14:07:03.000000000 +0200
@@ -71,6 +71,7 @@
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
+CONFIG_NEW_TIME_C=y
 CONFIG_PCI=y
 CONFIG_NEW_PCI=y
 CONFIG_PCI_AUTO=y
@@ -515,6 +516,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -647,6 +649,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-nino linux-2.4.22/arch/mips/defconfig-nino
--- linux-2.4.22.clean/arch/mips/defconfig-nino	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-nino	2003-09-27 14:07:03.000000000 +0200
@@ -518,6 +518,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-ocelot linux-2.4.22/arch/mips/defconfig-ocelot
--- linux-2.4.22.clean/arch/mips/defconfig-ocelot	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-ocelot	2003-09-27 14:07:03.000000000 +0200
@@ -642,6 +642,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-osprey linux-2.4.22/arch/mips/defconfig-osprey
--- linux-2.4.22.clean/arch/mips/defconfig-osprey	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-osprey	2003-09-27 14:07:03.000000000 +0200
@@ -539,6 +539,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-pb1000 linux-2.4.22/arch/mips/defconfig-pb1000
--- linux-2.4.22.clean/arch/mips/defconfig-pb1000	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-pb1000	2003-09-27 14:07:03.000000000 +0200
@@ -72,6 +72,7 @@
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1000=y
+CONFIG_NEW_TIME_C=y
 CONFIG_PCI=y
 CONFIG_NEW_PCI=y
 CONFIG_NONCOHERENT_IO=y
@@ -643,6 +644,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -955,6 +957,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-pb1100 linux-2.4.22/arch/mips/defconfig-pb1100
--- linux-2.4.22.clean/arch/mips/defconfig-pb1100	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-pb1100	2003-09-27 14:07:03.000000000 +0200
@@ -71,6 +71,7 @@
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1100=y
+CONFIG_NEW_TIME_C=y
 CONFIG_PCI=y
 # CONFIG_PCI_AUTO is not set
 CONFIG_NEW_PCI=y
@@ -629,6 +630,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -978,6 +980,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-pb1500 linux-2.4.22/arch/mips/defconfig-pb1500
--- linux-2.4.22.clean/arch/mips/defconfig-pb1500	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-pb1500	2003-09-27 14:07:03.000000000 +0200
@@ -71,6 +71,7 @@
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
+CONFIG_NEW_TIME_C=y
 CONFIG_PCI=y
 CONFIG_NEW_PCI=y
 CONFIG_PCI_AUTO=y
@@ -690,6 +691,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -1046,6 +1048,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-rbtx4927 linux-2.4.22/arch/mips/defconfig-rbtx4927
--- linux-2.4.22.clean/arch/mips/defconfig-rbtx4927	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/arch/mips/defconfig-rbtx4927	2003-09-10 02:17:31.000000000 +0200
@@ -0,0 +1,602 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+CONFIG_MIPS=y
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# Machine selection
+#
+# CONFIG_ACER_PICA_61 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_COGENT_CSB250 is not set
+# CONFIG_BAGET_MIPS is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_HP_LASERJET is not set
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MAGNUM_4000 is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_NEC_OSPREY is not set
+# CONFIG_NEC_EAGLE is not set
+# CONFIG_OLIVETTI_M700 is not set
+# CONFIG_NINO is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TANBAC_TB0226 is not set
+# CONFIG_TANBAC_TB0229 is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+CONFIG_TOSHIBA_RBTX4927=y
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_NEW_TIME_C=y
+CONFIG_PCI=y
+CONFIG_NEW_PCI=y
+CONFIG_PCI_AUTO=y
+CONFIG_SWAP_IO_SPACE_W=y
+CONFIG_SWAP_IO_SPACE_L=y
+CONFIG_ISA=y
+CONFIG_NONCOHERENT_IO=y
+CONFIG_DUMMY_KEYB=y
+# CONFIG_MIPS_AU1000 is not set
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32 is not set
+# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+CONFIG_CPU_TX49XX=y
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_CPU_ADVANCED=y
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_LLDSCD=y
+CONFIG_CPU_HAS_WB=y
+CONFIG_CPU_HAS_SYNC=y
+
+#
+# General setup
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_NET=y
+# CONFIG_PCI_NAMES is not set
+CONFIG_EISA=y
+# CONFIG_TC is not set
+# CONFIG_MCA is not set
+# CONFIG_SBUS is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+# CONFIG_HOTPLUG_PCI is not set
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_MIPS32_COMPAT is not set
+# CONFIG_MIPS32_O32 is not set
+# CONFIG_MIPS32_N32 is not set
+# CONFIG_BINFMT_ELF32 is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_FILTER is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+# CONFIG_PHONE_IXJ is not set
+# CONFIG_PHONE_IXJ_PCMCIA is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+# CONFIG_IDE is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_PCI is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_AC3200 is not set
+# CONFIG_APRICOT is not set
+# CONFIG_B44 is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_TULIP is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_DGRS is not set
+# CONFIG_DM9102 is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_EEPRO100_PIO is not set
+# CONFIG_E100 is not set
+# CONFIG_LNE390 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_NE3210 is not set
+# CONFIG_ES3210 is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_SUNDANCE_MMIO is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_RHINE_MMIO is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_LAN_SAA9730 is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Input core support
+#
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_ESPSERIAL is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+CONFIG_SERIAL_TXX9=y
+CONFIG_SERIAL_TXX9_CONSOLE=y
+# CONFIG_SERIAL_TX3912 is not set
+# CONFIG_SERIAL_TX3912_CONSOLE is not set
+# CONFIG_TXX927_SERIAL is not set
+# CONFIG_TXX927_SERIAL_CONSOLE is not set
+# CONFIG_UNIX98_PTYS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_MIPS_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_TMPFS is not set
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_EXT2_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Kernel hacking
+#
+CONFIG_CROSSCOMPILE=y
+# CONFIG_RUNTIME_DEBUG is not set
+# CONFIG_KGDB is not set
+# CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_MIPS_UNCACHED is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+# CONFIG_ZLIB_INFLATE is not set
+# CONFIG_ZLIB_DEFLATE is not set
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-rm200 linux-2.4.22/arch/mips/defconfig-rm200
--- linux-2.4.22.clean/arch/mips/defconfig-rm200	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-rm200	2003-09-27 14:07:03.000000000 +0200
@@ -498,6 +498,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-sb1250-swarm linux-2.4.22/arch/mips/defconfig-sb1250-swarm
--- linux-2.4.22.clean/arch/mips/defconfig-sb1250-swarm	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-sb1250-swarm	2003-09-27 14:07:03.000000000 +0200
@@ -607,6 +607,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_SB1XXX_CORELIS is not set
 # CONFIG_MAGIC_SYSRQ is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-sead linux-2.4.22/arch/mips/defconfig-sead
--- linux-2.4.22.clean/arch/mips/defconfig-sead	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-sead	2003-09-27 14:07:03.000000000 +0200
@@ -377,6 +377,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-tb0226 linux-2.4.22/arch/mips/defconfig-tb0226
--- linux-2.4.22.clean/arch/mips/defconfig-tb0226	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-tb0226	2003-09-27 14:07:03.000000000 +0200
@@ -790,6 +790,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-tb0229 linux-2.4.22/arch/mips/defconfig-tb0229
--- linux-2.4.22.clean/arch/mips/defconfig-tb0229	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-tb0229	2003-09-27 14:07:03.000000000 +0200
@@ -630,6 +630,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-ti1500 linux-2.4.22/arch/mips/defconfig-ti1500
--- linux-2.4.22.clean/arch/mips/defconfig-ti1500	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-ti1500	2003-09-27 14:07:03.000000000 +0200
@@ -71,6 +71,7 @@
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
+CONFIG_NEW_TIME_C=y
 CONFIG_PCI=y
 CONFIG_NEW_PCI=y
 CONFIG_PCI_AUTO=y
@@ -621,6 +622,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -972,6 +974,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-workpad linux-2.4.22/arch/mips/defconfig-workpad
--- linux-2.4.22.clean/arch/mips/defconfig-workpad	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-workpad	2003-09-27 14:07:03.000000000 +0200
@@ -613,6 +613,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/defconfig-xxs1500 linux-2.4.22/arch/mips/defconfig-xxs1500
--- linux-2.4.22.clean/arch/mips/defconfig-xxs1500	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/defconfig-xxs1500	2003-09-27 14:07:03.000000000 +0200
@@ -71,6 +71,7 @@
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
+CONFIG_NEW_TIME_C=y
 CONFIG_PCI=y
 CONFIG_NEW_PCI=y
 CONFIG_PCI_AUTO=y
@@ -664,6 +665,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -879,6 +881,7 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/burner.c linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/burner.c
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/burner.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/burner.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,230 +0,0 @@
-/*
- *  arch/mips/galileo/compressed/burner.c
- *
- *  By RidgeRun Inc (Leveraged from Galileo's main.c, misc.c, etc).
- *
- *  Burn image from ram to flash
- *  For use with Galileo EVB64120A MIPS eval board.
- */
-#include <asm/types.h>
-#include <asm/byteorder.h>
-#include <asm/galileo-boards/evb64120A/eeprom_param.h>
-#include <asm/galileo-boards/evb64120A/flashdrv.h>
-
-#define IMAGEOFFSET 0x00300000
-
-static void burn_image_from_memory(void);
-static char *sprintf(char *buf, const char *fmt, ...);
-static void printf(const char *fmt, ...);
-
-unsigned int FlashSize;
-
-/******************************
- Routine:
- Description:
- ******************************/
-int main(void)
-{
-	printf("\n");
-	printf("\n");
-	printf("\n");
-	printf("\n");
-	printf("       +--------------------+\n");
-	printf("       |                    |\n");
-	printf("       | Flash Burn Utility |\n");
-	printf("       |                    |\n");
-	printf("       +--------------------+\n");
-	printf("\n");
-	printf("Please send your *.srec image to the parallel port\n");
-	printf("\n");
-	printf("Note: The *.srec image should be setup to\n");
-	printf("      load into address 0xa0300000 where\n");
-	printf("      it will then be transferred to flash\n");
-	printf("\n");
-
-	SET_REG_BITS(0x468, BIT20);	// Set Flash to be 16 bit wide
-	FlashSize = flashInit(0xbf000000, 2, X16);
-
-	galileo_dl();		// read in the users *.srec image.
-	burn_image_from_memory();	// put it in flash.
-
-	printf("\n");
-	printf("\n");
-	printf("+---------------+\n");
-	printf("|     Done      |\n");
-	printf("|(please reboot)|\n");
-	printf("+---------------+\n");
-	printf("\n");
-
-	while (1) {
-	}
-	return 0;
-}
-
-/******************************
- Routine:
- Description:
- ******************************/
-static void burn_image_from_memory(void)
-{
-	unsigned int count, delta, temp, temp1;
-	unsigned int to_sector, last_sector;
-
-	/* Find how many sectors needed to be erased */
-	to_sector = flashInWhichSector(FlashSize - 4);	// skranz, modified.
-	if (to_sector == 0xffffffff) {
-		printf
-		    ("Flash Burning Error - Flash too small - Cannot burn image\n");	// skranz, modified.
-		return;
-	}
-
-	/* Which is the last sector */
-	last_sector = flashInWhichSector(FlashSize - 4);
-	delta = 0;
-	printf("\nErasing first %d sectors\n", to_sector);
-	for (count = 0; count < to_sector + 1; count++) {
-		printf("Erasing sector %d\n", count);
-		flashEraseSector(count);
-	}
-	printf("flash region size = %d\n", FlashSize);	// skranz, added
-	printf("Sdram IMAGEOFFSET = %d\n", IMAGEOFFSET);	// skranz, added
-
-	printf("Burning from Sdram to %d mark; full burn.\n", FlashSize);
-	for (count = 0; count < (FlashSize - delta); count = count + 4) {
-		flashWriteWord(count,
-			       *(unsigned int *) ((count | NONE_CACHEABLE)
-						  + IMAGEOFFSET));	// skranz, modified.
-		temp = flashReadWord(count);
-		temp1 = *(unsigned int *) ((count | NONE_CACHEABLE) + IMAGEOFFSET);	// skranz, modified.
-		if (((unsigned int) temp) != ((unsigned int) temp1)) {
-			printf
-			    ("Burning error at address %X : flash(%X) sdram(%X)\n",
-			     count, flashReadWord(count),
-			     *(unsigned int *) ((count | NONE_CACHEABLE) + IMAGEOFFSET));	// skranz, modified.
-			printf("Aborting Prematurally.\n");
-			break;
-		}
-	}
-	printf("Finished burning Image\n");
-}
-
-/******************************
- Routine:
- Description:
-	Formats:
-		%X	- 4 byte ASCII (8 hex digits)
-		%x	- 2 byte ASCII (4 hex digits)
-		%b	- 1 byte ASCII (2 hex digits)
-		%d	- decimal (also %i)
-		%c	- ASCII char
-		%s	- ASCII string
-		%I	- Internet address in x.x.x.x notation
- ******************************/
-static char hex[] = "0123456789ABCDEF";
-static char *do_printf(char *buf, const char *fmt, const int *dp)
-{
-	register char *p;
-	char tmp[16];
-	while (*fmt) {
-		if (*fmt == '%') {	/* switch() uses more space */
-			fmt++;
-
-			if (*fmt == 'X') {
-				const long *lp = (const long *) dp;
-				register long h = *lp++;
-				dp = (const int *) lp;
-				*(buf++) = hex[(h >> 28) & 0x0F];
-				*(buf++) = hex[(h >> 24) & 0x0F];
-				*(buf++) = hex[(h >> 20) & 0x0F];
-				*(buf++) = hex[(h >> 16) & 0x0F];
-				*(buf++) = hex[(h >> 12) & 0x0F];
-				*(buf++) = hex[(h >> 8) & 0x0F];
-				*(buf++) = hex[(h >> 4) & 0x0F];
-				*(buf++) = hex[h & 0x0F];
-			}
-			if (*fmt == 'x') {
-				register int h = *(dp++);
-				*(buf++) = hex[(h >> 12) & 0x0F];
-				*(buf++) = hex[(h >> 8) & 0x0F];
-				*(buf++) = hex[(h >> 4) & 0x0F];
-				*(buf++) = hex[h & 0x0F];
-			}
-			if (*fmt == 'b') {
-				register int h = *(dp++);
-				*(buf++) = hex[(h >> 4) & 0x0F];
-				*(buf++) = hex[h & 0x0F];
-			}
-			if ((*fmt == 'd') || (*fmt == 'i')) {
-				register int dec = *(dp++);
-				p = tmp;
-				if (dec < 0) {
-					*(buf++) = '-';
-					dec = -dec;
-				}
-				do {
-					*(p++) = '0' + (dec % 10);
-					dec = dec / 10;
-				} while (dec);
-				while ((--p) >= tmp)
-					*(buf++) = *p;
-			}
-			if (*fmt == 'I') {
-				union {
-					long l;
-					unsigned char c[4];
-				} u;
-				const long *lp = (const long *) dp;
-				u.l = *lp++;
-				dp = (const int *) lp;
-				buf = sprintf(buf, "%d.%d.%d.%d",
-					      u.c[0], u.c[1], u.c[2],
-					      u.c[3]);
-			}
-			if (*fmt == 'c')
-				*(buf++) = *(dp++);
-			if (*fmt == 's') {
-				p = (char *) *dp++;
-				while (*p)
-					*(buf++) = *p++;
-			}
-		} else
-			*(buf++) = *fmt;
-		fmt++;
-	}
-	*buf = 0;
-	return (buf);
-}
-
-/******************************
- Routine:
- Description:
- ******************************/
-static char *sprintf(char *buf, const char *fmt, ...)
-{
-	return do_printf(buf, fmt, ((const int *) &fmt) + 1);
-}
-
-/******************************
- Routine:
- Description:
- ******************************/
-void putchar(int c)
-{
-	if (c == '\n') {
-		serial_putc('\r');
-	}
-	serial_putc(c);
-}
-
-/******************************
- Routine:
- Description:
- ******************************/
-static void printf(const char *fmt, ...)
-{
-	char buf[256], *p;
-	p = buf;
-	do_printf(buf, fmt, ((const int *) &fmt) + 1);
-	while (*p)
-		putchar(*p++);
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/doit.c linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/doit.c
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/doit.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/doit.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-/*
- *    By RidgeRun Inc.
- *
- *    The input to this program is intended to be
- *    a compressed linux kernel. The output of this
- *    program is then a constructed *.S file which
- *    defines a large data structure -- the contents
- *    of which represent the compressed kernel which
- *    can subsequently be used in a program designed
- *    to access that struture for decompression at
- *    runtime and then subsequent kernel bootup.
- *
- *    Example Usage:
- *       ./doit < piggy.gz > piggy.S
- *
- */
-
-#include <stdio.h>
-
-void printval(int i)
-{
-	int tth, th, h, t, d;
-
-	if (i > 99999) {
-		printf("Error - printval outofbounds\n");
-		return;
-	}
-
-	tth = 0;
-	th = 0;
-	//tth = (i) / 10000;
-	//th  = (i - (tth * 10000)) / 1000;
-	h = (i - ((tth * 10000) + (th * 1000))) / 100;
-	t = (i - ((tth * 10000) + (th * 1000) + (h * 100))) / 10;
-	d = (i - ((tth * 10000) + (th * 1000) + (h * 100) + (t * 10)));
-	//putchar(tth + '0');
-	//putchar(th + '0');
-	putchar(h + '0');
-	putchar(t + '0');
-	putchar(d + '0');
-}
-
-main(int argc, char **argv)
-{
-	int val;
-	int size = 0;
-	unsigned char c;
-
-	printf("gcc2_compiled.:\n");
-	printf("__gnu_compiled_c:\n");
-	printf("\t.globl linux_compressed_start\n");
-	printf("\t.text\n");
-	printf("\t.align 2\n");
-	printf("\t.type linux_compressed_start,@object\n");
-	printf("linux_compressed_start:\n");
-
-
-	val = getchar();
-	while (val != EOF) {
-		size++;
-		c = (unsigned char) (val & 0x00ff);
-		printf("\t.byte  ");
-		printval((int) c);
-		printf("\n");
-		val = getchar();
-	}
-	printf("\t.size linux_compressed_start,%d\n", size);
-	printf("\t.globl linux_compressed_size\n");
-	printf("\t.text\n");
-	printf("\t.align 2\n");
-	printf("\t.type linux_compressed_size,@object\n");
-	printf("\t.size linux_compressed_size,4\n");
-	printf("linux_compressed_size:\n");
-	printf("\t.word %d\n", size);
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/etherboot.h linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/etherboot.h
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/etherboot.h	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/etherboot.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,566 +0,0 @@
-/**************************************************************************
-ETHERBOOT -  BOOTP/TFTP Bootstrap Program
-
-Author: Martin Renters
-  Date: Dec/93
-
-**************************************************************************/
-
-#include "osdep.h"
-
-/* These could be customised for different languages perhaps */
-#define	ASK_PROMPT	"Boot from (N)etwork or from (L)ocal? "
-#define	ANS_NETWORK	'N'
-#define	ANS_LOCAL	'L'
-#ifndef	ANS_DEFAULT		/* in case left out in Makefile */
-#define	ANS_DEFAULT	ANS_NETWORK
-#endif
-
-#define	TAGGED_IMAGE		/* eventually optional */
-#if	!defined(TAGGED_IMAGE) && !defined(AOUT_IMAGE) && !defined(ELF_IMAGE)
-#define	TAGGED_IMAGE		/* choose at least one */
-#endif
-
-#define ESC		0x1B
-
-#ifndef	DEFAULT_BOOTFILE
-#define DEFAULT_BOOTFILE	"/tftpboot/kernel"
-#endif
-
-/* Clean up console settings... mainly CONSOLE_CRT and CONSOLE_SERIAL are used
- * in the sources (except start.S and serial.S which cannot include
- * etherboot.h).  At least one of the CONSOLE_xxx has to be set, and
- * CONSOLE_DUAL sets both CONSOLE_CRT and CONSOLE_SERIAL.  If none is set,
- * CONSOLE_CRT is assumed.  */
-#ifdef	CONSOLE_DUAL
-#undef CONSOLE_CRT
-#define CONSOLE_CRT
-#undef CONSOLE_SERIAL
-#define CONSOLE_SERIAL
-#endif
-#if	defined(CONSOLE_CRT) && defined(CONSOLE_SERIAL)
-#undef CONSOLE_DUAL
-#define CONSOLE_DUAL
-#endif
-#if	!defined(CONSOLE_CRT) && !defined(CONSOLE_SERIAL)
-#define CONSOLE_CRT
-#endif
-
-#ifndef	DOWNLOAD_PROTO_NFS
-#undef DOWNLOAD_PROTO_TFTP
-#define DOWNLOAD_PROTO_TFTP	/* default booting protocol */
-#endif
-
-#ifdef	DOWNLOAD_PROTO_TFTP
-#define download(fname,loader) tftp((fname),(loader))
-#endif
-#ifdef	DOWNLOAD_PROTO_NFS
-#define download(fname,loader) nfs((fname),(loader))
-#endif
-
-#ifndef	MAX_TFTP_RETRIES
-#define MAX_TFTP_RETRIES	20
-#endif
-
-#ifndef	MAX_BOOTP_RETRIES
-#define MAX_BOOTP_RETRIES	20
-#endif
-
-#ifndef	MAX_BOOTP_EXTLEN
-#if	(RELOC < 0x94000)
-/* Force internal buffer (if external buffer would overlap with our code...) */
-#undef INTERNAL_BOOTP_DATA
-#define INTERNAL_BOOTP_DATA
-#endif
-/* sizeof(struct bootp_t) == 0x240 */
-#if	defined(INTERNAL_BOOTP_DATA) || (RELOC >= 0x94240)
-#define MAX_BOOTP_EXTLEN	1024
-#else
-#define MAX_BOOTP_EXTLEN	(1024-sizeof(struct bootp_t))
-#endif
-#endif
-
-#ifndef	MAX_ARP_RETRIES
-#define MAX_ARP_RETRIES		20
-#endif
-
-#ifndef	MAX_RPC_RETRIES
-#define MAX_RPC_RETRIES		20
-#endif
-
-#define	TICKS_PER_SEC		18
-
-/* Inter-packet retry in ticks */
-#define TIMEOUT			(10*TICKS_PER_SEC)
-
-/* These settings have sense only if compiled with -DCONGESTED */
-/* total retransmission timeout in ticks */
-#define TFTP_TIMEOUT		(30*TICKS_PER_SEC)
-/* packet retransmission timeout in ticks */
-#define TFTP_REXMT		(3*TICKS_PER_SEC)
-
-#ifndef	NULL
-#define NULL	((void *)0)
-#endif
-
-#define TRUE		1
-#define FALSE		0
-
-#define ETHER_ADDR_SIZE		6	/* Size of Ethernet address */
-#define ETHER_HDR_SIZE		14	/* Size of ethernet header */
-#define ETH_MIN_PACKET		64
-#define ETH_MAX_PACKET		1518
-
-#define VENDOR_NONE	0
-#define VENDOR_WD	1
-#define VENDOR_NOVELL	2
-#define VENDOR_3COM	3
-#define VENDOR_3C509	4
-#define VENDOR_CS89x0	5
-
-#define FLAG_PIO	0x01
-#define FLAG_16BIT	0x02
-#define FLAG_790	0x04
-
-#define ARP_CLIENT	0
-#define ARP_SERVER	1
-#define ARP_GATEWAY	2
-#define ARP_ROOTSERVER	3
-#define ARP_SWAPSERVER	4
-#define MAX_ARP		ARP_SWAPSERVER+1
-
-#define	RARP_REQUEST	3
-#define	RARP_REPLY	4
-
-#define IP		0x0800
-#define ARP		0x0806
-#define	RARP		0x8035
-
-#define BOOTP_SERVER	67
-#define BOOTP_CLIENT	68
-#define TFTP_PORT	69
-#define SUNRPC_PORT	111
-
-#define IP_UDP		17
-/* Same after going through htonl */
-#define IP_BROADCAST	0xFFFFFFFF
-
-#define ARP_REQUEST	1
-#define ARP_REPLY	2
-
-#define BOOTP_REQUEST	1
-#define BOOTP_REPLY	2
-
-#define TAG_LEN(p)		(*((p)+1))
-#define RFC1533_COOKIE		99, 130, 83, 99
-#define RFC1533_PAD		0
-#define RFC1533_NETMASK		1
-#define RFC1533_TIMEOFFSET	2
-#define RFC1533_GATEWAY		3
-#define RFC1533_TIMESERVER	4
-#define RFC1533_IEN116NS	5
-#define RFC1533_DNS		6
-#define RFC1533_LOGSERVER	7
-#define RFC1533_COOKIESERVER	8
-#define RFC1533_LPRSERVER	9
-#define RFC1533_IMPRESSSERVER	10
-#define RFC1533_RESOURCESERVER	11
-#define RFC1533_HOSTNAME	12
-#define RFC1533_BOOTFILESIZE	13
-#define RFC1533_MERITDUMPFILE	14
-#define RFC1533_DOMAINNAME	15
-#define RFC1533_SWAPSERVER	16
-#define RFC1533_ROOTPATH	17
-#define RFC1533_EXTENSIONPATH	18
-#define RFC1533_IPFORWARDING	19
-#define RFC1533_IPSOURCEROUTING	20
-#define RFC1533_IPPOLICYFILTER	21
-#define RFC1533_IPMAXREASSEMBLY	22
-#define RFC1533_IPTTL		23
-#define RFC1533_IPMTU		24
-#define RFC1533_IPMTUPLATEAU	25
-#define RFC1533_INTMTU		26
-#define RFC1533_INTLOCALSUBNETS	27
-#define RFC1533_INTBROADCAST	28
-#define RFC1533_INTICMPDISCOVER	29
-#define RFC1533_INTICMPRESPOND	30
-#define RFC1533_INTROUTEDISCOVER 31
-#define RFC1533_INTROUTESOLICIT	32
-#define RFC1533_INTSTATICROUTES	33
-#define RFC1533_LLTRAILERENCAP	34
-#define RFC1533_LLARPCACHETMO	35
-#define RFC1533_LLETHERNETENCAP	36
-#define RFC1533_TCPTTL		37
-#define RFC1533_TCPKEEPALIVETMO	38
-#define RFC1533_TCPKEEPALIVEGB	39
-#define RFC1533_NISDOMAIN	40
-#define RFC1533_NISSERVER	41
-#define RFC1533_NTPSERVER	42
-#define RFC1533_VENDOR		43
-#define RFC1533_NBNS		44
-#define RFC1533_NBDD		45
-#define RFC1533_NBNT		46
-#define RFC1533_NBSCOPE		47
-#define RFC1533_XFS		48
-#define RFC1533_XDM		49
-#ifndef	NO_DHCP_SUPPORT
-#define RFC2132_REQ_ADDR	50
-#define RFC2132_MSG_TYPE	53
-#define RFC2132_SRV_ID		54
-#define RFC2132_PARAM_LIST	55
-#define RFC2132_MAX_SIZE	57
-
-#define DHCPDISCOVER		1
-#define DHCPOFFER		2
-#define DHCPREQUEST		3
-#define DHCPACK			5
-#endif				/* NO_DHCP_SUPPORT */
-
-#define RFC1533_VENDOR_MAJOR	0
-#define RFC1533_VENDOR_MINOR	0
-
-#define RFC1533_VENDOR_MAGIC	128
-#define RFC1533_VENDOR_ADDPARM	129
-#ifdef	IMAGE_FREEBSD
-#define RFC1533_VENDOR_HOWTO    132
-#endif
-#define RFC1533_VENDOR_MNUOPTS	160
-#define RFC1533_VENDOR_SELECTION 176
-#define RFC1533_VENDOR_MOTD	184
-#define RFC1533_VENDOR_NUMOFMOTD 8
-#define RFC1533_VENDOR_IMG	192
-#define RFC1533_VENDOR_NUMOFIMG	16
-
-#define RFC1533_END		255
-#define BOOTP_VENDOR_LEN	64
-#ifndef	NO_DHCP_SUPPORT
-#define DHCP_OPT_LEN		312
-#endif				/* NO_DHCP_SUPPORT */
-
-#define	TFTP_DEFAULTSIZE_PACKET	512
-#define	TFTP_MAX_PACKET		1432	/* 512 */
-
-#define TFTP_RRQ	1
-#define TFTP_WRQ	2
-#define TFTP_DATA	3
-#define TFTP_ACK	4
-#define TFTP_ERROR	5
-#define TFTP_OACK	6
-
-#define TFTP_CODE_EOF	1
-#define TFTP_CODE_MORE	2
-#define TFTP_CODE_ERROR	3
-#define TFTP_CODE_BOOT	4
-#define TFTP_CODE_CFG	5
-
-#define AWAIT_ARP	0
-#define AWAIT_BOOTP	1
-#define AWAIT_TFTP	2
-#define AWAIT_RARP	3
-#define AWAIT_RPC	4
-#define AWAIT_QDRAIN	5	/* drain queue, process ARP requests */
-
-typedef struct {
-	unsigned long s_addr;
-} in_addr;
-
-struct arptable_t {
-	in_addr ipaddr;
-	unsigned char node[6];
-};
-
-/*
- * A pity sipaddr and tipaddr are not longword aligned or we could use
- * in_addr. No, I don't want to use #pragma packed.
- */
-struct arprequest {
-	unsigned short hwtype;
-	unsigned short protocol;
-	char hwlen;
-	char protolen;
-	unsigned short opcode;
-	char shwaddr[6];
-	char sipaddr[4];
-	char thwaddr[6];
-	char tipaddr[4];
-};
-
-struct iphdr {
-	char verhdrlen;
-	char service;
-	unsigned short len;
-	unsigned short ident;
-	unsigned short frags;
-	char ttl;
-	char protocol;
-	unsigned short chksum;
-	in_addr src;
-	in_addr dest;
-};
-
-struct udphdr {
-	unsigned short src;
-	unsigned short dest;
-	unsigned short len;
-	unsigned short chksum;
-};
-
-struct bootp_t {
-	struct iphdr ip;
-	struct udphdr udp;
-	char bp_op;
-	char bp_htype;
-	char bp_hlen;
-	char bp_hops;
-	unsigned long bp_xid;
-	unsigned short bp_secs;
-	unsigned short unused;
-	in_addr bp_ciaddr;
-	in_addr bp_yiaddr;
-	in_addr bp_siaddr;
-	in_addr bp_giaddr;
-	char bp_hwaddr[16];
-	char bp_sname[64];
-	char bp_file[128];
-#ifdef	NO_DHCP_SUPPORT
-	char bp_vend[BOOTP_VENDOR_LEN];
-#else
-	char bp_vend[DHCP_OPT_LEN];
-#endif				/* NO_DHCP_SUPPORT */
-};
-
-struct bootpd_t {
-	struct bootp_t bootp_reply;
-	unsigned char bootp_extension[MAX_BOOTP_EXTLEN];
-};
-
-struct tftp_t {
-	struct iphdr ip;
-	struct udphdr udp;
-	unsigned short opcode;
-	union {
-		char rrq[TFTP_DEFAULTSIZE_PACKET];
-		struct {
-			unsigned short block;
-			char download[TFTP_MAX_PACKET];
-		} data;
-		struct {
-			unsigned short block;
-		} ack;
-		struct {
-			unsigned short errcode;
-			char errmsg[TFTP_DEFAULTSIZE_PACKET];
-		} err;
-		struct {
-			char data[TFTP_DEFAULTSIZE_PACKET + 2];
-		} oack;
-	} u;
-};
-
-#define TFTP_MIN_PACKET	(sizeof(struct iphdr) + sizeof(struct udphdr) + 4)
-
-struct rpc_t {
-	struct iphdr ip;
-	struct udphdr udp;
-	union {
-		char data[300];	/* longest RPC call must fit!!!! */
-		struct {
-			long id;
-			long type;
-			long rpcvers;
-			long prog;
-			long vers;
-			long proc;
-			long data[1];
-		} call;
-		struct {
-			long id;
-			long type;
-			long rstatus;
-			long verifier;
-			long v2;
-			long astatus;
-			long data[1];
-		} reply;
-	} u;
-};
-
-#define PROG_PORTMAP	100000
-#define PROG_NFS	100003
-#define PROG_MOUNT	100005
-
-#define MSG_CALL	0
-#define MSG_REPLY	1
-
-#define PORTMAP_GETPORT	3
-
-#define MOUNT_ADDENTRY	1
-#define MOUNT_UMOUNTALL	4
-
-#define NFS_LOOKUP	4
-#define NFS_READ	6
-
-#define NFS_FHSIZE	32
-
-#define NFSERR_PERM	1
-#define NFSERR_NOENT	2
-#define NFSERR_ACCES	13
-
-/* Block size used for NFS read accesses.  A RPC reply packet (including  all
- * headers) must fit within a single Ethernet frame to avoid fragmentation.
- * Chosen to be a power of two, as most NFS servers are optimized for this.  */
-#define NFS_READ_SIZE	1024
-
-#define	FLOPPY_BOOT_LOCATION	0x7c00
-
-#define	ROM_INFO_LOCATION	0x7dfa
-/* at end of floppy boot block */
-
-struct rom_info {
-	unsigned short rom_segment;
-	unsigned short rom_length;
-};
-
-/***************************************************************************
-External prototypes
-***************************************************************************/
-/* main.c */
-extern void print_bytes P((unsigned char *bytes, int len));
-extern void load P((void));
-extern int load_linux P((int root_mount_port, int swap_mount_port,
-			 int root_nfs_port, char *kernel_handle));
-extern int downloadkernel P((unsigned char *, int, int, int));
-extern int tftp
-P((const char *name, int (*)(unsigned char *, int, int, int)));
-extern void rpc_init(void);
-extern int nfs
-P((const char *name, int (*)(unsigned char *, int, int, int)));
-extern void nfs_umountall P((int));
-extern int bootp P((void));
-extern int rarp P((void));
-extern int udp_transmit P((unsigned long destip, unsigned int srcsock,
-			   unsigned int destsock, int len,
-			   const void *buf));
-
-extern int await_reply P((int type, int ival, void *ptr, int timeout));
-extern int decode_rfc1533 P((unsigned char *, int, int, int));
-extern unsigned short ipchksum P((unsigned short *, int len));
-extern void rfc951_sleep P((int));
-extern void cleanup_net P((void));
-extern void cleanup P((void));
-
-/* config.c */
-extern void print_config(void);
-extern void eth_reset(void);
-extern int eth_probe(void);
-extern int eth_poll(void);
-extern void eth_transmit(const char *d, unsigned int t, unsigned int s,
-			 const void *p);
-extern void eth_disable(void);
-
-/* bootmenu.c */
-extern int execute P((char *string));
-extern void bootmenu P((int));
-extern void show_motd P((void));
-extern void parse_menuopts P((char *, int));
-extern int getoptvalue P((char **, int *, int *));
-extern void selectImage P((char **));
-
-/* osloader.c */
-#if	defined(AOUT_IMAGE) || defined(ELF_IMAGE)
-extern int howto;
-#endif
-extern int os_download P((unsigned int, unsigned char *, unsigned int));
-
-/* misc.c */
-extern void twiddle P((void));
-extern void sleep P((int secs));
-extern int strcasecmp P((char *a, char *b));
-extern char *substr P((char *a, char *b));
-extern int getdec P((char **));
-extern void printf P((const char *, ...));
-extern char *sprintf P((char *, const char *, ...));
-extern int inet_aton P((char *p, in_addr * i));
-extern void gateA20_set P((void));
-extern void gateA20_unset P((void));
-extern void putchar P((int));
-extern int getchar P((void));
-extern int iskey P((void));
-
-/* start*.S */
-extern int getc P((void));
-extern void putc P((int));
-extern int ischar P((void));
-extern int getshift P((void));
-extern unsigned int memsize P((void));
-extern unsigned short basememsize P((void));
-extern void disk_init P((void));
-extern unsigned int disk_read P((int drv, int c, int h, int s, char *buf));
-extern void xstart P((unsigned long, unsigned long, char *));
-extern unsigned long currticks P((void));
-extern int setjmp P((void *jmpbuf));
-extern void longjmp P((void *jmpbuf, int where));
-extern void exit P((int status));
-extern void slowdownio P((void));
-
-/* serial.S */
-extern int serial_getc P((void));
-extern void serial_putc P((int));
-extern int serial_ischar P((void));
-extern int serial_init P((void));
-
-/* ansiesc.c */
-extern void ansi_reset P((void));
-extern void enable_cursor P((int));
-extern void handleansi P((unsigned char));
-
-/* md5.c */
-extern void md5_put P((unsigned int ch));
-extern void md5_done P((unsigned char *buf));
-
-/* floppy.c */
-extern int bootdisk P((int dev, int part));
-
-/***************************************************************************
-External variables
-***************************************************************************/
-/* main.c */
-extern const char *kernel;
-extern char kernel_buf[128];
-extern struct rom_info rom;
-extern int hostnamelen;
-extern unsigned long netmask;
-extern int jmp_bootmenu[10];
-extern struct arptable_t arptable[MAX_ARP];
-#ifdef	IMAGE_MENU
-extern char *motd[RFC1533_VENDOR_NUMOFMOTD];
-extern int menutmo, menudefault;
-extern unsigned char *defparams;
-extern int defparams_max;
-#endif
-#if	defined(ETHERBOOT32) && !defined(INTERNAL_BOOTP_DATA)
-#define	BOOTP_DATA_ADDR	((struct bootpd_t *)0x93C00)
-#else
-extern struct bootpd_t bootp_data;
-#define	BOOTP_DATA_ADDR	(&bootp_data)
-#endif
-extern unsigned char *end_of_rfc1533;
-#ifdef	IMAGE_FREEBSD
-extern int freebsd_howto;
-#endif
-
-/* config.c */
-extern struct nic nic;
-
-/* bootmenu.c */
-
-/* osloader.c */
-
-/* created by linker */
-extern char _start[], _edata[], _end[];
-
-/*
- * Local variables:
- *  c-basic-offset: 8
- * End:
- */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/evb64120A_Setup.c linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/evb64120A_Setup.c
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/evb64120A_Setup.c	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/evb64120A_Setup.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,197 +0,0 @@
-/*
- *  arch/mips/galileo/compressed/evb64120A_memSetup.c
- *
- *  By RidgeRun Inc, (Leveraged from Galileo's sbd.c)
- *
- *  Xfer an image from flash to ram.
- *  For use with Galileo EVB64120A MIPS eval board.
- */
-#include "ns16550.h"
-#include <linux/serial_reg.h>
-#include <asm/galileo-boards/evb64120A/pci.h>
-#include <asm/galileo-boards/evb64120A/core.h>
-
-void XferToRam(void);
-bool mapMemoryBanks0and1(unsigned int bank0Base, unsigned int bank0Length,
-			 unsigned int bank1Base, unsigned int bank1Length);
-bool mapMemoryBanks2and3(unsigned int bank2Base, unsigned int bank2Length,
-			 unsigned int bank3Base, unsigned int bank3Length);
-bool mapDevices0_1and2MemorySpace(unsigned int device0Base,
-				  unsigned int device0Length,
-				  unsigned int device1Base,
-				  unsigned int device1Length,
-				  unsigned int device2Base,
-				  unsigned int device2Length);
-
-#define RUNNINGFROMFLASH
-#include "./xfer.c"
-
-/******************************
- Routine:
- Description:
- ******************************/
-unsigned int readWord(unsigned int addr)
-{
-	unsigned int tmp;
-	tmp = *(unsigned int *) (addr | NONE_CACHEABLE);
-	return WORDSWAP(tmp);
-}
-
-/******************************
- Routine:
- Description:
- ******************************/
-void writeWord(unsigned int addr, unsigned int data)
-{
-	*((unsigned int *) (addr | NONE_CACHEABLE)) = WORDSWAP(data);
-}
-
-/******************************
- Routine:
- Description:
- ******************************/
-unsigned int GetExtendedMemorySize(void)
-{
-	unsigned int address, data = 0x11223344, type;
-	unsigned int bank1_ef = false, bank2_ef = false, bank3_ef = false;
-	unsigned int bank0_size, bank2_size, bank3_size, total_size = 0;
-
-	mapMemoryBanks0and1(0, 0x800000, 0x800000, 0x800000);
-	mapMemoryBanks2and3(0x1000000, 0x800000, 0x1800000, 0x800000);
-	type = readWord(0x14000810);
-	switch (type) {
-	case 16:
-		bank0_size = 0x1000000;
-		break;
-	case 64:
-		bank0_size = 0x4000000;
-		break;
-	case 128:
-		bank0_size = 0x8000000;
-		break;
-	case 256:
-		bank0_size = 0x10000000;
-		break;
-	default:
-		bank0_size = 0x1000000;
-		break;
-	}
-
-	type = readWord(0x14000814);
-	switch (type) {
-	case 16:
-		bank2_size = 0x1000000;
-		bank3_size = 0x1000000;
-		break;
-	case 64:
-		bank2_size = 0x4000000;
-		bank3_size = 0x4000000;
-		break;
-	case 128:
-		bank2_size = 0x8000000;
-		bank3_size = 0x8000000;
-		break;
-	case 256:
-		bank2_size = 0x10000000;
-		bank3_size = 0x10000000;
-		break;
-	default:
-		bank2_size = 0x1000000;
-		bank3_size = 0x1000000;
-		break;
-	}
-
-	/* Check which banks exist */
-	/* Bank 1 */
-	for (address = 0xffff00; address < 0x1000000; address += 4)
-		writeWord(address, data);
-	for (address = 0xffff00; address < 0x1000000; address += 4) {
-		if (readWord(address) != data)
-			break;
-	}
-	if (address == 0x1000000)
-		bank1_ef = true;
-	// Bank 2
-	for (address = 0x17fff00; address < 0x1800000; address += 4)
-		writeWord(address, data);
-	for (address = 0x17fff00; address < 0x1800000; address += 4) {
-		if (readWord(address) != data)
-			break;
-	}
-	if (address == 0x1800000)
-		bank2_ef = true;
-	else
-		bank2_size = 0x0;
-	// Bank 3
-	for (address = 0x1ffff00; address < 0x2000000; address += 4)
-		writeWord(address, data);
-	for (address = 0x1ffff00; address < 0x2000000; address += 4) {
-		if (readWord(address) != data)
-			break;
-	}
-	if (address == 0x2000000)
-		bank3_ef = true;
-
-	// Reconfig the system with the new bank0 (and maybe bank1) size.
-	if (bank0_size == 0x10000000)
-		bank1_ef = false;
-	if (bank1_ef == true) {
-		mapMemoryBanks0and1(0, bank0_size, bank0_size, bank0_size);
-		// Fix the PCI bars
-		pci0MapMemoryBanks0_1(0, bank0_size * 2);
-		pci1MapMemoryBanks0_1(0, bank0_size * 2);
-		total_size += bank0_size * 2;
-	} else {
-		mapMemoryBanks0and1(0, bank0_size, bank0_size, 0);
-		// Fix the PCI bars
-		pci0MapMemoryBanks0_1(0, bank0_size);
-		pci1MapMemoryBanks0_1(0, bank0_size);
-		total_size += bank0_size;
-	}
-	if (total_size == 0x10000000) {
-		bank2_ef = false;
-		bank3_ef = false;
-	} else {
-		if ((total_size + bank2_size) > 0x10000000) {
-			bank2_size = 0x10000000 - total_size;
-			bank3_ef = false;
-		} else {
-			if (bank3_size + total_size + bank2_size >
-			    0x10000000) {
-				bank3_size =
-				    0x10000000 - (total_size + bank2_size);
-			}
-		}
-	}
-	if (bank2_ef == true) {
-		if (bank3_ef == true) {
-			mapMemoryBanks2and3(total_size, bank2_size,
-					    total_size + bank2_size,
-					    bank3_size);
-			// Fix the PCI bars
-			pci0MapMemoryBanks2_3(total_size,
-					      bank2_size + bank3_size);
-			pci1MapMemoryBanks2_3(total_size,
-					      bank2_size + bank3_size);
-			total_size += (bank2_size + bank3_size);
-		} else {
-			mapMemoryBanks2and3(total_size, bank2_size,
-					    total_size + bank2_size, 0);
-			// Fix the PCI bars
-			pci0MapMemoryBanks2_3(total_size, bank2_size);
-			pci1MapMemoryBanks2_3(total_size, bank2_size);
-			total_size += bank2_size;
-		}
-	} else {
-		mapMemoryBanks2and3(total_size, 0, total_size, 0);
-		pci0MapMemoryBanks2_3(total_size, 0);
-		pci1MapMemoryBanks2_3(total_size, 0);
-	}
-	/* Reorganize the devices memory map */
-	mapDevices0_1and2MemorySpace(0x1c000000, 0x800000, 0x1a000000,
-				     0xc00000, 0x1d000000, 0x800000);
-
-	XferToRam();
-	return 0;		// Not that we'll ever get to this line of code, but
-	// it does satisfy a compiler warning.
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/fixit linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/fixit
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/fixit	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/fixit	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-#!/bin/ksh
-
-# By RidgeRun Inc.
-#
-# The input to this script is
-# intended to be a *.S file which
-# was previously created by the doit
-# program. That program constructs
-# a *.S file which has a defined data
-# table containing values with leading
-# zeroes. To satisfy our assembler those
-# leading zeroes need to be stripped off
-# and that is the purpose of this script.
-
-echo "Removing leading zeros"
-sed -e "s/ 0\(.\)/ \1/g" $1 | sed -e "s/ 0\(.\)/ \1/g" > $1.new
-mv $1.new $1
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/flashdrv.c linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/flashdrv.c
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/flashdrv.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/flashdrv.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1560 +0,0 @@
-/* flashdrv.c - FLASH memory functions and definitions*/
-
-/* Copyright Galileo Technology. */
-
-/*
-DESCRIPTION
-This flash driver gives the user a convenient interface to FLASH memory located
-on the user`s board, it supports various layout configurations such as:
-1. One pure 8 bit device (Such as AMD`s AM29LV040B).
-2. 1,2,4 or 8 devices 16 bit wide configured to operate in 8 bit mode.
-3. 1,2 or 4 devices each 16 bit wide.
-Before using the driver you must call the initialization function at least once
-or when ever you are changing the FLASH base address.
-The list bellow contains the supported FLASH memory devices, new devices can be
-added easily in the future.
-*/
-
-/*includes*/
-#ifdef __linux__
-#include <asm/galileo-boards/evb64120A/flashdrv.h>
-#else
-#include "flashdrv.h"
-#endif
-/* locals */
-
-#ifdef __MIPSEB__		// skranz, add
-#define BE			// skranz, add
-#endif				// skranz, add
-
-/******************************************************************************
-* Those two tables contain the supported flash devices information needed by
-* the driver:
-* The first table "flashParametrs" starts with 10 shared fields
-*  (currently 6 are reserved):
-*   index 0 => Pointer to an entry in the second table list
-*   index 1 => baseAddress - Flash memory device base address.
-*   index 2 => width - 1, 2, 4 or 8 Bytes.
-*   index 3 => mode - PURE8, X8 or X16 flash configuration (for X16 devices only)
-* The second table (flashTypes) contains:
-* Entry`s structure:
-*   Manufacture ID,Device ID,number of sectors,list of sector`s sizes
-*   (in Kbytes starting with sector number 0).
-* The end of the list is pointed with a zero.
-******************************************************************************/
-unsigned int flashParametrs[10];	/* 0  Entry pointer */
-				 /* 0  Base address  */
-				 /* 0  Width         */
-				 /* 0  Mode          */
-				 /* 0,0,0,0,0,0, spare entries. */
-unsigned int flashTypes[] = {
-
-	/* 0 */ AMD_FLASH, AM29F400BB, 11, 16, 8, 8, 32, 64, 64, 64, 64,
-	    64, 64, 64,
-	/* 1 */ AMD_FLASH, AM29F400BT, 11, 64, 64, 64, 64, 64, 64, 64, 32,
-	    8, 8, 16,
-	/* 2 */ ST_FLASH, M29W040, 8, 64, 64, 64, 64, 64, 64, 64, 64,
-	/* 3 */ AMD_FLASH, AM29LV040B, 8, 64, 64, 64, 64, 64, 64, 64, 64,
-	/* 4 */ AMD_FLASH, AM29LV800BT, 19, 64, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64,
-	64, 64, 64, 64, 64, 32, 8, 8, 16,
-	/* 5 */ INTEL_FLASH, I28F320J3A, 32, 128, 128, 128, 128, 128, 128,
-	    128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128,
-	/* 6 */ INTEL_FLASH, I28F640J3A, 64, 128, 128, 128, 128, 128, 128,
-	    128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128,
-	/* 7 */ INTEL_FLASH, I28F128J3A, 128, 128, 128, 128, 128, 128, 128,
-	    128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
-	/* 8 */ AMD_FLASH, AM29LV400BB, 11, 16, 8, 8, 32, 64, 64, 64, 64,
-	    64, 64, 64,
-	/* 9 */ AMD_FLASH, AM29LV400BT, 11, 64, 64, 64, 64, 64, 64, 64, 32,
-	    8, 8, 16,
-	/* 10 */ INTEL_FLASH, I28F320B3_T, 71, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 8, 8, 8, 8, 8, 8, 8, 8,
-	/* 11 */ INTEL_FLASH, I28F320B3_B, 71, 8, 8, 8, 8, 8, 8, 8, 8, 64,
-	    64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	/* 12 */ INTEL_FLASH, I28F160B3_B, 39, 8, 8, 8, 8, 8, 8, 8, 8, 64,
-	    64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64,
-	/* 13 */ INTEL_FLASH, I28F160B3_T, 39, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 8, 8, 8, 8, 8, 8, 8, 8,
-
-	0			/* End of list indicator */
-};
-
-/********************************************************************
-* flashInit - Initializes the FLASH memory driver`s parameters, this function
-*             must be called at least once before using the FLASH memory.
-*             If you are changing the FLASH base address call this function
-*             again.
-*
-* INPUTS:     unsigned int flashBaseAddress - The flash base Address.
-*             unsigned int flashWidth - Flash bus width in Bytes: 1,2,4 or 8.
-*             flashMode - PURE8, X8 or X16.
-* RETURNS:    Flash Size, zero when operation (flashInit) failed.
-*********************************************************************/
-unsigned int flashInit(unsigned int flashBaseAddress,
-		       unsigned int flashWidth, FLASHmode flashMode)
-{
-	unsigned short mfrId = 0;
-	unsigned short devId = 0xffff;
-	unsigned int FirstAddr, SecondAddr, ThirdAddr;
-	unsigned int pArray = 0;
-	unsigned int counter;
-	unsigned int flashSize = 0;
-
-	/* update the list with relevant parametrs */
-	flashParametrs[0] = 0;	/* Default initialization */
-	flashParametrs[1] = flashBaseAddress;
-	flashParametrs[2] = flashWidth;
-	flashParametrs[3] = flashMode;
-	/* Get the FLASH`s ID */
-	switch (FLASH_WIDTH) {
-	case 1:
-		/* AMD or ST ?? * */
-		if (flashMode == PURE8) {	/* Boot Flash */
-			FirstAddr = 0x5555;
-			SecondAddr = 0x2aaa;
-			ThirdAddr = 0x5555;
-		} else {	/* X16 device configured to 8bit Mode */
-
-			FirstAddr = 0xaaaa;
-			SecondAddr = 0x5555;
-			ThirdAddr = 0xaaaa;
-		}
-		flashReset();
-		WRITE_CHAR(FLASH_BASE_ADDRESS + FirstAddr, 0xAA);
-		WRITE_CHAR(FLASH_BASE_ADDRESS + SecondAddr, 0x55);
-		WRITE_CHAR(FLASH_BASE_ADDRESS + ThirdAddr, 0x90);
-		READ_CHAR(FLASH_BASE_ADDRESS + 0x0, &mfrId);
-		if (mfrId == AMD_FLASH || mfrId == ST_FLASH) {
-			flashReset();
-			WRITE_CHAR(FLASH_BASE_ADDRESS + FirstAddr, 0xAA);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + SecondAddr, 0x55);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + ThirdAddr, 0x90);
-			READ_CHAR(FLASH_BASE_ADDRESS + 0x1, &devId);
-			break;
-		}
-		/* Micron or Intel ?? * */
-		WRITE_CHAR(FLASH_BASE_ADDRESS, 0xff);	/* Read Array */
-		/* Flash reset for Intel/Micron */
-		WRITE_CHAR(FLASH_BASE_ADDRESS, 0x90);	/* IDENTIFY Device */
-		READ_CHAR(FLASH_BASE_ADDRESS + 0x0, &mfrId);	/*Address for ManufactureID */
-		if (mfrId == INTEL_FLASH || mfrId == MICRON_FLASH) {
-			WRITE_CHAR(FLASH_BASE_ADDRESS, 0xff);	/* Read Array */
-			/*Flash reset for Intel/Micron */
-			WRITE_CHAR(FLASH_BASE_ADDRESS, 0x90);	/* IDENTIFY Device */
-			READ_CHAR(FLASH_BASE_ADDRESS + 0x1, &devId);	/*Address for DeviceID */
-		}
-		break;
-	case 2:
-	case 4:
-	case 8:
-		/* AMD or ST ??? */
-		flashReset();
-		WRITE_SHORT(FLASH_BASE_ADDRESS + 0x5555 * FLASH_WIDTH,
-			    0xaa);
-		WRITE_SHORT(FLASH_BASE_ADDRESS + 0x2aaa * FLASH_WIDTH,
-			    0x55);
-		WRITE_SHORT(FLASH_BASE_ADDRESS + 0x5555 * FLASH_WIDTH,
-			    0x90);
-		READ_SHORT(FLASH_BASE_ADDRESS, &mfrId);
-		flashReset();
-		/* Read the device ID */
-		if (mfrId == AMD_FLASH || mfrId == ST_FLASH) {
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    0x5555 * FLASH_WIDTH, 0xaa);
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    0x2aaa * FLASH_WIDTH, 0x55);
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    0x5555 * FLASH_WIDTH, 0x90);
-			READ_SHORT(FLASH_BASE_ADDRESS + 0x1 * FLASH_WIDTH,
-				   &devId);
-			break;
-		}
-		/* Micron or Intel ?? * */
-		WRITE_WORD(FLASH_BASE_ADDRESS, 0x00ff00ff);
-		WRITE_WORD(FLASH_BASE_ADDRESS, 0x00900090);
-		if ((FLASH_WIDTH == 4) || (FLASH_WIDTH == 8)) {	/* 32 or 64 bit */
-			READ_SHORT(FLASH_BASE_ADDRESS, &mfrId);
-		} else {	/* FLASH_WIDTH = 2 */
-
-			READ_SHORT(FLASH_BASE_ADDRESS, &mfrId);
-		}
-		if ((mfrId == INTEL_FLASH) || (mfrId == MICRON_FLASH)) {
-			/* Flash reset for Intel/Micron */
-			flashReset();
-			WRITE_WORD(FLASH_BASE_ADDRESS, 0x00ff00ff);
-			WRITE_WORD(FLASH_BASE_ADDRESS, 0x00900090);
-			READ_SHORT(FLASH_BASE_ADDRESS + 0x1 * FLASH_WIDTH,
-				   &devId);
-		}
-		break;
-
-	}
-	/* Try to locate the device in the supported flashes list (FLASH_TYPE).
-	   according to the keys:
-	   1) mfrId - manufactor ID.
-	   2) devId - device ID.
-	 */
-
-	while (true) {
-		if (flashTypes[pArray] == 0) {
-			flashReset();
-			return 0;	/* Device not in the list */
-		}
-		if ((flashTypes[pArray] == mfrId) &&
-		    (flashTypes[pArray + 1] == devId)) {
-			POINTER_TO_FLASH = pArray;
-			for (counter = 0;
-			     counter < flashTypes[NUMBER_OF_SECTORS];
-			     counter++) {
-				flashSize =
-				    flashSize +
-				    flashTypes[FIRST_SECTOR_SIZE +
-					       counter];
-			}
-			if (FLASH_MODE != PURE8) {
-				flashReset();
-				return (flashSize * _1K *
-					(FLASH_WIDTH / (FLASH_MODE / 8)));
-			} else {
-				flashReset();
-				return (flashSize * _1K * FLASH_WIDTH);
-			}
-		}
-		pArray += (3 + flashTypes[pArray + 2]);	/* Move to next entry */
-	}
-}
-
-/********************************************************************
-* flashReset - Resets the Flash memory (FLASH`s internal protocol reset).
-*
-* INTPUTS:  N/A
-* OUTPUT:   N/A
-*********************************************************************/
-void flashReset()
-{
-	unsigned char ucData;
-	unsigned short usData;
-	unsigned int uiData;
-
-	if ((flashTypes[POINTER_TO_FLASH] == AMD_FLASH) ||
-	    (flashTypes[POINTER_TO_FLASH]) == ST_FLASH) {
-		if (FLASH_MODE == X16) {
-			ucData = 0xf0;
-			usData = 0xf0;
-			uiData = 0x00f000f0;
-		} else {	/* case of PURE8 or X8 */
-
-			ucData = 0xf0;
-			usData = 0xf0f0;
-			uiData = 0xf0f0f0f0;
-		}
-	} else {
-		if (FLASH_MODE == X16) {
-			ucData = 0xff;
-			usData = 0xff;
-			uiData = 0x00ff00ff;
-		} else {	/* case of PURE8 or X8 */
-
-			ucData = 0xff;
-			usData = 0xffff;
-			uiData = 0xffffffff;
-		}
-	}
-	switch (FLASH_WIDTH) {
-	case 1:
-		WRITE_CHAR(FLASH_BASE_ADDRESS, ucData);
-		break;
-	case 2:
-		WRITE_SHORT(FLASH_BASE_ADDRESS, usData);
-		break;
-	case 4:
-		WRITE_WORD(FLASH_BASE_ADDRESS, uiData);
-		break;
-	case 8:
-		WRITE_WORD(FLASH_BASE_ADDRESS, uiData);
-		WRITE_WORD(FLASH_BASE_ADDRESS + 0x4, uiData);
-		break;
-	}
-}
-
-/********************************************************************
-* flashErase - The function erases the WHOLE flash memory.
-*
-*
-* RETURNS: true on success,false on failure
-*********************************************************************/
-bool flashErase()
-{
-	unsigned int totalFlashSize;
-	unsigned int address;
-	unsigned int readData;
-	unsigned int nextSector;
-
-	flashReset();
-	totalFlashSize = flashGetSize();
-	/* scan all flash memory space. */
-	address = 0;
-	while (address < totalFlashSize) {
-		readData = flashReadWord(address);
-		if (readData != 0xffffffff) {	/* offset with dirty data. */
-			flashEraseSector(flashInWhichSector(address));
-			nextSector = flashInWhichSector(address) + 1;
-			if (nextSector < flashTypes[NUMBER_OF_SECTORS])
-				/* jump to next sector. */
-				address = flashGetSectorOffset(nextSector);
-			else
-				/* end of erasing. */
-				address = totalFlashSize;
-		} else
-			address += 4;
-	}
-	return true;
-}
-
-/********************************************************************
-* flashEraseSector - The function erases a specific sector in the flash memory.
-*
-* INPUTS:  Sector number.
-* RETURNS: true on success,false on failure.
-*********************************************************************/
-bool flashEraseSector(unsigned int sectorNumber)
-{
-	volatile unsigned int spin;
-	unsigned int regValue;
-	unsigned int sectorBaseAddress = 0;
-	unsigned int i;
-	unsigned int data20, dataD0, data70;
-	unsigned int dataPoll;
-	unsigned int FirstAddr, SecondAddr, ThirdAddr, FourthAddr,
-	    FifthAddr;
-	unsigned int FirstData, SecondData, ThirdData;
-	unsigned int FourthData, FifthData, SixthData;
-
-	/* calculate the sector base Address according to the following parametrs:
-	   1: FLASH_WIDTH
-	   2: the size of each sector which it detailed in the table */
-
-	/* checking the if the sectorNumber is legal. */
-	if (sectorNumber > flashTypes[NUMBER_OF_SECTORS] - 1)
-		return false;
-	/* now the calculation begining of the sector Address */
-	for (i = 0; i < sectorNumber; i++) {
-		sectorBaseAddress =
-		    sectorBaseAddress + flashTypes[FIRST_SECTOR_SIZE + i];
-	}
-	/* In case of X8 wide the address should be */
-	if (FLASH_MODE == PURE8)
-		sectorBaseAddress = _1K * sectorBaseAddress;
-	if (FLASH_MODE == X8)
-		sectorBaseAddress = _1K * sectorBaseAddress;
-	/* In case of X16 wide the address should be */
-	if (FLASH_MODE == X16)
-		sectorBaseAddress = _1K * sectorBaseAddress / 2;
-	flashReset();
-	if ((flashTypes[POINTER_TO_FLASH] == AMD_FLASH) || \
-	    (flashTypes[POINTER_TO_FLASH] == ST_FLASH)) {
-		switch (FLASH_WIDTH) {
-		case 1:
-			if (FLASH_MODE == PURE8) {	/* Boot Flash PURE8 */
-				FirstAddr = 0x5555;
-				SecondAddr = 0x2aaa;
-				ThirdAddr = 0x5555;
-				FourthAddr = 0x5555;
-				FifthAddr = 0x2aaa;
-			} else {
-				FirstAddr = 0xaaaa;
-				SecondAddr = 0x5555;
-				ThirdAddr = 0xaaaa;
-				FourthAddr = 0xaaaa;
-				FifthAddr = 0x5555;
-			}
-			WRITE_CHAR(FLASH_BASE_ADDRESS + FirstAddr, 0xAA);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + SecondAddr, 0x55);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + ThirdAddr, 0x80);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + FourthAddr, 0xAA);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + FifthAddr, 0x55);
-			WRITE_CHAR(
-				   (FLASH_BASE_ADDRESS +
-				    (sectorBaseAddress & 0xffffff00)),
-				   0x30);
-			/* Poll on the flash */
-			do {
-				READ_CHAR(FLASH_BASE_ADDRESS +
-					  sectorBaseAddress, &regValue);
-			} while ((regValue & 0x80) != 0x80);
-
-			break;
-		case 2:
-			if (FLASH_MODE == X16) {
-				FirstData = 0xaa;	/* Data for the First  Cycle */
-				SecondData = 0x55;	/* Data for the Second Cycle */
-				ThirdData = 0x80;	/* Data for the Third  Cycle */
-				FourthData = 0xaa;	/* Data for the Fourth Cycle */
-				FifthData = 0x55;	/* Data for the Fifth  Cycle */
-				SixthData = 0x30;	/* Data for the Sixth  Cycle */
-				FirstAddr = 0x5555;	/* Address for the First  Cycle */
-				SecondAddr = 0x2aaa;	/* Address for the Second Cycle */
-				ThirdAddr = 0x5555;	/* Address for the Third  Cycle */
-				FourthAddr = 0x5555;	/* Address for the Fourth Cycle */
-				FifthAddr = 0x2aaa;	/* Address for the Fifth  Cycle */
-			} else {	/* (FLASH_MODE = 8) */
-
-				FirstData = 0xaaaa;	/* Data for the First  Cycle */
-				SecondData = 0x5555;	/* Data for the Second Cycle */
-				ThirdData = 0x8080;	/* Data for the Third  Cycle */
-				FourthData = 0xaaaa;	/* Data for the Fourth Cycle */
-				FifthData = 0x5555;	/* Data for the Fifth  Cycle */
-				SixthData = 0x3030;	/* Data for the Sixth  Cycle */
-				FirstAddr = 0xaaaa;	/* Address for the First  Cycle */
-				SecondAddr = 0x5555;	/* Address for the Second Cycle */
-				ThirdAddr = 0xaaaa;	/* Address for the Third  Cycle */
-				FourthAddr = 0xaaaa;	/* Address for the Fourth Cycle */
-				FifthAddr = 0x5555;	/* Address for the Fifth  Cycle */
-			}
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    FirstAddr * FLASH_WIDTH, FirstData);
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    SecondAddr * FLASH_WIDTH, SecondData);
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    ThirdAddr * FLASH_WIDTH, ThirdData);
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    FourthAddr * FLASH_WIDTH, FourthData);
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    FifthAddr * FLASH_WIDTH, FifthData);
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    (sectorBaseAddress & 0xffffff00) *
-				    FLASH_WIDTH, SixthData);
-			/* Poll on the flash */
-			if (FLASH_MODE == X16) {	/* 1 device of 16 bit */
-				dataPoll = 0x0080;
-			} else {	/* (FLASH_MODE = 8) ==> 2 devices , 8 bit each => 16bit */
-
-				dataPoll = 0x8080;
-			}
-			do {
-				READ_SHORT(FLASH_BASE_ADDRESS +
-					   sectorBaseAddress * FLASH_WIDTH,
-					   &regValue);
-				for (spin = 0; spin < 100; spin++) {
-				}	// skranz, added spin loop.
-			} while ((regValue & dataPoll) != dataPoll);
-			break;
-		case 4:
-			if (FLASH_MODE == X16) {
-				FirstData = 0x00aa00aa;	/* Data for the First  Cycle */
-				SecondData = 0x00550055;	/* Data for the Second Cycle */
-				ThirdData = 0x00800080;	/* Data for the Third  Cycle */
-				FourthData = 0x00aa00aa;	/* Data for the Fourth Cycle */
-				FifthData = 0x00550055;	/* Data for the Fifth  Cycle */
-				SixthData = 0x00300030;	/* Data for the Sixth  Cycle */
-				FirstAddr = 0x5555;	/* Address for the First  Cycle */
-				SecondAddr = 0x2aaa;	/* Address for the Second Cycle */
-				ThirdAddr = 0x5555;	/* Address for the Third  Cycle */
-				FourthAddr = 0x5555;	/* Address for the Fourth Cycle */
-				FifthAddr = 0x2aaa;	/* Address for the Fifth  Cycle */
-			} else {	/* if (FLASH_MODE == 8) */
-
-				FirstData = 0xaaaaaaaa;	/* Data for the First  Cycle */
-				SecondData = 0x55555555;	/* Data for the Second Cycle */
-				ThirdData = 0x80808080;	/* Data for the Third  Cycle */
-				FourthData = 0xAAAAAAAA;	/* Data for the Fourth Cycle */
-				FifthData = 0x55555555;	/* Data for the Fifth  Cycle */
-				SixthData = 0x30303030;	/* Data for the Sixth  Cycle */
-				FirstAddr = 0xaaaa;	/* Address for the First  Cycle */
-				SecondAddr = 0x5555;	/* Address for the Second Cycle */
-				ThirdAddr = 0xaaaa;	/* Address for the Third  Cycle */
-				FourthAddr = 0xaaaa;	/* Address for the Fourth Cycle */
-				FifthAddr = 0x5555;	/* Address for the Fifth  Cycle */
-			}
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   FirstAddr * FLASH_WIDTH, FirstData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   SecondAddr * FLASH_WIDTH, SecondData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   ThirdAddr * FLASH_WIDTH, ThirdData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   FourthAddr * FLASH_WIDTH, FourthData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   FifthAddr * FLASH_WIDTH, FifthData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   (sectorBaseAddress & 0xffffff00) *
-				   FLASH_WIDTH, SixthData);
-			/* Poll on the flash */
-			if (FLASH_MODE == X16) {	/* 4 devices , 16 bit each => 64bit */
-				dataPoll = 0x00800080;
-			} else {	/* (FLASH_MODE = 8) ==> 8 devices , 8 bit each => 64bit */
-
-				dataPoll = 0x80808080;
-			}
-			do {
-				READ_WORD(FLASH_BASE_ADDRESS +
-					  sectorBaseAddress * FLASH_WIDTH,
-					  &regValue);
-			} while ((regValue & dataPoll) != dataPoll);
-			break;
-		case 8:	/* In case of 64bit width the transformation is 1->8 */
-			if (FLASH_MODE == X16) {
-				FirstData = 0x00aa00aa;	/* Data for the First  Cycle */
-				SecondData = 0x00550055;	/* Data for the Second Cycle */
-				ThirdData = 0x00800080;	/* Data for the Third  Cycle */
-				FourthData = 0x00aa00aa;	/* Data for the Fourth Cycle */
-				FifthData = 0x00550055;	/* Data for the Fifth  Cycle */
-				SixthData = 0x00300030;	/* Data for the Sixth  Cycle */
-				FirstAddr = 0x5555;	/* Address for the First  Cycle */
-				SecondAddr = 0x2aaa;	/* Address for the Second Cycle */
-				ThirdAddr = 0x5555;	/* Address for the Third  Cycle */
-				FourthAddr = 0x5555;	/* Address for the Fourth Cycle */
-				FifthAddr = 0x2aaa;	/* Address for the Fifth  Cycle */
-			} else {	/* (FLASH_MODE = 8 */
-
-				FirstData = 0xaaaaaaaa;	/* Data for the First  Cycle */
-				SecondData = 0x55555555;	/* Data for the Second Cycle */
-				ThirdData = 0x80808080;	/* Data for the Third  Cycle */
-				FourthData = 0xAAAAAAAA;	/* Data for the Fourth Cycle */
-				FifthData = 0x55555555;	/* Data for the Fifth  Cycle */
-				SixthData = 0x30303030;	/* Data for the Sixth  Cycle */
-				FirstAddr = 0xaaaa;	/* Address for the First  Cycle */
-				SecondAddr = 0x5555;	/* Address for the Second Cycle */
-				ThirdAddr = 0xaaaa;	/* Address for the Third  Cycle */
-				FourthAddr = 0xaaaa;	/* Address for the Fourth Cycle */
-				FifthAddr = 0x5555;	/* Address for the Fifth  Cycle */
-			}
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   FirstAddr * FLASH_WIDTH, FirstData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   SecondAddr * FLASH_WIDTH, SecondData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   ThirdAddr * FLASH_WIDTH, ThirdData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   FourthAddr * FLASH_WIDTH, FourthData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   FifthAddr * FLASH_WIDTH, FifthData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   (sectorBaseAddress & 0xffffff00) *
-				   FLASH_WIDTH, SixthData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   FirstAddr * FLASH_WIDTH + 4, FirstData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   SecondAddr * FLASH_WIDTH + 4,
-				   SecondData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   ThirdAddr * FLASH_WIDTH + 4, ThirdData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   FourthAddr * FLASH_WIDTH + 4,
-				   FourthData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   FifthAddr * FLASH_WIDTH + 4, FifthData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   (sectorBaseAddress & 0xffffff00)
-				   * FLASH_WIDTH + 4, SixthData);
-			/* Poll on the flash */
-			if (FLASH_MODE == X16) {	/* 4 devices , 16 bit each => 64bit */
-				dataPoll = 0x00800080;
-			} else {	/* (FLASH_MODE = 8) ==> 8 devices , 8 bit each => 64bit */
-
-				dataPoll = 0x80808080;
-			}
-			do {
-				READ_WORD(FLASH_BASE_ADDRESS +
-					  sectorBaseAddress * FLASH_WIDTH,
-					  &regValue);
-			} while ((regValue & dataPoll) != dataPoll);
-			do {
-				READ_WORD(FLASH_BASE_ADDRESS +
-					  sectorBaseAddress * FLASH_WIDTH +
-					  4, &regValue);
-			} while ((regValue & dataPoll) != dataPoll);
-			break;
-		default:
-			return false;
-		}
-	} /* End of 'flash erase sector' for AMD/ST */
-	else {			/* Intel/Micron */
-
-		switch (FLASH_WIDTH) {
-		case 1:
-			WRITE_CHAR(FLASH_BASE_ADDRESS, 0x20);
-			WRITE_CHAR(
-				   (FLASH_BASE_ADDRESS +
-				    (sectorBaseAddress & 0xffffff00)),
-				   0xd0);
-			/* Poll on the flash */
-			while (true) {
-				WRITE_CHAR(FLASH_BASE_ADDRESS, 0x70);
-				READ_CHAR(FLASH_BASE_ADDRESS, &regValue);
-				if ((regValue & 0x80) == 0x80)
-					break;
-			}
-			break;
-		case 2:
-			if (FLASH_MODE == X16) {	/* 1 device 16 bit.  */
-				data20 = 0x0020;;
-				dataD0 = 0x00d0;;
-			} else {	/* (FLASH_MODE = 8) ==> 2 devices , 8 bit each => 16bit */
-
-				data20 = 0x2020;
-				dataD0 = 0xd0d0;
-			}
-			WRITE_SHORT(FLASH_BASE_ADDRESS, data20);
-			WRITE_SHORT(
-				    (FLASH_BASE_ADDRESS +
-				     ((sectorBaseAddress * 2) &
-				      0xffffff00)), dataD0);
-			/* Poll on the flash */
-			if (FLASH_MODE == X16) {
-				dataPoll = 0x0080;
-				data70 = 0x0070;
-			} else {	/* (FLASH_MODE = 8) */
-
-				dataPoll = 0x8080;
-				data70 = 0x7070;
-			}
-			while (true) {
-				WRITE_SHORT(FLASH_BASE_ADDRESS +
-					    sectorBaseAddress * 2, data70);
-				READ_SHORT(FLASH_BASE_ADDRESS +
-					   sectorBaseAddress * 2,
-					   &regValue);
-				if ((regValue & 0x0080) == 0x0080)
-					break;
-			}
-			break;
-		case 4:
-			if (FLASH_MODE == X16) {	/* 2 devices , 16 bit each => 32bit */
-				data20 = 0x00200020;
-				dataD0 = 0x00d000d0;
-			} else {	/* (FLASH_MODE = 8) ==> 4 devices , 8 bit each => 32bit */
-
-				data20 = 0x20202020;
-				dataD0 = 0xd0d0d0d0;
-			}
-			WRITE_WORD(FLASH_BASE_ADDRESS, data20);
-			WRITE_WORD(
-				   (FLASH_BASE_ADDRESS +
-				    ((sectorBaseAddress * 4) &
-				     0xffffff00)), dataD0);
-			/* Poll on the flash */
-			if (FLASH_MODE == X16) {
-				dataPoll = 0x0080;
-				data70 = 0x0070;
-			} else {	/* (FLASH_MODE = 8) */
-
-				dataPoll = 0x8080;
-				data70 = 0x7070;
-			}
-			while (true) {
-				WRITE_SHORT(FLASH_BASE_ADDRESS, data70);
-				READ_SHORT(FLASH_BASE_ADDRESS, &regValue);
-				if ((regValue & dataPoll) == dataPoll)
-					break;
-			}
-			while (true) {
-				WRITE_SHORT(FLASH_BASE_ADDRESS + 2,
-					    data70);
-				READ_SHORT(FLASH_BASE_ADDRESS + 2,
-					   &regValue);
-				if ((regValue & dataPoll) == dataPoll)
-					break;
-			}
-			break;
-		case 8:
-			if (FLASH_MODE == X16) {	/* 4 devices , 16 bit each => 64bit */
-				data20 = 0x00200020;
-				dataD0 = 0x00d000d0;
-			} else {	/* (FLASH_MODE = 8) ==> 8 devices , 8 bit each => 64bit */
-
-				data20 = 0x20202020;
-				dataD0 = 0xd0d0d0d0;
-			}
-			WRITE_WORD(FLASH_BASE_ADDRESS, data20);
-			WRITE_WORD(
-				   (FLASH_BASE_ADDRESS +
-				    ((sectorBaseAddress * 8) &
-				     0xffffff00)), dataD0);
-			WRITE_WORD(FLASH_BASE_ADDRESS + 4, data20);
-			WRITE_WORD(
-				   (FLASH_BASE_ADDRESS +
-				    ((sectorBaseAddress * 8) & 0xffffff00 +
-				     4)), dataD0);
-			/* Poll on the flash */
-			if (FLASH_MODE == X16) {
-				dataPoll = 0x0080;
-				data70 = 0x0070;
-			} else {	/* (FLASH_MODE = 8) */
-
-				dataPoll = 0x8080;
-				data70 = 0x7070;
-			}
-			while (true) {
-				WRITE_SHORT(FLASH_BASE_ADDRESS +
-					    sectorBaseAddress * 8, data70);
-				READ_SHORT(FLASH_BASE_ADDRESS +
-					   sectorBaseAddress * 8,
-					   &regValue);
-				if ((regValue & dataPoll) == dataPoll)
-					break;
-			}
-			while (true) {
-				WRITE_SHORT(FLASH_BASE_ADDRESS + 2,
-					    data70);
-				READ_SHORT(FLASH_BASE_ADDRESS + 2,
-					   &regValue);
-				if ((regValue & dataPoll) == dataPoll)
-					break;
-			}
-			while (true) {
-				WRITE_SHORT(FLASH_BASE_ADDRESS + 4,
-					    data70);
-				READ_SHORT(FLASH_BASE_ADDRESS + 4,
-					   &regValue);
-				if ((regValue & dataPoll) == dataPoll)
-					break;
-			}
-			while (true) {
-				WRITE_SHORT(FLASH_BASE_ADDRESS + 6,
-					    data70);
-				READ_SHORT(FLASH_BASE_ADDRESS + 6,
-					   &regValue);
-				if ((regValue & dataPoll) == dataPoll)
-					break;
-			}
-			break;
-		default:
-			return false;
-		}
-	}
-	flashReset();
-	return true;
-}
-
-/********************************************************************
-* flashWriteWord - Write 32Bit to the FLASH memory at the given offset from the
-*                  FLASH base address.
-*   			   address 0 = 0x00000000 !!
-*				   Attention!!! data "0" cannot be programed back to
-*                  "1" (only by first performing an earase operation).
-*                  The function takes care of Big/Little endian conversion
-*
-* INPUTS:  offset - The offset from the flash`s base address.
-*          data   - The data that should be written.
-* RETURNS: true on success,false on failure
-*********************************************************************/
-bool flashWriteWord(unsigned int offset, unsigned int data)
-{
-	unsigned char c, rc;
-	unsigned short s, rs;
-	register unsigned int rw;
-	register unsigned int regValue;
-	register unsigned int FirstAddr, SecondAddr, ThirdAddr;
-	register unsigned int FirstData, SecondData, ThirdData;
-	register unsigned int data10, data20, data70, data80;
-
-	if ((flashTypes[POINTER_TO_FLASH] == AMD_FLASH) || \
-	    (flashTypes[POINTER_TO_FLASH] == ST_FLASH)) {
-		switch (FLASH_WIDTH) {
-		case 1:	/* Split the 32 bit write into four 8bit Writings */
-			if (FLASH_MODE == PURE8) {	/* Boot Flash */
-				FirstAddr = 0x5555;
-				SecondAddr = 0x2aaa;
-				ThirdAddr = 0x5555;
-			} else {
-				FirstAddr = 0xaaaa;
-				SecondAddr = 0x5555;
-				ThirdAddr = 0xaaaa;
-			}
-			WRITE_CHAR(FLASH_BASE_ADDRESS + FirstAddr, 0xaa);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + SecondAddr, 0x55);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + ThirdAddr, 0xa0);
-#ifdef BE
-			c = (data >> 24);
-#else
-			c = data;
-#endif
-			WRITE_CHAR(FLASH_BASE_ADDRESS + offset, c);
-			/* Writing first Byte */
-			while (true) {
-				READ_CHAR(FLASH_BASE_ADDRESS + offset,
-					  &rc);
-				if ((rc & 0x80) == (c & 0x80))	/* DQ7 =? DATA */
-					break;	/* DQ7 =  DATA */
-				if ((rc & 0x20) == 0x20) {	/* DQ5 =? '1'  */
-					READ_CHAR(FLASH_BASE_ADDRESS +
-						  offset, &rc);
-					if ((rc & 0x80) == (c & 0x80))
-						break;	/* DQ7 = DATA  */
-					else
-						return false;	/* DQ7 != DATA */
-				}
-			}
-			WRITE_CHAR(FLASH_BASE_ADDRESS + FirstAddr, 0xaa);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + SecondAddr, 0x55);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + ThirdAddr, 0xa0);
-#ifdef BE
-			c = (data >> 16);
-#else
-			c = (data >> 8);
-#endif
-			WRITE_CHAR(FLASH_BASE_ADDRESS + offset + 1, c);
-			/* Writing second Byte */
-			while (true) {
-				READ_CHAR(FLASH_BASE_ADDRESS + offset + 1,
-					  &rc);
-				if ((rc & 0x80) == (c & 0x80))	/* DQ7 =? DATA */
-					break;	/* DQ7 = DATA  */
-				if ((rc & 0x20) == 0x20) {	/* DQ5 =? '1'  */
-					READ_CHAR(FLASH_BASE_ADDRESS +
-						  offset + 1, &rc);
-					if ((rc & 0x80) == (c & 0x80))
-						break;	/* DQ7 = DATA  */
-					else
-						return false;	/* DQ7 != DATA */
-				}
-			}
-			WRITE_CHAR(FLASH_BASE_ADDRESS + FirstAddr, 0xaa);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + SecondAddr, 0x55);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + ThirdAddr, 0xa0);
-#ifdef BE
-			c = (data >> 8);
-#else
-			c = (data >> 16);
-#endif
-			WRITE_CHAR(FLASH_BASE_ADDRESS + offset + 2, c);
-			/* Writing third Byte */
-			while (true) {
-				READ_CHAR(FLASH_BASE_ADDRESS + offset + 2,
-					  &rc);
-				if ((rc & 0x80) == (c & 0x80))	/* DQ7 =? DATA */
-					break;	/* DQ7 = DATA  */
-				if ((rc & 0x20) == 0x20) {	/* DQ5 =? '1'  */
-					READ_CHAR(FLASH_BASE_ADDRESS +
-						  offset + 2, &rc);
-					if ((rc & 0x80) == (c & 0x80))
-						break;	/* DQ7 = DATA  */
-					else
-						return false;	/* DQ7 != DATA */
-				}
-			}
-			WRITE_CHAR(FLASH_BASE_ADDRESS + FirstAddr, 0xaa);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + SecondAddr, 0x55);
-			WRITE_CHAR(FLASH_BASE_ADDRESS + ThirdAddr, 0xa0);
-#ifdef BE
-			c = data;
-#else
-			c = (data >> 24);
-#endif
-			WRITE_CHAR(FLASH_BASE_ADDRESS + offset + 3, c);
-			/* Writing fourth Byte */
-			while (true) {
-				READ_CHAR(FLASH_BASE_ADDRESS + offset + 3,
-					  &rc);
-				if ((rc & 0x80) == (c & 0x80))	/* DQ7 =? DATA */
-					break;	/* DQ7 = DATA  */
-				if ((rc & 0x20) == 0x20) {	/* DQ5 =? '1'  */
-					READ_CHAR(FLASH_BASE_ADDRESS +
-						  offset + 3, &rc);
-					if ((rc & 0x80) == (c & 0x80))
-						break;	/* DQ7 = DATA  */
-					else
-						return false;	/* DQ7 != DATA */
-				}
-			}
-			break;
-		case 2:	/* Split the 32 bit write into two 8/16 bit Writings
-				   (16bit width). */
-			if (FLASH_MODE == X16) {
-				FirstData = 0xaa;	/* Data for the First  Cycle    */
-				SecondData = 0x55;	/* Data for the Second Cycle    */
-				ThirdData = 0xa0;	/* Data for the Third  Cycle    */
-				FirstAddr = 0x5555;	/* Address for the First  Cycle */
-				SecondAddr = 0x2aaa;	/* Address for the Second Cycle */
-				ThirdAddr = 0x5555;	/* Address for the Third  Cycle */
-			} else {	/* if (FLASH_MODE == 8) */
-
-				FirstData = 0xaaaa;	/* Data for the First  Cycle    */
-				SecondData = 0x5555;	/* Data for the Second Cycle    */
-				ThirdData = 0xa0a0;	/* Data for the Third  Cycle    */
-				FirstAddr = 0xaaaa;	/* Address for the First  Cycle */
-				SecondAddr = 0x5555;	/* Address for the Second Cycle */
-				ThirdAddr = 0xaaaa;	/* Address for the Third  Cycle */
-			}
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    FirstAddr * FLASH_WIDTH, FirstData);
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    SecondAddr * FLASH_WIDTH, SecondData);
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    ThirdAddr * FLASH_WIDTH, ThirdData);
-#ifdef BE
-			s = (data >> 16);
-#else
-			s = data;
-#endif
-			WRITE_SHORT(FLASH_BASE_ADDRESS + offset, s);
-			/* Writing Two Bytes */
-			if (FLASH_MODE == X16) {
-				data80 = 0x80;;
-				data20 = 0x20;;
-			} else {	/* if (FLASH_MODE == 8) */
-
-				data80 = 0x8080;
-				data20 = 0x2020;
-			}
-			while (true) {
-				READ_SHORT(FLASH_BASE_ADDRESS + offset,
-					   &rs);
-				if ((rs & data80) == (s & data80))	/* DQ7 =? DATA */
-					break;	/* DQ7 =  DATA */
-				if ((rs & data20) == data20) {	/* DQ5 =? DATA */
-					READ_SHORT(FLASH_BASE_ADDRESS +
-						   offset, &rs);
-					if ((rs & data80) == (s & data80))
-						break;	/* DQ7 = DATA  */
-					else {
-						flashReset();
-						return false;	/* DQ7 != DATA */
-					}
-				}
-			}
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    FirstAddr * FLASH_WIDTH, FirstData);
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    SecondAddr * FLASH_WIDTH, SecondData);
-			WRITE_SHORT(FLASH_BASE_ADDRESS +
-				    ThirdAddr * FLASH_WIDTH, ThirdData);
-#ifdef BE
-			s = data;
-#else
-			s = (data >> 16);
-#endif
-			WRITE_SHORT(FLASH_BASE_ADDRESS + offset + 2, s);
-			/* Writing Two Bytes */
-			while (true) {
-				READ_SHORT(FLASH_BASE_ADDRESS + offset + 2,
-					   &rs);
-				if ((rs & data80) == (s & data80))	/* DQ7 =? DATA */
-					break;	/* DQ7 =  DATA */
-				if ((rs & data20) == data20) {	/* DQ5 =? '1'  */
-					READ_SHORT(FLASH_BASE_ADDRESS +
-						   offset + 2, &rs);
-					if ((rs & data80) == (s & data80))
-						break;	/* DQ7 = DATA  */
-					else {
-						flashReset();
-						return false;	/* DQ7 != DATA */
-					}
-				}
-			}
-			return true;
-		case 4:
-		case 8:
-			if (FLASH_MODE == X16) {
-				FirstData = 0x00aa00aa;
-				SecondData = 0x00550055;
-				ThirdData = 0x00a000a0;
-				FirstAddr = 0x5555;
-				SecondAddr = 0x2aaa;
-				ThirdAddr = 0x5555;
-			} else {	/* (FLASH_MODE == 8) */
-
-				FirstData = 0xaaaaaaaa;	/* Data for the First  Cycle    */
-				SecondData = 0x55555555;	/* Data for the Second Cycle    */
-				ThirdData = 0xa0a0a0a0;	/* Data for the Third  Cycle    */
-				FirstAddr = 0xaaaaaaaa;	/* Address for the First  Cycle */
-				SecondAddr = 0x55555555;	/* Address for the Second Cycle */
-				ThirdAddr = 0xaaaaaaaa;	/* Address for the Third  Cycle */
-			}
-			WRITE_WORD(FLASH_BASE_ADDRESS + FirstAddr *
-				   FLASH_WIDTH + offset % FLASH_WIDTH,
-				   FirstData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   SecondAddr * FLASH_WIDTH +
-				   offset % FLASH_WIDTH, SecondData);
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   ThirdAddr * FLASH_WIDTH +
-				   offset % FLASH_WIDTH, ThirdData);
-			/* writting the word. */
-			WRITE_WORD(FLASH_BASE_ADDRESS + offset, data);
-			/* preparing the polling patterns. */
-			if (FLASH_MODE == X16) {
-				data80 = 0x00800080;
-				data20 = 0x00200020;
-			} else {	/* (FLASH_MODE == 8) */
-
-				data80 = 0x80808080;
-				data20 = 0x20202020;
-			}
-			while (true) {	/* polling loop. */
-				rw = READWORD(FLASH_BASE_ADDRESS + offset);
-				/* DQ7 =? DATA */
-				if ((rw & data80) == (data & data80))
-					break;	/* DQ7 =  DATA */
-				if ((rw & data20) == data20) {	/* DQ5 =? '1'  */
-					rw =
-					    READWORD(FLASH_BASE_ADDRESS +
-						     offset);
-					if ((rw & data80) ==
-					    (data & data80)) break;	/* DQ7 = DATA  */
-					else
-						return false;	/* DQ7 != DATA */
-				}
-			}
-			return true;
-		default:
-			return false;	/* case of invalid flash Width. */
-		}
-	} else {		/* Intel/Micron */
-
-		switch (FLASH_WIDTH) {
-		case 1:
-			/* Writing First Byte */
-			WRITE_CHAR(FLASH_BASE_ADDRESS, 0x10);
-#ifdef BE
-			c = (data >> 24);
-#else
-			c = data;
-#endif
-			WRITE_CHAR(FLASH_BASE_ADDRESS + offset, c);
-			while (true) {
-				/* Reading STATUS Register */
-				WRITE_CHAR(FLASH_BASE_ADDRESS, 0x70);
-				regValue = READCHAR(FLASH_BASE_ADDRESS);
-				if ((regValue & 0x80) == 0x80)
-					break;	/* Case of Write-Operation had Ended */
-			}
-			/* Reading STATUS Register for Writing Verification */
-			WRITE_CHAR(FLASH_BASE_ADDRESS, 0x70);
-			regValue = READCHAR(FLASH_BASE_ADDRESS);
-			if ((regValue & 0x10) == 0x10)
-				return false;	/* Write failure */
-
-			/* Writing Second Byte */
-			WRITE_CHAR(FLASH_BASE_ADDRESS + 1, 0x10);
-#ifdef BE
-			c = (data >> 16);
-#else
-			c = (data >> 8);
-#endif
-			WRITE_CHAR(FLASH_BASE_ADDRESS + offset + 1, c);
-			while (true) {
-				/* Reading STATUS Register */
-				WRITE_CHAR(FLASH_BASE_ADDRESS + 1, 0x70);
-				regValue =
-				    READCHAR(FLASH_BASE_ADDRESS + 1);
-				if ((regValue & 0x80) == 0x80)
-					break;	/* Write operation ended */
-			}
-			/* Reading STATUS Register for Writing verification */
-			WRITE_CHAR(FLASH_BASE_ADDRESS + 1, 0x70);
-			regValue = READCHAR(FLASH_BASE_ADDRESS + 1);
-			if ((regValue & 0x10) == 0x10)
-				return false;	/* Write failure */
-
-			/* Writing Third Byte */
-			WRITE_CHAR(FLASH_BASE_ADDRESS + 2, 0x10);
-#ifdef BE
-			c = (data >> 8);
-#else
-			c = (data >> 16);
-#endif
-			WRITE_CHAR(FLASH_BASE_ADDRESS + offset + 2, c);
-			while (true) {
-				/* Reading STATUS Register */
-				WRITE_CHAR(FLASH_BASE_ADDRESS + 2, 0x70);
-				regValue =
-				    READCHAR(FLASH_BASE_ADDRESS + 2);
-				if ((regValue & 0x80) == 0x80)
-					break;	/* Write operation ended */
-			}
-			/* Reading STATUS Register for Writing Verification */
-			WRITE_CHAR(FLASH_BASE_ADDRESS + 2, 0x70);
-			regValue = READCHAR(FLASH_BASE_ADDRESS + 2);
-			if ((regValue & 0x10) == 0x10)
-				return false;	/* Write failure */
-
-			/* Writing Fourth Byte */
-			WRITE_CHAR(FLASH_BASE_ADDRESS + 3, 0x10);
-#ifdef BE
-			c = data;
-#else
-			c = (data >> 24);
-#endif
-			WRITE_CHAR(FLASH_BASE_ADDRESS + offset + 3, c);
-			while (true) {
-				/* Reading STATUS Register */
-				WRITE_CHAR(FLASH_BASE_ADDRESS + 3, 0x70);
-				regValue =
-				    READCHAR(FLASH_BASE_ADDRESS + 3);
-				if ((regValue & 0x80) == 0x80)
-					break;	/* Write operation ended */
-			}
-			/* Reading STATUS Register for Writing Verification */
-			WRITE_CHAR(FLASH_BASE_ADDRESS + 3, 0x70);
-			regValue = READCHAR(FLASH_BASE_ADDRESS + 3);
-			if ((regValue & 0x10) == 0x10)
-				return false;	/* Write failure */
-			flashReset();
-			return true;
-		case 2:
-			if (FLASH_MODE == X16) {	/* Case of one X16 bit device */
-				FirstData = 0x0010;	/* Data for the First  Cycle  */
-			} else {	/* if (FLASH_MODE == 8) ==> Case of two X8 bit devices */
-
-				FirstData = 0x1010;	/* Data for the First  Cycle  */
-			}
-			/* Writing First two Bytes */
-			WRITE_SHORT(FLASH_BASE_ADDRESS, FirstData);
-#ifdef BE
-			s = (data >> 16);
-#else
-			s = data;
-#endif
-			WRITE_SHORT(FLASH_BASE_ADDRESS + offset, s);
-			if (FLASH_MODE == X16) {
-				data70 = 0x0070;
-				data80 = 0x0080;
-				data10 = 0x0010;
-			} else {	/* case of (FLASH_MODE == X8) */
-
-				data70 = 0x7070;
-				data80 = 0x8080;
-				data10 = 0x1010;
-			}
-			/* polling on writing action => when done break. */
-			while (true) {
-				WRITE_SHORT(FLASH_BASE_ADDRESS, data70);
-				regValue = READSHORT(FLASH_BASE_ADDRESS);
-				if ((regValue & data80) == data80)
-					break;
-			}
-			/* Reading STATUS Register for Writing Verification */
-			WRITE_CHAR(FLASH_BASE_ADDRESS, data70);
-			regValue = READCHAR(FLASH_BASE_ADDRESS);
-			if ((regValue & data10) == data10)
-				return false;	/* Write failure */
-			/* Writing Last two Bytes */
-			WRITE_SHORT(FLASH_BASE_ADDRESS + 2, FirstData);
-#ifdef BE
-			s = data;
-#else
-			s = (data >> 16);
-#endif
-			WRITE_SHORT(FLASH_BASE_ADDRESS + offset + 2, s);
-			/* polling on writing action => when done break. */
-			while (true) {
-				WRITE_SHORT(FLASH_BASE_ADDRESS + 2,
-					    data70);
-				regValue =
-				    READSHORT(FLASH_BASE_ADDRESS + 2);
-				if ((regValue & data80) == data80)
-					break;
-			}
-			/* Reading STATUS Register for Writing Verification */
-			WRITE_CHAR(FLASH_BASE_ADDRESS, data70);
-			regValue = READCHAR(FLASH_BASE_ADDRESS);
-			if ((regValue & data10) == data10)
-				return false;	/* Write failure */
-			flashReset();
-			return true;
-		case 4:
-		case 8:
-			if (FLASH_MODE == X16) {	/* Case of one X16 bit device */
-				FirstData = 0x00100010;	/* Data for the First  Cycle  */
-			} else {	/* (FLASH_MODE == 8) ==> Case of two X8 bit devices */
-
-				FirstData = 0x10101010;	/* Data for the First  Cycle  */
-			}
-			/* Writing First two Bytes */
-			WRITE_WORD(FLASH_BASE_ADDRESS +
-				   offset % FLASH_WIDTH, FirstData);
-#ifdef BE
-			s = (data >> 16);
-#else
-			s = data;
-#endif
-			/* writing the 32-bit data to flash. */
-			WRITE_WORD(FLASH_BASE_ADDRESS + offset, data);
-			if (FLASH_MODE == X16) {
-				data70 = 0x0070;
-				data80 = 0x0080;
-				data10 = 0x0010;
-			} else {	/* (FLASH_MODE == 8) */
-
-				data70 = 0x7070;
-				data80 = 0x8080;
-				data10 = 0x1010;
-			}
-			while (true) {
-				WRITE_SHORT(FLASH_BASE_ADDRESS +
-					    offset % FLASH_WIDTH, data70);
-				regValue = READSHORT(FLASH_BASE_ADDRESS);
-				if ((regValue & data80) == data80)
-					break;
-			}
-			/* Reading STATUS Register for Writing Verification */
-			WRITE_CHAR(FLASH_BASE_ADDRESS, data70);
-			regValue = READCHAR(FLASH_BASE_ADDRESS);
-			if ((regValue & data10) == data10)
-				return false;	/* Write failure */
-
-			/* Writing Last two Bytes */
-#ifdef BE
-			s = data;
-#else
-			s = (data >> 16);
-#endif
-			while (true) {
-				WRITE_SHORT(FLASH_BASE_ADDRESS +
-					    offset % FLASH_WIDTH + 2,
-					    data70);
-				regValue =
-				    READSHORT(FLASH_BASE_ADDRESS +
-					      offset % FLASH_WIDTH + 2);
-				if ((regValue & data80) == data80)
-					break;
-			}
-			/* Reading STATUS Register for Writing Verification */
-			WRITE_CHAR(FLASH_BASE_ADDRESS, data70);
-			regValue = READCHAR(FLASH_BASE_ADDRESS);
-			if ((regValue & data10) == data10)
-				return false;	/* Write failure */
-
-			flashReset();
-			return true;
-		default:
-			flashReset();
-			return false;
-		}
-	}
-	flashReset();
-	return true;
-}
-
-/********************************************************************
-* flashReadWord - Read 32Bit from the FLASH memory at a given offset
-*                 from the FLASH base address.
-* 				  address 0 = 0x00000000 !!
-*                 The function takes care of Big/Little endian conversion
-* INPUTS:  offset,the offset from the flash`s base address
-* RETURNS: data
-*********************************************************************/
-unsigned int flashReadWord(unsigned int offset)
-{
-	unsigned int regValue;
-	flashReset();
-	READ_WORD(FLASH_BASE_ADDRESS + offset, &regValue);
-	return regValue;
-}
-
-/********************************************************************
-* flashInWhichSector - Returns the sector`s number at which offset is at.
-*
-* INPUTS:  Offset
-* RETURNS: Sector number,or 0xffffffff in case the address is out of range or
-*          flash wasn't initialize.
-*********************************************************************/
-unsigned int flashInWhichSector(unsigned int offset)
-{
-	unsigned int sectorNumber, numberOfDevices;
-	unsigned int accMemory = 0;
-
-	if ((FLASH_MODE == PURE8) || (FLASH_MODE == X8)) {
-		numberOfDevices = FLASH_WIDTH;
-	} else {		/* X16 mode */
-
-		numberOfDevices = FLASH_WIDTH / 2;
-	}
-	for (sectorNumber = 0;
-	     sectorNumber < flashTypes[NUMBER_OF_SECTORS]; sectorNumber++) {
-		accMemory =
-		    accMemory + flashTypes[FIRST_SECTOR_SIZE +
-					   sectorNumber];
-		if (offset < accMemory * numberOfDevices * 1024)
-			return sectorNumber;
-	}
-	return 0xffffffff;
-}
-
-/********************************************************************
-* flashGetSectorSize - When given a Valid sector Number returns its Size.
-*
-* INPUTS:  unsigned int sectorNumber.
-* RETURNS: Sector size. (if Sector number isn't valid or flash wasn't
-*          initialize return 0.)
-*********************************************************************/
-unsigned int flashGetSectorSize(unsigned int sectorNumber)
-{
-	if (sectorNumber >= flashTypes[NUMBER_OF_SECTORS])
-		return 0;
-	else {
-		if (FLASH_MODE != PURE8)
-			return (flashTypes
-				[FIRST_SECTOR_SIZE +
-				 sectorNumber] * _1K * (FLASH_WIDTH * 8 /
-							FLASH_MODE));
-		else		/* in case of PUR8 */
-			return (flashTypes
-				[FIRST_SECTOR_SIZE +
-				 sectorNumber] * _1K * FLASH_WIDTH);
-	}
-}
-
-/********************************************************************
-* getFlashSize - Return Total flash size.
-*
-* INPUTS:  N/A.
-* RETURNS: Flash size. (If flash wasn't initialize return 0)
-*********************************************************************/
-unsigned int flashGetSize()
-{
-	unsigned int sectorNum;
-	unsigned int totalSize = 0;
-
-	if (POINTER_TO_FLASH == 0)
-		return 0;	/* case of flash not initialize */
-	for (sectorNum = 0; sectorNum < flashTypes[NUMBER_OF_SECTORS];
-	     sectorNum++) {
-		totalSize += flashGetSectorSize(sectorNum);
-	}
-	return (totalSize);
-
-}
-
-/********************************************************************
-* flashGetSectorOffset - Returns sector base address.
-*
-* INPUTS:  unsigned int sectorNum.
-* RETURNS: Sector Base Address.
-*********************************************************************/
-unsigned int flashGetSectorOffset(unsigned int sectorNum)
-{
-	unsigned int i;
-	unsigned int sectorBaseAddress = 0;
-	unsigned int numOfDevices;
-
-	if (sectorNum > (flashParametrs[NUMBER_OF_SECTORS] - 1))
-		return 0xffffffff;
-	for (i = 0; i < sectorNum; i++) {
-		sectorBaseAddress =
-		    sectorBaseAddress + flashTypes[FIRST_SECTOR_SIZE + i];
-	}
-	if (FLASH_MODE == X16)
-		numOfDevices = FLASH_WIDTH * 8 / FLASH_MODE;
-	else
-		numOfDevices = FLASH_WIDTH;
-	return (_1K * sectorBaseAddress * numOfDevices);
-
-}
-
-/********************************************************************
-* flashWriteBlock - Write block of chars to flash.
-*
-* INPUTS:  unsigned int offset - flash destination address.
-*          unsigned int numOfByte - block size.
-*          unsigned char * blockAddress - block source address.
-* RETURNS: Number of Bytes written.
-*********************************************************************/
-unsigned int flashWriteBlock(unsigned int offset, unsigned int numOfByte,
-			     unsigned char *blockAddress)
-{
-	register unsigned int flashWrite;
-	register unsigned int align;
-	register unsigned int num;
-	register unsigned int i;
-
-	if ((offset + numOfByte) > flashGetSize())
-		numOfByte = flashGetSize() - offset;	/* getting to flash boundary. */
-	num = numOfByte;
-	align = offset % 4;	/* alignment toward flash.    */
-	/* writes chars until the offset toward flash will be align. */
-	for (i = align; (i < 4) && (numOfByte > 0) && (align != 0); i++) {
-		flashWriteChar(offset, blockAddress[0]);
-		numOfByte--;
-		offset++;
-		blockAddress++;
-	}
-	while (numOfByte > 3) {
-#ifdef LE
-		flashWrite = blockAddress[0] | (blockAddress[1] << 8) |
-		    (blockAddress[2] << 16) | (blockAddress[3] << 24);
-#else
-		flashWrite = blockAddress[3] | (blockAddress[2] << 8) |
-		    (blockAddress[1] << 16) | (blockAddress[0] << 24);
-#endif
-		if (flashWrite != 0xffffffff)	/* for optimization. */
-			flashWriteWord(offset, flashWrite);
-		numOfByte -= 4;
-		blockAddress += 4;
-		offset += 4;
-	}
-	while (numOfByte > 0) {
-		flashWriteChar(offset, blockAddress[0]);
-		numOfByte--;
-		blockAddress++;
-		offset++;
-	}
-	return num;
-}
-
-/********************************************************************
-* flashReadBlock - Read block of chars from flash.
-*
-* INPUTS:  unsigned int offset - flash source address.
-*          unsigned int numOfByte - block size.
-*          unsigned char * blockAddress - block destination address.
-* RETURNS: Number of Bytes written.
-*********************************************************************/
-unsigned int flashReadBlock(unsigned int offset, unsigned int numOfByte,
-			    unsigned char *blockAddress)
-{
-	unsigned int i;
-	for (i = 0; i < numOfByte; i++) {
-		blockAddress[i] = flashReadChar(offset + i);
-	}
-	return numOfByte;
-}
-
-/********************************************************************
-* flashReadChar - read one charecter form given flash offset.
-*
-* INPUTS:  unsigned int offset - required offset to be read from.
-* RETURNS: read charecter.
-*********************************************************************/
-unsigned char flashReadChar(unsigned int offset)
-{
-	unsigned char regValue;
-
-	flashReset();
-	READ_CHAR(FLASH_BASE_ADDRESS + offset, &regValue);
-	return regValue;
-}
-
-/********************************************************************
-* flashReadShort - read 16bit form given flash offset.
-*
-* INPUTS:  unsigned int offset - required offset to be read from.
-* RETURNS: 16bit data.
-*********************************************************************/
-unsigned short flashReadShort(unsigned int offset)
-{
-	unsigned short regValue;
-
-	flashReset();
-	READ_SHORT(FLASH_BASE_ADDRESS + offset, &regValue);
-	return regValue;
-}
-
-/********************************************************************
-* flashWriteShort - write 16bit data to a given flash offset.
-*                  It reads the whole word 32bit wide, modify the  short
-*                  and write back the word.
-*
-* INPUTS:  unsigned int offset - required offset to be write to.
-*          unsigned short sdata - data to be written.
-* RETURNS: true if writting successesed false otherwise.
-*********************************************************************/
-bool flashWriteShort(unsigned int offset, unsigned short sdata)
-{
-	unsigned int align;
-	unsigned int flashWrite;
-	unsigned int flashRead;
-
-	align = offset % 4;
-	if ((align == 1) || (align == 3))
-		return false;	/* offset misaligned. */
-	flashRead = flashReadWord(offset - align);
-	if (align == 0)
-#ifdef BE
-		flashWrite = (flashRead & 0x0000ffff) | (sdata << 16);
-#else
-		flashWrite = (flashRead & 0xffff0000) | sdata;
-#endif
-	else			/* (align == 2) */
-#ifdef BE
-		flashWrite = (flashRead & 0xffff0000) | sdata;
-#else
-		flashWrite = (flashRead & 0x0000ffff) | (sdata << 16);
-#endif
-	flashWriteWord(offset - align, flashWrite);
-	return true;
-
-}
-
-/********************************************************************
-* flashWriteChar - write one charecter (8 bit) to a given flash offset.
-*                  It reads the whole word 32bit wide, modify the charecter
-*                  and write back the word.
-*
-* INPUTS:  unsigned int offset - required offset to be write to.
-*          unsigned short sdata - data to be written.
-* RETURNS: true if writting successed.
-*********************************************************************/
-bool flashWriteChar(unsigned int offset, unsigned char cdata)
-{
-	unsigned int align;
-	unsigned int flashWrite;
-	unsigned int flashRead;
-
-	align = offset % 4;
-	flashRead = flashReadWord(offset - align);
-#ifdef BE
-	flashWrite = (flashRead & ~(0xff000000 >> (8 * align))) |
-	    (cdata << (8 * (3 - align)));
-#else
-	flashWrite = (flashRead & ~(0xff000000 << (8 * align))) |
-	    (cdata << (8 * align));
-#endif
-	flashWriteWord(offset - align, flashWrite);
-	return true;
-}
-
-/********************************************************************
-* flashGetNumOfSectors - write one charecter (8 bit) to a given flash offset.
-*                        It reads the whole word 32bit wide, modify the
-*                        charecter and write back the word.
-*
-* INPUTS:  N/A.
-* RETURNS: Number of sectors.
-*********************************************************************/
-unsigned int flashGetNumOfSectors(void)
-{
-	return (flashTypes[NUMBER_OF_SECTORS]);
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/galileo_port.h linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/galileo_port.h
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/galileo_port.h	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/galileo_port.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-#define GFP_KERNEL 0
-#define GFP_ATOMIC 1
-#define KERN_ERR ""
-
-void *kmalloc(unsigned int, int);
-void *memset(void *, char, unsigned int);
-int memcmp(char *, char *, unsigned int);
-void *memcpy(void *to, const void *from, unsigned int);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/gt64011.h linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/gt64011.h
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/gt64011.h	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/gt64011.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,279 +0,0 @@
-/*
- * gt64011.h: Galileo PCI system controller
- * Copyright (c) 1998 Algorithmics Ltd
- */
-
-#ifdef __ASSEMBLY__
-
-/* offsets from base register */
-#define GT64011(x)		(x)
-
-/* device is littleendian, so data may need to be swapped */
-#ifdef GALILEO_PORT
-#define htoll(x) ((((x) & 0x00ff) << 24) | \
-		  (((x) & 0xff00) <<  8) | \
-		  (((x) >> 8)  & 0xff00) | \
-		  (((x) >> 24) & 0x00ff))
-/*#define ltohl(x) htoll(x)*/
-#else
-#define htoll(x) (x)
-/* #define ltohl(x) (x) */
-#endif
-
-#else /* !__ASSEMBLY__ */
-
-/* offsets from base pointer, this construct allows optimisation */
-static char *const _gt64011p = (char *) PA_TO_KVA1(GT64011_BASE);
-
-#define GT64011(x)		*(volatile unsigned long *)(_gt64011p + (x))
-
-/* device is littleendian, so data may need to be swapped */
-#ifdef GALILEO_PORT
-#define htoll(x)     ({			\
-  unsigned int v = (unsigned int)(x);	\
-  v = (((v & 0x00ff) << 24) |		\
-       ((v & 0xff00) <<  8) |		\
-       ((v >>  8) & 0xff00) |		\
-       ((v >> 24) & 0x00ff));		\
-    v;					\
-    })
-#define ltohl(x) htoll(x)
-
-#else
-asjdsajd
-#define htoll(x) (x)
-#define ltohl(x) (x)
-#endif
-#endif /* __ASSEMBLY__ */
-/* CPU configuration */
-#define GT_CPU_CFG	GT64011(0x000)
-#define GT_CPU_CFG_WriteMode	(1<<11)
-#define GT_CPU_CFG_Endianess	(1<<12)
-/* Processor Address Space */
-#define GT_PAS_RAS10LO	GT64011(0x008)
-#define GT_PAS_RAS10HI	GT64011(0x010)
-#define GT_PAS_RAS32LO	GT64011(0x018)
-#define GT_PAS_RAS32HI	GT64011(0x020)
-#define GT_PAS_CS20LO	GT64011(0x028)
-#define GT_PAS_CS20HI	GT64011(0x030)
-#define GT_PAS_CS3BOOTLO GT64011(0x038)
-#define GT_PAS_CS3BOOTHI GT64011(0x040)
-#define GT_PAS_PCIIOLO	GT64011(0x048)
-#define GT_PAS_PCIIOHI	GT64011(0x050)
-#define GT_PAS_PCIMEMLO	GT64011(0x058)
-#define GT_PAS_PCIMEMHI	GT64011(0x060)
-#define GT_PAS_INTDEC	GT64011(0x068)
-#define GT_PAS_BUSERRLO	GT64011(0x070)
-#define GT_PAS_PCIMEM1LO GT64011(0x080)
-#define GT_PAS_PCIMEM1HI GT64011(0x088)
-#define GT_PAS_LOMASK_Low	0x7ff
-#define GT_PAS_LOSHIFT_Low	0
-#define GT_PAS_HIMASK_High	0x07f
-#define GT_PAS_HISHIFT_High	0
-/* DRAM and  Device Address Space */
-#define GT_DDAS_RAS0LO	GT64011(0x400)
-#define GT_DDAS_RAS0HI	GT64011(0x404)
-#define GT_DDAS_RAS1LO	GT64011(0x408)
-#define GT_DDAS_RAS1HI	GT64011(0x40c)
-#define GT_DDAS_RAS2LO	GT64011(0x410)
-#define GT_DDAS_RAS2HI	GT64011(0x414)
-#define GT_DDAS_RAS3LO	GT64011(0x418)
-#define GT_DDAS_RAS3HI	GT64011(0x41c)
-#define GT_DDAS_CS0LO	GT64011(0x420)
-#define GT_DDAS_CS0HI	GT64011(0x424)
-#define GT_DDAS_CS1LO	GT64011(0x428)
-#define GT_DDAS_CS1HI	GT64011(0x42c)
-#define GT_DDAS_CS2LO	GT64011(0x430)
-#define GT_DDAS_CS2HI	GT64011(0x434)
-#define GT_DDAS_CS3LO	GT64011(0x438)
-#define GT_DDAS_CS3HI	GT64011(0x43c)
-#define GT_DDAS_BOOTCSLO	GT64011(0x440)
-#define GT_DDAS_BOOTCSHI	GT64011(0x444)
-#define GT_DDAS_ERROR	GT64011(0x470)
-#define GT_DDAS_LOMASK_Low	0xff
-#define GT_DDAS_LOSHIFT_Low	0
-#define GT_DDAS_HIMASK_High	0xff
-#define GT_DDAS_HISHIFT_High	0
-/* DRAM Configuration */
-#define GT_DRAM_CFG	GT64011(0x448)
-#define GT_DRAM_CFG_RefIntCntMASK	0x00003fff
-#define GT_DRAM_CFG_RefIntCntSHIFT	0
-#define GT_DRAM_CFG_RefIntCnt(x)	(((x)<<GT_DRAM_CFG_RefIntCntSHIFT)&\
-					 GT_DRAM_CFG_RefIntCntMASK)
-#define GT_DRAM_CFG_StagRef		(1<<16)
-#define GT_DRAM_CFG_StagRefOn		0
-#define GT_DRAM_CFG_StagRefAll		GT_DRAM_CFG_StagRef
-#define GT_DRAM_CFG_ADSFunct		(1<<17)
-#define GT_DRAM_CFG_ADSFunctDRAM	0
-#define GT_DRAM_CFG_ADSFunctOnly	GT_DRAM_CFG_ADSFunct
-#define GT_DRAM_CFG_DRAMLatch		(1<<18)
-#define GT_DRAM_CFG_DRAMLatchActive	0
-#define GT_DRAM_CFG_DRAMLatchTransparent GT_DRAM_CFG_DRAMLatch
-/* DRAM Parameters */
-#define GT_DRAMPAR_BANK0 GT64011(0x44c)
-#define GT_DRAMPAR_BANK1 GT64011(0x450)
-#define GT_DRAMPAR_BANK2 GT64011(0x454)
-#define GT_DRAMPAR_BANK3 GT64011(0x458)
-#define GT_DRAMPAR_CASWr		(1<<0)
-#define GT_DRAMPAR_CASWr1		0
-#define GT_DRAMPAR_CASWr2		GT_DRAMPAR_CASWr
-#define GT_DRAMPAR_RAStoCASWr		(1<<1)
-#define GT_DRAMPAR_RAStoCASWr2		0
-#define GT_DRAMPAR_RAStoCASWr3		GT_DRAMPAR_RAStoCASWr
-#define GT_DRAMPAR_CASRd		(1<<2)
-#define GT_DRAMPAR_CASRd1		0
-#define GT_DRAMPAR_CASRd2		GT_DRAMPAR_CASRd
-#define GT_DRAMPAR_RAStoCASRd		(1<<3)
-#define GT_DRAMPAR_RAStoCASRd2		0
-#define GT_DRAMPAR_RAStoCASRd3		GT_DRAMPAR_RAStoCASRd
-#define GT_DRAMPAR_RefreshSHIFT		4
-#define GT_DRAMPAR_RefreshMASK		(3<<4)
-#define GT_DRAMPAR_Refresh512		(0<<4)
-#define GT_DRAMPAR_Refresh1024		(1<<4)
-#define GT_DRAMPAR_Refresh2048		(2<<4)
-#define GT_DRAMPAR_Refresh4096		(3<<4)
-#define GT_DRAMPAR_BankWidth		(1<<6)
-#define GT_DRAMPAR_BankWidth32		0
-#define GT_DRAMPAR_BankWidth64		GT_DRAMPAR_BankWidth
-#define GT_DRAMPAR_BankLoc		(1<<7)
-#define GT_DRAMPAR_BankLocEven		0
-#define GT_DRAMPAR_BankLocOdd		GT_DRAMPAR_BankLoc
-#define GT_DRAMPAR_Parity		(1<<8)
-#define GT_DRAMPAR_ParityDisable	0
-#define GT_DRAMPAR_ParityEnable		GT_DRAMPAR_Parity
-#define GT_DRAMPAR_MBZ			(1<<9)
-/* Device Parameters */
-#define GT_DEVPAR_BANK0	GT64011(0x45c)
-#define GT_DEVPAR_BANK1	GT64011(0x460)
-#define GT_DEVPAR_BANK2	GT64011(0x464)
-#define GT_DEVPAR_BANK3	GT64011(0x468)
-#define GT_DEVPAR_BOOT	GT64011(0x46c)
-#define GT_DEVPAR_TurnOffMASK		(7<<0)
-#define GT_DEVPAR_TurnOffSHIFT		0
-#define GT_DEVPAR_TurnOff(x)		((x)<<0)
-#define GT_DEVPAR_AccToFirstMASK	(15<<3)
-#define GT_DEVPAR_AccToFirstSHIFT	3
-#define GT_DEVPAR_AccToFirst(x)		((x)<<3)
-#define GT_DEVPAR_AccToNextMASK		(15<<7)
-#define GT_DEVPAR_AccToNextSHIFT	7
-#define GT_DEVPAR_AccToNext(x)		((x)<<7)
-#define GT_DEVPAR_ADStoWrMASK		(7<<11)
-#define GT_DEVPAR_ADStoWrSHIFT		11
-#define GT_DEVPAR_ADStoWr(x)		((x)<<11)
-#define GT_DEVPAR_WrActiveMASK		(7<<14)
-#define GT_DEVPAR_WrActiveSHIFT		14
-#define GT_DEVPAR_WrActive(x)		((x)<<14)
-#define GT_DEVPAR_WrHighMASK		(7<<17)
-#define GT_DEVPAR_WrHighSHIFT		17
-#define GT_DEVPAR_WrHigh(x)		((x)<<17)
-#define GT_DEVPAR_DevWidthMASK		(3<<20)
-#define GT_DEVPAR_DevWidthSHIFT		20
-#define GT_DEVPAR_DevWidth8		(0<<20)
-#define GT_DEVPAR_DevWidth16		(1<<20)
-#define GT_DEVPAR_DevWidth32		(2<<20)
-#define GT_DEVPAR_DevWidth64		(3<<20)
-#define GT_DEVPAR_DevLoc		(1<<23)
-#define GT_DEVPAR_DevLocEven		0
-#define GT_DEVPAR_DevLocOdd		GT_DEVPAR_DevLoc
-#define GT_DEVPAR_LatchFunct		(1<<25)
-#define GT_DEVPAR_LatchFunctTransparent 0
-#define GT_DEVPAR_LatchFunctEnable	GT_DEVPAR_LatchFunct
-#define GT_DEVPAR_Parity		(1<<30)
-#define GT_DEVPAR_ParityDisable		0
-#define GT_DEVPAR_ParityEnable		GT_DEVPAR_Parity
-#define GT_DEVPAR_ReservedMASK		0x3d400000
-#define GT_DEVPAR_Reserved		0x14400000
-/* PCI Internal */
-#define GT_IPCI_CMD GT64011(0xc00)
-#define GT_IPCI_CMD_ByteSwap		(1<<0)
-#define GT_IPCI_CMD_ByteSwapOn		0
-#define GT_IPCI_CMD_ByteSwapOff		GT_INTPCI_CMD_ByteSwap
-#define GT_IPCI_CMD_SyncModeMASK	(3<<1)
-#define GT_IPCI_CMD_SyncModeSHIFT	1
-#define GT_IPCI_CMD_SyncModeStd		(0<<1)
-#define GT_IPCI_CMD_SyncMode1		(1<<1)
-#define GT_IPCI_CMD_SyncMode2		(2<<1)
-#define GT_IPCI_TOR	GT64011(0xc04)
-#define GT_IPCI_TOR_Timeout0MASK	(255<<0)
-#define GT_IPCI_TOR_Timeout0SHIFT	0
-#define GT_IPCI_TOR_Timeout0(x)	((x)<<0)
-#define GT_IPCI_TOR_Timeout1MASK	(255<<8)
-#define GT_IPCI_TOR_Timeout1SHIFT	8
-#define GT_IPCI_TOR_Timeout1(x)	((x)<<8)
-#define GT_IPCI_TOR_RetryCtrMASK	(255<<16)
-#define GT_IPCI_TOR_RetryCtrSHIFT	16
-#define GT_IPCI_TOR_RetryCtr(x)		((x)<<16)
-#define GT_IPCI_RAS10SIZE	GT64011(0xc08)
-#define GT_IPCI_RAS32SIZE	GT64011(0xc0c)
-#define GT_IPCI_CS20SIZE	GT64011(0xc10)
-#define GT_IPCI_CS3BOOTSIZE	GT64011(0xc14)
-#define GT_IPCI_SIZE_BankSizeMASK	(0xfffff<<12)
-#define GT_IPCI_SIZE_BankSizeSHIFT	12
-#define GT_IPCI_INTRCAUSE	GT64011(0xc18)
-#define GT_IPCI_INTRMASK	GT64011(0xc1c)
-#define  GT_INTR_INTSUM			0x0000001
-#define  GT_INTR_MEMOUT			0x0000002
-#define  GT_INTR_DMAOUT			0x0000004
-#define  GT_INTR_CPUOUT			0x0000008
-#define  GT_INTR_DMA0COMP		0x0000010
-#define  GT_INTR_DMA1COMP		0x0000020
-#define  GT_INTR_DMA2COMP		0x0000040
-#define  GT_INTR_DMA3COMP		0x0000080
-#define  GT_INTR_T0EXP			0x0000100
-#define  GT_INTR_T1EXP			0x0000200
-#define  GT_INTR_T2EXP			0x0000400
-#define  GT_INTR_T3EXP			0x0000800
-#define  GT_INTR_MASRDERR		0x0001000
-#define  GT_INTR_SLVWRERR		0x0002000
-#define  GT_INTR_MASWRERR		0x0004000
-#define  GT_INTR_SLVRDERR		0x0008000
-#define  GT_INTR_ADDRERR		0x0010000
-#define  GT_INTR_MEMERR			0x0020000
-#define  GT_INTR_MASABORT		0x0040000
-#define  GT_INTR_TARABORT		0x0080000
-#define  GT_INTR_RETRYCTR		0x0010000
-#define  GT_INTR_CPU2PCIA		0x0020000
-#define  GT_INTR_CPU2PCIB		0x0040000
-#define  GT_INTR_CPU2PCIC		0x0080000
-#define  GT_INTR_CPU2PCID		0x0100000
-#define  GT_INTR_CPU2PCIE		0x0200000
-#define  GT_INTR_PCI2CPUA		0x0400000
-#define  GT_INTR_PCI2CPUB		0x0800000
-#define  GT_INTR_PCI2CPUC		0x1000000
-#define  GT_INTR_PCI2CPUD		0x2000000
-#define  GT_INTR_CPUINTSUM		0x4000000
-#define  GT_INTR_PCIINTSUM		0x8000000
-#define GT_IPCI_PCIINTMASK	GT64011(0xc24)
-#define GT_IPCI_SERMASK		GT64011(0xc28)
-#define GT_IPCI_SERMASK_AddrErr		(1<<0)
-#define GT_IPCI_SERMASK_MasWrErr	(1<<1)
-#define GT_IPCI_SERMASK_MasRdErr	(1<<2)
-#define GT_IPCI_SERMASK_MemErr		(1<<3)
-#define GT_IPCI_SERMASK_MasAbort	(1<<4)
-#define GT_IPCI_SERMASK_TarAbort	(1<<5)
-#define GT_IPCI_INTACK		GT64011(0xc34)
-#define GT_IPCI_BAREN		GT64011(0xc3c)
-#define GT_IPCI_BAREN_SwCs3BootDis	(1<<0)
-#define GT_IPCI_BAREN_SwRas32Dis	(1<<1)
-#define GT_IPCI_BAREN_SwRas10Dis	(1<<2)
-#define GT_IPCI_BAREN_IntIODis		(1<<3)
-#define GT_IPCI_BAREN_IntMemDis		(1<<4)
-#define GT_IPCI_BAREN_Cs3BootDis	(1<<5)
-#define GT_IPCI_BAREN_Cs20Dis		(1<<6)
-#define GT_IPCI_BAREN_Ras32Dis		(1<<7)
-#define GT_IPCI_BAREN_Ras10Dis		(1<<8)
-#define GT_IPCI_CFGADDR		GT64011(0xcf8)
-#define GT_IPCI_CFGDATA		GT64011(0xcfc)
-#define GT_IPCI_CFGADDR_RegNumMASK	(0x3f<<2)
-#define GT_IPCI_CFGADDR_RegNumSHIFT	2
-#define GT_IPCI_CFGADDR_RegNum(x)	((x)<<2)
-#define GT_IPCI_CFGADDR_FunctNumMASK	(0x7<<8)
-#define GT_IPCI_CFGADDR_FunctNumSHIFT	8
-#define GT_IPCI_CFGADDR_FunctNum(x)	((x)<<8)
-#define GT_IPCI_CFGADDR_DevNumMASK	(0x1f<<11)
-#define GT_IPCI_CFGADDR_DevNumSHIFT	11
-#define GT_IPCI_CFGADDR_DevNum(x)	((x)<<11)
-#define GT_IPCI_CFGADDR_BusNumMASK	(0xff<<16)
-#define GT_IPCI_CFGADDR_BusNumSHIFT	16
-#define GT_IPCI_CFGADDR_BusNum(x)	((x)<<16)
-#define GT_IPCI_CFGADDR_ConfigEn	(1<<31)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/head.S linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/head.S
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/head.S	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/head.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-/*
- *  arch/mips/galileo/compressed/head.S
- *
- */
-
-#include <asm/asm.h>
-#include <asm/regdef.h>
-
-	.text
-NESTED(startup, 16, sp)
-	.set	noreorder
-
-	jal decompress_kernel
-	nop
-
-        jal kernel_location_start+0x584
-        nop
-
-	END(startup)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/ld.script.gal linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/ld.script.gal
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/ld.script.gal	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/ld.script.gal	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-OUTPUT_FORMAT("elf32-bigmips")
-OUTPUT_ARCH(mips)
-ENTRY(startup)
-SECTIONS
-{
-  kernel_location_start = 0x80100000;
-  . = 0x80400000;
-  .text : {
-  *(.text)
-  }
-  .bss : {
-  *(.bss)
-  }
-  .data :{
-  *(.data)
-  }
-  malloc_start = .;
-}
-
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.burner linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.burner
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.burner	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.burner	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-OUTPUT_FORMAT("elf32-bigmips")
-OUTPUT_ARCH(mips)
-ENTRY(main)
-
-SECTIONS
-{
- . = 0xA0400000;
- .text : {*(.text)}
- .data : {*(.data)}
- .bss  : {*(.bss)}
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.Flash linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.Flash
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.Flash	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.Flash	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-OUTPUT_FORMAT("elf32-bigmips")
-OUTPUT_ARCH(mips)
-ENTRY(sbdreset)
-
-SECTIONS
-{
-  . = 0xBFC00000;
-  .got : {*(.got)}
-  .reset : {
-    sbdreset = ABSOLUTE(.);
-    sbdreset_evb64120A.o
-    evb64120A_Setup.o /* <-- Note: contains xfer.c contents as well.. */
-    pci_etherboot.o
-    memory.o
-    pci.o
-  }
-  kernel_location_start = 0x80100000;
-  . = 0x80400000;
-  .text : {
-  *(.text)
-  }
-  .bss : {
-  *(.bss)
-  }
-  .data :{
-  *(.data)
-  }
-  malloc_start = .;
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.Flash2 linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.Flash2
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.Flash2	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/ld.sys.big.Flash2	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-OUTPUT_FORMAT("elf32-bigmips")
-OUTPUT_ARCH(mips)
-ENTRY(XferToRam)
-
-SECTIONS
-{
-  . = 0xBF000000;
-  .got : {*(.got)}
-  .reset : {
-    xfer.o
-  }
-  kernel_location_start = 0x80100000;
-  . = 0x80400000;
-  .text : {
-  *(.text)
-  }
-  .bss : {
-  *(.bss)
-  }
-  .data :{
-  *(.data)
-  }
-  malloc_start = .;
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/load.c linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/load.c
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/load.c	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/load.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,244 +0,0 @@
-
-/* control character used for download */
-#define ETX	CNTRL('c')
-#define ACK	CNTRL('f')
-#define NAK	CNTRL('u')
-#define XON	CNTRL('q')
-#define XOFF	CNTRL('s')
-
-unsigned int csum;
-unsigned int dl_entry;
-
-static const unsigned char hextab[256] = {
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 255, 255, 255, 255, 255, 255,
-	255, 10, 11, 12, 13, 14, 15, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	255, 10, 11, 12, 13, 14, 15, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-	    255, 255, 255,
-};
-
-
-unsigned char ascii_to_bin(unsigned char c)
-{
-	return hextab[c];
-}
-
-unsigned char read_char_direct(void)
-{
-	unsigned char c, *cp;
-	cp = (unsigned char *) 0xbd000020;
-	while (1) {
-		if (*(cp + 0x14) & 0x01) {
-			c = (volatile unsigned char) *cp;
-			return c;
-		}
-		cp++;
-		cp--;
-	}
-}
-
-unsigned char get_pair(void)
-{
-	unsigned char byte;
-
-	byte = ascii_to_bin(read_char_direct()) << 4;
-	byte |= ascii_to_bin(read_char_direct());
-	csum += byte;
-	return (byte);
-}
-
-
-void serial_putc(int ch)
-{
-	unsigned long temp;
-	for (temp = 0; temp < 1000; temp++) {
-	}
-	*(char *) 0xbd000020 = (char) ch;
-}
-
-
-int inline serial_getc(void)
-{
-	return read_char_direct();
-}
-
-int serial_ischar(void)
-{
-
-	unsigned char c, *cp;
-	unsigned count;
-	cp = (unsigned char *) 0xbd000020;
-	count = 0;
-	while (count != 100) {
-		if (*(cp + 0x14) & 0x01) {
-			c = (volatile unsigned char) *cp;
-			return c;
-		}
-		cp++;
-		cp--;
-		count++;
-	}
-	return 0;
-}
-
-int serial_init(void)
-{
-	return 0;
-}
-
-
-int galileo_dl(void)
-{
-#define display_char '.'
-#define display_error 'E'
-#define display_error_bad_7 '7'
-#define display_error_unknown 'U'
-#define display_error_length 'L'
-
-	register int length, address, save_csum;
-	int i, first, done, eof, reccount, type, client_pc;
-	int src, dbl_length;
-	unsigned char *buffptr, databuff[258], tempo;
-	register int display_counter, chunks, leftovers, putter,
-	    bytes_per_chunk;
-	display_counter = 0;
-	bytes_per_chunk = 16;
-	csum = 0;
-
-	reccount = 1;
-	for (first = 1, done = 0; !done; first = 0, reccount++) {
-		while (read_char_direct() != 'S')
-			continue;
-		csum = 0;
-		type = read_char_direct();
-		length = get_pair();
-		if (length < 0 || length >= 256) {
-			*(char *) 0xbd000020 = display_error_length;
-			//      *(char*)0xbd00000c = display_error_length;
-			return 0;
-		}
-		length--;
-		switch (type) {
-		case '0':
-			while (length-- > 0)
-				get_pair();
-			break;
-		case '3':
-			address = 0;
-			for (i = 0; i < 4; i++) {
-				address <<= 8;
-				address |= get_pair();
-				length--;
-			}
-			if (address == -1) {
-				eof = 1;
-				continue;
-			}
-			buffptr = &databuff[0];
-			dbl_length = length << 1;
-			chunks = dbl_length / bytes_per_chunk;
-			leftovers = dbl_length % bytes_per_chunk;
-			putter = bytes_per_chunk >> 1;
-			while (chunks--) {
-				for (i = 0; i < bytes_per_chunk; i++)
-					databuff[i] = read_char_direct();
-				src = i = 0;
-				while (i++ < putter) {
-					tempo =
-					    (ascii_to_bin(databuff[src++])
-					     << 4) |
-					    ascii_to_bin(databuff[src++]);
-					csum += tempo;
-					*(char *) address++ = tempo;
-				}
-			}
-			if (leftovers) {
-				putter = leftovers / 2;
-				for (i = 0; i < leftovers; i++)
-					databuff[i] = read_char_direct();
-				src = i = 0;
-				while (i++ < putter) {
-					tempo =
-					    (ascii_to_bin(databuff[src++])
-					     << 4) |
-					    ascii_to_bin(databuff[src++]);
-					csum += tempo;
-					*(char *) address++ = tempo;
-				}
-			}
-			break;
-
-		case '7':
-			address = 0;
-			for (i = 0; i < 4; i++) {
-				address <<= 8;
-				address |= get_pair();
-				length--;
-			}
-			if (address == -1) {
-				eof = 1;
-				continue;
-			}
-			client_pc = address;
-			if (length) {
-				*(char *) 0xbd000020 = display_error_bad_7;
-				//                      *(char*)0xbd00000c = display_error_bad_7;
-			}
-
-			done = 1;
-			break;
-
-		default:
-			*(char *) 0xbd000020 = display_error_unknown;
-			//              *(char*)0xbd00000c = display_error_unknown;
-
-			break;
-		}
-		save_csum = (~csum) & 0xff;
-		if ((csum = get_pair()) < 0) {
-			eof = 1;
-			continue;
-		}
-		if (csum != save_csum) {
-			*(char *) 0xbd000020 = display_error;
-			//                *(char*)0xbd00000c = display_error;
-		} else {
-
-			if (display_counter % 50 == 0) {
-				*(char *) 0xbd000020 = display_char;
-				display_counter = 0;
-			}
-			display_counter++;
-
-		}
-	}
-	--reccount;
-	dl_entry = client_pc;
-	return dl_entry;	/* Success */
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/Makefile linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/Makefile
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/Makefile	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,177 +0,0 @@
-# =============================================================
-#
-# linux/arch/mips/galileo/compressed/Makefile
-#
-# By RidgeRun Inc.
-#
-# Description:
-#   Create a system containing a copy of the compressed vmlinux kernel.
-#   The system knows how to decompress the contained kernel and then
-#   jump to it resulting in a linux kernel boot.
-#
-#   The system comes in three forms:
-#
-#       1. - ramsys -
-#          to be loaded into ram then run. When run
-#          it decompresses the kernel housed in its internal
-#          data structures and then jumps to the image which
-#          results in a linux kernel boot.
-#
-#       2. - flashsys -
-#          to be loaded into ram so that it can be
-#          burned into the onboard flash. Then the board jumpers
-#          can be switched so that the next power cycle caused
-#          the system in flash to run which then proceeds as
-#          described by #1 above.
-#          Note: burner.srec is the utility that will allow
-#          the user to get this image into flash.
-#
-#       3. - flashsys2 -
-#          to be loaded into ram so that it can be
-#          burned into the onboard flash. Then on each power
-#          cycle when the standard PMON prompt is presented
-#          the user can type `call 0xbf000000` to invoke
-#          the system in flash which then proceeds as
-#          described by #1 above.
-#          Note: burner.srec is the utility that will allow
-#          the user to get this image into flash.
-#
-#       4. - burner.srec -
-#          related to #2 and #3 above.
-#
-# =============================================================
-
-USE_STANDARD_AS_RULE := true
-
-all: ramsys.srec \
-     flashsys.srec \
-     flashsys2.srec \
-     burner.srec
-
-SYSTEM = $(TOPDIR)/vmlinux
-
-CFLAGS_2 = -DCONSOLE_SERIAL -DDELIMITERLINES -DGALILEO_PORT \
-           -DANSIESC -DELF_IMAGE -DELF_IMAGE -DDOWNLOAD_PROTO_TFTP \
-           -DEVB64120A -D__MIPSEB__ -DINCLUDE_EEPRO100 \
-           -DINCLUDE_GETH0 -DNOPRINTK -DPROM -DCOMPRESSEDVMLINUX
-
-sbdreset_evb64120A.o:
-	$(CC) $(CFLAGS) $(CFLAGS_2) -c sbdreset_evb64120A.S -o $*.o
-memory.o:
-	$(CC) $(CFLAGS) $(CFLAGS_2) -c memory.c -o $*.o
-pci.o:
-	$(CC) $(CFLAGS) $(CFLAGS_2) -c pci.c -o $*.o
-pci_etherboot.o:
-	$(CC) $(CFLAGS) $(CFLAGS_2) -c pci_etherboot.c -o $*.o
-load.o:
-	$(CC) $(CFLAGS) $(CFLAGS_2) -c load.c -o $*.o
-flashdrv.o:
-	$(CC) $(CFLAGS) $(CFLAGS_2) -c flashdrv.c -o $*.o
-
-gz2asm: gz2asm.c
-	g++ -o gz2asm gz2asm.c
-
-doit: doit.c
-	gcc -o doit doit.c
-
-piggy.gz: $(SYSTEM)
-	rm -f piggy piggy.gz
-	$(OBJCOPY) -S -O binary $(SYSTEM) piggy
-	gzip -f -9 < piggy > piggy.gz
-
-piggy.S: doit fixit piggy.gz
-	./doit < piggy.gz > piggy.S; . ./fixit piggy.S
-
-OBJECTS_ramsys    = head.o misc.o piggy.o ../serialGT.o
-OBJECTS_flashsys  = sbdreset_evb64120A.o evb64120A_Setup.o pci_etherboot.o memory.o pci.o head.o misc.o piggy.o ../serialGT.o
-OBJECTS_flashsys2 = xfer.o head.o misc.o piggy.o ../serialGT.o
-OBJECTS_burner    = burner.o load.o flashdrv.o
-
-ramsys.srec : $(OBJECTS_ramsys) ld.script.gal
-	@# Note: this image is intended to run out of ram. No flash involved.
-	$(LD) -T ld.script.gal -o ramsys $(OBJECTS_ramsys)
-	$(NM) ramsys | grep -v '\(compiled\)\|\(\.o$$\)\|\( [aU] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | sort > System_ramsys.map
-	$(OBJCOPY) -O srec ramsys ramsys.srec
-	cp ramsys.srec $(TOPDIR)/.
-
-flashsys.srec : $(OBJECTS_flashsys) ld.sys.big.Flash
-	@# Note1: Use the burn utility to get this image into flash.
-	@# Note2: This image is intended to run out of flash as invoked
-	@# directly at powerup when EVB64120A jumpers are configured to
-	@# bypass the onboard eprom.
-	@# Assumes that 0xBFC00000 is the bootup run address (normal MIPS).
-	@# And assumes that EVB64120A jumber J11 is added to the board and jumber
-	@# J20 is moved from the 2&3 position to the 1&2 position instead. Without
-	@# the jumper settings the system will execute at address 0xBFC00000,
-	@# as normal, yet that address will map to the onboard eeprom instead
-	@# of the onboard flash.
-	@#
-	$(LD) -T ld.sys.big.Flash -o flashsys $(OBJECTS_flashsys)
-	$(NM) flashsys | grep -v '\(compiled\)\|\(\.o$$\)\|\( a \)' | sort > System_flashsys.map
-	@#
-	@# Next, Create the image that we want to place in the flash part.
-	$(OBJCOPY)  -S -g --strip-unneeded \
-	      --adjust-section-vma=.text+0x3f820000 \
-	      --adjust-section-vma=.rodata+0x3f820000 \
-	      --adjust-section-vma=.reginfo+0x3f820000 \
-	      --adjust-section-vma=.data+0x3f820000  \
-	      --remove-section=.bss \
-	      --remove-section=.scommon \
-	      --remove-section=.note \
-	      --remove-section=.comment \
-	      flashsys flashsys.temp
-	@#
-	@# Next, change the addresses so that when we download to
-	@# to the board's ram it will land starting at address 0xA0300000
-	@# because this is where we have choosen to have the image temporarily sit
-	@# while we subsequently burn it (using some method not revealed here) into
-	@# the board's flash. After the burn the system can be setup (via jumpers)
-	@# to boot this image directory from the flash part.
-	$(OBJCOPY) -O srec --adjust-vma=0xe0700000 flashsys.temp flashsys.srec
-	cp flashsys.srec $(TOPDIR)/.
-
-flashsys2.srec : $(OBJECTS_flashsys2) ld.sys.big.Flash2
-	@# Note1: Use the burn utility to get this image into flash.
-	@# Note2: This image is intended to be run out of flash as invoked
-	@# manually from the standard PMON running in eprom. This means that
-	@# the image will be set to run from location 0xBF000000 which is the
-	@# location the flash is mapped to when the board jumpers are set to
-	@# the standard location such that the board boots out of onboard
-	@# eprom. From the PMON prompt the user can type `call 0xbf000000`
-	@# to transfer control to the image we are constructing here.
-	@#
-	$(LD) -T ld.sys.big.Flash2 -o flashsys2 $(OBJECTS_flashsys2)
-	$(NM) flashsys2 | grep -v '\(compiled\)\|\(\.o$$\)\|\( a \)' | sort > System_flashsys2.map
-	@#
-	@# Next, Create the image that we want to place in the flash part.
-	$(OBJCOPY)  -S -g --strip-unneeded \
-	      --adjust-section-vma=.text+0x3ec20000 \
-	      --adjust-section-vma=.rodata+0x3ec20000 \
-	      --adjust-section-vma=.reginfo+0x3ec20000 \
-	      --adjust-section-vma=.data+0x3ec20000  \
-	      --remove-section=.bss \
-	      --remove-section=.scommon \
-	      --remove-section=.note \
-	      --remove-section=.comment \
-	      flashsys2 flashsys2.temp
-	@#
-	@# Next, change the addresses so that when we download to
-	@# to the board's ram it will land starting at address 0xA0300000
-	@# because this is where we have choosen to have the image temporarily sit
-	@# while we subsequently burn it (using some method not revealed here) into
-	@# the board's flash. After the burn a user will then be able to type
-	@# `call 0xbf000000` at the PMON prompt (following a power cycle) to invoke
-	@# the linux kernel.
-	$(OBJCOPY) -O srec --adjust-vma=0xe1300000 flashsys2.temp flashsys2.srec
-	cp flashsys2.srec $(TOPDIR)/.
-
-burner.srec : $(OBJECTS_burner) ld.sys.big.burner
-	@# This utility can be used to burn the flashsys.srec or flashsys2.srec
-	@# into the EVB64120A's on board flash part (1Meg minimum).
-	$(LD) -T ld.sys.big.burner -o burner $(OBJECTS_burner)
-	$(NM) burner | grep -v '\(compiled\)\|\(\.o$$\)\|\( [aU] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | sort > System_burner.map
-	$(OBJCOPY) -O srec burner burner.srec
-	cp burner.srec $(TOPDIR)/.
-
-clean:
-	rm -f doit piggy.S piggy.gz piggy burner *.o ramsys* flashsys* System*.map *.srec
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/meminit.S linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/meminit.S
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/meminit.S	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/meminit.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,187 +0,0 @@
-/*
- * Define BUSWIDTH to usually be real buswidth X 2 (i.e assuming
- * 2-way interleaving).  This is so that the test pattern and
- * inverted pattern are written to the same bank of memory, which
- * prevents us reading back data sitting in the dram buffers and
- * getting a false match.
- */
-
-#ifndef BUSWIDTH
-# if #cpu(r3000) || #cpu(r4300) || #cpu(r4650)
-#  define BUSWIDTH	8		/* 32 bit memory, bank interleaved */
-# elif #cpu(r4000)
-#  define BUSWIDTH	16		/* 64 bit memory, bank interleaved */
-# endif
-#endif
-
-#ifndef RAM_BASE
-#define RAM_BASE	KSEG1_BASE
-#endif
-
-#ifndef MEMSTART
-#define MEMSTART	0x0		/* start of physical memory */
-#endif
-
-#ifndef MEMINCR
-# define MEMINCR	0x10000		/* work up in 64Kb increments */
-#endif
-
-SLEAF(size_mem)
-	mfc0	t8,C0_STATUS
-#if #cpu(r4000)
-	/* disable cache and memory parity checking */
-	or	t0,t8,SR_DE
-	mtc0	t0,C0_STATUS
-#endif
-
-	li	t0,RAM_BASE+MEMSTART	# start at bottom of phys mem
-	move	t1,t0			# remember start address
-	li	t2,0xaa55aa55		# pattern
-	not	t3,t2			# ~pattern
-
-	move	t7,k0
-	la	t4,.fail		# bus error exception catcher
-	addu	k0,t4,s8		# RELOC
-
-	/* fill first 64Kb with zero (for cache init) */
-	move	t4,t0
-	li	t5,0x10000
-1:	sw	zero,0(t4)
-	sw	zero,4(t4)
-	sw	zero,8(t4)
-	sw	zero,12(t4)
-	subu	t5,16
-	addu	t4,16
-	bnez	t5,1b
-
-.loop:
-        addu    t0,MEMINCR
-	move	t4,t0
-
-	/* store pattern in bank 0, line 0 */
-	sw	t2,0(t4)
-	addu	t4,4
-
-#if BUSWIDTH > 4
-	/* fill remainder of line with zeros */
-	li	t5,BUSWIDTH-4
-1:	sw	zero,0(t4)
-	subu	t5,4
-	addu	t4,4
-	bnez	t5,1b
-#endif
-
-	/* store inverse pattern in bank 0, line 1 */
-	sw	t3,0(t4)
-	addu	t4,4
-
-#if BUSWIDTH > 4
-	/* fill remainder of line with zeros */
-	li	t5,BUSWIDTH-4
-1:	sw	zero,0(t4)
-	subu	t5,4
-	addu	t4,4
-	bnez	t5,1b
-#endif
-
-	/* defeat write buffering */
-#if #cpu(r4000)
-	sync
-#else
-	lw	zero,-4(t4)
-#endif
-
-	lw	t4,0(t0)		# read first word of line
-	lw	t5,0(t1)		# read start of memory (should be zero)
-	bne	t4,t2,.fail		# this line wrong?
-        beq     t5,zero,.loop		# start of mem overwritten?
-
-.fail:
-	move	k0,t7			# clear exception catcher
-
-	/* restore Status register */
-	mtc0	t8,C0_STATUS
-
-	/* return top of memory offset (normally == size) */
-	subu 	v0,t0,RAM_BASE
-	j	ra
-END(size_mem)
-
-
-/*
- * We must often initialise memory so that it has good parity/ecc,
- * and this must be done before the caches are used.
- */
-
-/*
-	clear_mem (size)
-	  - clear memory from RAM_BASE+MEMSTART to RAM_BASE+MEMSTART+size
-	clear_mem_range (size, start)
-	  - clear memory from start to start+size
-*/
-
-SLEAF(clear_mem)
-	li	a1,RAM_BASE+MEMSTART	# start at bottom of phys mem
-clear_mem_range:
-	beqz	a0,9f
-	addu	a0,a1			# end of memory
-
-	/* XXX should run cached, but caches may not be initialised yet */
-	.set noreorder
-#if __mips >= 3
-1:	sd	zero,0(a1)
-	sd	zero,8(a1)
-	sd	zero,16(a1)
-	sd	zero,24(a1)
-	sd	zero,32(a1)
-	sd	zero,40(a1)
-	sd	zero,48(a1)
-	addu	a1,64
-	bne	a1,a0,1b
-	sd	zero,-8(a1)		# BDSLOT
-#else
-1:	sw	zero,0(a1)
-	sw	zero,4(a1)
-	sw	zero,8(a1)
-	sw	zero,12(a1)
-	sw	zero,16(a1)
-	sw	zero,20(a1)
-	sw	zero,24(a1)
-	sw	zero,28(a1)
-	sw	zero,32(a1)
-	sw	zero,36(a1)
-	sw	zero,40(a1)
-	sw	zero,44(a1)
-	sw	zero,48(a1)
-	sw	zero,52(a1)
-	sw	zero,56(a1)
-	addu	a1,64
-	bne	a1,a0,1b
-	sw	zero,-4(a1)		# BDSLOT
-#endif
-	.set	reorder
-
-9:	j	ra
-END(clear_mem)
-
-
-SLEAF(init_tlb)
-	/* initialise tlb */
-	mtc0	zero,C0_TLBLO0		/* tlblo0 = invalid */
-	mtc0	zero,C0_TLBLO1		/* tlblo1 = invalid */
-        mtc0	zero,C0_PGMASK
-	li	t8,K1BASE		/* tlbhi  = impossible vpn */
-	li	t9,(NTLBENTRIES-1)	/* index */
-
-	.set noreorder
-	nop
-1:	mtc0	t8,C0_TLBHI
-	mtc0	t9,C0_INX
-	addu	t8,0x2000		/* inc vpn */
-	tlbwi
-	bnez	t9,1b
-	subu	t9,1			# BDSLOT
-	.set reorder
-
-	j	ra
-END(init_tlb)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/memory.c linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/memory.c
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/memory.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/memory.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,593 +0,0 @@
-/* Memory.c - Memory mappings and remapping functions */
-
-/* Copyright - Galileo technology. */
-
-/*
-DESCRIPTION
-This file contains function which gives the user the ability to remap the
-SDRAM memory and devices windows, please pay attention to overlapping windows
-since the function do not take care of that for you.
-When remapping the SDRAM or devices memory space pay attention to the PCI
-mappings and make sure to coordinate between the two interfaces!!!
-*/
-
-/* includes */
-
-#ifdef __linux__
-#include <asm/galileo-boards/evb64120A/core.h>
-#include <asm/galileo-boards/evb64120A/memory.h>
-#else
-#include "Core.h"
-#include "Memory.h"
-#endif
-
-/********************************************************************
-* getMemoryBankBaseAddress - Extract the base address of a memory bank
-*      - If the memory bank size is 0 then this base address has no meaning !!!
-*
-* INPUTS:  MEMORY_BANK bank - SDRAM Bank number.
-* OUTPUT:  N/A
-* RETURNS: Memory bank base address.
-*********************************************************************/
-unsigned int getMemoryBankBaseAddress(MEMORY_BANK bank)
-{
-	unsigned int base, regBase;
-	GT_REG_READ((SCS_1_0_LOW_DECODE_ADDRESS + (bank / 2) * 0x10),
-		    &base);
-	base = base << 21;
-	GT_REG_READ((SCS_0_LOW_DECODE_ADDRESS + bank * 8), &regBase);
-	base = base | (regBase << 20);
-	return base;
-}
-
-/********************************************************************
-* getDeviceBaseAddress - Extract the base address of a device.
-*           - If the device size is 0 then this base address has no meaning!!!
-*
-* INPUT:   DEVICE device - Bank number.
-* OUTPUT:  N/A
-* RETURNS: Device base address.
-*********************************************************************/
-unsigned int getDeviceBaseAddress(DEVICE device)
-{
-	unsigned int base, regBase;
-	GT_REG_READ((CS_2_0_LOW_DECODE_ADDRESS + (device / 3) * 0x10),
-		    &base);
-	base = base << 21;
-	GT_REG_READ((CS_0_LOW_DECODE_ADDRESS + device * 0x8), &regBase);
-	base = base | (regBase << 20);
-	return base;
-}
-
-/********************************************************************
-* getMemoryBankSize - Extract the size of a memory bank.
-*
-* INPUT:   MEMORY_BANK bank - Bank number
-* OUTPUT:  N/A
-* RETURNS: Memory bank size.
-*********************************************************************/
-unsigned int getMemoryBankSize(MEMORY_BANK bank)
-{
-	unsigned int size, base, value;
-	base = getMemoryBankBaseAddress(bank);
-	GT_REG_READ((SCS_0_HIGH_DECODE_ADDRESS + bank * 8), &size);
-	size = ((size + 1) << 20) - (base & 0x0fffffff);
-	GT_REG_READ((SCS_0_HIGH_DECODE_ADDRESS + bank * 8), &value);
-	if (value == 0)
-		return 0;
-	else
-		return size;
-}
-
-/********************************************************************
-* getDeviceSize - Extract the size of a device memory space
-*
-* INPUT:    DEVICE device - Device number
-* OUTPUT:   N/A
-* RETURNS:  Size of a device memory space.
-*********************************************************************/
-unsigned int getDeviceSize(DEVICE device)
-{
-	unsigned int size, base, value;
-	base = getDeviceBaseAddress(device);
-	GT_REG_READ((CS_0_HIGH_DECODE_ADDRESS + device * 8), &size);
-	size = ((size + 1) << 20) - (base & 0x0fffffff);
-	GT_REG_READ((CS_0_HIGH_DECODE_ADDRESS + device * 8), &value);
-	if ((value + 1) == 0)
-		return 0;
-	else
-		return size;
-}
-
-/********************************************************************
-* getDeviceWidth - A device can be with: 1,2,4 or 8 Bytes data width.
-*                  The width is determine in registers: 'Device Parameters'
-*                  registers (0x45c, 0x460, 0x464, 0x468, 0x46c - for each device.
-*                  at bits: [21:20].
-*
-* INPUT:    DEVICE device - Device number
-* OUTPUT:   N/A
-* RETURNS:  Device width in Bytes (1,2,4, or 8), 0 if error had occurred.
-*********************************************************************/
-unsigned int getDeviceWidth(DEVICE device)
-{
-	unsigned int width;
-	unsigned int regValue;
-
-	GT_REG_READ(DEVICE_BANK0PARAMETERS + device * 4, &regValue);
-	width = (regValue & 0x00300000) >> 20;
-	switch (width) {
-	case 0:
-		return 1;
-	case 1:
-		return 2;
-	case 2:
-		return 4;
-	case 3:
-		return 8;
-	default:
-		return 0;
-	}
-}
-
-/********************************************************************
-* mapMemoryBanks0and1 - Sets new bases and boundaries for memory banks 0 and 1
-*                     - Pay attention to the PCI mappings and make sure to
-*                       coordinate between the two interfaces!!!
-*                     - It is the programmer`s responsibility to make sure
-*                       there are no conflicts with other memory spaces!!!
-*                     - If a bank needs to be closed , give it a 0 length
-*
-*
-* INPUTS: unsigned int bank0Base - required bank 0 base address.
-*         unsigned int bank0Length - required bank 0 size.
-*         unsigned int bank1Base - required bank 1 base address.
-*         unsigned int bank1Length - required bank 1 size.
-* RETURNS: true on success, false on failure or if one of the parameters is
-*          erroneous.
-*********************************************************************/
-bool mapMemoryBanks0and1(unsigned int bank0Base, unsigned int bank0Length,
-			 unsigned int bank1Base, unsigned int bank1Length)
-{
-	unsigned int mainBank0Top = bank0Base + bank0Length;
-	unsigned int mainBank1Top = bank1Base + bank1Length;
-	unsigned int memBank0Base, bank0Top;
-	unsigned int memBank1Base, bank1Top;
-
-	if (bank0Base <= bank1Base) {
-		if ((bank0Base + bank0Length) > bank1Base)
-			return false;
-	} else {
-		if ((bank1Base + bank1Length) > bank0Base)
-			return false;
-	}
-
-	if (bank0Length == 0)
-		mainBank0Top++;
-	if (bank1Length == 0)
-		mainBank1Top++;
-
-	memBank0Base = ((unsigned int) (bank0Base & 0x0fffffff)) >> 20;
-	bank0Top = ((unsigned int) (mainBank0Top & 0x0fffffff)) >> 20;
-	memBank1Base = ((unsigned int) (bank1Base & 0x0fffffff)) >> 20;
-	bank1Top = ((unsigned int) (mainBank1Top & 0x0fffffff)) >> 20;
-
-	if (mainBank1Top > mainBank0Top) {
-		bank0Base >>= 21;
-		mainBank0Top =
-		    ((unsigned int) (mainBank1Top & 0x0fffffff)) >> 21;
-	} else {
-		bank0Base = bank1Base >> 21;
-		mainBank0Top =
-		    ((unsigned int) (mainBank0Top & 0x0fffffff)) >> 21;
-	}
-	GT_REG_WRITE(SCS_1_0_LOW_DECODE_ADDRESS, bank0Base);
-	if ((bank0Length + bank1Length) != 0) {
-		GT_REG_WRITE(SCS_1_0_HIGH_DECODE_ADDRESS,
-			     mainBank0Top - 1);
-	} else {
-		GT_REG_WRITE(SCS_1_0_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	if (bank1Length != 0) {
-		GT_REG_WRITE(SCS_1_HIGH_DECODE_ADDRESS, bank1Top - 1);
-	} else {
-		GT_REG_WRITE(SCS_1_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	GT_REG_WRITE(SCS_1_LOW_DECODE_ADDRESS, memBank1Base);
-	if (bank0Length != 0) {
-		GT_REG_WRITE(SCS_0_HIGH_DECODE_ADDRESS, bank0Top - 1);
-	} else {
-		GT_REG_WRITE(SCS_0_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	GT_REG_WRITE(SCS_0_LOW_DECODE_ADDRESS, memBank0Base);
-	return true;
-}
-
-/********************************************************************
-* mapMemoryBanks2and3 - Sets new bases and boundaries for memory banks 2 and 3
-*                     - Pay attention to the PCI mappings and make sure to
-*                       coordinate between the two interfaces!!!
-*                     - It`s the programmer`s responsibility to make sure there
-*                       are no conflicts with other memory spaces!!!
-*                     - If a bank needs to be closed , give it a 0 length.
-*
-*
-* INPUTS: unsigned int bank2Base - required bank 2 base address.
-*         unsigned int bank2Length - required bank 2 size.
-*         unsigned int bank3Base - required bank 3 base address.
-*         unsigned int bank3Length - required bank 3 size.
-* RETURNS: true on success, false on failure or if one of the parameters is
-*          erroneous.
-*********************************************************************/
-bool mapMemoryBanks2and3(unsigned int bank2Base, unsigned int bank2Length,
-			 unsigned int bank3Base, unsigned int bank3Length)
-{
-	unsigned int mainBank2Top =
-	    (unsigned int) (bank2Base + bank2Length);
-	unsigned int mainBank3Top =
-	    (unsigned int) (bank3Base + bank3Length);
-	unsigned int memBank2Base, bank2Top;
-	unsigned int memBank3Base, bank3Top;
-
-	if (bank2Base <= bank3Base) {
-		if ((bank2Base + bank2Length) > bank3Base)
-			return false;
-	} else {
-		if ((bank3Base + bank3Length) > bank2Base)
-			return false;
-	}
-	if (bank2Length == 0)
-		mainBank2Top++;
-	if (bank3Length == 0)
-		mainBank3Top++;
-
-	memBank2Base = ((unsigned int) (bank2Base & 0x0fffffff)) >> 20;
-	bank2Top = ((unsigned int) (mainBank2Top & 0x0fffffff)) >> 20;
-	memBank3Base = ((unsigned int) (bank3Base & 0x0fffffff)) >> 20;
-	bank3Top = ((unsigned int) (mainBank3Top & 0x0fffffff)) >> 20;
-
-	if (mainBank3Top > mainBank2Top) {
-		bank2Base >>= 21;
-		mainBank2Top =
-		    ((unsigned int) (mainBank3Top & 0x0fffffff)) >> 21;
-	} else {
-		bank2Base = bank3Base >> 21;
-		mainBank2Top =
-		    ((unsigned int) (mainBank2Top & 0x0fffffff)) >> 21;
-	}
-	GT_REG_WRITE(SCS_3_2_LOW_DECODE_ADDRESS, bank2Base);
-	if ((bank2Length + bank3Length) != 0) {
-		GT_REG_WRITE(SCS_3_2_HIGH_DECODE_ADDRESS,
-			     mainBank2Top - 1);
-	} else {
-		GT_REG_WRITE(SCS_3_2_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	if (bank3Length != 0) {
-		GT_REG_WRITE(SCS_3_HIGH_DECODE_ADDRESS, bank3Top - 1);
-	} else {
-		GT_REG_WRITE(SCS_3_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	GT_REG_WRITE(SCS_3_LOW_DECODE_ADDRESS, memBank3Base);
-	if (bank2Length != 0) {
-		GT_REG_WRITE(SCS_2_HIGH_DECODE_ADDRESS, bank2Top - 1);
-	} else {
-		GT_REG_WRITE(SCS_2_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	GT_REG_WRITE(SCS_2_LOW_DECODE_ADDRESS, memBank2Base);
-	return true;
-}
-
-/********************************************************************
-* mapDevices0_1and2MemorySpace - Sets new bases and boundaries for devices 0,1
-*                                and 2
-*                     - Pay attention to the PCI mappings and make sure to
-*                        coordinate between the two interfaces!!!
-*                     - It`s the programmer`s responsibility to make sure there
-*                       are no conflicts with other memory spaces!!!
-*                     - If a device needs to be closed , give it a 0 length
-*
-*
-* INPUTS: unsigned int device0Base - required cs_0 base address.
-*         unsigned int device0Length - required cs_0 size.
-*         unsigned int device1Base - required cs_1 base address.
-*         unsigned int device1Length - required cs_0 size.
-*         unsigned int device2Base - required cs_2 base address.
-*         unsigned int device2Length - required cs_2 size.
-* RETURNS: true on success, false on failure or if one of the parameters is
-*          erroneous.
-*********************************************************************/
-bool mapDevices0_1and2MemorySpace(unsigned int device0Base,
-				  unsigned int device0Length,
-				  unsigned int device1Base,
-				  unsigned int device1Length,
-				  unsigned int device2Base,
-				  unsigned int device2Length)
-{
-	unsigned int deviceBank0Top =
-	    (unsigned int) (device0Base + device0Length);
-	unsigned int deviceBank1Top =
-	    (unsigned int) (device1Base + device1Length);
-	unsigned int deviceBank2Top =
-	    (unsigned int) (device2Base + device2Length);
-	unsigned int device0BaseTemp = 0, device0TopTemp = 0;
-	unsigned int bank0Base, bank0Top;
-	unsigned int bank1Base, bank1Top;
-	unsigned int bank2Base, bank2Top;
-	bank0Base = ((unsigned int) (device0Base & 0x0fffffff)) >> 20;
-	bank0Top = ((unsigned int) (deviceBank0Top & 0x0fffffff)) >> 20;
-	bank1Base = ((unsigned int) (device1Base & 0x0fffffff)) >> 20;
-	bank1Top = ((unsigned int) (deviceBank1Top & 0x0fffffff)) >> 20;
-	bank2Base = ((unsigned int) (device2Base & 0x0fffffff)) >> 20;
-	bank2Top = ((unsigned int) (deviceBank2Top & 0x0fffffff)) >> 20;
-
-	if (device0Length == 0)
-		deviceBank0Top++;
-	if (device1Length == 0)
-		deviceBank1Top++;
-	if (device2Length == 0)
-		deviceBank2Top++;
-
-	if (device0Base <= device1Base && device0Base <= device2Base) {
-		if ((device0Base + device0Length) > device1Base || \
-		    (device0Base + device0Length) > device2Base)
-			return false;
-		if (device1Base <= device2Base) {
-			if ((device1Base + device1Length) > device2Base)
-				return false;
-		} else {
-			if ((device2Base + device2Length) > device1Base)
-				return false;
-		}
-	}
-
-	if (device1Base <= device0Base && device1Base <= device2Base) {
-		if ((device1Base + device1Length) > device0Base ||
-		    (device1Base + device1Length) > device2Base)
-			return false;
-		if (device0Base <= device2Base) {
-			if ((device0Base + device0Length) > device2Base)
-				return false;
-		} else {
-			if ((device2Base + device2Length) > device0Base)
-				return false;
-		}
-	}
-
-	if (device2Base <= device1Base && device2Base <= device0Base) {
-		if ((device2Base + device2Length) > device1Base ||
-		    (device2Base + device2Length) > device0Base)
-			return false;
-		if (device0Base <= device1Base) {
-			if ((device0Base + device0Length) > device1Base)
-				return false;
-		} else {
-			if ((device1Base + device1Length) > device0Base)
-				return false;
-		}
-	}
-
-	if ((deviceBank2Top > deviceBank1Top) && (deviceBank1Top >
-						  deviceBank0Top)) {
-		device0BaseTemp = device0Base >> 21;
-		device0TopTemp =
-		    ((unsigned int) (deviceBank2Top & 0x0fffffff)) >> 21;
-	}
-	if ((deviceBank2Top > deviceBank0Top)
-	    && (deviceBank0Top > deviceBank1Top)) {
-		device0BaseTemp = device1Base >> 21;
-		device0TopTemp =
-		    ((unsigned int) (deviceBank2Top & 0x0fffffff)) >> 21;
-	}
-	if ((deviceBank1Top > deviceBank2Top)
-	    && (deviceBank2Top > deviceBank0Top)) {
-		device0BaseTemp = device0Base >> 21;
-		device0TopTemp =
-		    ((unsigned int) (deviceBank1Top & 0x0fffffff)) >> 21;
-	}
-	if ((deviceBank1Top > deviceBank0Top)
-	    && (deviceBank0Top > deviceBank2Top)) {
-		device0BaseTemp = device2Base >> 21;
-		device0TopTemp =
-		    ((unsigned int) (deviceBank1Top & 0x0fffffff)) >> 21;
-	}
-	if ((deviceBank0Top > deviceBank2Top)
-	    && (deviceBank2Top > deviceBank1Top)) {
-		device0BaseTemp = device1Base >> 21;
-		device0TopTemp =
-		    ((unsigned int) (deviceBank0Top & 0x0fffffff)) >> 21;
-	}
-	if ((deviceBank0Top > deviceBank1Top)
-	    && (deviceBank1Top > deviceBank2Top)) {
-		device0BaseTemp = device2Base >> 21;
-		device0TopTemp =
-		    ((unsigned int) (deviceBank0Top & 0x0fffffff)) >> 21;
-	}
-	GT_REG_WRITE(CS_2_0_LOW_DECODE_ADDRESS, device0BaseTemp);
-	if ((device0Length + device1Length + device2Length) != 0) {
-		GT_REG_WRITE(CS_2_0_HIGH_DECODE_ADDRESS,
-			     device0TopTemp - 1);
-	} else {
-		GT_REG_WRITE(CS_2_0_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	GT_REG_WRITE(CS_0_LOW_DECODE_ADDRESS, bank0Base);
-	if (device0Length != 0) {
-		GT_REG_WRITE(CS_0_HIGH_DECODE_ADDRESS, bank0Top - 1);
-	} else {
-		GT_REG_WRITE(CS_0_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	GT_REG_WRITE(CS_1_LOW_DECODE_ADDRESS, bank1Base);
-	if (device1Length != 0) {
-		GT_REG_WRITE(CS_1_HIGH_DECODE_ADDRESS, bank1Top - 1);
-	} else {
-		GT_REG_WRITE(CS_1_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	GT_REG_WRITE(CS_2_LOW_DECODE_ADDRESS, bank2Base);
-	if (device2Length != 0) {
-		GT_REG_WRITE(CS_2_HIGH_DECODE_ADDRESS, bank2Top - 1);
-	} else {
-		GT_REG_WRITE(CS_2_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	return true;
-}
-
-/********************************************************************
-* mapDevices3andBootMemorySpace - Sets new bases and boundaries for devices:
-*                                 3 and boot
-*                     - Pay attention to the PCI mappings and make sure to
-*                       coordinate between the two interfaces!!!
-*                     - It is the programmer`s responsibility to make sure
-*                       there are no conflicts with other memory spaces!!!
-*                     - If a device needs to be closed , give it a 0 length.
-*
-* INPUTS: base and length of device 3and boot
-* RETURNS: true on success, false on failure
-*********************************************************************/
-bool mapDevices3andBootMemorySpace(unsigned int device3Base,
-				   unsigned int device3Length,
-				   unsigned int bootDeviceBase,
-				   unsigned int bootDeviceLength)
-{
-	unsigned int deviceBank3Top =
-	    (unsigned int) (device3Base + device3Length);
-	unsigned int deviceBankBootTop =
-	    (unsigned int) (bootDeviceBase + bootDeviceLength);
-	unsigned int bank3Base, bank3Top;
-	unsigned int bank4Base, bank4Top;
-	unsigned int Device1Base, Device1Top;
-
-	bank3Top = ((unsigned int) (deviceBank3Top & 0x0fffffff)) >> 20;
-	bank4Top = ((unsigned int) (deviceBankBootTop & 0x0fffffff)) >> 20;
-	bank3Base = ((unsigned int) (device3Base & 0x0fffffff)) >> 20;
-	bank4Base = ((unsigned int) (bootDeviceBase & 0x0fffffff)) >> 20;
-
-	if (device3Base <= bootDeviceBase) {
-		if (deviceBank3Top > bootDeviceBase)
-			return false;
-	} else {
-		if (deviceBankBootTop > device3Base)
-			return false;
-	}
-
-	if (deviceBankBootTop > deviceBank3Top) {
-		Device1Base = device3Base >> 21;
-		Device1Top =
-		    ((unsigned int) (deviceBankBootTop & 0x0fffffff)) >>
-		    21;
-	} else {
-		Device1Base = bootDeviceBase >> 21;
-		Device1Top =
-		    ((unsigned int) (deviceBank3Top & 0x0fffffff)) >> 21;
-	}
-	GT_REG_WRITE(CS_3_BOOTCS_LOW_DECODE_ADDRESS, Device1Base);
-	if ((device3Length + bootDeviceLength) != 0) {
-		GT_REG_WRITE(CS_3_BOOTCS_HIGH_DECODE_ADDRESS,
-			     Device1Top - 1);
-	} else {
-		GT_REG_WRITE(CS_3_BOOTCS_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	GT_REG_WRITE(CS_3_LOW_DECODE_ADDRESS, bank3Base);
-	if (device3Length != 0) {
-		GT_REG_WRITE(CS_3_HIGH_DECODE_ADDRESS, bank3Top - 1);
-	} else {
-		GT_REG_WRITE(CS_3_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	GT_REG_WRITE(BOOTCS_LOW_DECODE_ADDRESS, bank4Base);
-	if (bootDeviceLength != 0) {
-		GT_REG_WRITE(BOOTCS_HIGH_DECODE_ADDRESS, bank4Top - 1);
-	} else {
-		GT_REG_WRITE(BOOTCS_HIGH_DECODE_ADDRESS, 0x0);
-	}
-	return true;
-}
-
-/********************************************************************
-* modifyDeviceParameters - This function can be used to modify a device`s
-*                          parameters.
-*                        - Be advised to check the spec before modifying them.
-* Inputs:
-* Returns: false if one of the parameters is erroneous,true otherwise.
-*********************************************************************/
-bool modifyDeviceParameters(DEVICE device, unsigned int turnOff,
-			    unsigned int accToFirst,
-			    unsigned int accToNext, unsigned int aleToWr,
-			    unsigned int wrActive, unsigned int wrHigh,
-			    unsigned int width, bool paritySupport)
-{
-	unsigned int data, oldValue;
-
-	if ((turnOff > 0x7 && turnOff != DONT_MODIFY)
-	    || (accToFirst > 0xf && accToFirst != DONT_MODIFY)
-	    || (accToNext > 0xf && accToNext != DONT_MODIFY)
-	    || (aleToWr > 0x7 && aleToWr != DONT_MODIFY)
-	    || (wrActive > 0x7 && wrActive != DONT_MODIFY)
-	    || (wrHigh > 0x7 && wrHigh != DONT_MODIFY)) {
-		return false;
-	}
-
-	GT_REG_READ((DEVICE_BANK0PARAMETERS + device * 4), &oldValue);
-	if (turnOff == DONT_MODIFY)
-		turnOff = oldValue & 0x00000007;
-	else
-		turnOff = turnOff;
-
-	if (accToFirst == DONT_MODIFY)
-		accToFirst = oldValue & 0x00000078;
-	else
-		accToFirst = accToFirst << 3;
-
-	if (accToNext == DONT_MODIFY)
-		accToNext = oldValue & 0x00000780;
-	else
-		accToNext = accToNext << 7;
-
-	if (aleToWr == DONT_MODIFY)
-		aleToWr = oldValue & 0x00003800;
-	else
-		aleToWr = aleToWr << 11;
-
-	if (wrActive == DONT_MODIFY)
-		wrActive = oldValue & 0x0001c000;
-	else
-		wrActive = wrActive << 14;
-
-	if (wrHigh == DONT_MODIFY)
-		wrHigh = oldValue & 0x000e0000;
-	else
-		wrHigh = wrHigh << 17;
-
-	data =
-	    turnOff | accToFirst | accToNext | aleToWr | wrActive | wrHigh;
-	switch (width) {
-	case _8BIT:
-		break;
-	case _16BIT:
-		data = data | _16BIT;
-		break;
-	case _32BIT:
-		data = data | _32BIT;
-		break;
-	case _64BIT:
-		data = data | _64BIT;
-		break;
-	default:
-		return false;
-	}
-	if (paritySupport == true)
-		data = data | PARITY_SUPPORT;
-	GT_REG_WRITE(DEVICE_BANK0PARAMETERS + device * 4, data);
-	return true;
-}
-
-/********************************************************************
-* remapAddress - This fubction used for address remapping
-* Inputs:      - regOffset: remap register
-*                remapHeader : remapped address
-* Returns: false if one of the parameters is erroneous,true otherwise.
-*********************************************************************/
-bool remapAddress(unsigned int remapReg, unsigned int remapValue)
-{
-	unsigned int valueForReg;
-	valueForReg = (remapValue & 0xffe00000) >> 21;
-	GT_REG_WRITE(remapReg, valueForReg);
-	return true;
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/misc.c linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/misc.c
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/misc.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/misc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,313 +0,0 @@
-/*
- * arch/mips/galileo/misc.c
- *
- * This is a collection of several routines from gzip-1.0.3
- * adapted for Linux.
- *
- * malloc by Hannu Savolainen 1993 and Matthias Urlichs 1994
- * puts by Nick Holloway 1993, better puts by Martin Mares 1995
- * High loaded stuff by Hans Lermen & Werner Almesberger, Feb. 1996
- *
- * Modified by RidgeRun Inc.
- */
-
-#include <linux/vmalloc.h>
-#include <asm/io.h>
-/*
- * gzip declarations
- */
-
-#define OF(args)  args
-#define STATIC static
-
-#define channel 1
-
-#undef memset
-#undef memcpy
-#define memzero(s, n)     memset ((s), 0, (n))
-
-typedef unsigned char uch;
-typedef unsigned short ush;
-typedef unsigned long ulg;
-
-#define WSIZE 0x8000		/* Window size must be at least 32k, */
-			     /* and a power of two */
-
-static uch *inbuf;		/* input buffer */
-static uch window[WSIZE];	/* Sliding window buffer */
-
-static unsigned insize = 0;	/* valid bytes in inbuf */
-static unsigned inptr = 0;	/* index of next byte to be processed in inbuf */
-static unsigned outcnt = 0;	/* bytes in output buffer */
-
-/* gzip flag byte */
-#define ASCII_FLAG   0x01	/* bit 0 set: file probably ASCII text */
-#define CONTINUATION 0x02	/* bit 1 set: continuation of multi-part gzip file */
-#define EXTRA_FIELD  0x04	/* bit 2 set: extra field present */
-#define ORIG_NAME    0x08	/* bit 3 set: original file name present */
-#define COMMENT      0x10	/* bit 4 set: file comment present */
-#define ENCRYPTED    0x20	/* bit 5 set: file is encrypted */
-#define RESERVED     0xC0	/* bit 6,7:   reserved */
-
-void variable_init();
-static void puts(const char *);
-
-void int2hex(int i)
-{
-	int tth, th, h, t, d;
-
-	if (i > 99999) {
-		serial_putc(channel, "Error - int2hex outofbounds");
-		return;
-	}
-
-	tth = (i) / 10000;
-	th = (i - (tth * 10000)) / 1000;
-	h = (i - ((tth * 10000) + (th * 1000))) / 100;
-	t = (i - ((tth * 10000) + (th * 1000) + (h * 100))) / 10;
-	d = (i - ((tth * 10000) + (th * 1000) + (h * 100) + (t * 10)));
-	serial_putc(channel, tth + '0');
-	serial_putc(channel, th + '0');
-	serial_putc(channel, h + '0');
-	serial_putc(channel, t + '0');
-	serial_putc(channel, d + '0');
-}
-
-int checksum;
-int byte_count;
-static unsigned char *input_data;
-
-static int printCnt = 0;
-
-int get_byte()
-{
-	unsigned char c = (inptr < insize ? inbuf[inptr++] : fill_inbuf());
-	byte_count++;
-	checksum += c;
-
-	// if (printCnt++ < 150)
-	// {
-	//   puts("\n");
-	//   puts("byte count = ");
-	//   int2hex(byte_count & 0xff);
-	//   puts(" byte val = ");
-	//   int2hex(c);
-	//   puts(" checksum = ");
-	//   int2hex(checksum & 0xff);
-	//   puts("\n");
-	// }
-	return c;
-}
-
-/* Diagnostic functions */
-#ifdef DEBUG
-#  define Assert(cond,msg) {if(!(cond)) error(msg);}
-#  define Trace(x) fprintf x
-#  define Tracev(x) {if (verbose) fprintf x ;}
-#  define Tracevv(x) {if (verbose>1) fprintf x ;}
-#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
-#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
-#else
-#  define Assert(cond,msg)
-#  define Trace(x)
-#  define Tracev(x)
-#  define Tracevv(x)
-#  define Tracec(c,x)
-#  define Tracecv(c,x)
-#endif
-
-static int fill_inbuf(void);
-static void flush_window(void);
-static void error(char *m);
-static void gzip_mark(void **);
-static void gzip_release(void **);
-
-/*
- * This is set up by the setup-routine at boot-time
- */
-
-
-#define STACK_SIZE (4096)
-long user_stack[STACK_SIZE];
-long *stack_start = &user_stack[STACK_SIZE];
-
-extern int linux_compressed_start;
-extern int linux_compressed_size;
-extern int malloc_start;
-
-static int input_len;
-
-static long bytes_out = 0;
-extern int kernel_location_start;
-static uch *output_data;
-static unsigned long output_ptr = 0;
-
-
-static void *malloc(int size);
-static void free(void *where);
-static void error(char *m);
-static void gzip_mark(void **);
-static void gzip_release(void **);
-
-static unsigned long free_mem_ptr;
-static unsigned long free_mem_end_ptr;
-
-#include "../../../../../lib/inflate.c"
-
-static void *malloc(int size)
-{
-	void *p;
-
-	if (size < 0)
-		error("Malloc error\n");
-	//      if (free_mem_ptr <= 0) error("Memory error\n");
-
-	free_mem_ptr = (free_mem_ptr + 3) & ~3;	/* Align */
-
-	p = (void *) free_mem_ptr;
-	free_mem_ptr += size;
-
-	if (free_mem_ptr >= free_mem_end_ptr)
-		error("\nOut of memory\n");
-
-	return p;
-}
-
-static void free(void *where)
-{				/* Don't care */
-}
-
-static void gzip_mark(void **ptr)
-{
-	*ptr = (void *) free_mem_ptr;
-}
-
-static void gzip_release(void **ptr)
-{
-	free_mem_ptr = (long) *ptr;
-}
-
-static void puts(const char *s)
-{
-	while (*s) {
-		if (*s == 10)
-			serial_putc(channel, 13);
-		serial_putc(channel, *s++);
-	}
-}
-
-void *memset(void *s, int c, size_t n)
-{
-	int i;
-	char *ss = (char *) s;
-
-	for (i = 0; i < n; i++)
-		ss[i] = c;
-	return s;
-}
-
-void *memcpy(void *__dest, __const void *__src, size_t __n)
-{
-	int i;
-	char *d = (char *) __dest, *s = (char *) __src;
-
-	for (i = 0; i < __n; i++)
-		d[i] = s[i];
-	return __dest;
-}
-
-/* ===========================================================================
- * Fill the input buffer. This is called only when the buffer is empty
- * and at least one byte is really needed.
- */
-static int fill_inbuf(void)
-{
-	if (insize != 0) {
-		error("ran out of input data\n");
-	}
-
-	inbuf = input_data;
-	insize = input_len;
-	inptr = 1;
-	return inbuf[0];
-}
-
-/* ===========================================================================
- * Write the output window window[0..outcnt-1] and update crc and bytes_out.
- * (Used for the decompressed data only.)
- */
-static void flush_window(void)
-{
-	ulg c = crc;		/* temporary variable */
-	unsigned n;
-	uch *in, *out, ch;
-
-	in = window;
-	out = &output_data[output_ptr];
-	for (n = 0; n < outcnt; n++) {
-		ch = *out++ = *in++;
-		c = crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);
-	}
-	crc = c;
-	bytes_out += (ulg) outcnt;
-	output_ptr += (ulg) outcnt;
-	outcnt = 0;
-}
-
-check_mem()
-{
-	int i;
-
-	puts("\ncplens = ");
-	for (i = 0; i < 10; i++) {
-		int2hex(cplens[i]);
-		puts(" ");
-	}
-	puts("\ncplext = ");
-	for (i = 0; i < 10; i++) {
-		int2hex(cplext[i]);
-		puts(" ");
-	}
-	puts("\nborder = ");
-	for (i = 0; i < 10; i++) {
-		int2hex(border[i]);
-		puts(" ");
-	}
-	puts("\n");
-}
-
-static void error(char *x)
-{
-	check_mem();
-	puts("\n\n");
-	puts(x);
-	puts("byte_count = ");
-	int2hex(byte_count);
-	puts("\n");
-	puts("\n\n -- System halted");
-	while (1);		/* Halt */
-}
-
-void variable_init()
-{
-	byte_count = 0;
-	checksum = 0;
-	input_data = (unsigned char *) &linux_compressed_start;
-	input_len = linux_compressed_size;
-	output_data = &kernel_location_start;
-	free_mem_ptr = (long) &malloc_start;
-	free_mem_end_ptr = (long) ((char *) &malloc_start + 0x400000);
-}
-
-int decompress_kernel()
-{
-	//check_mem();
-
-	variable_init();
-
-	makecrc();
-	puts("Uncompressing Linux... \n");
-	gunzip();		// ...see inflate.c
-	puts("Ok, booting the kernel.\n");
-	return 0;
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/ns16550.h linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/ns16550.h
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/ns16550.h	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/ns16550.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-/*  NS16550 UART registers  */
-
-#ifndef NS16550H
-#define NS16550H
-
-#define UART_BASE		0xbd000000
-#define NS16550_CHANA   PHYS_TO_K1(UART_BASE + 0x20)
-#define NS16550_CHANB   PHYS_TO_K1(UART_BASE)
-
-#ifndef NS16550_HZ
-#define NS16550_HZ      3686400
-#endif
-
-#ifdef __ASSEMBLY__
-
-#ifndef NSREG
-#define NSREG(x) ((x)*4)
-#endif
-
-#define DATA	NSREG(0)	/* data register (R/W) */
-#define IER	    NSREG(1)	/* interrupt enable (W) */
-#define IIR	    NSREG(2)	/* interrupt identification (R) */
-#define	FIFO	IIR		/* 16550 fifo control (W) */
-#define CFCR	NSREG(3)	/* line control register (R/W) */
-#define MCR	    NSREG(4)	/* modem control register (R/W) */
-#define LSR	    NSREG(5)	/* line status register (R/W) */
-#define MSR	    NSREG(6)	/* modem status register (R/W) */
-#define SCR	    NSREG(7)	/* scratch register (R/W) */
-
-#else
-
-#ifndef nsreg
-#if #endian(little)
-#define nsreg(x)	unsigned :24; unsigned char x;
-#else
-/*#define nsreg(x)	unsigned char x; unsigned :24;*/
-#define nsreg(x) unsigned int x:8;unsigned int :24;
-#endif
-#endif
-
-typedef struct {
-	nsreg(data);		/* data register (R/W) */
-	nsreg(ier);		/* interrupt enable (W) */
-	nsreg(iir);		/* interrupt identification (R) */
-#define	fifo	iir		/* 16550 fifo control (W) */
-	nsreg(cfcr);		/* line control register (R/W) */
-	nsreg(mcr);		/* modem control register (R/W) */
-	nsreg(lsr);		/* line status register (R/W) */
-	nsreg(msr);		/* modem status register (R/W) */
-	nsreg(scr);		/* scratch register (R/W) */
-} ns16550dev;
-#endif
-
-
-/* 16 bit baud rate divisor (lower byte in dca_data, upper in dca_ier) */
-#define BRTC(x)         (NS16550_HZ / (16*(x)))
-
-/* interrupt enable register */
-#define IER_ERXRDY      0x1	/* int on rx ready */
-#define IER_ETXRDY      0x2	/* int on tx ready */
-#define IER_ERLS        0x4	/* int on line status change */
-#define IER_EMSC        0x8	/* int on modem status change */
-
-/* interrupt identification register */
-#define IIR_IMASK       0xf	/* mask */
-#define IIR_RXTOUT      0xc	/* receive timeout */
-#define IIR_RLS         0x6	/* receive line status */
-#define IIR_RXRDY       0x4	/* receive ready */
-#define IIR_TXRDY       0x2	/* transmit ready */
-#define IIR_NOPEND      0x1	/* nothing */
-#define IIR_MLSC        0x0	/* modem status */
-#define IIR_FIFO_MASK   0xc0	/* set if FIFOs are enabled */
-
-/* fifo control register */
-#define FIFO_ENABLE     0x01	/* enable fifo */
-#define FIFO_RCV_RST    0x02	/* reset receive fifo */
-#define FIFO_XMT_RST    0x04	/* reset transmit fifo */
-#define FIFO_DMA_MODE   0x08	/* enable dma mode */
-#define FIFO_TRIGGER_1  0x00	/* trigger at 1 char */
-#define FIFO_TRIGGER_4  0x40	/* trigger at 4 chars */
-#define FIFO_TRIGGER_8  0x80	/* trigger at 8 chars */
-#define FIFO_TRIGGER_14 0xc0	/* trigger at 14 chars */
-
-/* character format control register */
-#define CFCR_DLAB       0x80	/* divisor latch */
-#define CFCR_SBREAK     0x40	/* send break */
-#define CFCR_PZERO      0x30	/* zero parity */
-#define CFCR_PONE       0x20	/* one parity */
-#define CFCR_PEVEN      0x10	/* even parity */
-#define CFCR_PODD       0x00	/* odd parity */
-#define CFCR_PENAB      0x08	/* parity enable */
-#define CFCR_STOPB      0x04	/* 2 stop bits */
-#define CFCR_8BITS      0x03	/* 8 data bits */
-#define CFCR_7BITS      0x02	/* 7 data bits */
-#define CFCR_6BITS      0x01	/* 6 data bits */
-#define CFCR_5BITS      0x00	/* 5 data bits */
-
-/* modem control register */
-#define MCR_LOOPBACK    0x10	/* loopback */
-#define MCR_IENABLE     0x08	/* output 2 = int enable */
-#define MCR_DRS         0x04	/* output 1 = xxx */
-#define MCR_RTS         0x02	/* enable RTS */
-#define MCR_DTR         0x01	/* enable DTR */
-
-/* line status register */
-#define LSR_RCV_FIFO    0x80	/* error in receive fifo */
-#define LSR_TSRE        0x40	/* transmitter empty */
-#define LSR_TXRDY       0x20	/* transmitter ready */
-#define LSR_BI          0x10	/* break detected */
-#define LSR_FE          0x08	/* framing error */
-#define LSR_PE          0x04	/* parity error */
-#define LSR_OE          0x02	/* overrun error */
-#define LSR_RXRDY       0x01	/* receiver ready */
-#define LSR_RCV_MASK    0x1f
-
-/* modem status register */
-#define MSR_DCD         0x80	/* DCD active */
-#define MSR_RI          0x40	/* RI  active */
-#define MSR_DSR         0x20	/* DSR active */
-#define MSR_CTS         0x10	/* CTS active */
-#define MSR_DDCD        0x08	/* DCD changed */
-#define MSR_TERI        0x04	/* RI  changed */
-#define MSR_DDSR        0x02	/* DSR changed */
-#define MSR_DCTS        0x01	/* CTS changed */
-
-#endif
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/osdep.h linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/osdep.h
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/osdep.h	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/osdep.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-#ifndef	__OSDEP_H__
-#define __OSDEP_H__
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-#if	defined(__linux__) || defined(__FreeBSD__) || defined (__MIPSEB__)
-#define	ETHERBOOT32
-#define ntohl(x) (x)
-#define htonl(x) (x)
-#define ntohs(x) (x)
-#define htons(x) (x)
-
-#endif
-
-
-
-
-/* ANSI prototyping macro */
-#ifdef	__STDC__
-#define	P(x)	x
-#else
-#define	P(x)	()
-#endif
-
-#endif
-
-/*
- * Local variables:
- *  c-basic-offset: 8
- * End:
- */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/pci.c linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/pci.c
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/pci.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/pci.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1336 +0,0 @@
-/* PCI.c - PCI functions */
-
-/* Copyright - Galileo technology. */
-
-#ifdef __linux__
-#include <asm/galileo-boards/evb64120A/core.h>
-#include <asm/galileo-boards/evb64120A/pci.h>
-#ifndef PROM
-#include <linux/kernel.h>
-#endif
-
-#undef PCI_DEBUG
-
-#ifdef PCI_DEBUG
-#define DBG(x...) printk(x)
-#else
-#define DBG(x...)
-#endif
-
-#else
-#include "core.h"
-#include "pci.h"
-#include <string.h>
-#endif
-
-/********************************************************************
-* pci0ScanDevices   - This function scan PCI0 bus, if found any device on
-*                     this bus it interrogate the Device for the information
-*                     it can discover.
-*                     The fields with all information are the following:
-*    char            type[20];
-*    unsigned int    deviceNum;
-*    unsigned int    venID;
-*    unsigned int    deviceID;
-*    unsigned int    bar0Base;
-*    unsigned int    bar0Size;
-*    unsigned int    bar1Base;
-*    unsigned int    bar1Size;
-*    unsigned int    bar2Base;
-*    unsigned int    bar2Size;
-*    unsigned int    bar3Base;
-*    unsigned int    bar3Size;
-*    unsigned int    bar4Base;
-*    unsigned int    bar4Size;
-*    unsigned int    bar5Base;
-*    unsigned int    bar5Size;
-*
-* Inputs:   PCI0_DEVICE* pci0Detect - Pointer to an array of STRUCT PCI0_DEVICE.
-*           unsigned int numberOfElment - The PCI0_DEVICE Array length.
-* Output:   None.
-*********************************************************************/
-
-void pci0ScanDevices(PCI_DEVICE * pci0Detect, unsigned int numberOfElment)
-{
-	PCI_DEVICE *pci0ArrayPointer = pci0Detect;
-	unsigned int id;	/* PCI Configuration register 0x0. */
-	unsigned int device;	/* device`s Counter. */
-	unsigned int classCode;	/* PCI Configuration register 0x8 */
-	unsigned int arrayCounter = 0;
-	unsigned int memBaseAddress;
-	unsigned int memSize;
-	unsigned int c18RegValue;
-
-	PCI0_MASTER_ENABLE(SELF);
-	/* According to PCI REV 2.1 MAX agents on the bus are -21- */
-	for (device = 6; device < 8; device++) {
-		id = pci0ReadConfigReg(PCI_0DEVICE_AND_VENDOR_ID, device);
-		GT_REG_READ(INTERRUPT_CAUSE_REGISTER, &c18RegValue);
-		/* Clearing bit 18 of in the Cause Register 0xc18 by writting 0. */
-		GT_REG_WRITE(INTERRUPT_CAUSE_REGISTER,
-			     c18RegValue & 0xfffbffff);
-		if ((id != 0xffffffff) && !(c18RegValue & 0x40000)) {
-			classCode =
-			    pci0ReadConfigReg
-			    (PCI_0CLASS_CODE_AND_REVISION_ID, device);
-			pci0ArrayPointer->deviceNum = device;
-			pci0ArrayPointer->venID = (id & 0xffff);
-			pci0ArrayPointer->deviceID =
-			    ((id & 0xffff0000) >> 16);
-			DBG("\nrr: venID %x devID %x\n",
-			    pci0ArrayPointer->venID,
-			    pci0ArrayPointer->deviceID);
-			DBG("rr: device found %x\n",
-			    pci0ArrayPointer->deviceNum);
-			/* BAR0 parameters */
-			memBaseAddress = pci0ReadConfigReg(BAR0, device);
-			pci0ArrayPointer->bar0Type = memBaseAddress & 1;
-			pci0ArrayPointer->bar0Base =
-			    memBaseAddress & 0xfffff000;
-			pci0WriteConfigReg(BAR0, device, 0xffffffff);
-			memSize = pci0ReadConfigReg(BAR0, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci0ArrayPointer->bar0Size = 0;
-			} else {
-				if (pci0ArrayPointer->bar0Type == 0)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci0ArrayPointer->bar0Size = memSize;
-			}
-			DBG("rr: device BAR0 size %x\n", memSize);
-			DBG("rr: device BAR0 address %x\n",
-			    memBaseAddress);
-			pci0WriteConfigReg(BAR0, device, memBaseAddress);
-			/* BAR1 parameters */
-			memBaseAddress = pci0ReadConfigReg(BAR1, device);
-			pci0ArrayPointer->bar1Type = memBaseAddress & 1;
-			pci0ArrayPointer->bar1Base =
-			    memBaseAddress & 0xfffff000;
-			pci0WriteConfigReg(BAR1, device, 0xffffffff);
-			memSize = pci0ReadConfigReg(BAR1, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci0ArrayPointer->bar1Size = 0;
-			} else {
-				if (pci0ArrayPointer->bar1Type == 0)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci0ArrayPointer->bar1Size = memSize;
-			}
-			DBG("rr: device BAR1 size %x\n", memSize);
-			DBG("rr: device BAR1 address %x\n",
-			    memBaseAddress);
-			pci0WriteConfigReg(BAR1, device, memBaseAddress);
-			/* BAR2 parameters */
-			memBaseAddress = pci0ReadConfigReg(BAR2, device);
-			pci0ArrayPointer->bar2Type = memBaseAddress & 1;
-			pci0ArrayPointer->bar2Base =
-			    memBaseAddress & 0xfffff000;
-			pci0WriteConfigReg(BAR2, device, 0xffffffff);
-			memSize = pci0ReadConfigReg(BAR2, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci0ArrayPointer->bar2Size = 0;
-			} else {
-				if (pci0ArrayPointer->bar2Type == 0)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci0ArrayPointer->bar2Size = memSize;
-			}
-			DBG("rr: device BAR2 size %x\n", memSize);
-			DBG("rr: device BAR2 address %x\n",
-			    memBaseAddress);
-			pci0WriteConfigReg(BAR2, device, memBaseAddress);
-			/* BAR3 parameters */
-			memBaseAddress = pci0ReadConfigReg(BAR3, device);
-			pci0ArrayPointer->bar3Type = memBaseAddress & 1;
-			pci0ArrayPointer->bar3Base =
-			    memBaseAddress & 0xfffff000;
-			pci0WriteConfigReg(BAR3, device, 0xffffffff);
-			memSize = pci0ReadConfigReg(BAR3, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci0ArrayPointer->bar3Size = 0;
-			} else {
-				if (pci0ArrayPointer->bar3Type == 0)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci0ArrayPointer->bar3Size = memSize;
-			}
-			DBG("rr: device BAR3 size %x\n", memSize);
-			DBG("rr: device BAR3 address %x\n",
-			    memBaseAddress);
-			pci0WriteConfigReg(BAR3, device, memBaseAddress);
-			/* BAR4 parameters */
-			memBaseAddress = pci0ReadConfigReg(BAR4, device);
-			pci0ArrayPointer->bar4Type = memBaseAddress & 1;
-			pci0ArrayPointer->bar4Base =
-			    memBaseAddress & 0xfffff000;
-			pci0WriteConfigReg(BAR4, device, 0xffffffff);
-			memSize = pci0ReadConfigReg(BAR4, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci0ArrayPointer->bar4Size = 0;
-			} else {
-				if (pci0ArrayPointer->bar4Type == 0)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci0ArrayPointer->bar4Size = memSize;
-			}
-			DBG("rr: device BAR4 size %x\n", memSize);
-			DBG("rr: device BAR4 address %x\n",
-			    memBaseAddress);
-			pci0WriteConfigReg(BAR4, device, memBaseAddress);
-			/* BAR5 parameters */
-			memBaseAddress = pci0ReadConfigReg(BAR5, device);
-			pci0ArrayPointer->bar5Type = memBaseAddress & 1;
-			pci0ArrayPointer->bar5Base =
-			    memBaseAddress & 0xfffff000;
-			pci0WriteConfigReg(BAR5, device, 0xffffffff);
-			memSize = pci0ReadConfigReg(BAR5, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci0ArrayPointer->bar5Size = 0;
-			} else {
-				if (pci0ArrayPointer->bar5Type == 1)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci0ArrayPointer->bar5Size = memSize;
-			}
-			DBG("rr: device BAR5 size %x\n", memSize);
-			DBG("rr: device BAR5 address %x\n",
-			    memBaseAddress);
-			pci0WriteConfigReg(BAR5, device, memBaseAddress);
-			/* End of BARs Detection. */
-
-			classCode = ((classCode & 0xff000000) >> 24);
-			switch (classCode) {
-			case 0x0:
-				strcpy(pci0ArrayPointer->type,
-				       "Old generation device");
-				break;
-			case 0x1:
-				strcpy(pci0ArrayPointer->type,
-				       "Mass storage controller");
-				break;
-			case 0x2:
-				strcpy(pci0ArrayPointer->type,
-				       "Network controller");
-				break;
-			case 0x3:
-				strcpy(pci0ArrayPointer->type,
-				       "Display controller");
-				break;
-			case 0x4:
-				strcpy(pci0ArrayPointer->type,
-				       "Multimedia device");
-				break;
-			case 0x5:
-				strcpy(pci0ArrayPointer->type,
-				       "Memory controller");
-				break;
-			case 0x6:
-				strcpy(pci0ArrayPointer->type,
-				       "Bridge Device");
-				break;
-			case 0x7:
-				strcpy(pci0ArrayPointer->type,
-				       "Simple Communication controllers");
-				break;
-			case 0x8:
-				strcpy(pci0ArrayPointer->type,
-				       "Base system peripherals");
-				break;
-			case 0x9:
-				strcpy(pci0ArrayPointer->type,
-				       "Input Devices");
-				break;
-			case 0xa:
-				strcpy(pci0ArrayPointer->type,
-				       "Docking stations");
-				break;
-			case 0xb:
-				strcpy(pci0ArrayPointer->type,
-				       "Processors");
-				break;
-			case 0xc:
-				strcpy(pci0ArrayPointer->type,
-				       "Serial bus controllers");
-				break;
-			case 0xd:
-				strcpy(pci0ArrayPointer->type,
-				       "Wireless controllers");
-				break;
-			case 0xe:
-				strcpy(pci0ArrayPointer->type,
-				       "Intelligent I/O controllers");
-				break;
-			case 0xf:
-				strcpy(pci0ArrayPointer->type,
-				       "Satellite communication controllers");
-				break;
-			case 0x10:
-				strcpy(pci0ArrayPointer->type,
-				       "Encryption/Decryption controllers");
-				break;
-			case 0x11:
-				strcpy(pci0ArrayPointer->type,
-				       "Data acquisition and signal processing controllers");
-				break;
-			default:
-				break;
-
-			}
-			arrayCounter++;	/* point to the next element in the Array. */
-			if (arrayCounter == numberOfElment)
-				return;	/* When the Array is fully used, return. */
-			/* Else, points to next free Element. */
-			pci0ArrayPointer = &pci0Detect[arrayCounter];
-		}
-	}
-	pci0ArrayPointer->deviceNum = 0;	/* 0 => End of List */
-}
-
-
-/********************************************************************
-* pci1ScanDevices   - This function scan PCI1 bus, if found any device on
-*                     this bus it interrogate the Device for the information
-*                     it can discover.
-*                     The fields with all information are the following:
-*    char            type[20];
-*    unsigned int    deviceNum;
-*    unsigned int    venID;
-*    unsigned int    deviceID;
-*    unsigned int    bar0Base;
-*    unsigned int    bar0Size;
-*    unsigned int    bar1Base;
-*    unsigned int    bar1Size;
-*    unsigned int    bar2Base;
-*    unsigned int    bar2Size;
-*    unsigned int    bar3Base;
-*    unsigned int    bar3Size;
-*    unsigned int    bar4Base;
-*    unsigned int    bar4Size;
-*    unsigned int    bar5Base;
-*    unsigned int    bar5Size;
-*
-* Inputs:   Pointer to an array of STRUCT PCI1_DEVICE.
-* Output:   None.
-*********************************************************************/
-
-void pci1ScanDevices(PCI_DEVICE * pci1Detect, unsigned int numberOfElment)
-{
-	PCI_DEVICE *pci1ArrayPointer = pci1Detect;
-	unsigned int id;	/* PCI Configuration register 0x0. */
-	unsigned int device;	/* device`s Counter. */
-	unsigned int classCode;	/* PCI Configuration register 0x8 */
-	unsigned int arrayCounter = 0;
-	unsigned int memBaseAddress;
-	unsigned int memSize;
-	unsigned int c98RegValue;
-
-	PCI1_MASTER_ENABLE(SELF);
-	/* According to PCI REV 2.1 MAX agents on the bus are -21- */
-	for (device = 1; device < 22; device++) {
-		id = pci1ReadConfigReg(PCI_0DEVICE_AND_VENDOR_ID, device);
-		GT_REG_READ(HIGH_INTERRUPT_CAUSE_REGISTER, &c98RegValue);
-		/* Clearing bit 18 of in the High Cause Register 0xc98 */
-		GT_REG_WRITE(HIGH_INTERRUPT_CAUSE_REGISTER,
-			     c98RegValue & 0xfffbffff);
-		if ((id != 0xffffffff) && !(c98RegValue & 0x40000)) {
-			classCode =
-			    pci1ReadConfigReg
-			    (PCI_0CLASS_CODE_AND_REVISION_ID, device);
-			pci1ArrayPointer->deviceNum = device;
-			pci1ArrayPointer->venID = (id & 0xffff);
-			pci1ArrayPointer->deviceID =
-			    ((id & 0xffff0000) >> 16);
-
-			/* BAR0 parameters */
-			memBaseAddress = pci1ReadConfigReg(BAR0, device);
-			pci1ArrayPointer->bar0Type = memBaseAddress & 1;
-			pci1ArrayPointer->bar0Base =
-			    memBaseAddress & 0xfffff000;
-			pci1WriteConfigReg(BAR0, device, 0xffffffff);
-			memSize = pci1ReadConfigReg(BAR0, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci1ArrayPointer->bar0Size = 0;
-			} else {
-				if (pci1ArrayPointer->bar0Type == 0)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci1ArrayPointer->bar0Size = memSize;
-			}
-			pci1WriteConfigReg(BAR0, device, memBaseAddress);
-			/* BAR1 parameters */
-			memBaseAddress = pci1ReadConfigReg(BAR1, device);
-			pci1ArrayPointer->bar1Type = memBaseAddress & 1;
-			pci1ArrayPointer->bar1Base =
-			    memBaseAddress & 0xfffff000;
-			pci1WriteConfigReg(BAR1, device, 0xffffffff);
-			memSize = pci1ReadConfigReg(BAR1, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci1ArrayPointer->bar1Size = 0;
-			} else {
-				if (pci1ArrayPointer->bar1Type == 0)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci1ArrayPointer->bar1Size = memSize;
-			}
-			pci1WriteConfigReg(BAR1, device, memBaseAddress);
-			/* BAR2 parameters */
-			memBaseAddress = pci1ReadConfigReg(BAR2, device);
-			pci1ArrayPointer->bar2Type = memBaseAddress & 1;
-			pci1ArrayPointer->bar2Base =
-			    memBaseAddress & 0xfffff000;
-			pci1WriteConfigReg(BAR2, device, 0xffffffff);
-			memSize = pci1ReadConfigReg(BAR2, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci1ArrayPointer->bar2Size = 0;
-			} else {
-				if (pci1ArrayPointer->bar2Type == 0)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci1ArrayPointer->bar2Size = memSize;
-			}
-			pci1WriteConfigReg(BAR2, device, memBaseAddress);
-			/* BAR3 parameters */
-			memBaseAddress = pci1ReadConfigReg(BAR3, device);
-			pci1ArrayPointer->bar3Type = memBaseAddress & 1;
-			pci1ArrayPointer->bar3Base =
-			    memBaseAddress & 0xfffff000;
-			pci1WriteConfigReg(BAR3, device, 0xffffffff);
-			memSize = pci1ReadConfigReg(BAR3, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci1ArrayPointer->bar3Size = 0;
-			} else {
-				if (pci1ArrayPointer->bar3Type == 0)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci1ArrayPointer->bar3Size = memSize;
-			}
-			pci1WriteConfigReg(BAR3, device, memBaseAddress);
-			/* BAR4 parameters */
-			memBaseAddress = pci1ReadConfigReg(BAR4, device);
-			pci1ArrayPointer->bar4Type = memBaseAddress & 1;
-			pci1ArrayPointer->bar4Base =
-			    memBaseAddress & 0xfffff000;
-			pci1WriteConfigReg(BAR4, device, 0xffffffff);
-			memSize = pci1ReadConfigReg(BAR4, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci1ArrayPointer->bar4Size = 0;
-			} else {
-				if (pci1ArrayPointer->bar4Type == 0)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci1ArrayPointer->bar4Size = memSize;
-			}
-			pci1WriteConfigReg(BAR4, device, memBaseAddress);
-			/* BAR5 parameters */
-			memBaseAddress = pci1ReadConfigReg(BAR5, device);
-			pci1ArrayPointer->bar5Type = memBaseAddress & 1;
-			pci1ArrayPointer->bar5Base =
-			    memBaseAddress & 0xfffff000;
-			pci1WriteConfigReg(BAR5, device, 0xffffffff);
-			memSize = pci1ReadConfigReg(BAR5, device);
-			if (memSize == 0) {	/* case of an empty BAR */
-				pci1ArrayPointer->bar5Size = 0;
-			} else {
-				if (pci1ArrayPointer->bar5Type == 0)	/* memory space */
-					memSize =
-					    ~(memSize & 0xfffffff0) + 1;
-				else	/* IO space */
-					memSize =
-					    ~(memSize & 0xfffffffc) + 1;
-				pci1ArrayPointer->bar5Size = memSize;
-			}
-			pci1WriteConfigReg(BAR5, device, memBaseAddress);
-			/* End of BARs Detection. */
-
-			classCode = ((classCode & 0xff000000) >> 24);
-			switch (classCode) {
-			case 0x0:
-				strcpy(pci1ArrayPointer->type,
-				       "Old generation device");
-				break;
-			case 0x1:
-				strcpy(pci1ArrayPointer->type,
-				       "Mass storage controller");
-				break;
-			case 0x2:
-				strcpy(pci1ArrayPointer->type,
-				       "Network controller");
-				break;
-			case 0x3:
-				strcpy(pci1ArrayPointer->type,
-				       "Display controller");
-				break;
-			case 0x4:
-				strcpy(pci1ArrayPointer->type,
-				       "Multimedia device");
-				break;
-			case 0x5:
-				strcpy(pci1ArrayPointer->type,
-				       "Memory controller");
-				break;
-			case 0x6:
-				strcpy(pci1ArrayPointer->type,
-				       "Bridge Device");
-				break;
-			case 0x7:
-				strcpy(pci1ArrayPointer->type,
-				       "Simple Communication controllers");
-				break;
-			case 0x8:
-				strcpy(pci1ArrayPointer->type,
-				       "Base system peripherals");
-				break;
-			case 0x9:
-				strcpy(pci1ArrayPointer->type,
-				       "Input Devices");
-				break;
-			case 0xa:
-				strcpy(pci1ArrayPointer->type,
-				       "Docking stations");
-				break;
-			case 0xb:
-				strcpy(pci1ArrayPointer->type,
-				       "Processors");
-				break;
-			case 0xc:
-				strcpy(pci1ArrayPointer->type,
-				       "Serial bus controllers");
-				break;
-			case 0xd:
-				strcpy(pci1ArrayPointer->type,
-				       "Wireless controllers");
-				break;
-			case 0xe:
-				strcpy(pci1ArrayPointer->type,
-				       "Intelligent I/O controllers");
-				break;
-			case 0xf:
-				strcpy(pci1ArrayPointer->type,
-				       "Satellite communication controllers");
-				break;
-			case 0x10:
-				strcpy(pci1ArrayPointer->type,
-				       "Encryption/Decryption controllers");
-				break;
-			case 0x11:
-				strcpy(pci1ArrayPointer->type,
-				       "Data acquisition and signal processing controllers");
-				break;
-			}
-			arrayCounter++;	/* point to the next element in the Array. */
-			if (arrayCounter == numberOfElment)
-				return;	/* When the Array is fully used, return. */
-			/* Else, points to next free Element. */
-			pci1ArrayPointer = &pci1Detect[arrayCounter];
-		}
-	}
-	pci1ArrayPointer->deviceNum = 0;	/* 0 => End of List */
-}
-
-/********************************************************************
-* pci0WriteConfigReg - Write to a PCI configuration register
-*                    - Make sure the GT is configured as a master before
-*                      writingto another device on the PCI.
-*                    - The function takes care of Big/Little endian conversion.
-* Inputs:   unsigned int regOffset: The register offset as it apears in the GT spec
-*                   (or any other PCI device spec)
-*           pciDevNum: The device number needs to be addressed.
-*
-*  Configuration Address 0xCF8:
-*
-*       31 30    24 23  16 15  11 10     8 7      2  0     <=bit Number
-*  |congif|Reserved|  Bus |Device|Function|Register|00|
-*  |Enable|        |Number|Number| Number | Number |  |    <=field Name
-*
-*********************************************************************/
-
-void pci0WriteConfigReg(unsigned int regOffset, unsigned int pciDevNum,
-			unsigned int data)
-{
-	unsigned int DataForRegCf8;
-	unsigned int functionNum;
-
-	functionNum = regOffset & 0x00000700;
-	pciDevNum = pciDevNum << 11;
-	regOffset = regOffset & 0x0fffffff;
-	DataForRegCf8 = (regOffset | pciDevNum | functionNum) | BIT31;
-	GT_REG_WRITE(PCI_0CONFIGURATION_ADDRESS, DataForRegCf8);
-	if (pciDevNum == SELF) {	/* This board */
-		GT_REG_WRITE(PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER,
-			     data);
-	} else {		/* configuration Transaction over the pci. */
-
-		/* The PCI is working in LE Mode So it swap the Data. */
-		GT_REG_WRITE(PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER,
-			     WORDSWAP(data));
-	}
-}
-
-/********************************************************************
-* pci1WriteConfigReg - Write to a PCI configuration register
-*                   - Make sure the GT is configured as a master before writing
-*                     to another device on the PCI.
-*                   - The function takes care of Big/Little endian conversion.
-* Inputs:   unsigned int regOffset: The register offset as it apears in the
-*           GT spec (or any other PCI device spec)
-*           pciDevNum: The device number needs to be addressed.
-*
-*  Configuration Address 0xCF8:
-*
-*       31 30    24 23  16 15  11 10     8 7      2  0     <=bit Number
-*  |congif|Reserved|  Bus |Device|Function|Register|00|
-*  |Enable|        |Number|Number| Number | Number |  |    <=field Name
-*
-*********************************************************************/
-
-void pci1WriteConfigReg(unsigned int regOffset, unsigned int pciDevNum,
-			unsigned int data)
-{
-	unsigned int DataForRegCf8;
-	unsigned int functionNum;
-
-	functionNum = regOffset & 0x00000700;
-	pciDevNum = pciDevNum << 11;
-	regOffset = regOffset & 0x0fffffff;
-	if (pciDevNum == SELF) {	/* This board */
-		/* when configurating our own PCI 1 L-unit the access is through
-		   the PCI 0 interface with reg number = reg number + 0x80 */
-		DataForRegCf8 =
-		    (regOffset | pciDevNum | functionNum | 0x80) | BIT31;
-		GT_REG_WRITE(PCI_0CONFIGURATION_ADDRESS, DataForRegCf8);
-	} else {
-		DataForRegCf8 =
-		    (regOffset | pciDevNum | functionNum) | BIT31;
-		GT_REG_WRITE(PCI_1CONFIGURATION_ADDRESS, DataForRegCf8);
-	}
-	if (pciDevNum == SELF) {	/* This board */
-		GT_REG_WRITE(PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER,
-			     data);
-	} else {
-		GT_REG_WRITE(PCI_1CONFIGURATION_DATA_VIRTUAL_REGISTER,
-			     WORDSWAP(data));
-	}
-}
-
-/********************************************************************
-* pci0ReadConfigReg  - Read from a PCI0 configuration register
-*                    - Make sure the GT is configured as a master before
-*                      reading from another device on the PCI.
-*                   - The function takes care of Big/Little endian conversion.
-* INPUTS:   regOffset: The register offset as it apears in the GT spec (or PCI
-*                        spec)
-*           pciDevNum: The device number needs to be addressed.
-* RETURNS: data , if the data == 0xffffffff check the master abort bit in the
-*                 cause register to make sure the data is valid
-*
-*  Configuration Address 0xCF8:
-*
-*       31 30    24 23  16 15  11 10     8 7      2  0     <=bit Number
-*  |congif|Reserved|  Bus |Device|Function|Register|00|
-*  |Enable|        |Number|Number| Number | Number |  |    <=field Name
-*
-*********************************************************************/
-
-unsigned int pci0ReadConfigReg(unsigned int regOffset,
-			       unsigned int pciDevNum)
-{
-	unsigned int DataForRegCf8;
-	unsigned int data;
-	unsigned int functionNum;
-
-	functionNum = regOffset & 0x00000700;
-	pciDevNum = pciDevNum << 11;
-	regOffset = regOffset & 0x0fffffff;
-	DataForRegCf8 = (regOffset | pciDevNum | functionNum) | BIT31;
-	GT_REG_WRITE(PCI_0CONFIGURATION_ADDRESS, DataForRegCf8);
-	if (pciDevNum == SELF) {	/* This board */
-		GT_REG_READ(PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER,
-			    &data);
-		return data;
-	} else {		/* The PCI is working in LE Mode So it swap the Data. */
-
-		GT_REG_READ(PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER,
-			    &data);
-		return WORDSWAP(data);
-	}
-}
-
-/********************************************************************
-* pci1ReadConfigReg  - Read from a PCI1 configuration register
-*                    - Make sure the GT is configured as a master before
-*                      reading from another device on the PCI.
-*                   - The function takes care of Big/Little endian conversion.
-* INPUTS:   regOffset: The register offset as it apears in the GT spec (or PCI
-*                        spec)
-*           pciDevNum: The device number needs to be addressed.
-* RETURNS: data , if the data == 0xffffffff check the master abort bit in the
-*                 cause register to make sure the data is valid
-*
-*  Configuration Address 0xCF8:
-*
-*       31 30    24 23  16 15  11 10     8 7      2  0     <=bit Number
-*  |congif|Reserved|  Bus |Device|Function|Register|00|
-*  |Enable|        |Number|Number| Number | Number |  |    <=field Name
-*
-*********************************************************************/
-
-unsigned int pci1ReadConfigReg(unsigned int regOffset,
-			       unsigned int pciDevNum)
-{
-	unsigned int DataForRegCf8;
-	unsigned int data;
-	unsigned int functionNum;
-
-	functionNum = regOffset & 0x00000700;
-	pciDevNum = pciDevNum << 11;
-	regOffset = regOffset & 0x0fffffff;
-	if (pciDevNum == SELF) {	/* This board */
-		/* when configurating our own PCI 1 L-unit the access is through
-		   the PCI 0 interface with reg number = reg number + 0x80 */
-		DataForRegCf8 =
-		    (regOffset | pciDevNum | functionNum | 0x80) | BIT31;
-		GT_REG_WRITE(PCI_0CONFIGURATION_ADDRESS, DataForRegCf8);
-	} else {
-		DataForRegCf8 =
-		    (regOffset | pciDevNum | functionNum) | BIT31;
-		GT_REG_WRITE(PCI_1CONFIGURATION_ADDRESS, DataForRegCf8);
-	}
-	if (pciDevNum == SELF) {	/* This board */
-		GT_REG_READ(PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER,
-			    &data);
-		return data;
-	} else {
-		GT_REG_READ(PCI_1CONFIGURATION_DATA_VIRTUAL_REGISTER,
-			    &data);
-		return WORDSWAP(data);
-	}
-}
-
-/********************************************************************
-* pci0MapIOspace - Maps PCI0 IO space for the master.
-* Inputs: base and length of pci0Io
-*********************************************************************/
-
-void pci0MapIOspace(unsigned int pci0IoBase, unsigned int pci0IoLength)
-{
-	unsigned int pci0IoTop =
-	    (unsigned int) (pci0IoBase + pci0IoLength);
-
-	if (pci0IoLength == 0)
-		pci0IoTop++;
-
-	pci0IoBase = (unsigned int) (pci0IoBase >> 21);
-	pci0IoTop = (unsigned int) (((pci0IoTop - 1) & 0x0fffffff) >> 21);
-	GT_REG_WRITE(PCI_0I_O_LOW_DECODE_ADDRESS, pci0IoBase);
-	GT_REG_WRITE(PCI_0I_O_HIGH_DECODE_ADDRESS, pci0IoTop);
-}
-
-/********************************************************************
-* pci1MapIOspace - Maps PCI1 IO space for the master.
-* Inputs: base and length of pci1Io
-*********************************************************************/
-
-void pci1MapIOspace(unsigned int pci1IoBase, unsigned int pci1IoLength)
-{
-	unsigned int pci1IoTop =
-	    (unsigned int) (pci1IoBase + pci1IoLength);
-
-	if (pci1IoLength == 0)
-		pci1IoTop++;
-
-	pci1IoBase = (unsigned int) (pci1IoBase >> 21);
-	pci1IoTop = (unsigned int) (((pci1IoTop - 1) & 0x0fffffff) >> 21);
-	GT_REG_WRITE(PCI_1I_O_LOW_DECODE_ADDRESS, pci1IoBase);
-	GT_REG_WRITE(PCI_1I_O_HIGH_DECODE_ADDRESS, pci1IoTop);
-}
-
-/********************************************************************
-* pci0MapMemory0space - Maps PCI0 memory0 space for the master.
-* Inputs: base and length of pci0Mem0
-*********************************************************************/
-
-
-void pci0MapMemory0space(unsigned int pci0Mem0Base,
-			 unsigned int pci0Mem0Length)
-{
-	unsigned int pci0Mem0Top = pci0Mem0Base + pci0Mem0Length;
-
-	if (pci0Mem0Length == 0)
-		pci0Mem0Top++;
-
-	pci0Mem0Base = pci0Mem0Base >> 21;
-	pci0Mem0Top = ((pci0Mem0Top - 1) & 0x0fffffff) >> 21;
-	GT_REG_WRITE(PCI_0MEMORY0_LOW_DECODE_ADDRESS, pci0Mem0Base);
-	GT_REG_WRITE(PCI_0MEMORY0_HIGH_DECODE_ADDRESS, pci0Mem0Top);
-}
-
-/********************************************************************
-* pci1MapMemory0space - Maps PCI1 memory0 space for the master.
-* Inputs: base and length of pci1Mem0
-*********************************************************************/
-
-void pci1MapMemory0space(unsigned int pci1Mem0Base,
-			 unsigned int pci1Mem0Length)
-{
-	unsigned int pci1Mem0Top = pci1Mem0Base + pci1Mem0Length;
-
-	if (pci1Mem0Length == 0)
-		pci1Mem0Top++;
-
-	pci1Mem0Base = pci1Mem0Base >> 21;
-	pci1Mem0Top = ((pci1Mem0Top - 1) & 0x0fffffff) >> 21;
-	GT_REG_WRITE(PCI_1MEMORY0_LOW_DECODE_ADDRESS, pci1Mem0Base);
-	GT_REG_WRITE(PCI_1MEMORY0_HIGH_DECODE_ADDRESS, pci1Mem0Top);
-}
-
-/********************************************************************
-* pci0MapMemory1space - Maps PCI0 memory1 space for the master.
-* Inputs: base and length of pci0Mem1
-*********************************************************************/
-
-void pci0MapMemory1space(unsigned int pci0Mem1Base,
-			 unsigned int pci0Mem1Length)
-{
-	unsigned int pci0Mem1Top = pci0Mem1Base + pci0Mem1Length;
-
-	if (pci0Mem1Length == 0)
-		pci0Mem1Top++;
-
-	pci0Mem1Base = pci0Mem1Base >> 21;
-	pci0Mem1Top = ((pci0Mem1Top - 1) & 0x0fffffff) >> 21;
-	GT_REG_WRITE(PCI_0MEMORY1_LOW_DECODE_ADDRESS, pci0Mem1Base);
-	GT_REG_WRITE(PCI_0MEMORY1_HIGH_DECODE_ADDRESS, pci0Mem1Top);
-#ifndef PROM
-	DBG(KERN_INFO "pci0Mem1Base %x\n", pci0Mem1Base);
-	DBG(KERN_INFO "pci0Mem1Top %x\n", pci0Mem1Top);
-	GT_REG_READ(PCI_0MEMORY0_ADDRESS_REMAP, &pci0Mem1Base);
-	DBG(KERN_INFO "Mem 0/0 remap %x\n", pci0Mem1Base);
-	GT_REG_READ(PCI_0MEMORY1_ADDRESS_REMAP, &pci0Mem1Base);
-	DBG(KERN_INFO "Mem 0/1 remap %x\n", pci0Mem1Base);
-	GT_REG_WRITE(PCI_0MEMORY1_ADDRESS_REMAP, 0x500);
-	GT_REG_READ(PCI_0MEMORY1_ADDRESS_REMAP, &pci0Mem1Base);
-	DBG(KERN_INFO "Mem 0/1 remapped %x\n", pci0Mem1Base);
-#endif
-}
-
-/********************************************************************
-* pci1MapMemory1space - Maps PCI1 memory1 space for the master.
-* Inputs: base and length of pci1Mem1
-*********************************************************************/
-
-void pci1MapMemory1space(unsigned int pci1Mem1Base,
-			 unsigned int pci1Mem1Length)
-{
-	unsigned int pci1Mem1Top = pci1Mem1Base + pci1Mem1Length;
-
-	if (pci1Mem1Length == 0)
-		pci1Mem1Top++;
-
-	pci1Mem1Base = pci1Mem1Base >> 21;
-	pci1Mem1Top = ((pci1Mem1Top - 1) & 0x0fffffff) >> 21;
-	GT_REG_WRITE(PCI_1MEMORY1_LOW_DECODE_ADDRESS, pci1Mem1Base);
-	GT_REG_WRITE(PCI_1MEMORY1_HIGH_DECODE_ADDRESS, pci1Mem1Top);
-}
-
-/********************************************************************
-* pci0GetIOspaceBase - Return PCI0 IO Base Address.
-* Inputs: N/A
-* Returns: PCI0 IO Base Address.
-*********************************************************************/
-
-unsigned int pci0GetIOspaceBase()
-{
-	unsigned int base;
-	GT_REG_READ(PCI_0I_O_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	return base;
-}
-
-/********************************************************************
-* pci0GetIOspaceSize - Return PCI0 IO Bar Size.
-* Inputs: N/A
-* Returns: PCI0 IO Bar Size.
-*********************************************************************/
-
-unsigned int pci0GetIOspaceSize()
-{
-	unsigned int top, base, size;
-	GT_REG_READ(PCI_0I_O_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	GT_REG_READ(PCI_0I_O_HIGH_DECODE_ADDRESS, &top);
-	top = (top << 21);
-	size = ((top - base) & 0xfffffff);
-	size = size | 0x1fffff;
-	return (size + 1);
-}
-
-/********************************************************************
-* pci0GetMemory0Base - Return PCI0 Memory 0 Base Address.
-* Inputs: N/A
-* Returns: PCI0 Memory 0 Base Address.
-*********************************************************************/
-
-unsigned int pci0GetMemory0Base()
-{
-	unsigned int base;
-	GT_REG_READ(PCI_0MEMORY0_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	return base;
-}
-
-/********************************************************************
-* pci0GetMemory0Size - Return PCI0 Memory 0 Bar Size.
-* Inputs: N/A
-* Returns: PCI0 Memory 0 Bar Size.
-*********************************************************************/
-
-unsigned int pci0GetMemory0Size()
-{
-	unsigned int top, base, size;
-	GT_REG_READ(PCI_0MEMORY0_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	GT_REG_READ(PCI_0MEMORY0_HIGH_DECODE_ADDRESS, &top);
-	top = (top << 21);
-	size = ((top - base) & 0xfffffff);
-	size = size | 0x1fffff;
-	return (size + 1);
-}
-
-/********************************************************************
-* pci0GetMemory1Base - Return PCI0 Memory 1 Base Address.
-* Inputs: N/A
-* Returns: PCI0 Memory 1 Base Address.
-*********************************************************************/
-
-unsigned int pci0GetMemory1Base()
-{
-	unsigned int base;
-	GT_REG_READ(PCI_0MEMORY1_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	return base;
-}
-
-/********************************************************************
-* pci0GetMemory1Size - Return PCI0 Memory 1 Bar Size.
-* Inputs: N/A
-* Returns: PCI0 Memory 1 Bar Size.
-*********************************************************************/
-
-unsigned int pci0GetMemory1Size()
-{
-	unsigned int top, base, size;
-	GT_REG_READ(PCI_0MEMORY1_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	GT_REG_READ(PCI_0MEMORY1_HIGH_DECODE_ADDRESS, &top);
-	top = (top << 21);
-	size = ((top - base) & 0xfffffff);
-	size = size | 0x1fffff;
-	return (size + 1);
-}
-
-/********************************************************************
-* pci1GetIOspaceBase - Return PCI1 IO Base Address.
-* Inputs: N/A
-* Returns: PCI1 IO Base Address.
-*********************************************************************/
-
-unsigned int pci1GetIOspaceBase()
-{
-	unsigned int base;
-	GT_REG_READ(PCI_1I_O_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	return base;
-}
-
-/********************************************************************
-* pci1GetIOspaceSize - Return PCI1 IO Bar Size.
-* Inputs: N/A
-* Returns: PCI1 IO Bar Size.
-*********************************************************************/
-
-unsigned int pci1GetIOspaceSize()
-{
-	unsigned int top, base, size;
-	GT_REG_READ(PCI_1I_O_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	GT_REG_READ(PCI_1I_O_HIGH_DECODE_ADDRESS, &top);
-	top = (top << 21);
-	size = ((top - base) & 0xfffffff);
-	size = size | 0x1fffff;
-	return (size + 1);
-}
-
-/********************************************************************
-* pci1GetMemory0Base - Return PCI1 Memory 0 Base Address.
-* Inputs: N/A
-* Returns: PCI1 Memory 0 Base Address.
-*********************************************************************/
-
-unsigned int pci1GetMemory0Base()
-{
-	unsigned int base;
-	GT_REG_READ(PCI_1MEMORY0_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	return base;
-}
-
-/********************************************************************
-* pci1GetMemory0Size - Return PCI1 Memory 0 Bar Size.
-* Inputs: N/A
-* Returns: PCI1 Memory 0 Bar Size.
-*********************************************************************/
-
-unsigned int pci1GetMemory0Size()
-{
-	unsigned int top, base, size;
-	GT_REG_READ(PCI_1MEMORY1_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	GT_REG_READ(PCI_1MEMORY1_HIGH_DECODE_ADDRESS, &top);
-	top = (top << 21);
-	size = ((top - base) & 0xfffffff);
-	size = size | 0x1fffff;
-	return (size + 1);
-}
-
-/********************************************************************
-* pci1GetMemory1Base - Return PCI1 Memory 1 Base Address.
-* Inputs: N/A
-* Returns: PCI1 Memory 1 Base Address.
-*********************************************************************/
-
-unsigned int pci1GetMemory1Base()
-{
-	unsigned int base;
-	GT_REG_READ(PCI_1MEMORY1_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	return base;
-}
-
-/********************************************************************
-* pci1GetMemory1Size - Return PCI1 Memory 1 Bar Size.
-* Inputs: N/A
-* Returns: PCI1 Memory 1 Bar Size.
-*********************************************************************/
-
-unsigned int pci1GetMemory1Size()
-{
-	unsigned int top, base, size;
-	GT_REG_READ(PCI_1MEMORY1_LOW_DECODE_ADDRESS, &base);
-	base = base << 21;
-	GT_REG_READ(PCI_1MEMORY1_HIGH_DECODE_ADDRESS, &top);
-	top = (top << 21);
-	size = ((top - base) & 0xfffffff);
-	size = size | 0x1fffff;
-	return (size + 1);
-}
-
-/********************************************************************
-* pci0MapInternalRegSpace - Maps the internal registers memory space for the
-*                           slave.
-*                           Stays the same for all GT devices Disco include
-* Inputs: base of pci0 internal register
-*********************************************************************/
-
-void pci0MapInternalRegSpace(unsigned int pci0InternalBase)
-{
-	pci0InternalBase = pci0InternalBase & 0xfffff000;
-	pci0InternalBase =
-	    pci0InternalBase |
-	    (pci0ReadConfigReg
-	     (PCI_0INTERNAL_REGISTERS_MEMORY_MAPPED_BASE_ADDRESS,
-	      SELF) & 0x00000fff);
-	pci0WriteConfigReg
-	    (PCI_0INTERNAL_REGISTERS_MEMORY_MAPPED_BASE_ADDRESS, SELF,
-	     pci0InternalBase);
-}
-
-/********************************************************************
-* pci1MapInternalRegSpace - Maps the internal registers memory space for the
-*                           slave.
-*                           Stays the same for all GT devices Disco include
-* Inputs: base of pci1 internal register
-*********************************************************************/
-
-void pci1MapInternalRegSpace(unsigned int pci1InternalBase)
-{
-	pci1InternalBase = pci1InternalBase & 0xfffff000;
-	pci1InternalBase =
-	    pci1InternalBase |
-	    (pci1ReadConfigReg
-	     (PCI_0INTERNAL_REGISTERS_MEMORY_MAPPED_BASE_ADDRESS,
-	      SELF) & 0x00000fff);
-	pci1WriteConfigReg
-	    (PCI_0INTERNAL_REGISTERS_MEMORY_MAPPED_BASE_ADDRESS, SELF,
-	     pci1InternalBase);
-}
-
-/********************************************************************
-* pci0MapInternalRegIOSpace - Maps the internal registers IO space for the
-*                             slave.
-*                             Stays the same for all GT devices Disco include
-* Inputs: base of pci0 internal io register
-*********************************************************************/
-
-void pci0MapInternalRegIOSpace(unsigned int pci0InternalBase)
-{
-	pci0InternalBase = pci0InternalBase & 0xfffff000;
-	pci0InternalBase =
-	    pci0InternalBase |
-	    (pci0ReadConfigReg
-	     (PCI_0INTERNAL_REGISTERS_I_OMAPPED_BASE_ADDRESS,
-	      0) & 0x00000fff);
-	pci0WriteConfigReg(PCI_0INTERNAL_REGISTERS_I_OMAPPED_BASE_ADDRESS,
-			   SELF, pci0InternalBase);
-}
-
-/********************************************************************
-* pci0MapInternalRegIOSpace - Maps the internal registers IO space for the
-*                             slave.
-*                             Stays the same for all GT devices Disco include
-* Inputs: base of pci1 internal io register
-*********************************************************************/
-
-void pci1MapInternalRegIOSpace(unsigned int pci1InternalBase)
-{
-	pci1InternalBase = pci1InternalBase & 0xfffff000;
-	pci1InternalBase =
-	    pci1InternalBase |
-	    (pci1ReadConfigReg
-	     (PCI_0INTERNAL_REGISTERS_I_OMAPPED_BASE_ADDRESS,
-	      SELF) & 0x00000fff);
-	pci1WriteConfigReg(PCI_0INTERNAL_REGISTERS_I_OMAPPED_BASE_ADDRESS,
-			   SELF, pci1InternalBase);
-}
-
-/********************************************************************
-* pci0MapMemoryBanks0_1 - Maps PCI0 memory banks 0 and 1 for the slave.
-*                         for Discovery we need two function: SCS0 & SCS1
-*                         (instead of SCS[1:0])
-* Inputs: base and size of pci0 dram
-*********************************************************************/
-
-
-void pci0MapMemoryBanks0_1(unsigned int pci0Dram0_1Base,
-			   unsigned int pci0Dram0_1Size)
-{
-	pci0Dram0_1Base = pci0Dram0_1Base & 0xfffff000;
-	pci0Dram0_1Base =
-	    pci0Dram0_1Base |
-	    (pci0ReadConfigReg(PCI_0SCS_1_0_BASE_ADDRESS, SELF) &
-	     0x00000fff);
-	pci0WriteConfigReg(PCI_0SCS_1_0_BASE_ADDRESS, SELF,
-			   pci0Dram0_1Base);
-	/* swapped Bar */
-	pci0WriteConfigReg(PCI_0SWAPPED_SCS_1_0_BASE_ADDRESS, SELF,
-			   pci0Dram0_1Base);
-	if (pci0Dram0_1Size == 0)
-		pci0Dram0_1Size++;
-	GT_REG_WRITE(PCI_0SCS_1_0_BANK_SIZE, pci0Dram0_1Size - 1);
-}
-
-/********************************************************************
-* pci1MapMemoryBanks0_1 - Maps PCI1 memory banks 0 and 1 for the slave.
-*                         for Discovery we need two function: SCS0 & SCS1
-*                         (instead of SCS[1:0])
-* Inputs: base and size of pci1 dram
-*********************************************************************/
-
-void pci1MapMemoryBanks0_1(unsigned int pci1Dram0_1Base,
-			   unsigned int pci1Dram0_1Size)
-{
-	pci1Dram0_1Base = pci1Dram0_1Base & 0xfffff000;
-	pci1Dram0_1Base =
-	    pci1Dram0_1Base |
-	    (pci1ReadConfigReg(PCI_0SCS_1_0_BASE_ADDRESS, SELF) &
-	     0x00000fff);
-	pci1WriteConfigReg(PCI_0SCS_1_0_BASE_ADDRESS, SELF,
-			   pci1Dram0_1Base);
-	/* swapped Bar */
-	pci1WriteConfigReg(PCI_0SWAPPED_SCS_1_0_BASE_ADDRESS, SELF,
-			   pci1Dram0_1Base);
-	if (pci1Dram0_1Size == 0)
-		pci1Dram0_1Size++;
-	GT_REG_WRITE(PCI_1SCS_1_0_BANK_SIZE, pci1Dram0_1Size - 1);
-}
-
-/********************************************************************
-* pci0MapMemoryBanks2_3 - Maps PCI0 memory banks 2 and 3 for the slave.
-*                         for Discovery we need two function: SCS2 & SCS3
-*                         (instead of SCS[3:2])
-* Inputs: base and size of pci0 dram
-*********************************************************************/
-
-void pci0MapMemoryBanks2_3(unsigned int pci0Dram2_3Base,
-			   unsigned int pci0Dram2_3Size)
-{
-	pci0Dram2_3Base = pci0Dram2_3Base & 0xfffff000;
-	pci0Dram2_3Base =
-	    pci0Dram2_3Base |
-	    (pci0ReadConfigReg(PCI_0SCS_3_2_BASE_ADDRESS, SELF) &
-	     0x00000fff);
-	pci0WriteConfigReg(PCI_0SCS_3_2_BASE_ADDRESS, SELF,
-			   pci0Dram2_3Base);
-	/* swapped Bar */
-	pci0WriteConfigReg(PCI_0SWAPPED_SCS_3_2_BASE_ADDRESS, SELF,
-			   pci0Dram2_3Base);
-	if (pci0Dram2_3Size == 0)
-		pci0Dram2_3Size++;
-	GT_REG_WRITE(PCI_0SCS_3_2_BANK_SIZE, pci0Dram2_3Size - 1);
-}
-
-/********************************************************************
-* pci1MapMemoryBanks2_3 - Maps PCI1 memory banks 2 and 3 for the slave.
-*                         for Discovery we need two function: SCS2 & SCS3
-*                         (instead of SCS[3:2])
-* Inputs: base and size of pci1 dram
-*********************************************************************/
-
-void pci1MapMemoryBanks2_3(unsigned int pci1Dram2_3Base,
-			   unsigned int pci1Dram2_3Size)
-{
-	pci1Dram2_3Base = pci1Dram2_3Base & 0xfffff000;
-	pci1Dram2_3Base =
-	    pci1Dram2_3Base |
-	    (pci1ReadConfigReg(PCI_0SCS_3_2_BASE_ADDRESS, SELF) &
-	     0x00000fff);
-	pci1WriteConfigReg(PCI_0SCS_3_2_BASE_ADDRESS, SELF,
-			   pci1Dram2_3Base);
-	/* swapped Bar */
-	pci1WriteConfigReg(PCI_0SWAPPED_SCS_3_2_BASE_ADDRESS, SELF,
-			   pci1Dram2_3Base);
-	if (pci1Dram2_3Size == 0)
-		pci1Dram2_3Size++;
-	GT_REG_WRITE(PCI_1SCS_3_2_BANK_SIZE, pci1Dram2_3Size - 1);
-}
-
-/********************************************************************
-* pci0MapDevices0_1and2MemorySpace - Maps PCI0 devices 0,1 and 2 memory spaces
-*                                    for the slave.
-*                                    For the Discovery there are 3 separate
-*                                    fucnction's
-* Inputs: base and lengthof pci0 devises012
-*********************************************************************/
-
-
-void pci0MapDevices0_1and2MemorySpace(unsigned int pci0Dev012Base,
-				      unsigned int pci0Dev012Length)
-{
-	pci0Dev012Base = pci0Dev012Base & 0xfffff000;
-	pci0Dev012Base =
-	    pci0Dev012Base |
-	    (pci0ReadConfigReg(PCI_0CS_2_0_BASE_ADDRESS, SELF) &
-	     0x00000fff);
-	pci0WriteConfigReg(PCI_0CS_2_0_BASE_ADDRESS, SELF, pci0Dev012Base);
-	if (pci0Dev012Length == 0)
-		pci0Dev012Length++;
-	GT_REG_WRITE(PCI_0CS_2_0_BANK_SIZE, pci0Dev012Length - 1);
-}
-
-/********************************************************************
-* pci1MapDevices0_1and2MemorySpace - Maps PCI1 devices 0,1 and 2 memory spaces
-*                                    for the slave.
-*                                    For the Discovery there are 3 separate
-*                                    fucnction's
-* Inputs: base and lengthof pci1 devises012
-*********************************************************************/
-
-void pci1MapDevices0_1and2MemorySpace(unsigned int pci1Dev012Base,
-				      unsigned int pci1Dev012Length)
-{
-	pci1Dev012Base = pci1Dev012Base & 0xfffff000;
-	pci1Dev012Base =
-	    pci1Dev012Base |
-	    (pci1ReadConfigReg(PCI_0CS_2_0_BASE_ADDRESS, SELF) &
-	     0x00000fff);
-	pci1WriteConfigReg(PCI_0CS_2_0_BASE_ADDRESS, SELF, pci1Dev012Base);
-	if (pci1Dev012Length == 0)
-		pci1Dev012Length++;
-	GT_REG_WRITE(PCI_1CS_2_0_BANK_SIZE, pci1Dev012Length - 1);
-}
-
-/********************************************************************
-* pci0MapDevices3andBootMemorySpace - Maps PCI0 devices 3 and boot memory
-*                                     spaces for the slave.
-*                                     For the Discovery there are 2 separate
-*                                     fucnction's
-* Inputs: base and length of pci0 device3/ boot
-*********************************************************************/
-
-void pci0MapDevices3andBootMemorySpace(unsigned int pci0Dev3andBootBase,
-				       unsigned int pci0Dev3andBootLength)
-{
-	pci0Dev3andBootBase = pci0Dev3andBootBase & 0xfffff000;
-	pci0Dev3andBootBase =
-	    pci0Dev3andBootBase |
-	    (pci0ReadConfigReg(PCI_0CS_3_BOOTCS_BASE_ADDRESS, SELF) &
-	     0x00000fff);
-	pci0WriteConfigReg(PCI_0CS_3_BOOTCS_BASE_ADDRESS, SELF,
-			   pci0Dev3andBootBase);
-	/* swapped Bar */
-	pci0WriteConfigReg(PCI_0SWAPPED_CS_3_BOOTCS_BASE_ADDRESS, SELF,
-			   pci0Dev3andBootBase);
-	if (pci0Dev3andBootLength == 0)
-		pci0Dev3andBootLength++;
-	GT_REG_WRITE(PCI_0CS_3_BOOTCS_BANK_SIZE,
-		     pci0Dev3andBootLength - 1);
-}
-
-/********************************************************************
-* pci1MapDevices3andBootMemorySpace - Maps PCI1 devices 3 and boot memory
-*                                     spaces for the slave.
-*                                     For the Discovery there are 2 separate
-*                                     fucnction's
-* Inputs: base and length of pci1 device3/ boot
-*********************************************************************/
-
-void pci1MapDevices3andBootMemorySpace(unsigned int pci1Dev3andBootBase,
-				       unsigned int pci1Dev3andBootLength)
-{
-	pci1Dev3andBootBase = pci1Dev3andBootBase & 0xfffff000;
-	pci1Dev3andBootBase =
-	    pci1Dev3andBootBase |
-	    (pci1ReadConfigReg(PCI_0CS_3_BOOTCS_BASE_ADDRESS, SELF) &
-	     0x00000fff);
-	pci1WriteConfigReg(PCI_0CS_3_BOOTCS_BASE_ADDRESS, SELF,
-			   pci1Dev3andBootBase);
-	/* swapped Bar */
-	pci1WriteConfigReg(PCI_0SWAPPED_CS_3_BOOTCS_BASE_ADDRESS, SELF,
-			   pci1Dev3andBootBase);
-	if (pci1Dev3andBootLength == 0)
-		pci1Dev3andBootLength++;
-	GT_REG_WRITE(PCI_1CS_3_BOOTCS_BANK_SIZE,
-		     pci1Dev3andBootLength - 1);
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/pci_etherboot.c linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/pci_etherboot.c
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/pci_etherboot.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/pci_etherboot.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,318 +0,0 @@
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-#include <linux/config.h>
-#include <asm/galileo-boards/evb64120A/pci.h>
-#include <asm/byteorder.h>
-
-#include "etherboot.h"
-#include "pci_etherboot.h"
-#include "galileo_port.h"
-
-#define MAX_PCI_DEVS 10
-PCI_DEVICE pci0_devices[MAX_PCI_DEVS];
-PCI_DEVICE pci1_devices[MAX_PCI_DEVS];
-
-static int pci_range_ck(unsigned char bus, unsigned char dev)
-{
-	if ((bus == 0) && (dev >= 0) && (dev < 30))
-		return 0;	// Bus/Device Number OK
-
-	return -1;		// Bus/Device Number not OK
-}
-
-/********************************************************************
- * pcibios_(read/write)_config_(byte/word/dword)
- *
- *Inputs :
- *bus - bus number
- *dev - device number
- *offset - register offset in the configuration space
- *val - value to be written / read
- *
- *Outputs :
- *Sucees/Failure
- *********************************************************************/
-#define PCI_CFG_DATA    ((volatile unsigned long *)0xb4000cfc)
-#define PCI_CFG_CTRL    ((volatile unsigned long *)0xb4000cf8)
-
-#define PCI_CFG_SET(dev,fun,off) \
-        ((*PCI_CFG_CTRL) = cpu_to_le32((0x80000000 | ((dev)<<11) | ((fun)<<8) | (off))))
-
-int pcibios_read_config_dword(unsigned char bus, unsigned char dev,
-			      unsigned char offset, unsigned int *val)
-{
-
-	if (offset & 0x3) {
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-	}
-	if (pci_range_ck(bus, dev)) {
-		*val = 0xFFFFFFFF;
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	}
-	PCI_CFG_SET(dev, 0, offset);
-	if (dev != 0) {
-		*val = *PCI_CFG_DATA;
-	} else {
-		*val = cpu_to_le32(*PCI_CFG_DATA);
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-int pcibios_read_config_word(unsigned char bus, unsigned char dev,
-			     unsigned char offset, unsigned short *val)
-{
-	if (offset & 0x1)
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-	if (pci_range_ck(bus, dev)) {
-		*val = 0xffff;
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	}
-	PCI_CFG_SET(dev, 0, (offset & ~0x3));
-	if (dev != 0) {
-		*val = *PCI_CFG_DATA >> ((offset & 3) * 8);
-	} else {
-		*val = cpu_to_le32(*PCI_CFG_DATA) >> ((offset & 3) * 8);
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-int pcibios_read_config_byte(unsigned char bus, unsigned char dev,
-			     unsigned char offset, unsigned char *val)
-{
-	if (pci_range_ck(bus, dev)) {
-		*val = 0xff;
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	}
-	PCI_CFG_SET(dev, 0, (offset & ~0x3));
-	if (dev != 0) {
-		*val = *PCI_CFG_DATA >> ((offset & 3) * 8);
-	} else {
-		*val = cpu_to_le32(*PCI_CFG_DATA >> ((offset & 3) * 8));
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-int pcibios_write_config_dword(unsigned char bus, unsigned char dev,
-			       unsigned char offset, unsigned int val)
-{
-	if (offset & 0x3)
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-	if (pci_range_ck(bus, dev))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	PCI_CFG_SET(dev, 0, offset);
-	if (dev != 0) {
-		*PCI_CFG_DATA = val;
-	} else {
-		*PCI_CFG_DATA = cpu_to_le32(val);
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-int pcibios_write_config_word(unsigned char bus, unsigned char dev,
-			      unsigned char offset, unsigned short val)
-{
-	unsigned long tmp;
-
-	if (offset & 0x1)
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-	if (pci_range_ck(bus, dev))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	PCI_CFG_SET(dev, 0, (offset & ~0x3));
-	if (dev != 0) {
-		tmp = *PCI_CFG_DATA;
-	} else {
-		tmp = cpu_to_le32(*PCI_CFG_DATA);
-	}
-	tmp &= ~(0xffff << ((offset & 0x3) * 8));
-	tmp |= (val << ((offset & 0x3) * 8));
-	if (dev != 0) {
-		*PCI_CFG_DATA = tmp;
-	} else {
-		*PCI_CFG_DATA = cpu_to_le32(tmp);
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-int pcibios_write_config_byte(unsigned char bus, unsigned char dev,
-			      unsigned char offset, unsigned char val)
-{
-	unsigned long tmp;
-
-	if (pci_range_ck(bus, dev))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	PCI_CFG_SET(dev, 0, (offset & ~0x3));
-	if (dev != 0) {
-		tmp = *PCI_CFG_DATA;
-	} else {
-		tmp = cpu_to_le32(*PCI_CFG_DATA);
-	}
-	tmp &= ~(0xff << ((offset & 0x3) * 8));
-	tmp |= (val << ((offset & 0x3) * 8));
-	*PCI_CFG_DATA = cpu_to_le32(tmp);
-	return PCIBIOS_SUCCESSFUL;
-}
-
-
-/********************************************************************
- * eth_pci_init - Fill pci_devi
- *
- *Inputs :
- *bus - bus number
- *dev - device number
- *offset - register offset in the configuration space
- *val - value to be written / read
- *
- *Outputs :
- *Sucees/Failure
- *********************************************************************/
-void eth_pci_init(struct pci_device *pcidev)
-{
-	int i, count;
-	pcibios_write_config_word(0, 0, 4, 0x7);
-	pcibios_write_config_dword(0, 8, BAR0, 0x12000000);
-	pcibios_write_config_dword(0, 8, BAR1, 0x10000001);
-	pcibios_write_config_dword(0, 8, BAR2, 0x12100000);
-	strcpy(pci0_devices[0].type, "Network Controller");
-	pci0_devices[0].deviceNum = 8;
-	pci0_devices[0].venID = 0x8086;
-	pci0_devices[0].deviceID = 0x1229;
-
-	pci0_devices[0].bar0Base = 0x12000000;
-	pci0_devices[0].bar0Size = 0x00001000;
-	pci0_devices[0].bar0Type = 0;
-	pci0_devices[0].bar1Base = 0x10000000;
-	pci0_devices[0].bar1Size = 0x40;
-	pci0_devices[0].bar1Type = 1;
-	pci0_devices[0].bar2Base = 0x12100000;
-	pci0_devices[0].bar2Size = 0x00100000;
-	pci0_devices[0].bar2Type = 0;
-	for (i = 0; pcidev[i].vendor != 0; i++) {
-		/* Look for device in PCI0 first */
-		for (count = 0; count < MAX_PCI_DEVS; count++) {
-			if ((pci0_devices[count].type[0] != 0)
-			    && ((unsigned short) pci0_devices[count].
-				venID == (unsigned short) pcidev[i].vendor)
-			    && ((unsigned short) pci0_devices[count].
-				deviceID ==
-				(unsigned short) pcidev[i].dev_id)) {
-				if ((pci0_devices[count].bar0Type == 1)
-				    && (pci0_devices[count].bar0Size != 0))
-					pcidev[i].ioaddr =
-					    pci0_devices[count].bar0Base;
-				if ((pci0_devices[count].bar1Type == 1)
-				    && (pci0_devices[count].bar1Size != 0))
-					pcidev[i].ioaddr =
-					    pci0_devices[count].bar1Base;
-				if ((pci0_devices[count].bar2Type == 1)
-				    && (pci0_devices[count].bar2Size != 0))
-					pcidev[i].ioaddr =
-					    pci0_devices[count].bar2Base;
-				if ((pci0_devices[count].bar3Type == 1)
-				    && (pci0_devices[count].bar3Size != 0))
-					pcidev[i].ioaddr =
-					    pci0_devices[count].bar3Base;
-				if ((pci0_devices[count].bar4Type == 1)
-				    && (pci0_devices[count].bar4Size != 0))
-					pcidev[i].ioaddr =
-					    pci0_devices[count].bar4Base;
-				if ((pci0_devices[count].bar5Type == 1)
-				    && (pci0_devices[count].bar5Size != 0))
-					pcidev[i].ioaddr =
-					    pci0_devices[count].bar5Base;
-
-				if ((pci0_devices[count].bar0Type == 0)
-				    && (pci0_devices[count].bar0Size != 0))
-					pcidev[i].membase =
-					    pci0_devices[count].bar0Base;
-				if ((pci0_devices[count].bar1Type == 0)
-				    && (pci0_devices[count].bar1Size != 0))
-					pcidev[i].membase =
-					    pci0_devices[count].bar1Base;
-				if ((pci0_devices[count].bar2Type == 0)
-				    && (pci0_devices[count].bar2Size != 0))
-					pcidev[i].membase =
-					    pci0_devices[count].bar2Base;
-				if ((pci0_devices[count].bar3Type == 0)
-				    && (pci0_devices[count].bar3Size != 0))
-					pcidev[i].membase =
-					    pci0_devices[count].bar3Base;
-				if ((pci0_devices[count].bar4Type == 0)
-				    && (pci0_devices[count].bar4Size != 0))
-					pcidev[i].membase =
-					    pci0_devices[count].bar4Base;
-				if ((pci0_devices[count].bar5Type == 0)
-				    && (pci0_devices[count].bar5Size != 0))
-					pcidev[i].membase =
-					    pci0_devices[count].bar5Base;
-				pcidev[i].bus = 0;
-				pcidev[i].devfn =
-				    pci0_devices[count].deviceNum;
-			}
-#ifdef CONFIG_EVB_PCI1
-			if ((pci1_devices[count].type[0] != 0)
-			    && (pci1_devices[count].venID ==
-				pcidev[i].vendor)
-			    && (pci1_devices[count].deviceID ==
-				pcidev[i].dev_id)) {
-				if ((pci1_devices[count].bar0Type == 1)
-				    && (pci1_devices[count].bar0Size != 0))
-					pcidev[i].ioaddr =
-					    pci1_devices[count].bar0Base;
-				if ((pci1_devices[count].bar1Type == 1)
-				    && (pci1_devices[count].bar1Size != 0))
-					pcidev[i].ioaddr =
-					    pci1_devices[count].bar1Base;
-				if ((pci1_devices[count].bar2Type == 1)
-				    && (pci1_devices[count].bar2Size != 0))
-					pcidev[i].ioaddr =
-					    pci1_devices[count].bar2Base;
-				if ((pci1_devices[count].bar3Type == 1)
-				    && (pci1_devices[count].bar3Size != 0))
-					pcidev[i].ioaddr =
-					    pci1_devices[count].bar3Base;
-				if ((pci1_devices[count].bar4Type == 1)
-				    && (pci1_devices[count].bar4Size != 0))
-					pcidev[i].ioaddr =
-					    pci1_devices[count].bar4Base;
-				if ((pci1_devices[count].bar5Type == 1)
-				    && (pci1_devices[count].bar5Size != 0))
-					pcidev[i].ioaddr =
-					    pci1_devices[count].bar5Base;
-
-				if ((pci1_devices[count].bar0Type == 0)
-				    && (pci1_devices[count].bar0Size != 0))
-					pcidev[i].membase =
-					    pci1_devices[count].bar0Base;
-				if ((pci1_devices[count].bar1Type == 0)
-				    && (pci1_devices[count].bar1Size != 0))
-					pcidev[i].membase =
-					    pci1_devices[count].bar1Base;
-				if ((pci1_devices[count].bar2Type == 0)
-				    && (pci1_devices[count].bar2Size != 0))
-					pcidev[i].membase =
-					    pci1_devices[count].bar2Base;
-				if ((pci1_devices[count].bar3Type == 0)
-				    && (pci1_devices[count].bar3Size != 0))
-					pcidev[i].membase =
-					    pci1_devices[count].bar3Base;
-				if ((pci1_devices[count].bar4Type == 0)
-				    && (pci1_devices[count].bar4Size != 0))
-					pcidev[i].membase =
-					    pci1_devices[count].bar4Base;
-				if ((pci1_devices[count].bar5Type == 0)
-				    && (pci1_devices[count].bar5Size != 0))
-					pcidev[i].membase =
-					    pci1_devices[count].bar5Base;
-
-				pcidev[i].bus = 1;
-				pcidev[i].devfn =
-				    pci1_devices[count].deviceNum;
-			}
-#endif
-		}
-	}
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/pci_etherboot.h linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/pci_etherboot.h
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/pci_etherboot.h	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/pci_etherboot.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,144 +0,0 @@
-#ifndef	PCI_H
-#define PCI_H
-
-/*
-** Support for NE2000 PCI clones added David Monro June 1997
-** Generalised for other PCI NICs by Ken Yap July 1997
-**
-** Most of this is taken from:
-**
-** /usr/src/linux/drivers/pci/pci.c
-** /usr/src/linux/include/linux/pci.h
-** /usr/src/linux/arch/i386/bios32.c
-** /usr/src/linux/include/linux/bios32.h
-** /usr/src/linux/drivers/net/ne.c
-*/
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-#define PCI_COMMAND_IO			0x1	/* Enable response in I/O space */
-#define PCI_COMMAND_MASTER		0x4	/* Enable bus mastering */
-#define PCI_LATENCY_TIMER		0x0d	/* 8 bits */
-
-
-#define PCI_VENDOR_ID           0x00	/* 16 bits */
-#define PCI_DEVICE_ID           0x02	/* 16 bits */
-#define PCI_COMMAND             0x04	/* 16 bits */
-
-#define PCI_CLASS_CODE          0x0b	/* 8 bits */
-#define PCI_SUBCLASS_CODE       0x0a	/* 8 bits */
-#define PCI_HEADER_TYPE         0x0e	/* 8 bits */
-
-#define PCI_BASE_ADDRESS_0      0x10	/* 32 bits */
-#define PCI_BASE_ADDRESS_1      0x14	/* 32 bits */
-#define PCI_BASE_ADDRESS_2      0x18	/* 32 bits */
-#define PCI_BASE_ADDRESS_3      0x1c	/* 32 bits */
-#define PCI_BASE_ADDRESS_4      0x20	/* 32 bits */
-#define PCI_BASE_ADDRESS_5      0x24	/* 32 bits */
-
-#ifndef	PCI_BASE_ADDRESS_IO_MASK
-#define	PCI_BASE_ADDRESS_IO_MASK       (~0x03)
-#endif
-#define	PCI_BASE_ADDRESS_SPACE_IO	0x01
-#define	PCI_ROM_ADDRESS		0x30	/* 32 bits */
-#define	PCI_ROM_ADDRESS_ENABLE	0x01	/* Write 1 to enable ROM,
-					   bits 31..11 are address,
-					   10..2 are reserved */
-
-#define PCI_FUNC(devfn)           ((devfn) & 0x07)
-
-#define BIOS32_SIGNATURE        (('_' << 0) + ('3' << 8) + ('2' << 16) + ('_' << 24))
-
-/* PCI signature: "PCI " */
-#define PCI_SIGNATURE           (('P' << 0) + ('C' << 8) + ('I' << 16) + (' ' << 24))
-
-/* PCI service signature: "$PCI" */
-#define PCI_SERVICE             (('$' << 0) + ('P' << 8) + ('C' << 16) + ('I' << 24))
-
-#define KERN_CODE_SEG	0x8	/* This _MUST_ match start.S */
-
-#define PCI_VENDOR_ID_REALTEK           0x10ec
-#define PCI_DEVICE_ID_REALTEK_8029      0x8029
-#define PCI_DEVICE_ID_REALTEK_8139      0x8139
-#define PCI_VENDOR_ID_WINBOND2          0x1050
-#define PCI_DEVICE_ID_WINBOND2_89C940   0x0940
-#define PCI_VENDOR_ID_COMPEX            0x11f6
-#define PCI_DEVICE_ID_COMPEX_RL2000     0x1401
-#define PCI_VENDOR_ID_KTI               0x8e2e
-#define PCI_DEVICE_ID_KTI_ET32P2        0x3000
-#define PCI_VENDOR_ID_NETVIN            0x4a14
-#define PCI_DEVICE_ID_NETVIN_NV5000SC   0x5000
-#define PCI_VENDOR_ID_3COM		0x10b7
-#define PCI_DEVICE_ID_3COM_3C900TPO	0x9000
-#define PCI_DEVICE_ID_3COM_3C900COMBO	0x9001
-#define PCI_DEVICE_ID_3COM_3C905TX	0x9050
-#define PCI_DEVICE_ID_3COM_3C905T4	0x9051
-#define PCI_DEVICE_ID_3COM_3C905B_TX	0x9055
-#define PCI_DEVICE_ID_3COM_3C905C_TXM	0x9200
-#define PCI_VENDOR_ID_INTEL		0x8086
-#define PCI_DEVICE_ID_INTEL_82557	0x1229
-#define PCI_VENDOR_ID_AMD		0x1022
-#define PCI_DEVICE_ID_AMD_LANCE		0x2000
-#define PCI_VENDOR_ID_SMC_1211          0x1113
-#define PCI_DEVICE_ID_SMC_1211          0x1211
-#define PCI_VENDOR_ID_DEC		0x1011
-#define PCI_DEVICE_ID_DEC_TULIP		0x0002
-#define PCI_DEVICE_ID_DEC_TULIP_FAST	0x0009
-#define PCI_DEVICE_ID_DEC_TULIP_PLUS	0x0014
-#define PCI_DEVICE_ID_DEC_21142		0x0019
-#define PCI_VENDOR_ID_SMC		0x10B8
-#ifndef	PCI_DEVICE_ID_SMC_EPIC100
-# define PCI_DEVICE_ID_SMC_EPIC100	0x0005
-#endif
-#define PCI_VENDOR_ID_MACRONIX		0x10d9
-#define PCI_DEVICE_ID_MX987x5		0x0531
-#define PCI_VENDOR_ID_LINKSYS		0x11AD
-#define PCI_DEVICE_ID_LC82C115		0xC115
-#define PCI_VENDOR_ID_VIATEC		0x1106
-#define PCI_DEVICE_ID_VIA_RHINE_I	0x3043
-#define PCI_DEVICE_ID_VIA_86C100A	0x6100
-#define PCI_VENDOR_ID_DAVICOM		0x1282
-#define PCI_DEVICE_ID_DM9102		0x9102
-
-struct pci_device {
-	unsigned short vendor, dev_id;
-	const char *name;
-	unsigned int membase;
-	unsigned int ioaddr;
-	unsigned short devfn;
-	unsigned short bus;
-};
-
-extern void eth_pci_init(struct pci_device *);
-int pcibios_read_config_byte(unsigned char bus, unsigned char dev_fn,
-			     unsigned char where, unsigned char *val);
-int pcibios_read_config_word(unsigned char bus, unsigned char dev_fn,
-			     unsigned char where, unsigned short *val);
-int pcibios_read_config_dword(unsigned char bus, unsigned char dev_fn,
-			      unsigned char where, unsigned int *val);
-int pcibios_write_config_byte(unsigned char bus, unsigned char dev_fn,
-			      unsigned char where, unsigned char val);
-int pcibios_write_config_word(unsigned char bus, unsigned char dev_fn,
-			      unsigned char where, unsigned short val);
-int pcibios_write_config_dword(unsigned char bus, unsigned char dev_fn,
-			       unsigned char where, unsigned int val);
-
-/*
- * Error values that may be returned by the PCI bios.
- */
-#define PCIBIOS_SUCCESSFUL              0x00
-#define PCIBIOS_FUNC_NOT_SUPPORTED      0x81
-#define PCIBIOS_BAD_VENDOR_ID           0x83
-#define PCIBIOS_DEVICE_NOT_FOUND        0x86
-#define PCIBIOS_BAD_REGISTER_NUMBER     0x87
-#define PCIBIOS_SET_FAILED              0x88
-#define PCIBIOS_BUFFER_TOO_SMALL        0x89
-
-
-
-#endif				/* PCI_H */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/README linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/README
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/README	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,131 +0,0 @@
-+------------------------------------------------+
-|  $TOPDIR/arch/mips/galileo/compressed/README   |
-|                                                |
-|  By RidgeRun Inc,                              |
-|  Aug, 2000                                     |
-+------------------------------------------------+
-
-Description:
-============
-  It is intended that this makefile be wired in to run as
-  part of a top level linux build. For example, at the
-  time of this writing, if the user types "make gboot" at
-  the top level then in addition to building vmlinux the
-  build system's makefiles will descend into this
-  directory and build the "all:" target of this
-  Makefile. This will have the result of compressing the
-  vmlinux system and producing four separate systems. The
-  following snippet is pulled from this directory's
-  Makefile and describes each system.
-
-  Four systems are availalbe for download to the EVB64120A
-  board.
-
-   1. - ramsys -
-      To be loaded into ram then run. When run
-      it decompresses the "vmlinux" kernel housed in its internal
-      data structures and then jumps to the image which
-      results in a linux kernel boot.
-
-   2. - flashsys -
-      To be loaded into ram so that it can be
-      burned into the onboard flash. Then the board jumpers
-      can be switched so that the next power cycle caused
-      the system in flash to run which then proceeds as
-      described by #1 above.
-      Note: burner.srec is the utility that will allow
-      the user to get this image into flash.
-
-   3. - flashsys2 -
-      To be loaded into ram so that it can be
-      burned into the onboard flash. Then on each power
-      cycle when the standard PMON prompt is presented
-      the user can type `call 0xbf000000` to invoke
-      the system in flash which then proceeds as
-      described by #1 above.
-      Note: burner.srec is the utility that will allow
-      the user to get this image into flash.
-
-   4. - burner.srec -
-      Related to #2 and #3 above.
-
-Example: Running from Ram
-==========================
-
-  In this scenario the compressed system is downloaded
-  into ram and run directly from there. No flash is involved
-  in this scenario. Naturally, the download must be repeated
-  on every power cycle.
-
-  1. At the PMON prompt type `load`
-  2. Assuming you have your host connected to /dev/ttyS0
-     type the following command in a host shell window.
-     `cat ramsys.srec > /dev/ttyS0`
-  3. When the download completes type the following
-     at the PMON prompt: `g`
-
-
-Example: Running from flash: Scenario #1
-========================================
-
-  In this scenario vmlinux runs out of flash code
-  automatically on every power up. This means that
-  standard PMON code (of eprom) never runs.
-
-  1. Place the boot jumpers in the Boot-from-eprom
-     state. This is the normal state and how the jumpers
-     are found when booting PMON.
-
-     Jumper settings. J11 - Removed
-                      J20 - Moved from the 1&2 position to
-                            the 2&3 position instead
-
-  2. Use PMON to "load" the burner.srec image and then
-     run it. This utility will prompt you to download
-     the image that you want burned into the flash
-     part.
-
-  3. Send the flashsys.srec image to the running burner
-     utility. The utililty will indicate when the burn
-     process has completed.
-
-  4. Now switch off power and change the jumpers to
-     the boot-from-flash position. The next power cycle
-     will run the flash based system automatically.
-
-     Jumper settings. J11 - Added.
-                      J20 - Moved from the 2&3 position to
-                            the 1&2 position instead
-
-Example: Running from flash: Scenario #2
-========================================
-
-  In this scenario vmlinux runs out of flash only if the
-  PMON user decides to jump there by issuing a command to
-  PMON. Every power cycle would continue to bring up PMON
-  and a user will have to reissue the jump command to
-  force control transfer to the flash system.
-
-  1. Insure that the boot jumpers are in the Boot-from-eprom
-     state. This is the normal state and how the jumpers
-     are found when booting PMON.
-
-     Jumper settings. J11 - Removed
-                      J20 - Moved from the 1&2 position to
-                            the 2&3 position instead
-
-  2. Use PMON to "load" the burner.srec image and then
-     run it. This utility will prompt you to download
-     the image that you want burned into the flash
-     part.
-
-  3. Send the flashsys2.srec image to the running burner
-     utility. The utililty will indicate when the burn
-     process has completed.
-
-  4. Now that the image is in flash the user can invoke
-     the following PMON command whenever a vmlinux
-     boot is desired:
-
-     call 0xbf000000
-
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/sbd.h linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/sbd.h
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/sbd.h	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/sbd.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,52 +0,0 @@
-/*
- * sbd.h: cpu board definitions for Galileo-9
- * Copyright (c) 1997	Algorithmics Ltd
- */
-
-#ifndef MHZ
-/* fastest possible pipeline clock */
-#define MHZ		150
-#endif
-
-/* FIXME These timings are completely fictional */
-#define RAMCYCLE	60	/* 60ns dram cycle */
-#define ROMCYCLE	750	/* ~750ns rom cycle */
-#define CACHECYCLE	(1000/MHZ)	/* internal clock */
-#define CYCLETIME	CACHECYCLE
-#define CACHEMISS	(CYCLETIME * 6)
-
-/*
- * rough scaling factors for 2 instruction DELAY loop to get 1ms and 1us delays
- */
-#define ASMDELAY(ns,icycle)	\
-	(((ns) + (icycle)) / ((icycle) * 2))
-
-#define CACHEUS		ASMDELAY(1000, CACHECYCLE)
-#define RAMUS		ASMDELAY(1000, CACHEMISS+RAMCYCLE)
-#define ROMUS		ASMDELAY(1000, CACHEMISS+ROMCYCLE)
-#define CACHEMS		ASMDELAY(1000000, CACHECYCLE)
-#define RAMMS		ASMDELAY(1000000, CACHEMISS+RAMCYCLE)
-#define ROMMS		ASMDELAY(1000000, CACHEMISS+ROMCYCLE)
-
-#ifndef __ASSEMBLY__
-#define nsdelay(ns)	mips_cycle (ASMDELAY (ns, CACHECYCLE))
-#define usdelay(us)	mips_cycle (ASMDELAY ((us)*1000, CACHECYCLE))
-#endif
-
-#define DRAM_BASE		0x00000000
-#define PCI_IO_BASE		0x10000000
-#define PCI_IO_SIZE		0x02000000
-#define PCI_MEM_BASE		0x12000000
-#define PCI_MEM_SIZE		0x02000000
-#define GT64011_BASE		0x14000000
-#define DUART_BASE		0x1d000000
-#define FLASH_BASE		0x1f000000
-#define PROM_BASE		0x1fc00000
-
-
-#define LOCAL_MEM		DRAM_BASE
-#define LOCAL_MEM_SIZE		(128*1024*1024)	/* SDRAM size (16MB) */
-
-#define BOOTPROM_BASE		PROM_BASE
-
-#define DUART_CLOCK		3686400
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/sbdreset_evb64120A.S linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/sbdreset_evb64120A.S
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/sbdreset_evb64120A.S	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/sbdreset_evb64120A.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,1049 +0,0 @@
-/*
- * Copyright 1997 Algorithmics Ltd
- *	All Rights Reserved
- *
- * gal9/sbdreset.sx -- low level board dependent routines
- */
-
-#ifdef EVB64120A
-
-#include <asm/asm.h>
-#include <asm/regdef.h>
-#include <asm/cacheops.h>
-#include <asm/current.h>
-#include <asm/offset.h>
-#include <asm/processor.h>
-#include <asm/regdef.h>
-#include <asm/cachectl.h>
-#include <asm/mipsregs.h>
-#include <asm/stackframe.h>
-#include <asm/cpu.h>
-#include "sbd.h"
-
-
-#include "gt64011.h"
-#include "ns16550.h"
-
-#ifdef GALILEO_PORT // miniBios crack
-#define C0_CONFIG CP0_CONFIG
-#define C0_STATUS CP0_STATUS
-#define C0_TLBLO0 CP0_ENTRYLO0
-#define C0_TLBLO1 CP0_ENTRYLO1
-#define C0_PGMASK CP0_PAGEMASK
-#define C0_TLBHI CP0_ENTRYHI
-#define C0_INX CP0_INDEX
-#define NTLBENTRIES     48
-
-
-#define CFG_IB CONF_IB
-#define CFG_DB CONF_DB
-#define CFG_C_NONCOHERENT CONF_CM_CACHABLE_NONCOHERENT
-#define C0_SR CP0_STATUS
-#define SR_DE ST0_DE
-
-
-        #define SLEAF(x) LEAF(x)
-        #define SEND(x) END(x)
-        #define XLEAF(x) LEAF(x)
-        #define SBD_DISPLAY(a,b,c,d,e) ;
-
-#define K0BASE          0x80000000
-#define K0SIZE          0x20000000
-#define K1BASE          0xa0000000
-#define K1SIZE          0x20000000
-#define K2BASE          0xc0000000
-
-#define PHYS_TO_K0(pa)  ((pa)|K0BASE)
-#define PHYS_TO_K1(pa)  ((pa)|K1BASE)
-#define K0_TO_PHYS(va)  ((va)&(K0SIZE-1))
-#define K1_TO_PHYS(va)  ((va)&(K1SIZE-1))
-#define K0_TO_K1(va)    ((va)|K1SIZE)
-#define K1_TO_K0(va)    ((va)&~K1SIZE)
-
-#define PA_TO_KVA0(pa)  PHYS_TO_K0(pa)
-#define PA_TO_KVA1(pa)  PHYS_TO_K1(pa)
-#define KVA_TO_PA(pa)   K1_TO_PHYS(pa)
-#define KSEG0_BASE      K0BASE
-#define KSEG1_BASE      K1BASE
-
-
-#endif
-
-#define MB	0x100000
-
-#define MemTypeNone		0x8000
-#define MemRasMask		0x0f00
-#define MemRasShift		8
-#define MemCasMask		0x000f
-#define MemCasShift 		0
-
-#define rasave	s0
-#define p64011	s1
-#define bank0	s2
-#define bank1	s3
-#define bank2	s4
-#define bank3	s5
-#define memtop	s6
-#define membase	s7
-
-/*#if #endian(big)	*/
-#ifdef __MIPSEB__
-
-#define HTOLL(sr,tr) \
-	.set noat ; \
-	srl	AT,sr,24 ; \
-	srl	tr,sr,8 ; \
-	and	tr,0xff00 ; \
-	or	AT,tr ; \
-	and	tr,sr,0xff00 ; \
-	sll	tr,8 ; \
-	or	AT,tr ; \
-	sll	tr,sr,24 ; \
-	or	sr,AT,tr ; \
-	.set at
-#else
-#define HTOLL(sr,tr)
-#endif
-
-#undef DBGSBD
-
-#ifdef DBGSBD
-#define DBG(s) \
-	.rdata ; \
-88:	.asciiz	s ; \
-	.text ; \
-	la	a0, 88b ; \
-	jal	_dbgmsg
-
-LEAF(_dbgmsg)
-	.set noat
-	li	AT,PHYS_TO_K1(NS16550_CHANB)
-waitrdy:
-	lbu	v1,LSR(AT)
-	.set noreorder;	nop; nop; nop; nop; nop; nop; nop; nop; .set reorder
-	and	v1,LSR_TXRDY
-	beqz	v1,waitrdy
-
-	lbu	v1,(a0)
-	addu	a0,1
-	beqz	v1,9f
-	sb	v1,DATA(AT)
-	.set noreorder;	nop; nop; nop; nop; nop; nop; nop; nop; .set reorder
-	b	waitrdy
-9:	j	ra
-	.set at
-END(_dbgmsg)
-
-LEAF(_dbghex)
-	li	a1,PHYS_TO_K1(NS16550_CHANB)
-	li	t0,8
-1:
-	lbu	t1,LSR(a1)
-	.set noreorder;	nop; nop; nop; nop; nop; nop; nop; nop; .set reorder
-	and	t1,LSR_TXRDY
-	beqz	t1,1b
-
-	srl	t1,a0,28
-	addu	t1,'0'
-	ble	t1,'9',2f
-	addu	t1,'a'-'0'-10
-2:	sb	t1,DATA(a1)
-	.set noreorder;	nop; nop; nop; nop; nop; nop; nop; nop; .set reorder
-
-	sll	a0,4
-	sub	t0,1
-	bnez	t0,1b
-
-	j	ra
-	.set at
-END(_dbghex)
-
-	.rdata
-initb_str:
-	.byte	9,0x40	/* Reset CH B */
-	.byte	1,0x00	/* Interrupt disabled */
-	.byte	3,0xc1	/* 8 bits/char rx enable */
-	.byte	4,0x44	/* x16 clk mode 1 stop bit */
-	.byte	5,0x6a	/* tx 8/bit RTS & tx enable */
-	.byte	9,0x0a	/* MIE Master int enab. and NV No Vector */
-	.byte	11,0x50	/* Select BR gen. out for both rx and ts */
-	.byte	0,0x10
-	.byte	0,0x10
-	.byte	14,0x01	/* enable baud rate gen. */
-	.byte	15,0x00	/* known state for reg 15 */
-
-	.byte	14,0x00	/* disable baud rate gen. */
-	.byte	12,0x0a /* 0x0a	= 9600 baud time const. - lower 8 bits */
-	.byte	13,0x00	/* 9600 buad time const. - upper 8 bits */
-	.byte	14,0x01	/* enable baud rate gen. */
-	.byte	0xff
-
-	.text
-
-SLEAF(_dbginit)
-        /*
-        li	v0,PHYS_TO_K1(NS16550_CHANB)
-	la	a0,initb_str
-	or	a0,K1BASE
-1:	lbu	t0,0(a0)
-	beq	t0,0xff,1f
-	sb	t0,LSR(v0)
-	.set noreorder;	nop; nop; nop; nop; nop; nop; nop; nop; .set reorder
-	addu	a0,1
-	b	1b
-        */
-        jal     init_ns16550_chan_b # Debug channel
-	j	ra
-SEND(_dbginit)
-#else
-#define DBG(s)
-#endif
-
-LEAF(sbdreset)
-	move	rasave,ra
-
-	/* if launched by ITROM, leave Config alone */
-#ifndef ITBASE
-	/* set config register for 32b/32b cachelines, kseg0 cacheable */
-	mfc0	t1,C0_CONFIG
-	and	t1,~0x3f		# set bits 5..0 only
-	or	t1,CFG_IB | CFG_DB | CFG_C_NONCOHERENT
-	mtc0	t1,C0_CONFIG
-#endif
-
-       /* Initialize stack pointer to 6MB address */
-         li sp,0xa0600000
-
-
-        /*
-	 * slight amount of kludgery here to stop RAM resident
-	 * program from overwriting itself...
-	 */
-//	li	v1,0x1fc00000		/* check return address is in ROM */
-//	and	v0,ra,v1
-//	bne	v0,v1,.noinit
-
-        /* table driven hardware register initialization */
-        la      a0, reginittab
-        or      a0, K1BASE              /* force to kseg1 */
-
-1:      lw      v0,0(a0)
-        lw      v1,4(a0)
-        addu    a0,8
-        beqz    v0,8f
-
-        sw      v1,0(v0)
-        b       1b
-8:
-
-#ifdef DBGSBD
-	jal     init_ns16550_chan_b   # was - _dbginit
-	DBG("sbdreset\r\n")
-#endif
-#define DEVICE_BANK0PARAMETERS                                                          0x45C
-#define DEVICE_BANK1PARAMETERS                                                          0x460
-#define DEVICE_BANK2PARAMETERS                                                          0x464
-#define DEVICE_BANK3PARAMETERS                                                          0x468
-#define DEVICE_BOOT_BANK_PARAMETERS                                                     0x46C
-#define GT_INTERNAL_REG_BASE 0xb4000000
-
-        li      p64011, PA_TO_KVA1(GT64011_BASE)
-
-        li  v0,0xb400046c       /* Boot Device */
-        lw  t0,0(v0)
-        and t0,0x00003000       /* Keep the correct boot size */
-	or  t0,htoll(0x3847de70)
-	sw  t0,0(v0)
-
-        li  v0,0xb4000468       /* CS3 Device - 16 bit FLASH memory */
-        li  t0,htoll(0x3859e6e8)
-	sw  t0,0(v0)
-
-
-        li  v0,0xb4000c84       /* PCI 1 timeout register */
-        li  t0,htoll(0xffff)
-	sw  t0,0(v0)
-
-
-        li  v0,0xb4000c3c       /* Enable I/O response on PCI0 */
-        li  t0,htoll(0x7)
-	sw  t0,0(v0)
-
-        li  v0,0xb4000cbc       /* Enable I/O response on PCI1 */
-        li  t0,htoll(0x7)
-	sw  t0,0(v0)
-
-        /* GT-64120 Initialization */
-
-        li      p64011, PA_TO_KVA1(GT64011_BASE)
-
-        /*********************************************************************/
-        /************************* SDRAM initializing ************************/
-        /******************************* START *******************************/
-
-
-                                        /* SDRAM banks 0,1,2,3 parameters               */
-        li      t0,htoll(0x01908200)    /* - Standard Monitor: Interleave enabled       */
-        li      v0,0xb4000448           /* - Registered SDRAM (Bit 23)                  */
-        sw      t0,0(v0)                /* - Duplicate Dadr11,BankSel1 and Dadr12       */
-                                        /* - Cas latency: 2 Cycles                      */
-                                        /* - Flow Through enable: One sample            */
-                                        /* - SRAS - precharge time: 3 Cycles            */
-                                        /* - No ECC                                     */
-                                        /* - No ByPass                                  */
-                                        /* - Burst length: 8                            */
-
-        /* Detect whether we have a 16,64,128 or 256 Mbit SDRAM on DIMM0 */
-        /* Set bank0`s range to: 0 - 0x10000000 (256 MByte)     */
-_DIMM0:
-        li  v0,0xb4000008
-	li  t0,htoll(0x0)
-	sw  t0,0(v0)
-
-        li  v0,0xb4000010
-	li  t0,htoll(0x7f)
-	sw  t0,0(v0)
-
-        /* Close banks 2 and 3 */
-        li  v0,0xb4000018
-	li  t0,htoll(0x7ff)
-	sw  t0,0(v0)
-        li  v0,0xb4000020
-	li  t0,htoll(0x00)
-	sw  t0,0(v0)
-
-        /* Extend bank0 to 0x10000000 and Close bank1,2 and 3 */
-        DBG("Extend bank0 to 0x10000000 and Close bank1,2 and 3...\r\n")
-        li  v0,0xb4000400
-	li  t0,htoll(0x0)
-	sw  t0,0(v0)
-        li  v0,0xb4000404
-	li  t0,htoll(0xff)
-	sw  t0,0(v0)
-        li  v0,0xb4000408
-	li  t0,htoll(0xff)
-	sw  t0,0(v0)
-        li  v0,0xb400040c
-	li  t0,htoll(0x00)
-	sw  t0,0(v0)
-        li  v0,0xb4000410
-	li  t0,htoll(0xff)
-	sw  t0,0(v0)
-        li  v0,0xb4000414
-	li  t0,htoll(0x00)
-	sw  t0,0(v0)
-        li  v0,0xb4000418
-	li  t0,htoll(0xff)
-	sw  t0,0(v0)
-        li  v0,0xb400041c
-	li  t0,htoll(0x00)
-	sw  t0,0(v0)
-
-        /* Configure bank0 to 256 Mbit */
-        DBG("Configure bank0 to 256 Mbit...\r\n")
-        li  v0,0xb400044c
-	li  t0,htoll(0x00004c69)
-        sw  t0,0(v0)
-
-        /* Config the SDRAM banks decode system */
-	li  v0,0xb400047c
-	li  t0,htoll(2)
-	sw  t0,0(v0)
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x3)
-	sw  t0,0(v0)
-
-        li  v0,0xa0000000
-        li  t0,0
-        sw  t0,0(v0)
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x0)
-	sw  t0,0(v0)
-
-        /* Write to address 0x2000000 and check if 0x00000000 is being written too */
-        DBG("Write to address 0x2000000 and check if 0x00000000 is being written too...\r\n")
-        li  v0,0xa0000000
-        li  t1,0xa0000010
-        li  t0,htoll(0x0)
-1:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,1b
-
-        /* The address should activate Dadr12 */
-        li  v0,0xa2000000
-	li  t0,0x11111111
-        sw  t0,0(v0)
-        li  v0,0xa0000010
-        li  t1,0xa0000100
-        li  t0,0x22222222
-2:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,2b
-
-        DBG("Check address 0x00000000 for duplications...\r\n")
-        li    t0,0xa0000000
-        li    v0,0x11111111
-        lw    t0,(t0)
-        bne   t0,v0,_256MBIT
-
-        /* Write to address 0x1000 and check if 0x00000000 is being written too */
-        DBG("Write to address 0x1000 and check if 0x00000000 is being written too...\r\n")
-        li  v0,0xa0000000
-        li  t1,0xa0000010
-        li  t0,htoll(0x0)
-1:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,1b
-
-        /* The address should activate bank select1*/
-        li  v0,0xa0001000
-	li  t0,0x11111111
-        sw  t0,0(v0)
-        li  v0,0xa0000010
-        li  t1,0xa0000100
-        li  t0,0x22222222
-2:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,2b
-
-        DBG("Check address 0x00000000 for duplications...\r\n")
-        li    t0,0xa0000000
-        li    v0,0x11111111
-        lw    t0,(t0)
-        beq   t0,v0,_16MBIT
-
-        /* Write to address 0x8000000 and check if 0x00000000 is being written too */
-        DBG("Write to address 0x8000000 and check if 0x00000000 is being written too...\r\n")
-        li  v0,0xa0000000
-        li  t1,0xa0000010
-        li  t0,htoll(0x0)
-1:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,1b
-
-        /* The address should activate Dadr9 which on the column cycle is in active with 64 Mbit
-           device */
-        li  v0,0xa8000000
-	li  t0,0x11111111
-        sw  t0,0(v0)
-        li  v0,0xa0000010
-        li  t1,0xa0000100
-        li  t0,0x22222222
-2:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,2b
-
-        DBG("Check address 0x00000000 for duplications...\r\n")
-        li    t0,0xa0000000
-        li    v0,0x11111111
-        lw    t0,(t0)
-        beq   t0,v0,_64MBIT
-        b     _128MBIT
-
-_16MBIT:
-        DBG("16 Mbit SDRAM detected...\r\n")
-        /* In 16 Mbit SDRAM we must use 2 way bank interleaving!!! */
-        li  v0,0xb4000810
-	li  t0,htoll(16)
-	sw  t0,0(v0)
-        li  t1,htoll(0x00000449)
-        b   _DIMM1
-
-_64MBIT:
-        DBG("64 Mbit SDRAM detected...\r\n")
-        /* In 64 Mbit SDRAM we must use 4 way bank interleaving!!! */
-        li  v0,0xb4000810
-	li  t0,htoll(64)
-	sw  t0,0(v0)
-        li  t1,htoll(0x00000c69)
-        b   _DIMM1
-
-_128MBIT:
-        DBG("128 Mbit SDRAM detected...\r\n")
-        /* In 128 Mbit SDRAM we must use 4 way bank interleaving!!! */
-        li  v0,0xb4000810
-	li  t0,htoll(128)
-	sw  t0,0(v0)
-        li  t1,htoll(0x00000c69)
-        b   _DIMM1
-
-_256MBIT:
-        DBG("256 Mbit SDRAM detected...\r\n")
-        /* In 256 Mbit SDRAM we must use 4 way bank interleaving!!! */
-        li  v0,0xb4000810
-	li  t0,htoll(256)
-	sw  t0,0(v0)
-        li  t1,htoll(0x00004c69)
-        b   _DIMM1
-
-_DIMM1:
-        li  v0,0xb400044c
-        sw  t1,0(v0)  # Bank0
-        sw  t1,4(v0)  # Bank1
-
-        /* Detect whether we have a 16,64,128 or 256 Mbit SDRAM on DIMM1 */
-        /* Close banks 0 and 1 */
-        li  v0,0xb4000008
-	li  t0,htoll(0xff)
-	sw  t0,0(v0)
-
-        li  v0,0xb4000010
-	li  t0,htoll(0x0)
-	sw  t0,0(v0)
-
-        /* Set bank2`s range to: 0 - 0x10000000 (256 MByte)     */
-        li  v0,0xb4000018
-	li  t0,htoll(0x0)
-	sw  t0,0(v0)
-        li  v0,0xb4000020
-	li  t0,htoll(0x7f)
-	sw  t0,0(v0)
-
-        /* Extend bank2 to 0x10000000 and Close bank0,1 and 3 */
-        DBG("Extend bank2 to 0x10000000 and Close banks 0,1 and 3...\r\n")
-        li  v0,0xb4000400
-	li  t0,htoll(0xff)
-	sw  t0,0(v0)
-        li  v0,0xb4000404
-	li  t0,htoll(0x00)
-	sw  t0,0(v0)
-        li  v0,0xb4000408
-	li  t0,htoll(0xff)
-	sw  t0,0(v0)
-        li  v0,0xb400040c
-	li  t0,htoll(0x00)
-	sw  t0,0(v0)
-        li  v0,0xb4000410
-	li  t0,htoll(0x00)
-	sw  t0,0(v0)
-        li  v0,0xb4000414
-	li  t0,htoll(0xff)
-	sw  t0,0(v0)
-        li  v0,0xb4000418
-	li  t0,htoll(0xff)
-	sw  t0,0(v0)
-        li  v0,0xb400041c
-	li  t0,htoll(0x00)
-	sw  t0,0(v0)
-
-        /* Configure bank2 to 256 Mbit */
-        DBG("Configure bank2 to 256 Mbit...\r\n")
-        li  v0,0xb4000454
-	li  t0,htoll(0x00004c69)
-        sw  t0,0(v0)
-
-        /* Config the SDRAM banks decode system */
-	li  v0,0xb400047c
-	li  t0,htoll(2)
-	sw  t0,0(v0)
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x3)
-	sw  t0,0(v0)
-
-        li  v0,0xa0000000
-        li  t0,0
-        sw  t0,0(v0)
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x0)
-	sw  t0,0(v0)
-
-        /* Write to address 0x2000000 and check if 0x00000000 is being written too */
-        DBG("Write to address 0x2000000 and check if 0x00000000 is being written too...\r\n")
-        li  v0,0xa0000000
-        li  t1,0xa0000010
-        li  t0,htoll(0x0)
-1:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,1b
-
-        /* The address should activate Dadr12 */
-        li  v0,0xa2000000
-	li  t0,0x11111111
-        sw  t0,0(v0)
-        li  v0,0xa0000010
-        li  t1,0xa0000100
-        li  t0,0x22222222
-2:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,2b
-
-        DBG("Check address 0x00000000 for duplications...\r\n")
-        li    t0,0xa0000000
-        li    v0,0x11111111
-        lw    t0,(t0)
-        bne   t0,v0,_256MBIT2
-
-        /* Write to address 0x1000 and check if 0x00000000 is being written too */
-        DBG("Write to address 0x1000 and check if 0x00000000 is being written too...\r\n")
-        li  v0,0xa0000000
-        li  t1,0xa0000010
-        li  t0,htoll(0x0)
-1:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,1b
-
-        /* The address should activate bank select1*/
-        li  v0,0xa0001000
-	li  t0,0x11111111
-        sw  t0,0(v0)
-        li  v0,0xa0000010
-        li  t1,0xa0000100
-        li  t0,0x22222222
-2:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,2b
-
-        DBG("Check address 0x00000000 for duplications...\r\n")
-        li    t0,0xa0000000
-        li    v0,0x11111111
-        lw    t0,(t0)
-        beq   t0,v0,_16MBIT2
-
-        /* Write to address 0x8000000 and check if 0x00000000 is being written too */
-        DBG("Write to address 0x8000000 and check if 0x00000000 is being written too...\r\n")
-        li  v0,0xa0000000
-        li  t1,0xa0000010
-        li  t0,htoll(0x0)
-1:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,1b
-
-        /* The address should activate Dadr9 which on the column cycle is in active with 64 Mbit
-           device */
-        li  v0,0xa8000000
-	li  t0,0x11111111
-        sw  t0,0(v0)
-        li  v0,0xa0000010
-        li  t1,0xa0000100
-        li  t0,0x22222222
-2:      sw  t0,0(v0)
-        addu v0,4
-        bne t1,v0,2b
-
-        DBG("Check address 0x00000000 for duplications...\r\n")
-        li    t0,0xa0000000
-        li    v0,0x11111111
-        lw    t0,(t0)
-        beq   t0,v0,_64MBIT2
-        b     _128MBIT2
-
-_16MBIT2:
-        DBG("16 Mbit SDRAM detected...\r\n")
-        /* In 16 Mbit SDRAM we must use 2 way bank interleaving!!! */
-        li  v0,0xb4000814
-	li  t0,htoll(16)
-	sw  t0,0(v0)
-        li  t1,htoll(0x00000449)
-        b   _INIT_SDRAM
-
-_64MBIT2:
-        DBG("64 Mbit SDRAM detected...\r\n")
-        /* In 64 Mbit SDRAM we must use 4 way bank interleaving!!! */
-        li  v0,0xb4000814
-	li  t0,htoll(64)
-	sw  t0,0(v0)
-        li  t1,htoll(0x00000c69)
-        b   _INIT_SDRAM
-
-_128MBIT2:
-        DBG("128 Mbit SDRAM detected...\r\n")
-        /* In 128 Mbit SDRAM we must use 4 way bank interleaving!!! */
-        li  v0,0xb4000814
-	li  t0,htoll(128)
-	sw  t0,0(v0)
-        li  t1,htoll(0x00000c69)
-        b   _INIT_SDRAM
-
-_256MBIT2:
-        DBG("256 Mbit SDRAM detected...\r\n")
-        /* In 256 Mbit SDRAM we must use 4 way bank interleaving!!! */
-        li  v0,0xb4000814
-	li  t0,htoll(256)
-	sw  t0,0(v0)
-        li  t1,htoll(0x00004c69)
-        b   _INIT_SDRAM
-
-_INIT_SDRAM:
-        /* Restore defaults */
-        DBG("Restoring defaults...\r\n")
-        li  v0,0xb4000404
-	li  t0,htoll(0x07)
-	sw  t0,0(v0)
-        li  v0,0xb4000408
-	li  t0,htoll(0x08)
-	sw  t0,0(v0)
-        li  v0,0xb400040c
-	li  t0,htoll(0x0f)
-	sw  t0,0(v0)
-        li  v0,0xb4000410
-	li  t0,htoll(0x10)
-	sw  t0,0(v0)
-        li  v0,0xb4000414
-	li  t0,htoll(0x17)
-	sw  t0,0(v0)
-        li  v0,0xb4000418
-	li  t0,htoll(0x18)
-	sw  t0,0(v0)
-        li  v0,0xb400041c
-	li  t0,htoll(0x1f)
-	sw  t0,0(v0)
-        li  v0,0xb4000010
-	li  t0,htoll(0x07)
-	sw  t0,0(v0)
-        li  v0,0xb4000018
-	li  t0,htoll(0x008)
-	sw  t0,0(v0)
-        li  v0,0xb4000020
-	li  t0,htoll(0x0f)
-	sw  t0,0(v0)
-
-        li  v0,0xb400044c
-        sw  t1,8(v0)  # Bank2
-        sw  t1,12(v0) # Bank3
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x3)
-	sw  t0,0(v0)
-
-        li  v0,0xa0000000
-        li  t0,0
-        sw  t0,0(v0)
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x0)
-	sw  t0,0(v0)
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x3)
-	sw  t0,0(v0)
-
-        li  v0,0xa0800000
-        li  t0,0
-        sw  t0,0(v0)
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x0)
-	sw  t0,0(v0)
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x3)
-	sw  t0,0(v0)
-
-        li  v0,0xa1000000
-        li  t0,0
-        sw  t0,0(v0)
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x0)
-	sw  t0,0(v0)
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x3)
-	sw  t0,0(v0)
-
-        li  v0,0xa1800000
-        li  t0,0
-        sw  t0,0(v0)
-
-        li  v0,0xb4000474
-	li  t0,htoll(0x0)
-	sw  t0,0(v0)
-
-        /*********************************************************************/
-        /************************* SDRAM initializing ************************/
-        /******************************* END *********************************/
-
-        li      p64011, PA_TO_KVA1(GT64011_BASE)
-
-        li      t0,htoll(0x00000000)    /* RAS[1:0] low decode address */
-        sw      t0,0x008(p64011)
-
-        li      t0,htoll(0x00000007)    /* RAS[1:0] high decode address */
-        sw      t0,0x010(p64011)
-
-        li      t0,htoll(0x00000000)    /* RAS[0] Low decode address */
-        sw      t0,0x400(p64011)
-
-        li      t0,htoll(0x0000000f)    /* RAS[0] High decode address */
-        sw      t0,0x404(p64011)
-
-        li      t0,htoll(0x00000008)    /* RAS[3:2] low decode address */
-        sw      t0,0x018(p64011)
-
-        li      t0,htoll(0x0000000f)    /* RAS[3:2] high decode address */
-        sw      t0,0x020(p64011)
-
-        li      t0,htoll(0x0000000f)    /* RAS[1] Low Decode Address */
-        sw      t0,0x408(p64011)
-
-        li      t0,htoll(0x00000008)    /* RAS[1] High Decode Address */
-        sw      t0,0x40c(p64011)
-
-        li      t0,htoll(0x00000010)    /* RAS[2] Low Decode Address */
-        sw      t0,0x410(p64011)
-
-        li      t0,htoll(0x00000017)    /* RAS[2] High Decode Address */
-        sw      t0,0x414(p64011)
-
-        li      t0,htoll(0x00000018)    /* RAS[3] Low Decode Address */
-        sw      t0,0x418(p64011)
-
-        li      t0,htoll(0x0000001f)    /* RAS[3] High Decode Address <<<<<< 1*/
-        sw      t0,0x41c(p64011)
-
-#ifdef DBGSBD
-#define DREG(str,rname) \
-	DBG(str); \
-	DBG(":\t") ;			\
-	lw	a0,rname(p64011) ;	\
-	HTOLL(a0,t0) ;			\
-	jal	_dbghex ;		\
-	DBG("\r\n")
-
-	DBG("GT-64120 settings:\r\n")
-        DREG("DRAMPAR_BANK0   (44c)",GT_DRAMPAR_BANK0)
-        DREG("DRAMPAR_BANK1   (450)",GT_DRAMPAR_BANK1)
-        DREG("DRAMPAR_BANK2   (454)",GT_DRAMPAR_BANK2)
-        DREG("DRAMPAR_BANK3   (458)",GT_DRAMPAR_BANK3)
-        DREG("PAS_RAS10LO     (008)",GT_PAS_RAS10LO)
-        DREG("PAS_RAS10HI     (010)",GT_PAS_RAS10HI)
-        DREG("PAS_RAS32LO     (018)",GT_PAS_RAS32LO)
-        DREG("PAS_RAS32HI     (020)",GT_PAS_RAS32HI)
-        DREG("DDAS_RAS0LO     (400)",GT_DDAS_RAS0LO)
-        DREG("DDAS_RAS0HI     (404)",GT_DDAS_RAS0HI)
-        DREG("DDAS_RAS1LO     (408)",GT_DDAS_RAS1LO)
-        DREG("DDAS_RAS1HI     (40c)",GT_DDAS_RAS1HI)
-        DREG("DDAS_RAS2LO     (410)",GT_DDAS_RAS2LO)
-        DREG("DDAS_RAS2HI     (414)",GT_DDAS_RAS2HI)
-        DREG("DDAS_RAS3LO     (418)",GT_DDAS_RAS3LO)
-        DREG("DDAS_RAS3HI     (41c)",GT_DDAS_RAS3HI)
-        DREG("GT_DRAM_CFG     (448)",GT_DRAM_CFG)
-        DREG("GT_DEVPAR_BANK0 (45c)",GT_DEVPAR_BANK0)
-        DREG("GT_DEVPAR_BANK1 (460)",GT_DEVPAR_BANK1)
-        DREG("GT_DEVPAR_BANK2 (464)",GT_DEVPAR_BANK2)
-        DREG("GT_DEVPAR_BANK3 (468)",GT_DEVPAR_BANK3)
-        DREG("GT_IPCI_TOR     (c04)",GT_IPCI_TOR)
-#endif
-
-	/* we can now initialise the caches for a fast clear_mem */
-	SBD_DISPLAY ('C','A','C','H',CHKPNT_CACH)
-	DBG("init_cache\r\n")
-//	jal	mips_init_cache
-
-.noinit:
-
-	/* initialise tlb */
-	SBD_DISPLAY ('I','T','L','B', CHKPNT_ITLB)
-	DBG("init_tlb\r\n")
-//	bal	init_tlb
-
-//	DBG("sbdreset completed\r\n")
-//	move	ra,rasave
-        j       GetExtendedMemorySize
-        nop
-
-END(sbdreset)
-
-LEAF(_sbd_memfail)
-	SBD_DISPLAY ('!','M','E','M',CHKPNT_0MEM)
-1:	b	1b
-	j	ra
-END(_sbd_memfail)
-
-	.rdata
-RefreshBits:
-	.word	htoll(GT_DRAMPAR_Refresh512)
-	.word	htoll(GT_DRAMPAR_Refresh1024)
-	.word	htoll(GT_DRAMPAR_Refresh2048)
-	.word	htoll(GT_DRAMPAR_Refresh4096)
-	.text
-
-/* DRAM: */
-#define GT_DRAM_CFG_INIT \
-        GT_DRAM_CFG_RefIntCnt(160) | \
-        GT_DRAM_CFG_StagRefOn | \
-        GT_DRAM_CFG_ADSFunctDRAM | \
-        GT_DRAM_CFG_DRAMLatchActive
-
-/* serial port:  widest timings even 8 bit bus, latch enabled no parity */
-#define GT_DEVPAR_SERIALINIT \
-        GT_DEVPAR_TurnOff(7) | \
-        GT_DEVPAR_AccToFirst(15) | \
-        GT_DEVPAR_AccToNext(15) | \
-        GT_DEVPAR_ADStoWr(7) | \
-        GT_DEVPAR_WrActive(7) | \
-        GT_DEVPAR_WrHigh(7) | \
-        GT_DEVPAR_DevWidth8 | \
-        GT_DEVPAR_DevLocEven | \
-        GT_DEVPAR_LatchFunctTransparent | \
-        GT_DEVPAR_ParityDisable | \
-        GT_DEVPAR_Reserved
-
-/* PCI: */
-#define GT_IPCI_TOR_INIT \
-        GT_IPCI_TOR_Timeout0(255) | \
-        GT_IPCI_TOR_Timeout1(255) | \
-        GT_IPCI_TOR_RetryCtr(0)
-
-#define INIT(addr,val) \
-        .word   addr, val
-#define GTINIT(addr,val) \
-        INIT(PHYS_TO_K1(GT64011_BASE+(addr)), htoll(val))
-
-        .rdata
-reginittab:
-
-        /* disable ras1:0 and ras3:2 decodes */
-        GTINIT(GT_PAS_RAS10LO,  GT_PAS_LOMASK_Low);
-        GTINIT(GT_PAS_RAS10HI,  0);
-        GTINIT(GT_PAS_RAS32LO,  GT_PAS_LOMASK_Low);
-        GTINIT(GT_PAS_RAS32HI,  0);
-
-        /* disable RAS[0123] */
-        GTINIT(GT_DDAS_RAS0LO,  GT_DDAS_LOMASK_Low)
-        GTINIT(GT_DDAS_RAS0HI,  0);
-        GTINIT(GT_DDAS_RAS1LO,  GT_DDAS_LOMASK_Low)
-        GTINIT(GT_DDAS_RAS1HI,  0);
-        GTINIT(GT_DDAS_RAS2LO,  GT_DDAS_LOMASK_Low)
-        GTINIT(GT_DDAS_RAS2HI,  0);
-        GTINIT(GT_DDAS_RAS3LO,  GT_DDAS_LOMASK_Low)
-        GTINIT(GT_DDAS_RAS3HI,  0);
-
-        /* 0x45c, 0x460, 0x464, 0x468 */
-	/*GTINIT(GT_DEVPAR_BANK0, GT_DEVPAR_SERIALINIT)*/
-        GTINIT(GT_DEVPAR_BANK0, 0x3847de60)
-        GTINIT(GT_DEVPAR_BANK1, 0x146fffff)
-        GTINIT(GT_DEVPAR_BANK2, 0x144fffff)
-        GTINIT(GT_DEVPAR_BANK3, 0x167fffff)
-
-        GTINIT(GT_IPCI_TOR,     GT_IPCI_TOR_INIT)
-        INIT(0,0)
-        .text
-
-        .globl sbddelay
-
-LEAF(sbdberrenb)
-	mfc0	v0,C0_SR
-	li	t0,SR_DE
-	bnez	a0,1f
-	or	t1,v0,t0	# disable cache/parity errors (SR_DE = 1)
-	b	2f
-1:	not	t1,t0		# enable cache/parity errors (SR_DE = 0)
-	and	t1,v0
-2:	mtc0	t1,C0_SR
-	and	v0,t0		# get old SR_DE bit
-	xor	v0,t0		# and invert to make it an enable bit
-	j	ra
-END(sbdberrenb)
-
-
-LEAF(sbdberrcnt)
-	move	v0,zero
-	j	ra
-END(sbdberrcnt)
-
-	.lcomm	wbfltmp,4
-
-LEAF(wbflush)
-//XLEAF(mips_wbflush)
-	sync
-	la	t0,wbfltmp
-	or	t0,K1BASE
-	lw	zero,0(t0)
-	j	ra
-END(wbflush)
-
-
-LEAF(sbddelay)
-	li	t1,CACHEUS
-	and	t0,ra,0x20000000
-	beqz	t0,1f
-	li	t1,ROMUS
-1:	mul	a0,t1
-	subu	a0,15		# approx number of loops so far
-
-	.set	noreorder
-	.set	nomacro
-	nop
-2:	bgtz	a0,2b
-	subu	a0,1
-	.set	macro
-	.set	reorder
-
-	j	ra
-END(sbddelay)
-
-#include "meminit.S"
-
-
-LEAF(mips_cycle)
-	.set	noreorder
-	.set	nomacro
-1:	bgtz	a0,1b
-	subu	a0,1
-	.set	macro
-	.set	reorder
-	j	ra
-END(mips_cycle)
-
-LEAF(init_ns16550_chan_b)
-	# enable 16550 fifo if it is there
-        li      a0,NS16550_CHANB
-        li	t0,FIFO_ENABLE|FIFO_RCV_RST|FIFO_XMT_RST|FIFO_TRIGGER_4
-	sb	t0,FIFO(a0)
-
-	/* convert baud rate in a1 into register value */
-        li	t2,NS16550_HZ/(16*115200)	# brtc = CLK/16/speed
-
-	li	t0,CFCR_DLAB			# select brtc divisor
-	sb	t0,CFCR(a0)
-	sb	t2,DATA(a0)			# store divisor lsb
-	srl	t2,8
-	sb	t2,IER(a0)			# store divisor msb
-
-	li	t0,CFCR_8BITS			# set 8N1 mode
-	sb	t0,CFCR(a0)
-
-	li	t0,MCR_DTR|MCR_RTS # Galileo |MCR_IENABLE	# enable DTR & RTS
-  	sb	t0,MCR(a0)
- 	li	t0,0 # Galileo IER_ERXRDY			# enable receive interrupt(!)
-	sb	t0,IER(a0)
-
-	move	v0,zero				# indicate success
-	j	ra
-
-END(init_ns16550_chan_b)
-
-LEAF(init_ns16550_chan_a)
-	# enable 16550 fifo if it is there
-        li      a0,NS16550_CHANA
-        li	t0,FIFO_ENABLE|FIFO_RCV_RST|FIFO_XMT_RST|FIFO_TRIGGER_4
-	sb	t0,FIFO(a0)
-
-	/* convert baud rate in a1 into register value */
-        li	t2,NS16550_HZ/(16*9600)		# brtc = CLK/16/speed
-
-	li	t0,CFCR_DLAB			# select brtc divisor
-	sb	t0,CFCR(a0)
-	sb	t2,DATA(a0)			# store divisor lsb
-	srl	t2,8
-	sb	t2,IER(a0)			# store divisor msb
-
-	li	t0,CFCR_8BITS			# set 8N1 mode
-	sb	t0,CFCR(a0)
-
-	li	t0,MCR_DTR|MCR_RTS # Galileo |MCR_IENABLE	# enable DTR & RTS
-  	sb	t0,MCR(a0)
- 	li	t0,0 # Galileo IER_ERXRDY			# enable receive interrupt(!)
-	sb	t0,IER(a0)
-
-	move	v0,zero				# indicate success
-	j	ra
-
-END(init_ns16550_chan_a)
-
-#endif /* EVB64120A */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/xfer.c linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/xfer.c
--- linux-2.4.22.clean/arch/mips/galileo-boards/ev64120/compressed/xfer.c	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.22/arch/mips/galileo-boards/ev64120/compressed/xfer.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,114 +0,0 @@
-/*
- *  arch/mips/galileo/compressed/xfer.c
- *
- *  By RidgeRun Inc,
- *
- *  Xfer an image from flash to ram.
- *  For use with Galileo EVB64120A MIPS eval board.
- */
-
-#include "linux/serial_reg.h"
-
-#define port 0xbd000000
-#define inb(addr) (*(volatile unsigned char *) ((unsigned long)(addr)))
-#define outb(b,addr) (*(volatile unsigned char *) ((unsigned long)(addr)) = (b))
-
-#ifdef RUNNINGFROMFLASH
-// This is where our image of interest is mapped to
-// when the jumbers are set for booting out of flash.
-// (flash part starts at address 0xbfC00000)
-#define srcAddr 0xbfC20000
-#else
-// This is where our image of interest is mapped to
-// when the jumbers are set for booting out of eprom.
-// (flash part starts at address 0xbf000000)
-#define srcAddr 0xbf020000
-#endif
-
-static int PortAddress(unsigned int channel, unsigned char reg);
-static void inline cons_hook(void);
-static void print_message(const char *string);
-
-/******************************
- Routine:
- Description:
- ******************************/
-void XferToRam(void)
-{
-	unsigned int temp;
-	void (*entry_point) (void);
-
-	cons_hook();
-
-	print_message("Copying image from Flash to Ram.\n");
-	for (temp = 0; temp < (0x100000 - 0x20000); temp = temp + 4) {
-		*(volatile unsigned int *) (temp + 0xa0400000) =
-		    *(volatile unsigned int *) (temp + srcAddr);
-		if (*(volatile unsigned int *) (temp + 0xa0400000) !=
-		    *(volatile unsigned int *) (temp + srcAddr)) {
-			print_message
-			    ("Error!: copy verification failed.\n");
-			break;
-		}
-	}
-
-	print_message("Now jumping to the code just xferred to ram.\n");
-	entry_point = (void *) 0x80400000;
-	entry_point();
-}
-
-/******************************
- Routine:
- Description:
- ******************************/
-static int PortAddress(unsigned int channel, unsigned char reg)
-{
-	unsigned int channelOffset = 0x20;
-	unsigned int regDelta = 4;
-	return (port + (channel * channelOffset) + (reg * regDelta));
-}
-
-/******************************
- Routine:
- Description:
- ******************************/
-static void cons_hook(void)
-{
-	register int comstat;
-	unsigned temp;
-	unsigned int channel = 1;	// Channel 1 is the main serial
-	// connector of the EVB64120A. Channel 0
-	// is the secondary serial port (typically
-	// the unsoldered connector of the board).
-
-	temp = *(unsigned int *) 0xb4000464;
-	*(unsigned int *) 0xb4000464 = 0xffff4f14;
-
-	// Set Baud Rate, baud=115K
-	outb(0x83, PortAddress(channel, UART_LCR));
-	outb(0x00, PortAddress(channel, UART_DLM));
-	outb(0x02, PortAddress(channel, UART_DLL));
-	outb(0x03, PortAddress(channel, UART_LCR));
-
-	comstat = inb(PortAddress(channel, UART_LSR));
-	comstat = inb(PortAddress(channel, UART_RX));
-	outb(0x00, PortAddress(channel, UART_IER));
-}
-
-/******************************
- Routine:
- Description:
- ******************************/
-static void print_message(const char *string)
-{
-	register int count, loop;
-	/* Display Opening Message */
-	for (count = 0; string[count]; count++) {
-		if (string[count] == '\n') {
-			*(char *) 0xbd000020 = '\r';
-		}
-		*(char *) 0xbd000020 = string[count];
-		for (loop = 0; loop < 2000; loop++) {
-		}
-	}
-}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/ite-boards/generic/time.c linux-2.4.22/arch/mips/ite-boards/generic/time.c
--- linux-2.4.22.clean/arch/mips/ite-boards/generic/time.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/ite-boards/generic/time.c	2003-09-27 14:07:04.000000000 +0200
@@ -114,7 +114,7 @@
 
 static unsigned long r4k_offset; /* Amount to increment compare reg each time */
 static unsigned long r4k_cur;    /* What counter should be at next timer irq */
-extern unsigned int mips_counter_frequency;
+extern unsigned int mips_hpt_frequency;
 
 /*
  * Figure out the r4k offset, the amount to increment the compare
@@ -138,12 +138,12 @@
 	while (CMOS_READ(RTC_REG_A) & RTC_UIP);
 	while (!(CMOS_READ(RTC_REG_A) & RTC_UIP));
 
-	mips_counter_frequency = read_c0_count();
+	mips_hpt_frequency = read_c0_count();
 
 	/* restore interrupts */
 	local_irq_restore(flags);
 
-	return (mips_counter_frequency / HZ);
+	return (mips_hpt_frequency / HZ);
 }
 
 static unsigned long 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/kernel/ipc.c linux-2.4.22/arch/mips/kernel/ipc.c
--- linux-2.4.22.clean/arch/mips/kernel/ipc.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/kernel/ipc.c	2003-09-27 14:07:04.000000000 +0200
@@ -32,7 +32,11 @@
 
 	switch (call) {
 	case SEMOP:
-		return sys_semop (first, (struct sembuf *)ptr, second);
+		return sys_semtimedop (first, (struct sembuf *)ptr, second,
+		                       NULL);
+	case SEMTIMEDOP:
+		return sys_semtimedop (first, (struct sembuf *)ptr, second,
+		                       (const struct timespec *)fifth);
 	case SEMGET:
 		return sys_semget (first, second, third);
 	case SEMCTL: {
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/kernel/proc.c linux-2.4.22/arch/mips/kernel/proc.c
--- linux-2.4.22.clean/arch/mips/kernel/proc.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/kernel/proc.c	2003-09-21 03:07:51.000000000 +0200
@@ -101,6 +101,11 @@
 	seq_printf(m, "BogoMIPS\t\t: %lu.%02lu\n",
 	              loops_per_jiffy / (500000/HZ),
 	              (loops_per_jiffy / (5000/HZ)) % 100);
+#ifdef __MIPSEB__
+	seq_printf(m, "byteorder\t\t: big endian\n");
+#else
+	seq_printf(m, "byteorder\t\t: little endian\n");
+#endif
 	seq_printf(m, "wait instruction\t: %s\n", cpu_wait ? "yes" : "no");
 	seq_printf(m, "microsecond timers\t: %s\n",
 	              cpu_has_counter ? "yes" : "no");
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/kernel/setup.c linux-2.4.22/arch/mips/kernel/setup.c
--- linux-2.4.22.clean/arch/mips/kernel/setup.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/kernel/setup.c	2003-09-21 03:07:34.000000000 +0200
@@ -231,6 +231,37 @@
 	}
 }
 
+static inline void parse_rd_cmdline(unsigned long* rd_start, unsigned long* rd_end)
+{
+	char c = ' ', *to = command_line, *from = saved_command_line;
+	int len = 0;
+	unsigned long rd_size = 0;
+
+	for (;;) {
+		/*
+		 * "rd_start=0xNNNNNNNN" defines the memory address of an initrd
+		 * "rd_size=0xNN" it's size
+		 */
+		if (c == ' ' && !memcmp(from, "rd_start=", 9)) {
+			if (to != command_line)
+				to--;
+			(*rd_start) = memparse(from + 9, &from);
+		}
+		if (c == ' ' && !memcmp(from, "rd_size=", 8)) {
+			if (to != command_line)
+				to--;
+			rd_size = memparse(from + 8, &from);
+		}
+		c = *(from++);
+		if (!c)
+			break;
+		if (CL_SIZE <= ++len)
+			break;
+		*(to++) = c;
+	}
+	*to = '\0';
+	(*rd_end) = (*rd_start) + rd_size;
+}
 
 #define PFN_UP(x)	(((x) + PAGE_SIZE - 1) >> PAGE_SHIFT)
 #define PFN_DOWN(x)	((x) >> PAGE_SHIFT)
@@ -241,31 +272,24 @@
 
 static inline void bootmem_init(void)
 {
-#ifdef CONFIG_BLK_DEV_INITRD
-	unsigned long tmp;
-	unsigned long *initrd_header;
-#endif
 	unsigned long bootmap_size;
 	unsigned long start_pfn, max_pfn, max_low_pfn, first_usable_pfn;
+	unsigned long end = &_end;
 	int i;
 
 #ifdef CONFIG_BLK_DEV_INITRD
-	tmp = (((unsigned long)&_end + PAGE_SIZE-1) & PAGE_MASK) - 8;
-	if (tmp < (unsigned long)&_end)
-		tmp += PAGE_SIZE;
-	initrd_header = (unsigned long *)tmp;
-	if (initrd_header[0] == 0x494E5244) {
-		initrd_start = (unsigned long)&initrd_header[2];
-		initrd_end = initrd_start + initrd_header[1];
+	parse_rd_cmdline(&initrd_start, &initrd_end);
+	if(initrd_start && initrd_end)
+		end = initrd_end;
+	else {
+		initrd_start = initrd_end = 0;
 	}
-	start_pfn = PFN_UP(__pa((&_end)+(initrd_end - initrd_start) + PAGE_SIZE));
-#else
+#endif /* CONFIG_BLK_DEV_INITRD */
 	/*
 	 * Partially used pages are not usable - thus
 	 * we are rounding upwards.
 	 */
-	start_pfn = PFN_UP(__pa(&_end));
-#endif	/* CONFIG_BLK_DEV_INITRD */
+	start_pfn = PFN_UP(__pa(end));
 
 	/* Find the highest page frame number we have available.  */
 	max_pfn = 0;
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/kernel/time.c linux-2.4.22/arch/mips/kernel/time.c
--- linux-2.4.22.clean/arch/mips/kernel/time.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/kernel/time.c	2003-09-27 14:07:04.000000000 +0200
@@ -102,9 +102,9 @@
 
 
 /*
- * Timer ack for a R4k-compatible timer of a known frequency.
+ * Timer ack for an R4k-compatible timer of a known frequency.
  */
-static void c0_fixed_timer_ack(void)
+static void c0_timer_ack(void)
 {
 	unsigned int count;
 
@@ -129,22 +129,23 @@
 	return read_c0_count();
 }
 
-/* For unknown frequency.  */
+/* For use solely as a high precision timer.  */
 static void c0_hpt_init(unsigned int count)
 {
 	write_c0_count(read_c0_count() - count);
 }
 
-/* For a known frequency.  Used as an interrupt source.  */
-static void c0_fixed_hpt_init(unsigned int count)
+/* For use both as a high precision timer and an interrupt source.  */
+static void c0_hpt_timer_init(unsigned int count)
 {
-	expirelo = cycles_per_jiffy;
 	count = read_c0_count() - count;
-	write_c0_count(0);
-	write_c0_compare(cycles_per_jiffy);
+	expirelo = (count / cycles_per_jiffy + 1) * cycles_per_jiffy;
+	write_c0_count(expirelo - cycles_per_jiffy);
+	write_c0_compare(expirelo);
 	write_c0_count(count);
 }
 
+int (*mips_timer_state)(void);
 void (*mips_timer_ack)(void);
 unsigned int (*mips_hpt_read)(void);
 void (*mips_hpt_init)(unsigned int);
@@ -328,9 +329,9 @@
 				"dsll32	%1,%2,0\n\t"
 				"or	%1,%1,%0\n\t"
 				"ddivu	$0,%1,%4\n\t"
+				"mflo	%1\n\t"
 				"dsll32	%0,%5,0\n\t"
 				"or	%0,%0,%6\n\t"
-				"mflo	%1\n\t"
 				"ddivu	$0,%0,%1\n\t"
 				"mflo	%0\n\t"
 				".set	pop"
@@ -410,6 +411,7 @@
  */
 void timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
+	unsigned long j;
 	unsigned int count;
 
 	count = mips_hpt_read();
@@ -447,10 +449,41 @@
 	 * If jiffies has overflown in this timer_interrupt, we must
 	 * update the timer[hi]/[lo] to make fast gettimeoffset funcs
 	 * quotient calc still valid. -arca
-	 */
-	if (!jiffies) {
-		timerhi = timerlo = 0;
-		mips_hpt_init(count);
+	 *
+	 * The first timer interrupt comes late as interrupts are
+	 * enabled long after timers are initialized.  Therefore the
+	 * high precision timer is fast, leading to wrong gettimeoffset()
+	 * calculations.  We deal with it by setting it based on the
+	 * number of its ticks between the second and the third interrupt.
+	 * That is still somewhat imprecise, but it's a good estimate.
+	 * --macro
+	 */
+	j = jiffies;
+	if (j < 4) {
+		static unsigned int prev_count;
+		static int hpt_initialized;
+
+		switch (j) {
+		case 0:
+			timerhi = timerlo = 0;
+			mips_hpt_init(count);
+			break;
+		case 2:
+			prev_count = count;
+			break;
+		case 3:
+			if (!hpt_initialized) {
+				unsigned int c3 = 3 * (count - prev_count);
+
+				timerhi = 0;
+				timerlo = c3;
+				mips_hpt_init(count - c3);
+				hpt_initialized = 1;
+			}
+			break;
+		default:
+			break;
+		}
 	}
 
 #if !defined(CONFIG_SMP)
@@ -516,7 +549,7 @@
  *
  * 1) board_time_init() -
  * 	a) (optional) set up RTC routines,
- *      b) (optional) calibrate and set the mips_counter_frequency
+ *      b) (optional) calibrate and set the mips_hpt_frequency
  *	    (only needed if you intended to use fixed_rate_gettimeoffset
  *	     or use cpu counter as timer interrupt source)
  * 2) setup xtime based on rtc_get_time().
@@ -531,7 +564,7 @@
 void (*board_time_init)(void);
 void (*board_timer_setup)(struct irqaction *irq);
 
-unsigned int mips_counter_frequency;
+unsigned int mips_hpt_frequency;
 
 static struct irqaction timer_irqaction = {
 	.handler = timer_interrupt,
@@ -539,6 +572,49 @@
 	.name = "timer",
 };
 
+static unsigned int __init calibrate_hpt(void)
+{
+	u64 frequency;
+	u32 hpt_start, hpt_end, hpt_count, hz;
+
+	const int loops = HZ / 10;
+	int log_2_loops = 0;
+	int i;
+
+	/*
+	 * We want to calibrate for 0.1s, but to avoid a 64-bit
+	 * division we round the number of loops up to the nearest
+	 * power of 2.
+	 */
+	while (loops > 1 << log_2_loops)
+		log_2_loops++;
+	i = 1 << log_2_loops;
+
+	/*
+	 * Wait for a rising edge of the timer interrupt.
+	 */
+	while (mips_timer_state());
+	while (!mips_timer_state());
+
+	/*
+	 * Now see how many high precision timer ticks happen
+	 * during the calculated number of periods between timer
+	 * interrupts.
+	 */
+	hpt_start = mips_hpt_read();
+	do {
+		while (mips_timer_state());
+		while (!mips_timer_state());
+	} while (--i);
+	hpt_end = mips_hpt_read();
+
+	hpt_count = hpt_end - hpt_start;
+	hz = HZ;
+	frequency = (u64)hpt_count * (u64)hz;
+
+	return frequency >> log_2_loops;
+}
+
 void __init time_init(void)
 {
 	if (board_time_init)
@@ -555,7 +631,7 @@
 		/* No high precision timer -- sorry.  */
 		mips_hpt_read = null_hpt_read;
 		mips_hpt_init = null_hpt_init;
-	} else if (!mips_counter_frequency) {
+	} else if (!mips_hpt_frequency && !mips_timer_state) {
 		/* A high precision timer of unknown frequency.  */
 		if (!mips_hpt_read) {
 			/* No external high precision timer -- use R4k.  */
@@ -578,27 +654,36 @@
 			 */
 			do_gettimeoffset = calibrate_div64_gettimeoffset;
 	} else {
-		/* We know counter frequency! */
+		/* We know counter frequency.  Or we can get it.  */
 		if (!mips_hpt_read) {
 			/* No external high precision timer -- use R4k.  */
 			mips_hpt_read = c0_hpt_read;
-			mips_hpt_init = c0_fixed_hpt_init;
 
-			if (!mips_timer_ack)
-				/* R4k timer interrupt ack.  */
-				mips_timer_ack = c0_fixed_timer_ack;
+			if (mips_timer_state)
+				mips_hpt_init = c0_hpt_init;
+			else {
+				/* No external timer interrupt -- use R4k.  */
+				mips_hpt_init = c0_hpt_timer_init;
+				mips_timer_ack = c0_timer_ack;
+			}
 		}
+		if (!mips_hpt_frequency)
+			mips_hpt_frequency = calibrate_hpt();
 
 		do_gettimeoffset = fixed_rate_gettimeoffset;
 
 		/* Calculate cache parameters.  */
-		cycles_per_jiffy = mips_counter_frequency / HZ;
+		cycles_per_jiffy = (mips_hpt_frequency + HZ / 2) / HZ;
 
 		/* sll32_usecs_per_cycle = 10^6 * 2^32 / mips_counter_freq  */
-		/* Any better way to do this?  */
-		sll32_usecs_per_cycle = mips_counter_frequency / 100000;
-		sll32_usecs_per_cycle = 0xffffffff / sll32_usecs_per_cycle;
-		sll32_usecs_per_cycle *= 10;
+		do_div64_32(sll32_usecs_per_cycle,
+			    1000000, mips_hpt_frequency / 2,
+			    mips_hpt_frequency);
+
+		/* Report the high precision timer rate for a reference.  */
+		printk("Using %u.%03u MHz high precision timer.\n",
+		       ((mips_hpt_frequency + 500) / 1000) / 1000,
+		       ((mips_hpt_frequency + 500) / 1000) % 1000);
 	}
 
 	if (!mips_timer_ack)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/kernel/traps.c linux-2.4.22/arch/mips/kernel/traps.c
--- linux-2.4.22.clean/arch/mips/kernel/traps.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/kernel/traps.c	2003-09-27 14:07:04.000000000 +0200
@@ -523,6 +523,8 @@
 		simulate_sc(regs, opcode);
 		return 0;
 	}
+
+	return -EFAULT;			/* Strange things going on ... */
 }
 
 asmlinkage void do_ov(struct pt_regs *regs)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/lasat/lasat_board.c linux-2.4.22/arch/mips/lasat/lasat_board.c
--- linux-2.4.22.clean/arch/mips/lasat/lasat_board.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/lasat/lasat_board.c	2003-09-27 14:07:04.000000000 +0200
@@ -24,6 +24,7 @@
  * Routines specific to the LASAT boards
  */
 #include <linux/types.h>
+#include <linux/crc32.h>
 #include <asm/lasat/lasat.h>
 #include <linux/kernel.h>
 #include <linux/string.h>
@@ -33,9 +34,11 @@
 #include "at93c.h"
 /* New model description table */
 #include "lasat_models.h"
+
+#define EEPROM_CRC(data, len) (~0 ^ crc32(~0, data, len))
+
 struct lasat_info lasat_board_info;
 
-unsigned long crc32(unsigned long, unsigned char *, int);
 void update_bcastaddr(void);
 
 int EEPROMRead(unsigned int pos, unsigned char *data, int len)
@@ -68,19 +71,19 @@
 	ls[LASAT_MTD_NORMAL] = 0x100000;
 
 	if (mips_machtype == MACH_LASAT_100) {
-		lasat_board_info.li_flash_base = KSEG1ADDR(0x1e000000);
+		lasat_board_info.li_flash_base = 0x1e000000;
 		
-		lb[LASAT_MTD_BOOTLOADER] = KSEG1ADDR(0x1e400000);
+		lb[LASAT_MTD_BOOTLOADER] = 0x1e400000;
 
 		if (lasat_board_info.li_flash_size > 0x200000) {
 			ls[LASAT_MTD_CONFIG] = 0x100000;
 			ls[LASAT_MTD_FS] = 0x500000;
 		}
 	} else {
-		lasat_board_info.li_flash_base = KSEG1ADDR(0x10000000);
+		lasat_board_info.li_flash_base = 0x10000000;
 
 		if (lasat_board_info.li_flash_size < 0x1000000) {
-			lb[LASAT_MTD_BOOTLOADER] = KSEG1ADDR(0x10000000);
+			lb[LASAT_MTD_BOOTLOADER] = 0x10000000;
 			ls[LASAT_MTD_CONFIG] = 0x100000;
 			if (lasat_board_info.li_flash_size >= 0x400000) {
 				ls[LASAT_MTD_FS] = lasat_board_info.li_flash_size - 0x300000;
@@ -109,7 +112,7 @@
 		   sizeof(struct lasat_eeprom_struct));
 
 	/* Check the CRC */
-	crc = crc32(0x0, (unsigned char *)(&lasat_board_info.li_eeprom_info),
+	crc = EEPROM_CRC((unsigned char *)(&lasat_board_info.li_eeprom_info),
 		    sizeof(struct lasat_eeprom_struct) - 4);
 
 	if (crc != lasat_board_info.li_eeprom_info.crc32) {
@@ -268,7 +271,7 @@
 	unsigned long crc;
 
 	/* Generate the CRC */
-	crc = crc32(0x0, (unsigned char *)(&lasat_board_info.li_eeprom_info),
+	crc = EEPROM_CRC((unsigned char *)(&lasat_board_info.li_eeprom_info),
 		    sizeof(struct lasat_eeprom_struct) - 4);
 	lasat_board_info.li_eeprom_info.crc32 = crc;
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/lasat/Makefile linux-2.4.22/arch/mips/lasat/Makefile
--- linux-2.4.22.clean/arch/mips/lasat/Makefile	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/lasat/Makefile	2003-09-27 14:07:04.000000000 +0200
@@ -5,7 +5,7 @@
 
 O_TARGET := lasatkern.o
 obj-y	 := reset.o setup.o prom.o lasat_board.o \
-		crc32.o at93c.o interrupt.o lasatIRQ.o
+		at93c.o interrupt.o lasatIRQ.o
 
 obj-$(CONFIG_LASAT_SYSCTL) += sysctl.o
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/lasat/prom.c linux-2.4.22/arch/mips/lasat/prom.c
--- linux-2.4.22.clean/arch/mips/lasat/prom.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/lasat/prom.c	2003-09-27 14:07:04.000000000 +0200
@@ -78,7 +78,7 @@
 {
 	u32 version = *(u32 *)(RESET_VECTOR + 0x90);
 
-	if (version == 306) {
+	if (version >= 306) {
 		prom_display = (void *)PROM_DISPLAY_ADDR;
 		prom_putc = (void *)PROM_PUTC_ADDR;
 		prom_printf = real_prom_printf;
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/lasat/setup.c linux-2.4.22/arch/mips/lasat/setup.c
--- linux-2.4.22.clean/arch/mips/lasat/setup.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/lasat/setup.c	2003-09-27 14:07:04.000000000 +0200
@@ -138,7 +138,7 @@
 
 static void lasat_time_init(void)
 {
-	mips_counter_frequency = lasat_board_info.li_cpu_hz / 2;
+	mips_hpt_frequency = lasat_board_info.li_cpu_hz / 2;
 }
 
 static void lasat_timer_setup(struct irqaction *irq)
@@ -146,7 +146,7 @@
 
 	write_c0_compare(
 		read_c0_count() + 
-		mips_counter_frequency / HZ);
+		mips_hpt_frequency / HZ);
 	change_c0_status(ST0_IM, IE_IRQ0 | IE_IRQ5);
 }
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/lasat/sysctl.c linux-2.4.22/arch/mips/lasat/sysctl.c
--- linux-2.4.22.clean/arch/mips/lasat/sysctl.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/lasat/sysctl.c	2003-09-27 14:07:04.000000000 +0200
@@ -95,32 +95,6 @@
 	return 0;
 }
 
-static int rtctmp;
-
-#ifdef CONFIG_DS1603
-/* proc function to read/write RealTime Clock */ 
-int proc_dolasatrtc(ctl_table *table, int write, struct file *filp,
-		       void *buffer, size_t *lenp)
-{
-	int r;
-	down(&lasat_info_sem);
-	if (!write) {
-		rtctmp = ds1603_read();
-		/* check for time < 0 and set to 0 */
-		if (rtctmp < 0)
-			rtctmp = 0;
-	}
-	r = proc_dointvec(table, write, filp, buffer, lenp);
-	if ( (!write) || r) {
-		up(&lasat_info_sem);
-		return r;
-	}
-	ds1603_set(rtctmp);
-	up(&lasat_info_sem);
-	return 0;
-}
-#endif
-
 /* Sysctl for setting the IP addresses */
 int sysctl_lasat_intvec(ctl_table *table, int *name, int nlen,
 		    void *oldval, size_t *oldlenp,
@@ -140,30 +114,6 @@
 	return 1;
 }
 
-#if CONFIG_DS1603
-/* Same for RTC */
-int sysctl_lasat_rtc(ctl_table *table, int *name, int nlen,
-		    void *oldval, size_t *oldlenp,
-		    void *newval, size_t newlen, void **context)
-{
-	int r;
-	down(&lasat_info_sem);
-	rtctmp = ds1603_read();
-	if (rtctmp < 0)
-		rtctmp = 0;
-	r = sysctl_intvec(table, name, nlen, oldval, oldlenp, newval, newlen, context);
-	if (r < 0) {
-		up(&lasat_info_sem);
-		return r;
-	}
-	if (newval && newlen) {
-		ds1603_set(rtctmp);
-	}
-	up(&lasat_info_sem);
-	return 1;
-}
-#endif
-
 #ifdef CONFIG_INET
 static char lasat_bcastaddr[16];
 
@@ -328,10 +278,6 @@
 	 0600, NULL, &proc_dolasatstring, &sysctl_lasatstring},
 	{LASAT_SBOOT, "boot-service", &lasat_boot_to_service, sizeof(int),
 	 0644, NULL, &proc_dointvec, &sysctl_intvec},
-#if CONFIG_DS1603
-	{LASAT_RTC, "rtc", &rtctmp, sizeof(int),
-	 0644, NULL, &proc_dolasatrtc, &sysctl_lasat_rtc},
-#endif
 	{LASAT_NAMESTR, "namestr", &lasat_board_info.li_namestr, sizeof(lasat_board_info.li_namestr),
 	 0444, NULL, &proc_dostring, &sysctl_string},
 	{LASAT_TYPESTR, "typestr", &lasat_board_info.li_typestr, sizeof(lasat_board_info.li_typestr),
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/lasat/sysctl.h linux-2.4.22/arch/mips/lasat/sysctl.h
--- linux-2.4.22.clean/arch/mips/lasat/sysctl.h	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/lasat/sysctl.h	2003-09-27 14:07:04.000000000 +0200
@@ -16,7 +16,6 @@
 	LASAT_BCAST,
 	LASAT_PASSWORD,
 	LASAT_SBOOT,
-	LASAT_RTC,
 	LASAT_NAMESTR,
 	LASAT_TYPESTR,
 };
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/Makefile linux-2.4.22/arch/mips/Makefile
--- linux-2.4.22.clean/arch/mips/Makefile	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/arch/mips/Makefile	2003-09-27 14:07:02.000000000 +0200
@@ -47,7 +47,7 @@
 LINKFLAGS	+= -G 0 -static # -N
 MODFLAGS	+= -mlong-calls
 
-ifdef CONFIG_KGDB
+ifdef CONFIG_DEBUG_INFO
 GCCFLAGS	+= -g
 ifdef CONFIG_SB1XXX_CORELIS
 GCCFLAGS	+= -mno-sched-prolog -fno-omit-frame-pointer
@@ -57,41 +57,51 @@
 # CPU-dependent compiler/assembler options for optimization.
 #
 ifdef CONFIG_CPU_R3000
-GCCFLAGS	+= -mcpu=r3000 -mips1
+GCCFLAGS        += $(call check_gcc, -mtune=r3000, -mcpu=r3000) -mips1
 endif
 ifdef CONFIG_CPU_TX39XX
-GCCFLAGS	+= -mcpu=r3000 -mips1
+GCCFLAGS        += $(call check_gcc, -mtune=r3000, -mcpu=r3000) -mips1
 endif
 ifdef CONFIG_CPU_R6000
-GCCFLAGS	+= -mcpu=r6000 -mips2 -Wa,--trap
+GCCFLAGS        += $(call check_gcc, -mtune=r6000, -mcpu=r6000) \
+                   -mips2 -Wa,--trap
 endif
 ifdef CONFIG_CPU_R4300
-GCCFLAGS	+= -mcpu=r4300 -mips2 -Wa,--trap
+GCCFLAGS        += $(call check_gcc, -mtune=r4300, -mcpu=r4300) \
+                   -mips2 -Wa,--trap
 endif
 ifdef CONFIG_CPU_VR41XX
-GCCFLAGS	+= -mcpu=r4600 -mips2 -Wa,--trap
+GCCFLAGS        += $(call check_gcc, -mtune=r4600, -mcpu=r4600) \
+                   -mips2 -Wa,--trap
 endif
 ifdef CONFIG_CPU_R4X00
-GCCFLAGS	+= -mcpu=r4600 -mips2 -Wa,--trap
+GCCFLAGS        += $(call check_gcc, -mtune=r4600, -mcpu=r4600) \
+                   -mips2 -Wa,--trap
 endif
 ifdef CONFIG_CPU_TX49XX
-GCCFLAGS	+= -mcpu=r4600 -mips2 -Wa,--trap
+GCCFLAGS        += $(call check_gcc, -mtune=r4600, -mcpu=r4600) \
+                   -mips2 -Wa,--trap
 endif
 ifdef CONFIG_CPU_MIPS32
-GCCFLAGS	+= -mcpu=r4600 -mips2 -Wa,--trap
+GCCFLAGS        += $(call check_gcc, -mtune=r4600, -mcpu=r4600) \
+                   -mips2 -Wa,--trap
 endif
 ifdef CONFIG_CPU_MIPS64
-GCCFLAGS	+= -mcpu=r4600 -mips2 -Wa,--trap
+GCCFLAGS        += $(call check_gcc, -mtune=r4600, -mcpu=r4600) \
+                   -mips2 -Wa,--trap
 endif
 ifdef CONFIG_CPU_R5000
-GCCFLAGS	+= -mcpu=r5000 -mips2 -Wa,--trap
+GCCFLAGS        += $(call check_gcc, -mtune=r5000, -mcpu=r5000) \
+                   -mips2 -Wa,--trap
 endif
 ifdef CONFIG_CPU_R5432
-GCCFLAGS	+= -mcpu=r5000 -mips2 -Wa,--trap
+GCCFLAGS        += $(call check_gcc, -mtune=r5000, -mcpu=r5000) \
+                   -mips2 -Wa,--trap
 endif
 ifdef CONFIG_CPU_NEVADA
 # Cannot use -mmad with currently recommended tools
-GCCFLAGS	+= -mcpu=r5000 -mips2 -Wa,--trap
+GCCFLAGS        += $(call check_gcc, -mtune=r5000, -mcpu=r5000) \
+                   -mips2 -Wa,--trap
 endif
 ifdef CONFIG_CPU_RM7000
 GCCFLAGS	+= $(call check_gcc, -march=rm7000, -mcpu=r5000) \
@@ -223,6 +233,16 @@
 LOADADDR      += 0x80100000
 endif
 
+#
+# Cogent CSB250
+#
+ifdef CONFIG_COGENT_CSB250
+LIBS		+= arch/mips/au1000/csb250/csb250.o \
+		   arch/mips/au1000/common/au1000.o
+SUBDIRS		+= arch/mips/au1000/csb250 arch/mips/au1000/common
+LOADADDR	:= 0x80100000
+endif
+
 ifdef CONFIG_PCI
 CORE_FILES    += arch/mips/pci/pci-core.o
 SUBDIRS       += arch/mips/pci
@@ -632,6 +652,9 @@
 vmlinux.ecoff: vmlinux
 	@$(MAKEBOOT) $@
 
+vmlinux.srec: vmlinux
+	@$(MAKEBOOT) $@
+
 archclean:
 	@$(MAKEBOOT) clean
 	rm -f arch/$(ARCH)/ld.script
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/Makefile.lib linux-2.4.22/arch/mips/Makefile.lib
--- linux-2.4.22.clean/arch/mips/Makefile.lib	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/arch/mips/Makefile.lib	2003-08-18 04:59:02.000000000 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_LASAT) += crc32.o
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/mips-boards/generic/time.c linux-2.4.22/arch/mips/mips-boards/generic/time.c
--- linux-2.4.22.clean/arch/mips/mips-boards/generic/time.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/mips-boards/generic/time.c	2003-09-27 14:07:04.000000000 +0200
@@ -102,12 +102,12 @@
 	while (CMOS_READ(RTC_REG_A) & RTC_UIP);
 	while (!(CMOS_READ(RTC_REG_A) & RTC_UIP));
 
-	mips_counter_frequency = read_c0_count();
+	mips_hpt_frequency = read_c0_count();
 
 	/* restore interrupts */
 	local_irq_restore(flags);
 
-	return (mips_counter_frequency / HZ);
+	return (mips_hpt_frequency / HZ);
 }
 
 unsigned long __init mips_rtc_get_time(void)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/mm/cerr-sb1.c linux-2.4.22/arch/mips/mm/cerr-sb1.c
--- linux-2.4.22.clean/arch/mips/mm/cerr-sb1.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/mm/cerr-sb1.c	2003-09-27 14:07:04.000000000 +0200
@@ -193,7 +193,9 @@
 		prom_printf(" cp0_cerr_i   ==   %08x", cerr_i);
 		breakout_cerri(cerr_i);
 		if (CP0_CERRI_IDX_VALID(cerr_i)) {
-			if ((eepc & SB1_CACHE_INDEX_MASK) != (cerr_i & SB1_CACHE_INDEX_MASK))
+			/* Check index of EPC, allowing for delay slot */
+			if (((eepc & SB1_CACHE_INDEX_MASK) != (cerr_i & SB1_CACHE_INDEX_MASK)) &&
+			    ((eepc & SB1_CACHE_INDEX_MASK) != ((cerr_i & SB1_CACHE_INDEX_MASK) - 4)))
 				prom_printf(" cerr_i idx doesn't match eepc\n");
 			else {
 				res = extract_ic(cerr_i & SB1_CACHE_INDEX_MASK,
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/mm/c-sb1.c linux-2.4.22/arch/mips/mm/c-sb1.c
--- linux-2.4.22.clean/arch/mips/mm/c-sb1.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/mm/c-sb1.c	2003-09-27 14:07:04.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
  * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
- * Copyright (C) 2000, 2001 Broadcom Corporation
+ * Copyright (C) 2000, 2001, 2002, 2003 Broadcom Corporation
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -596,7 +596,6 @@
 	 * occur
 	 */
 	_flush_cache_range = (void *) sb1_nop;
-	_flush_cache_page = sb1_flush_cache_page;
 	_flush_cache_mm = (void (*)(struct mm_struct *))sb1_nop;
 	_flush_cache_all = sb1_nop;
 
@@ -605,6 +604,9 @@
 	_flush_icache_page = sb1_flush_icache_page;
 	_flush_icache_all = __sb1_flush_icache_all; /* local only */
 
+	/* This implies an Icache flush too, so can't be nop'ed */
+	_flush_cache_page = sb1_flush_cache_page;
+
 	_flush_cache_sigtramp = sb1_flush_cache_sigtramp;
 	_flush_data_cache_page = (void *) sb1_nop;
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/mm/sc-ip22.c linux-2.4.22/arch/mips/mm/sc-ip22.c
--- linux-2.4.22.clean/arch/mips/mm/sc-ip22.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/mm/sc-ip22.c	2003-09-28 02:58:28.000000000 +0200
@@ -14,6 +14,7 @@
 #include <asm/pgtable.h>
 #include <asm/system.h>
 #include <asm/bootinfo.h>
+#include <asm/cpu.h>
 #include <asm/sgi/ip22.h>
 #include <asm/sgi/mc.h>
 
@@ -170,8 +171,14 @@
 
 void __init indy_sc_init(void)
 {
-	if (indy_sc_probe()) {
-		indy_sc_enable();
-		bcops = &indy_sc_ops;
+	struct cpuinfo_mips *c = &current_cpu_data;
+	/* second level cache doesn't work on R5k IP22 at the moment */
+	if ( c->cputype == CPU_R5000 ) {
+	    printk(KERN_INFO "ScInit: Not enabling second level caches.\n");
+	} else {
+	    if (indy_sc_probe()) {
+		    indy_sc_enable();
+		    bcops = &indy_sc_ops;
+	    }
 	}
 }
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/mm/tlbex-r4k.S linux-2.4.22/arch/mips/mm/tlbex-r4k.S
--- linux-2.4.22.clean/arch/mips/mm/tlbex-r4k.S	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/mm/tlbex-r4k.S	2003-09-27 14:07:04.000000000 +0200
@@ -453,6 +453,7 @@
 #endif
 invalid_tlbl:
 #ifdef TLB_OPTIMIZE
+	.set	mips3
 	/* Test present bit in entry. */
 	LOAD_PTE(k0, k1)
 	R5K_HAZARD
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/mm/tlb-sb1.c linux-2.4.22/arch/mips/mm/tlb-sb1.c
--- linux-2.4.22.clean/arch/mips/mm/tlb-sb1.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/mm/tlb-sb1.c	2003-09-27 14:07:04.000000000 +0200
@@ -18,6 +18,7 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
 #include <linux/config.h>
+#include <linux/init.h>
 #include <asm/mmu_context.h>
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
@@ -95,10 +96,13 @@
 	old_ctx = read_c0_entryhi() & ASID_MASK;
 	write_c0_entrylo0(0);
 	write_c0_entrylo1(0);
-	for (entry = 0; entry < current_cpu_data.tlbsize; entry++) {
+
+	entry = read_c0_wired();
+	while (entry < current_cpu_data.tlbsize) {
 		write_c0_entryhi(KSEG0 + (PAGE_SIZE << 1) * entry);
 		write_c0_index(entry);
 		tlb_write_indexed();
+		entry++;
 	}
 	write_c0_entryhi(old_ctx);
 	local_irq_restore(flags);
@@ -110,7 +114,7 @@
  * Use increments of the maximum page size (16MB), and check for duplicate
  * entries before doing a given write.  Then, when we're safe from collisions
  * with the firmware, go back and give all the entries invalid addresses with
- * the normal flush routine.
+ * the normal flush routine.  Wired entries will be killed as well!
  */
 void sb1_sanitize_tlb(void)
 {
@@ -252,6 +256,34 @@
 	local_irq_restore(flags);
 }
 
+void __init add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
+	unsigned long entryhi, unsigned long pagemask)
+{
+	unsigned long flags;
+	unsigned long wired;
+	unsigned long old_pagemask;
+	unsigned long old_ctx;
+
+	local_irq_save(flags);
+	old_ctx = read_c0_entryhi() & 0xff;
+	old_pagemask = read_c0_pagemask();
+	wired = read_c0_wired();
+	write_c0_wired(wired + 1);
+	write_c0_index(wired);
+
+	write_c0_pagemask(pagemask);
+	write_c0_entryhi(entryhi);
+	write_c0_entrylo0(entrylo0);
+	write_c0_entrylo1(entrylo1);
+	tlb_write_indexed();
+
+	write_c0_entryhi(old_ctx);
+	write_c0_pagemask(old_pagemask);
+
+	local_flush_tlb_all();
+	local_irq_restore(flags);
+}
+
 /*
  * This is called from loadmmu.c.  We have to set up all the
  * memory management function pointers, as well as initialize
@@ -260,6 +292,7 @@
 void sb1_tlb_init(void)
 {
 	write_c0_pagemask(PM_4K);
+	write_c0_wired(0);
 
 	/*
 	 * We don't know what state the firmware left the TLB's in, so this is
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/momentum/ocelot_c/setup.c linux-2.4.22/arch/mips/momentum/ocelot_c/setup.c
--- linux-2.4.22.clean/arch/mips/momentum/ocelot_c/setup.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/momentum/ocelot_c/setup.c	2003-09-27 14:07:04.000000000 +0200
@@ -183,9 +183,9 @@
 void momenco_time_init(void)
 {
 #ifdef CONFIG_CPU_SR71000
-	mips_counter_frequency = cpu_clock;
+	mips_hpt_frequency = cpu_clock;
 #elif defined(CONFIG_CPU_RM7000)
-	mips_counter_frequency = cpu_clock / 2;
+	mips_hpt_frequency = cpu_clock / 2;
 #else
 #error Unknown CPU for this board
 #endif
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/sgi-ip22/ip22-time.c linux-2.4.22/arch/mips/sgi-ip22/ip22-time.c
--- linux-2.4.22.clean/arch/mips/sgi-ip22/ip22-time.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/sgi-ip22/ip22-time.c	2003-09-27 14:07:04.000000000 +0200
@@ -177,7 +177,7 @@
 		(int) (r4k_tick / (500000 / HZ)),
 		(int) (r4k_tick % (500000 / HZ)));
 
-	mips_counter_frequency = r4k_tick * HZ;
+	mips_hpt_frequency = r4k_tick * HZ;
 }
 
 /* Generic SGI handler for (spurious) 8254 interrupts */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/sibyte/cfe/smp.c linux-2.4.22/arch/mips/sibyte/cfe/smp.c
--- linux-2.4.22.clean/arch/mips/sibyte/cfe/smp.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/sibyte/cfe/smp.c	2003-09-27 14:07:04.000000000 +0200
@@ -47,12 +47,12 @@
 	unsigned int imask = STATUSF_IP4 | STATUSF_IP3 | STATUSF_IP2 |
 		STATUSF_IP1 | STATUSF_IP0;
 
+	/* cache and TLB setup */
+	load_mmu();
+
 	/* Enable basic interrupts */
 	change_c0_status(ST0_IM, imask);
 	set_c0_status(ST0_IE);
-
-	/* cache and TLB setup */
-	load_mmu();
 }
 
 /*
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/sibyte/sb1250/smp.c linux-2.4.22/arch/mips/sibyte/sb1250/smp.c
--- linux-2.4.22.clean/arch/mips/sibyte/sb1250/smp.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/sibyte/sb1250/smp.c	2003-09-27 14:07:04.000000000 +0200
@@ -62,9 +62,6 @@
 
 void sb1250_smp_finish(void)
 {
-	extern void sb1_sanitize_tlb(void);
-
-	sb1_sanitize_tlb();
 	sb1250_time_init();
 }
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/tx4927/common/tx4927_setup.c linux-2.4.22/arch/mips/tx4927/common/tx4927_setup.c
--- linux-2.4.22.clean/arch/mips/tx4927/common/tx4927_setup.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/tx4927/common/tx4927_setup.c	2003-09-27 14:07:04.000000000 +0200
@@ -120,7 +120,7 @@
 
 	/* to generate the first timer interrupt */
 	c1 = read_c0_count();
-	count = c1 + (mips_counter_frequency / HZ);
+	count = c1 + (mips_hpt_frequency / HZ);
 	write_c0_compare(count);
 	c2 = read_c0_count();
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c linux-2.4.22/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c
--- linux-2.4.22.clean/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c	2003-09-27 14:07:04.000000000 +0200
@@ -1168,7 +1168,7 @@
 				       ":rtc_ds1742_init()+\n");
 
 	TOSHIBA_RBTX4927_SETUP_DPRINTK(TOSHIBA_RBTX4927_SETUP_TIME_INIT,
-				       ":Calibrate mips_counter_frequency-\n");
+				       ":Calibrate mips_hpt_frequency-\n");
 	rtc_ds1742_wait();
 
 	/* get the count */
@@ -1181,29 +1181,29 @@
 	c2 = read_c0_count();
 
 	TOSHIBA_RBTX4927_SETUP_DPRINTK(TOSHIBA_RBTX4927_SETUP_TIME_INIT,
-				       ":Calibrate mips_counter_frequency+\n");
+				       ":Calibrate mips_hpt_frequency+\n");
 	TOSHIBA_RBTX4927_SETUP_DPRINTK(TOSHIBA_RBTX4927_SETUP_TIME_INIT,
 				       ":c1=%12u\n", c1);
 	TOSHIBA_RBTX4927_SETUP_DPRINTK(TOSHIBA_RBTX4927_SETUP_TIME_INIT,
 				       ":c2=%12u\n", c2);
 
 	/* this diff is as close as we are going to get to counter ticks per sec */
-	mips_counter_frequency = abs(c2 - c1);
+	mips_hpt_frequency = abs(c2 - c1);
 	TOSHIBA_RBTX4927_SETUP_DPRINTK(TOSHIBA_RBTX4927_SETUP_TIME_INIT,
-				       ":f1=%12u\n", mips_counter_frequency);
+				       ":f1=%12u\n", mips_hpt_frequency);
 
 	/* round to 1/10th of a MHz */
-	mips_counter_frequency /= (100 * 1000);
-	mips_counter_frequency *= (100 * 1000);
+	mips_hpt_frequency /= (100 * 1000);
+	mips_hpt_frequency *= (100 * 1000);
 	TOSHIBA_RBTX4927_SETUP_DPRINTK(TOSHIBA_RBTX4927_SETUP_TIME_INIT,
-				       ":f2=%12u\n", mips_counter_frequency);
+				       ":f2=%12u\n", mips_hpt_frequency);
 
 	TOSHIBA_RBTX4927_SETUP_DPRINTK(TOSHIBA_RBTX4927_SETUP_INFO,
-				       ":mips_counter_frequency=%uHz (%uMHz)\n",
-				       mips_counter_frequency,
-				       mips_counter_frequency / 1000000);
+				       ":mips_hpt_frequency=%uHz (%uMHz)\n",
+				       mips_hpt_frequency,
+				       mips_hpt_frequency / 1000000);
 #else
-	mips_counter_frequency = 100000000;
+	mips_hpt_frequency = 100000000;
 #endif
 
 	TOSHIBA_RBTX4927_SETUP_DPRINTK(TOSHIBA_RBTX4927_SETUP_TIME_INIT, "+\n");
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/vr41xx/common/bcu.c linux-2.4.22/arch/mips/vr41xx/common/bcu.c
--- linux-2.4.22.clean/arch/mips/vr41xx/common/bcu.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/vr41xx/common/bcu.c	2003-09-27 14:07:04.000000000 +0200
@@ -36,7 +36,7 @@
  *  - Added support for NEC VR4111 and VR4121.
  *
  *  Paul Mundt <lethal@chaoticdreams.org>
- *  - Calculate mips_counter_frequency properly on VR4131.
+ *  - Calculate mips_hpt_frequency properly on VR4131.
  *
  *  MontaVista Software Inc. <yyuasa@mvista.com> or <source@mvista.com>
  *  - New creation, NEC VR4122 and VR4131 are supported.
@@ -177,7 +177,7 @@
 	return tclock;
 }
 
-static inline unsigned long calculate_mips_counter_frequency(unsigned long tclock)
+static inline unsigned long calculate_mips_hpt_frequency(unsigned long tclock)
 {
 	/*
 	 * VR4131 Revision 2.0 and 2.1 use a value of (tclock / 2).
@@ -202,5 +202,5 @@
 	vtclock = calculate_vtclock(clkspeed, pclock);
 	tclock = calculate_tclock(clkspeed, pclock, vtclock);
 
-	mips_counter_frequency = calculate_mips_counter_frequency(tclock);
+	mips_hpt_frequency = calculate_mips_hpt_frequency(tclock);
 }
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips/vr41xx/common/time.c linux-2.4.22/arch/mips/vr41xx/common/time.c
--- linux-2.4.22.clean/arch/mips/vr41xx/common/time.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips/vr41xx/common/time.c	2003-09-27 14:07:04.000000000 +0200
@@ -89,5 +89,5 @@
 	setup_irq(MIPS_COUNTER_IRQ, irq);
 
 	count = read_c0_count();
-	write_c0_compare(count + (mips_counter_frequency / HZ));
+	write_c0_compare(count + (mips_hpt_frequency / HZ));
 }
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/defconfig linux-2.4.22/arch/mips64/defconfig
--- linux-2.4.22.clean/arch/mips64/defconfig	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/defconfig	2003-09-27 14:07:04.000000000 +0200
@@ -137,7 +137,6 @@
 # CONFIG_MIPS32_N32 is not set
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_PM is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -473,6 +472,7 @@
 # File systems
 #
 # CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
 CONFIG_AUTOFS_FS=y
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_REISERFS_FS is not set
@@ -482,6 +482,7 @@
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BEFS_DEBUG is not set
 # CONFIG_BFS_FS is not set
@@ -531,6 +532,7 @@
 # CONFIG_INTERMEZZO_FS is not set
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_DIRECTIO is not set
 CONFIG_ROOT_NFS=y
 # CONFIG_NFSD is not set
 # CONFIG_NFSD_V3 is not set
@@ -599,10 +601,17 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 
 #
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
 # Library routines
 #
+# CONFIG_CRC32 is not set
 # CONFIG_ZLIB_INFLATE is not set
 # CONFIG_ZLIB_DEFLATE is not set
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/defconfig-atlas linux-2.4.22/arch/mips64/defconfig-atlas
--- linux-2.4.22.clean/arch/mips64/defconfig-atlas	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/defconfig-atlas	2003-09-27 14:07:04.000000000 +0200
@@ -132,7 +132,6 @@
 # CONFIG_MIPS32_N32 is not set
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_PM is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -484,6 +483,7 @@
 # File systems
 #
 # CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
 CONFIG_AUTOFS_FS=y
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_REISERFS_FS is not set
@@ -493,6 +493,7 @@
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BEFS_DEBUG is not set
 # CONFIG_BFS_FS is not set
@@ -542,6 +543,7 @@
 # CONFIG_INTERMEZZO_FS is not set
 CONFIG_NFS_FS=y
 # CONFIG_NFS_V3 is not set
+# CONFIG_NFS_DIRECTIO is not set
 CONFIG_ROOT_NFS=y
 # CONFIG_NFSD is not set
 # CONFIG_NFSD_V3 is not set
@@ -595,11 +597,18 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
 #
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
 # Library routines
 #
+# CONFIG_CRC32 is not set
 # CONFIG_ZLIB_INFLATE is not set
 # CONFIG_ZLIB_DEFLATE is not set
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/defconfig-decstation linux-2.4.22/arch/mips64/defconfig-decstation
--- linux-2.4.22.clean/arch/mips64/defconfig-decstation	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/defconfig-decstation	2003-09-27 14:07:04.000000000 +0200
@@ -70,6 +70,7 @@
 CONFIG_BOOT_ELF32=y
 CONFIG_IRQ_CPU=y
 CONFIG_L1_CACHE_SHIFT=4
+CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 # CONFIG_MIPS_AU1000 is not set
 
@@ -125,7 +126,6 @@
 # CONFIG_MIPS32_N32 is not set
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_PM is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -476,6 +476,7 @@
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
+# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -491,6 +492,7 @@
 # File systems
 #
 # CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_REISERFS_FS is not set
@@ -500,6 +502,7 @@
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BEFS_DEBUG is not set
 # CONFIG_BFS_FS is not set
@@ -549,6 +552,7 @@
 # CONFIG_INTERMEZZO_FS is not set
 # CONFIG_NFS_FS is not set
 # CONFIG_NFS_V3 is not set
+# CONFIG_NFS_DIRECTIO is not set
 # CONFIG_ROOT_NFS is not set
 # CONFIG_NFSD is not set
 # CONFIG_NFSD_V3 is not set
@@ -616,11 +620,18 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
 #
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
 # Library routines
 #
+# CONFIG_CRC32 is not set
 # CONFIG_ZLIB_INFLATE is not set
 # CONFIG_ZLIB_DEFLATE is not set
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/defconfig-ip22 linux-2.4.22/arch/mips64/defconfig-ip22
--- linux-2.4.22.clean/arch/mips64/defconfig-ip22	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/defconfig-ip22	2003-09-27 14:07:05.000000000 +0200
@@ -527,6 +527,7 @@
 # File systems
 #
 # CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
 CONFIG_AUTOFS_FS=y
 CONFIG_AUTOFS4_FS=y
 # CONFIG_REISERFS_FS is not set
@@ -536,6 +537,7 @@
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BEFS_DEBUG is not set
 # CONFIG_BFS_FS is not set
@@ -585,6 +587,7 @@
 # CONFIG_INTERMEZZO_FS is not set
 CONFIG_NFS_FS=y
 # CONFIG_NFS_V3 is not set
+# CONFIG_NFS_DIRECTIO is not set
 CONFIG_ROOT_NFS=y
 CONFIG_NFSD=y
 # CONFIG_NFSD_V3 is not set
@@ -690,11 +693,18 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
 #
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
 # Library routines
 #
+# CONFIG_CRC32 is not set
 # CONFIG_ZLIB_INFLATE is not set
 # CONFIG_ZLIB_DEFLATE is not set
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/defconfig-ip27 linux-2.4.22/arch/mips64/defconfig-ip27
--- linux-2.4.22.clean/arch/mips64/defconfig-ip27	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/defconfig-ip27	2003-09-27 14:07:05.000000000 +0200
@@ -137,7 +137,6 @@
 # CONFIG_MIPS32_N32 is not set
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_PM is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -473,6 +472,7 @@
 # File systems
 #
 # CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
 CONFIG_AUTOFS_FS=y
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_REISERFS_FS is not set
@@ -482,6 +482,7 @@
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BEFS_DEBUG is not set
 # CONFIG_BFS_FS is not set
@@ -531,6 +532,7 @@
 # CONFIG_INTERMEZZO_FS is not set
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_DIRECTIO is not set
 CONFIG_ROOT_NFS=y
 # CONFIG_NFSD is not set
 # CONFIG_NFSD_V3 is not set
@@ -599,10 +601,17 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 
 #
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
 # Library routines
 #
+# CONFIG_CRC32 is not set
 # CONFIG_ZLIB_INFLATE is not set
 # CONFIG_ZLIB_DEFLATE is not set
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/defconfig-malta linux-2.4.22/arch/mips64/defconfig-malta
--- linux-2.4.22.clean/arch/mips64/defconfig-malta	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/defconfig-malta	2003-09-27 14:07:05.000000000 +0200
@@ -136,7 +136,6 @@
 # CONFIG_MIPS32_N32 is not set
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_PM is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -487,6 +486,7 @@
 # File systems
 #
 # CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
 CONFIG_AUTOFS_FS=y
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_REISERFS_FS is not set
@@ -496,6 +496,7 @@
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BEFS_DEBUG is not set
 # CONFIG_BFS_FS is not set
@@ -545,6 +546,7 @@
 # CONFIG_INTERMEZZO_FS is not set
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_DIRECTIO is not set
 CONFIG_ROOT_NFS=y
 CONFIG_NFSD=y
 CONFIG_NFSD_V3=y
@@ -599,11 +601,18 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
 #
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
 # Library routines
 #
+# CONFIG_CRC32 is not set
 # CONFIG_ZLIB_INFLATE is not set
 # CONFIG_ZLIB_DEFLATE is not set
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/defconfig-sb1250-swarm linux-2.4.22/arch/mips64/defconfig-sb1250-swarm
--- linux-2.4.22.clean/arch/mips64/defconfig-sb1250-swarm	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/defconfig-sb1250-swarm	2003-09-27 14:07:05.000000000 +0200
@@ -157,7 +157,6 @@
 # CONFIG_MIPS32_N32 is not set
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_PM is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -459,6 +458,7 @@
 # File systems
 #
 # CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_REISERFS_FS is not set
@@ -468,6 +468,7 @@
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BEFS_DEBUG is not set
 # CONFIG_BFS_FS is not set
@@ -517,6 +518,7 @@
 # CONFIG_INTERMEZZO_FS is not set
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_DIRECTIO is not set
 # CONFIG_ROOT_NFS is not set
 # CONFIG_NFSD is not set
 # CONFIG_NFSD_V3 is not set
@@ -571,11 +573,18 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_SB1XXX_CORELIS is not set
 # CONFIG_MAGIC_SYSRQ is not set
 
 #
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
 # Library routines
 #
+# CONFIG_CRC32 is not set
 # CONFIG_ZLIB_INFLATE is not set
 # CONFIG_ZLIB_DEFLATE is not set
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/defconfig-sead linux-2.4.22/arch/mips64/defconfig-sead
--- linux-2.4.22.clean/arch/mips64/defconfig-sead	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/defconfig-sead	2003-09-27 14:07:05.000000000 +0200
@@ -126,7 +126,6 @@
 # CONFIG_MIPS32_N32 is not set
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_PM is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -276,6 +275,7 @@
 # File systems
 #
 # CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_REISERFS_FS is not set
@@ -285,6 +285,7 @@
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BEFS_DEBUG is not set
 # CONFIG_BFS_FS is not set
@@ -374,11 +375,18 @@
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_MIPS_UNCACHED is not set
 
 #
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
 # Library routines
 #
+# CONFIG_CRC32 is not set
 # CONFIG_ZLIB_INFLATE is not set
 # CONFIG_ZLIB_DEFLATE is not set
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/kernel/cpu-probe.c linux-2.4.22/arch/mips64/kernel/cpu-probe.c
--- linux-2.4.22.clean/arch/mips64/kernel/cpu-probe.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/kernel/cpu-probe.c	2003-09-27 14:07:05.000000000 +0200
@@ -113,18 +113,40 @@
 	}
 }
 
-static inline void check_mult_sh(void)
+static inline void align_mod(const int align, const int mod)
+{
+	asm volatile(
+		".set	push\n\t"
+		".set	noreorder\n\t"
+		".balign %0\n\t"
+		".rept	%1\n\t"
+		"nop\n\t"
+		".endr\n\t"
+		".set	pop"
+		:
+		: "n" (align), "n" (mod));
+}
+
+static inline void mult_sh_align_mod(long *v1, long *v2, long *w,
+				     const int align, const int mod)
 {
 	unsigned long flags;
 	int m1, m2;
-	long p, s, v;
+	long p, s, lv1, lv2, lw;
 
-	printk("Checking for the multiply/shift bug... ");
+	/*
+	 * We want the multiply and the shift to be isolated from the
+	 * rest of the code to disable gcc optimizations.  Hence the
+	 * asm statements that execute nothing, but make gcc not know
+	 * what the values of m1, m2 and s are and what lv2 and p are
+	 * used for.
+	 */
 
 	local_irq_save(flags);
 	/*
-	 * The following code leads to a wrong result of dsll32 when
-	 * executed on R4000 rev. 2.2 or 3.0.
+	 * The following code leads to a wrong result of the first
+	 * dsll32 when executed on R4000 rev. 2.2 or 3.0 (PRId
+	 * 00000422 or 00000430, respectively).
 	 *
 	 * See "MIPS R4000PC/SC Errata, Processor Revision 2.2 and
 	 * 3.0" by MIPS Technologies, Inc., errata #16 and #28 for
@@ -132,52 +154,97 @@
 	 * sigh... --macro
 	 */
 	asm volatile(
+		""
+		: "=r" (m1), "=r" (m2), "=r" (s)
+		: "0" (5), "1" (8), "2" (5));
+	align_mod(align, mod);
+	/*
+	 * The trailing nop is needed to fullfill the two-instruction
+	 * requirement between reading hi/lo and staring a mult/div.
+	 * Leaving it out may cause gas insert a nop itself breaking
+	 * the desired alignment of the next chunk.
+	 */
+	asm volatile(
 		".set	push\n\t"
 		".set	noat\n\t"
 		".set	noreorder\n\t"
 		".set	nomacro\n\t"
-		"mult	%1, %2\n\t"
-		"dsll32	%0, %3, %4\n\t"
+		"mult	%2, %3\n\t"
+		"dsll32	%0, %4, %5\n\t"
 		"mflo	$0\n\t"
+		"dsll32	%1, %4, %5\n\t"
+		"nop\n\t"
 		".set	pop"
-		: "=r" (v)
-		: "r" (5), "r" (8), "r" (5), "I" (0)
+		: "=&r" (lv1), "=r" (lw)
+		: "r" (m1), "r" (m2), "r" (s), "I" (0)
 		: "hi", "lo", "accum");
-	local_irq_restore(flags);
-
-	if (v == 5L << 32) {
-		printk("no.\n");
-		return;
-	}
-
-	printk("yes, workaround... ");
-	local_irq_save(flags);
-	/*
-	 * We want the multiply and the shift to be isolated from the
-	 * rest of the code to disable gcc optimizations.  Hence the
-	 * asm statements that execute nothing, but make gcc not know
-	 * what the values of m1, m2 and s are and what v and p are
-	 * used for.
-	 *
-	 * We have to use single integers for m1 and m2 and a double
+	/* We have to use single integers for m1 and m2 and a double
 	 * one for p to be sure the mulsidi3 gcc's RTL multiplication
 	 * instruction has the workaround applied.  Older versions of
-	 * gcc have correct mulsi3, but other multiplication variants
-	 * lack the workaround.
+	 * gcc have correct umulsi3 and mulsi3, but other
+	 * multiplication variants lack the workaround.
 	 */
 	asm volatile(
 		""
 		: "=r" (m1), "=r" (m2), "=r" (s)
-		: "0" (5), "1" (8), "2" (5));
+		: "0" (m1), "1" (m2), "2" (s));
+	align_mod(align, mod);
 	p = m1 * m2;
-	v = s << 32;
+	lv2 = s << 32;
 	asm volatile(
 		""
-		: "=r" (v)
-		: "0" (v), "r" (p));
+		: "=r" (lv2)
+		: "0" (lv2), "r" (p));
 	local_irq_restore(flags);
 
-	if (v == 5L << 32) {
+	*v1 = lv1;
+	*v2 = lv2;
+	*w = lw;
+}
+
+static inline void check_mult_sh(void)
+{
+	long v1[8], v2[8], w[8];
+	int bug, fix, i;
+
+	printk("Checking for the multiply/shift bug... ");
+
+	/*
+	 * Testing discovered false negatives for certain code offsets
+	 * into cache lines.  Hence we test all possible offsets for
+	 * the worst assumption of an R4000 I-cache line width of 32
+	 * bytes.
+	 *
+	 * We can't use a loop as alignment directives need to be
+	 * immediates.
+	 */
+	mult_sh_align_mod(&v1[0], &v2[0], &w[0], 32, 0);
+	mult_sh_align_mod(&v1[1], &v2[1], &w[1], 32, 1);
+	mult_sh_align_mod(&v1[2], &v2[2], &w[2], 32, 2);
+	mult_sh_align_mod(&v1[3], &v2[3], &w[3], 32, 3);
+	mult_sh_align_mod(&v1[4], &v2[4], &w[4], 32, 4);
+	mult_sh_align_mod(&v1[5], &v2[5], &w[5], 32, 5);
+	mult_sh_align_mod(&v1[6], &v2[6], &w[6], 32, 6);
+	mult_sh_align_mod(&v1[7], &v2[7], &w[7], 32, 7);
+
+	bug = 0;
+	for (i = 0; i < 8; i++)
+		if (v1[i] != w[i])
+			bug = 1;
+		
+	if (bug == 0) {
+		printk("no.\n");
+		return;
+	}
+
+	printk("yes, workaround... ");
+
+	fix = 1;
+	for (i = 0; i < 8; i++)
+		if (v2[i] != w[i])
+			fix = 0;
+		
+	if (fix == 1) {
 		printk("yes.\n");
 		return;
 	}
@@ -213,7 +280,8 @@
 	handler = set_except_vector(12, handle_daddi_ov);
 	/*
 	 * The following code fails to trigger an overflow exception
-	 * when executed on R4000 rev. 2.2 or 3.0.
+	 * when executed on R4000 rev. 2.2 or 3.0 (PRId 00000422 or
+	 * 00000430, respectively).
 	 *
 	 * See "MIPS R4000PC/SC Errata, Processor Revision 2.2 and
 	 * 3.0" by MIPS Technologies, Inc., erratum #23 for details.
@@ -273,15 +341,16 @@
 
 	/*
 	 * The following code leads to a wrong result of daddiu when
-	 * executed on R4400 rev. 1.0.
+	 * executed on R4400 rev. 1.0 (PRId 00000440).
 	 *
 	 * See "MIPS R4400PC/SC Errata, Processor Revision 1.0" by
 	 * MIPS Technologies, Inc., erratum #7 for details.
 	 *
 	 * According to "MIPS R4000PC/SC Errata, Processor Revision
 	 * 2.2 and 3.0" by MIPS Technologies, Inc., erratum #41 this
-	 * problem affects R4000 rev. 2.2 and 3.0, too.  Testing
-	 * failed to trigger it so far.
+	 * problem affects R4000 rev. 2.2 and 3.0 (PRId 00000422 and
+	 * 00000430, respectively), too.  Testing failed to trigger it
+	 * so far.
 	 *
 	 * I got no permission to duplicate the errata here, sigh...
 	 * --macro
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/kernel/linux32.c linux-2.4.22/arch/mips64/kernel/linux32.c
--- linux-2.4.22.clean/arch/mips64/kernel/linux32.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/kernel/linux32.c	2003-09-27 14:07:05.000000000 +0200
@@ -29,6 +29,7 @@
 #include <linux/personality.h>
 #include <linux/timex.h>
 #include <linux/dnotify.h>
+#include <linux/linkage.h>
 #include <linux/module.h>
 #include <net/sock.h>
 #include <net/scm.h>
@@ -37,6 +38,37 @@
 #include <asm/mman.h>
 #include <asm/ipc.h>
 
+extern asmlinkage long sys_socket(int family, int type, int protocol);
+extern asmlinkage long sys_bind(int fd, struct sockaddr *umyaddr, int addrlen);
+extern asmlinkage long sys_connect(int fd, struct sockaddr *uservaddr,
+	int addrlen);
+extern asmlinkage long sys_listen(int fd, int backlog);
+extern asmlinkage long sys_accept(int fd, struct sockaddr *upeer_sockaddr,
+	int *upeer_addrlen);
+extern asmlinkage long sys_getsockname(int fd, struct sockaddr *usockaddr,
+	int *usockaddr_len);
+extern asmlinkage long sys_getpeername(int fd, struct sockaddr *usockaddr,
+	int *usockaddr_len);
+extern asmlinkage long sys_socketpair(int family, int type, int protocol,
+	int *usockvec);
+extern asmlinkage long sys_send(int fd, void * buff, size_t len,
+	unsigned flags);
+extern asmlinkage long sys_sendto(int fd, void * buff, size_t len,
+	unsigned flags, struct sockaddr *addr, int addr_len);
+extern asmlinkage long sys_recv(int fd, void * ubuf, size_t size,
+	unsigned flags);
+extern asmlinkage long sys_recvfrom(int fd, void * ubuf, size_t size,
+	unsigned flags, struct sockaddr *addr, int *addr_len);
+extern asmlinkage long sys_shutdown(int fd, int how);
+extern asmlinkage long sys_setsockopt(int fd, int level, int optname,
+	char *optval, int optlen);
+extern asmlinkage long sys_getsockopt(int fd, int level, int optname,
+	char *optval, int *optlen);
+extern asmlinkage long sys_sendmsg(int fd, struct msghdr *msg, unsigned flags);
+extern asmlinkage long sys_recvmsg(int fd, struct msghdr *msg,
+	unsigned int flags);
+
+
 /* Use this to get at 32-bit user passed pointers. */
 /* A() macro should be used for places where you e.g.
    have some internal variable u32 and just want to get
@@ -1463,9 +1495,6 @@
 	return ret;
 }
 
-extern asmlinkage int sys_setsockopt(int fd, int level, int optname,
-				     char *optval, int optlen);
-
 static int do_set_attach_filter(int fd, int level, int optname,
 				char *optval, int optlen)
 {
@@ -2130,13 +2159,36 @@
 		break;
 
 	default:
-		err = -ENOSYS;
+		err = -EINVAL;
 		break;
 	}
 
 	return err;
 }
 
+static inline void *alloc_user_space(long len)
+{
+	unsigned long sp = (unsigned long) current + THREAD_SIZE - 32;
+ 
+	return (void *) (sp - len);
+}
+
+static int sys32_semtimedop(int semid, struct sembuf *tsems, int nsems,
+                            const struct timespec32 *timeout32)
+{
+	struct timespec32 t32;
+	struct timespec *t64 = alloc_user_space(sizeof(*t64));
+
+	if (copy_from_user(&t32, timeout32, sizeof(t32)))
+		return -EFAULT;
+                                                                                
+	if (put_user(t32.tv_sec, &t64->tv_sec) ||
+	    put_user(t32.tv_nsec, &t64->tv_nsec))
+		return -EFAULT;
+
+	return sys_semtimedop(semid, tsems, nsems, t64);
+}
+
 asmlinkage long
 sys32_ipc (u32 call, int first, int second, int third, u32 ptr, u32 fifth)
 {
@@ -2149,8 +2201,12 @@
 
 	case SEMOP:
 		/* struct sembuf is the same on 32 and 64bit :)) */
-		err = sys_semop (first, (struct sembuf *)AA(ptr),
-				 second);
+		err = sys_semtimedop (first, (struct sembuf *)AA(ptr),
+		                      second, NULL);
+		break;
+	case SEMTIMEDOP:
+		err = sys32_semtimedop(first, (struct sembuf *)AA(ptr), second,
+		                       (const struct timespec32 *) AA(fifth));
 		break;
 	case SEMGET:
 		err = sys_semget (first, second, third);
@@ -2915,6 +2971,98 @@
 	return sys_readahead(fd, merge_64(a2, a3), count);
 }
 
+/* Argument list sizes for sys_socketcall */
+#define AL(x) ((x) * sizeof(unsigned int))
+static unsigned char socketcall_nargs[18]={AL(0),AL(3),AL(3),AL(3),AL(2),AL(3),
+				AL(3),AL(3),AL(4),AL(4),AL(4),AL(6),
+				AL(6),AL(2),AL(5),AL(5),AL(3),AL(3)};
+#undef AL
+
+/*
+ *	System call vectors. 
+ *
+ *	Argument checking cleaned up. Saved 20% in size.
+ *  This function doesn't need to set the kernel lock because
+ *  it is set by the callees. 
+ */
+
+asmlinkage long sys32_socketcall(int call, unsigned int *args32)
+{
+	unsigned int a[6];
+	unsigned int a0,a1;
+	int err;
+
+	if(call<1||call>SYS_RECVMSG)
+		return -EINVAL;
+
+	/* copy_from_user should be SMP safe. */
+	if (copy_from_user(a, args32, socketcall_nargs[call]))
+		return -EFAULT;
+		
+	a0=a[0];
+	a1=a[1];
+	
+	switch (call) {
+	case SYS_SOCKET:
+		err = sys_socket(a0,a1,a[2]);
+		break;
+	case SYS_BIND:
+		err = sys_bind(a0,(struct sockaddr *)A(a1), a[2]);
+		break;
+	case SYS_CONNECT:
+		err = sys_connect(a0, (struct sockaddr *)A(a1), a[2]);
+		break;
+	case SYS_LISTEN:
+		err = sys_listen(a0,a1);
+		break;
+	case SYS_ACCEPT:
+		err = sys_accept(a0,(struct sockaddr *)A(a1), (int *)A(a[2]));
+		break;
+	case SYS_GETSOCKNAME:
+		err = sys_getsockname(a0,(struct sockaddr *)A(a1), (int *)A(a[2]));
+		break;
+	case SYS_GETPEERNAME:
+		err = sys_getpeername(a0, (struct sockaddr *)A(a1), (int *)A(a[2]));
+		break;
+	case SYS_SOCKETPAIR:
+		err = sys_socketpair(a0,a1, a[2], (int *)A(a[3]));
+		break;
+	case SYS_SEND:
+		err = sys_send(a0, (void *)A(a1), a[2], a[3]);
+		break;
+	case SYS_SENDTO:
+		err = sys_sendto(a0,(void *)A(a1), a[2], a[3],
+				 (struct sockaddr *)A(a[4]), a[5]);
+		break;
+	case SYS_RECV:
+		err = sys_recv(a0, (void *)A(a1), a[2], a[3]);
+		break;
+	case SYS_RECVFROM:
+		err = sys_recvfrom(a0, (void *)A(a1), a[2], a[3],
+				   (struct sockaddr *)A(a[4]), (int *)A(a[5]));
+		break;
+	case SYS_SHUTDOWN:
+		err = sys_shutdown(a0,a1);
+		break;
+	case SYS_SETSOCKOPT:
+		err = sys_setsockopt(a0, a1, a[2], (char *)A(a[3]), a[4]);
+		break;
+	case SYS_GETSOCKOPT:
+		err = sys_getsockopt(a0, a1, a[2], (char *)A(a[3]), (int *)A(a[4]));
+		break;
+	case SYS_SENDMSG:
+		err = sys_sendmsg(a0, (struct msghdr *) A(a1), a[2]);
+		break;
+	case SYS_RECVMSG:
+		err = sys_recvmsg(a0, (struct msghdr *) A(a1), a[2]);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	return err;
+}
+
 #ifdef CONFIG_MODULES
 
 /* From sparc64 */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/kernel/scall_64.S linux-2.4.22/arch/mips64/kernel/scall_64.S
--- linux-2.4.22.clean/arch/mips64/kernel/scall_64.S	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/kernel/scall_64.S	2003-09-27 14:07:05.000000000 +0200
@@ -345,3 +345,6 @@
 	PTR	sys_ni_syscall
 	PTR	sys_ni_syscall			/* 5210 */
 	PTR	sys_rt_sigreturn
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_semtimedop
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/kernel/scall_n32.S linux-2.4.22/arch/mips64/kernel/scall_n32.S
--- linux-2.4.22.clean/arch/mips64/kernel/scall_n32.S	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/kernel/scall_n32.S	2003-09-27 14:07:05.000000000 +0200
@@ -348,7 +348,7 @@
 	PTR	sys_fcntl
 	PTR	sys_ni_syscall
 	PTR	sys_ni_syscall
-	PTR	sys_ni_syscall			/* 6215 */
+	PTR	sys_semtimedop			/* 6215 */
 	PTR	sys_ni_syscall
 	PTR	sys_ni_syscall
 	PTR	sys_ni_syscall
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/kernel/scall_o32.S linux-2.4.22/arch/mips64/kernel/scall_o32.S
--- linux-2.4.22.clean/arch/mips64/kernel/scall_o32.S	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/kernel/scall_o32.S	2003-09-27 14:07:05.000000000 +0200
@@ -426,7 +426,7 @@
 	sys	sys32_statfs	2
 	sys	sys32_fstatfs	2			/* 4100 */
 	sys	sys_ni_syscall	0	/* sys_ioperm */
-	sys	sys_socketcall	2
+	sys	sys32_socketcall	2
 	sys	sys_syslog	3
 	sys	sys32_setitimer	3
 	sys	sys32_getitimer	2			/* 4105 */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/kernel/signal32.c linux-2.4.22/arch/mips64/kernel/signal32.c
--- linux-2.4.22.clean/arch/mips64/kernel/signal32.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/kernel/signal32.c	2003-09-27 14:07:06.000000000 +0200
@@ -234,7 +234,7 @@
 		if (!access_ok(VERIFY_READ, uss, sizeof(*uss)))
 			return -EFAULT;
 		err |= __get_user(sp, &uss->ss_sp);
-		kss.ss_size = (long) sp;
+		kss.ss_sp = (void *) (long) sp;
 		err |= __get_user(kss.ss_size, &uss->ss_size);
 		err |= __get_user(kss.ss_flags, &uss->ss_flags);
 		if (err)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/kernel/time.c linux-2.4.22/arch/mips64/kernel/time.c
--- linux-2.4.22.clean/arch/mips64/kernel/time.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/kernel/time.c	2003-09-27 14:07:06.000000000 +0200
@@ -102,9 +102,9 @@
 
 
 /*
- * Timer ack for a R4k-compatible timer of a known frequency.
+ * Timer ack for an R4k-compatible timer of a known frequency.
  */
-static void c0_fixed_timer_ack(void)
+static void c0_timer_ack(void)
 {
 	unsigned int count;
 
@@ -129,22 +129,23 @@
 	return read_c0_count();
 }
 
-/* For unknown frequency.  */
+/* For use solely as a high precision timer.  */
 static void c0_hpt_init(unsigned int count)
 {
 	write_c0_count(read_c0_count() - count);
 }
 
-/* For a known frequency.  Used as an interrupt source.  */
-static void c0_fixed_hpt_init(unsigned int count)
+/* For use both as a high precision timer and an interrupt source.  */
+static void c0_hpt_timer_init(unsigned int count)
 {
-	expirelo = cycles_per_jiffy;
 	count = read_c0_count() - count;
-	write_c0_count(0);
-	write_c0_compare(cycles_per_jiffy);
+	expirelo = (count / cycles_per_jiffy + 1) * cycles_per_jiffy;
+	write_c0_count(expirelo - cycles_per_jiffy);
+	write_c0_compare(expirelo);
 	write_c0_count(count);
 }
 
+int (*mips_timer_state)(void);
 void (*mips_timer_ack)(void);
 unsigned int (*mips_hpt_read)(void);
 void (*mips_hpt_init)(unsigned int);
@@ -185,7 +186,7 @@
 	 * This is revolting.  We need to set "xtime" correctly.  However,
 	 * the value in this location is the value at the most recent update
 	 * of wall time.  Discover what correction gettimeofday() would have
-	 * done, and then undo it!
+	 * made, and then undo it!
 	 */
 	tv->tv_usec -= do_gettimeoffset();
 	tv->tv_usec -= (jiffies - wall_jiffies) * USECS_PER_JIFFY;
@@ -328,9 +329,9 @@
 				"dsll32	%1,%2,0\n\t"
 				"or	%1,%1,%0\n\t"
 				"ddivu	$0,%1,%4\n\t"
+				"mflo	%1\n\t"
 				"dsll32	%0,%5,0\n\t"
 				"or	%0,%0,%6\n\t"
-				"mflo	%1\n\t"
 				"ddivu	$0,%0,%1\n\t"
 				"mflo	%0\n\t"
 				".set	pop"
@@ -410,6 +411,7 @@
  */
 void timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
+	unsigned long j;
 	unsigned int count;
 
 	count = mips_hpt_read();
@@ -447,10 +449,41 @@
 	 * If jiffies has overflown in this timer_interrupt, we must
 	 * update the timer[hi]/[lo] to make fast gettimeoffset funcs
 	 * quotient calc still valid. -arca
-	 */
-	if (!jiffies) {
-		timerhi = timerlo = 0;
-		mips_hpt_init(count);
+	 *
+	 * The first timer interrupt comes late as interrupts are
+	 * enabled long after timers are initialized.  Therefore the
+	 * high precision timer is fast, leading to wrong gettimeoffset()
+	 * calculations.  We deal with it by setting it based on the
+	 * number of its ticks between the second and the third interrupt.
+	 * That is still somewhat imprecise, but it's a good estimate.
+	 * --macro
+	 */
+	j = jiffies;
+	if (j < 4) {
+		static unsigned int prev_count;
+		static int hpt_initialized;
+
+		switch (j) {
+		case 0:
+			timerhi = timerlo = 0;
+			mips_hpt_init(count);
+			break;
+		case 2:
+			prev_count = count;
+			break;
+		case 3:
+			if (!hpt_initialized) {
+				unsigned int c3 = 3 * (count - prev_count);
+
+				timerhi = 0;
+				timerlo = c3;
+				mips_hpt_init(count - c3);
+				hpt_initialized = 1;
+			}
+			break;
+		default:
+			break;
+		}
 	}
 
 #if !defined(CONFIG_SMP)
@@ -516,7 +549,7 @@
  *
  * 1) board_time_init() -
  * 	a) (optional) set up RTC routines,
- *      b) (optional) calibrate and set the mips_counter_frequency
+ *      b) (optional) calibrate and set the mips_hpt_frequency
  *	    (only needed if you intended to use fixed_rate_gettimeoffset
  *	     or use cpu counter as timer interrupt source)
  * 2) setup xtime based on rtc_get_time().
@@ -531,7 +564,7 @@
 void (*board_time_init)(void);
 void (*board_timer_setup)(struct irqaction *irq);
 
-unsigned int mips_counter_frequency;
+unsigned int mips_hpt_frequency;
 
 static struct irqaction timer_irqaction = {
 	.handler = timer_interrupt,
@@ -539,6 +572,49 @@
 	.name = "timer",
 };
 
+static unsigned int __init calibrate_hpt(void)
+{
+	u64 frequency;
+	u32 hpt_start, hpt_end, hpt_count, hz;
+
+	const int loops = HZ / 10;
+	int log_2_loops = 0;
+	int i;
+
+	/*
+	 * We want to calibrate for 0.1s, but to avoid a 64-bit
+	 * division we round the number of loops up to the nearest
+	 * power of 2.
+	 */
+	while (loops > 1 << log_2_loops)
+		log_2_loops++;
+	i = 1 << log_2_loops;
+
+	/*
+	 * Wait for a rising edge of the timer interrupt.
+	 */
+	while (mips_timer_state());
+	while (!mips_timer_state());
+
+	/*
+	 * Now see how many high precision timer ticks happen
+	 * during the calculated number of periods between timer
+	 * interrupts.
+	 */
+	hpt_start = mips_hpt_read();
+	do {
+		while (mips_timer_state());
+		while (!mips_timer_state());
+	} while (--i);
+	hpt_end = mips_hpt_read();
+
+	hpt_count = hpt_end - hpt_start;
+	hz = HZ;
+	frequency = (u64)hpt_count * (u64)hz;
+
+	return frequency >> log_2_loops;
+}
+
 void __init time_init(void)
 {
 	if (board_time_init)
@@ -555,7 +631,7 @@
 		/* No high precision timer -- sorry.  */
 		mips_hpt_read = null_hpt_read;
 		mips_hpt_init = null_hpt_init;
-	} else if (!mips_counter_frequency) {
+	} else if (!mips_hpt_frequency && !mips_timer_state) {
 		/* A high precision timer of unknown frequency.  */
 		if (!mips_hpt_read) {
 			/* No external high precision timer -- use R4k.  */
@@ -578,27 +654,36 @@
 			 */
 			do_gettimeoffset = calibrate_div64_gettimeoffset;
 	} else {
-		/* We know counter frequency! */
+		/* We know counter frequency.  Or we can get it.  */
 		if (!mips_hpt_read) {
 			/* No external high precision timer -- use R4k.  */
 			mips_hpt_read = c0_hpt_read;
-			mips_hpt_init = c0_fixed_hpt_init;
 
-			if (!mips_timer_ack)
-				/* R4k timer interrupt ack.  */
-				mips_timer_ack = c0_fixed_timer_ack;
+			if (mips_timer_state)
+				mips_hpt_init = c0_hpt_init;
+			else {
+				/* No external timer interrupt -- use R4k.  */
+				mips_hpt_init = c0_hpt_timer_init;
+				mips_timer_ack = c0_timer_ack;
+			}
 		}
+		if (!mips_hpt_frequency)
+			mips_hpt_frequency = calibrate_hpt();
 
 		do_gettimeoffset = fixed_rate_gettimeoffset;
 
 		/* Calculate cache parameters.  */
-		cycles_per_jiffy = mips_counter_frequency / HZ;
+		cycles_per_jiffy = (mips_hpt_frequency + HZ / 2) / HZ;
 
 		/* sll32_usecs_per_cycle = 10^6 * 2^32 / mips_counter_freq  */
-		/* Any better way to do this?  */
-		sll32_usecs_per_cycle = mips_counter_frequency / 100000;
-		sll32_usecs_per_cycle = 0xffffffff / sll32_usecs_per_cycle;
-		sll32_usecs_per_cycle *= 10;
+		do_div64_32(sll32_usecs_per_cycle,
+			    1000000, mips_hpt_frequency / 2,
+			    mips_hpt_frequency);
+
+		/* Report the high precision timer rate for a reference.  */
+		printk("Using %u.%03u MHz high precision timer.\n",
+		       ((mips_hpt_frequency + 500) / 1000) / 1000,
+		       ((mips_hpt_frequency + 500) / 1000) % 1000);
 	}
 
 	if (!mips_timer_ack)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/kernel/traps.c linux-2.4.22/arch/mips64/kernel/traps.c
--- linux-2.4.22.clean/arch/mips64/kernel/traps.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/kernel/traps.c	2003-09-27 14:07:06.000000000 +0200
@@ -533,6 +533,8 @@
 		simulate_sc(regs, opcode);
 		return 0;
 	}
+
+	return -EFAULT;			/* Strange things going on ... */
 }
 
 asmlinkage void do_ov(struct pt_regs *regs)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/Makefile linux-2.4.22/arch/mips64/Makefile
--- linux-2.4.22.clean/arch/mips64/Makefile	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/Makefile	2003-09-27 16:56:50.000000000 +0200
@@ -35,11 +35,11 @@
 # crossformat linking we rely on the elf2ecoff tool for format conversion.
 #
 GCCFLAGS	:= -I $(TOPDIR)/include/asm/gcc
-GCCFLAGS	+= -mabi=64 -G 0 -mno-abicalls -fno-pic -Wa,--trap -pipe
+GCCFLAGS	+= -mabi=64 -Wa,-mabi=o64 -G 0 -mno-abicalls -fno-pic -Wa,--trap -pipe
 LINKFLAGS	+= -G 0 -static # -N
 MODFLAGS	+= -mlong-calls
 
-ifdef CONFIG_KGDB
+ifdef CONFIG_DEBUG_INFO
 GCCFLAGS	+= -g
 ifdef CONFIG_SB1XXX_CORELIS
 GCCFLAGS	+= -mno-sched-prolog -fno-omit-frame-pointer
@@ -55,10 +55,10 @@
 GCCFLAGS	+= -mcpu=r4300 -mips3
 endif
 ifdef CONFIG_CPU_R4X00
-GCCFLAGS	+= -mcpu=r4600 -mips3
+GCCFLAGS	+= -march=r4600
 endif
 ifdef CONFIG_CPU_R5000
-GCCFLAGS	+= -mcpu=r8000 -mips4
+GCCFLAGS	+= -march=r5000
 endif
 ifdef CONFIG_CPU_NEVADA
 GCCFLAGS	+= -mcpu=r8000 -mips3 -mmad
@@ -274,7 +274,6 @@
 # convert to ECOFF using elf2ecoff.
 #
 ifdef CONFIG_BOOT_ELF32
-GCCFLAGS += -Wa,-32 $(shell if $(CC) -Wa,-mgp64 -c -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo "-Wa,-mgp64"; fi)
 LINKFLAGS += -T arch/mips64/ld.script.elf32
 endif
 #
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/Makefile.lib linux-2.4.22/arch/mips64/Makefile.lib
--- linux-2.4.22.clean/arch/mips64/Makefile.lib	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/arch/mips64/Makefile.lib	2003-08-18 04:59:02.000000000 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_LASAT) += crc32.o
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/mm/cerr-sb1.c linux-2.4.22/arch/mips64/mm/cerr-sb1.c
--- linux-2.4.22.clean/arch/mips64/mm/cerr-sb1.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/mm/cerr-sb1.c	2003-09-27 14:07:06.000000000 +0200
@@ -193,7 +193,9 @@
 		prom_printf(" c0_cerr_i   ==   %08x", cerr_i);
 		breakout_cerri(cerr_i);
 		if (CP0_CERRI_IDX_VALID(cerr_i)) {
-			if ((eepc & SB1_CACHE_INDEX_MASK) != (cerr_i & SB1_CACHE_INDEX_MASK))
+			/* Check index of EPC, allowing for delay slot */
+			if (((eepc & SB1_CACHE_INDEX_MASK) != (cerr_i & SB1_CACHE_INDEX_MASK)) &&
+			    ((eepc & SB1_CACHE_INDEX_MASK) != ((cerr_i & SB1_CACHE_INDEX_MASK) - 4)))
 				prom_printf(" cerr_i idx doesn't match eepc\n");
 			else {
 				res = extract_ic(cerr_i & SB1_CACHE_INDEX_MASK,
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/mm/c-sb1.c linux-2.4.22/arch/mips64/mm/c-sb1.c
--- linux-2.4.22.clean/arch/mips64/mm/c-sb1.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/mm/c-sb1.c	2003-09-27 14:07:06.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
  * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
- * Copyright (C) 2000, 2001 Broadcom Corporation
+ * Copyright (C) 2000, 2001, 2002, 2003 Broadcom Corporation
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -579,7 +579,6 @@
 	 * occur
 	 */
 	_flush_cache_range = (void *) sb1_nop;
-	_flush_cache_page = sb1_flush_cache_page;
 	_flush_cache_mm = (void (*)(struct mm_struct *))sb1_nop;
 	_flush_cache_all = sb1_nop;
 
@@ -590,6 +589,9 @@
 	_flush_cache_sigtramp = sb1_flush_cache_sigtramp;
 	_flush_data_cache_page = (void *) sb1_nop;
 
+	/* This implies an Icache flush too, so can't be nop'ed */
+	_flush_cache_page = sb1_flush_cache_page;
+
 	/* Full flushes */
 	___flush_cache_all = sb1___flush_cache_all;
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/arch/mips64/mm/tlb-sb1.c linux-2.4.22/arch/mips64/mm/tlb-sb1.c
--- linux-2.4.22.clean/arch/mips64/mm/tlb-sb1.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/mips64/mm/tlb-sb1.c	2003-09-27 14:07:06.000000000 +0200
@@ -18,6 +18,7 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
 #include <linux/config.h>
+#include <linux/init.h>
 #include <asm/mmu_context.h>
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
@@ -98,10 +99,13 @@
 	old_ctx = read_c0_entryhi() & ASID_MASK;
 	write_c0_entrylo0(0);
 	write_c0_entrylo1(0);
-	for (entry = 0; entry < current_cpu_data.tlbsize; entry++) {
+
+	entry = read_c0_wired();
+	while (entry < current_cpu_data.tlbsize) {
 		write_c0_entryhi(KSEG0 + (PAGE_SIZE << 1) * entry);
 		write_c0_index(entry);
 		tlb_write_indexed();
+		entry++;
 	}
 	write_c0_entryhi(old_ctx);
 	local_irq_restore(flags);
@@ -113,7 +117,7 @@
  * Use increments of the maximum page size (16MB), and check for duplicate
  * entries before doing a given write.  Then, when we're safe from collisions
  * with the firmware, go back and give all the entries invalid addresses with
- * the normal flush routine.
+ * the normal flush routine.  Wired entries will be killed as well!
  */
 void sb1_sanitize_tlb(void)
 {
@@ -254,6 +258,34 @@
 	local_irq_restore(flags);
 }
 
+void __init add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
+	unsigned long entryhi, unsigned long pagemask)
+{
+	unsigned long flags;
+	unsigned long wired;
+	unsigned long old_pagemask;
+	unsigned long old_ctx;
+
+	local_irq_save(flags);
+	old_ctx = read_c0_entryhi() & 0xff;
+	old_pagemask = read_c0_pagemask();
+	wired = read_c0_wired();
+	write_c0_wired(wired + 1);
+	write_c0_index(wired);
+
+	write_c0_pagemask(pagemask);
+	write_c0_entryhi(entryhi);
+	write_c0_entrylo0(entrylo0);
+	write_c0_entrylo1(entrylo1);
+	tlb_write_indexed();
+
+	write_c0_entryhi(old_ctx);
+	write_c0_pagemask(old_pagemask);
+
+	local_flush_tlb_all();
+	local_irq_restore(flags);
+}
+
 /*
  * This is called from loadmmu.c.  We have to set up all the
  * memory management function pointers, as well as initialize
@@ -262,6 +294,7 @@
 void sb1_tlb_init(void)
 {
 	write_c0_pagemask(PM_4K);
+	write_c0_wired(0);
 
 	/*
 	 * We don't know what state the firmware left the TLB's in, so this is
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/CREDITS linux-2.4.22/CREDITS
--- linux-2.4.22.clean/CREDITS	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/CREDITS	2003-09-27 14:06:41.000000000 +0200
@@ -1872,6 +1872,12 @@
 S: Niwot, Colorado 80503
 S: USA
 
+N: Pete Popov
+E: pete_popov@yahoo.com
+D: Linux/MIPS AMD/Alchemy Port and mips hacking and debugging
+S: San Jose, CA 95134
+S: USA
+
 N: Robert M. Love
 E: rml@tech9.net
 E: rml@ufl.edu
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/Documentation/Configure.help linux-2.4.22/Documentation/Configure.help
--- linux-2.4.22.clean/Documentation/Configure.help	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/Documentation/Configure.help	2003-09-27 14:06:46.000000000 +0200
@@ -4628,6 +4628,11 @@
   DECstation series (Personal DECstation 5000/20, /25, /33, /50,
   Codename "Maxine").
 
+PMAG-AA TURBOchannel framebuffer support
+CONFIG_FB_PMAG_AA
+  Support for the PMAG-AA TURBOchannel framebuffer card (1280x1024x1)
+  used mainly in the MIPS-based DECstation series.
+
 PMAG-BA TURBOchannel framebuffer support
 CONFIG_FB_PMAG_BA
   Support for the PMAG-BA TURBOchannel framebuffer card (1024x864x8)
@@ -11255,6 +11260,24 @@
   say M here and read <file:Documentation/modules.txt>.  This is
   recommended.  The module will be called tg3.o.
 
+MV-64340 Ethernet support
+CONFIG_MV64340_ETH
+  This driver supports the Marvell Discovery II MV64340 device
+  as an Ethernet controller.  Say Y here and select Port 0,1,2
+  as needed.  Otherwise, say N.
+
+MV-64340 Port 0
+CONFIG_MV64340_ETH_0
+  Enable port 0 on the MV64340 Ethernet controller.
+
+MV-64340 Port 1
+CONFIG_MV64340_ETH_1
+  Enable port 1 on the MV64340 Ethernet controller.
+
+MV-64340 Port 2
+CONFIG_MV64340_ETH_2
+  Enable port 2 on the MV64340 Ethernet controller.
+
 MyriCOM Gigabit Ethernet support
 CONFIG_MYRI_SBUS
   This driver supports MyriCOM Sbus gigabit Ethernet cards.
@@ -13807,7 +13830,7 @@
 
 DEC MS02-NV NVRAM module support
 CONFIG_MTD_MS02NV
-  This is a MTD driver for the DEC's MS02-NV (54-20948-01) battery
+  This is an MTD driver for the DEC's MS02-NV (54-20948-01) battery
   backed-up NVRAM module.  The module was originally meant as an NFS
   accelerator.  Say Y here if you have a DECstation 5000/2x0 or a
   DECsystem 5900 equipped with such a module.
@@ -18238,6 +18261,11 @@
   sensor.  Currently the device is only supported on a SiByte I2C
   adapter, and the driver prints status updates to the system log.
 
+SGI I2C Algorithm
+CONFIG_I2C_ALGO_SGI
+  Supports the SGI interfaces like the ones found on SGI Indy VINO
+  or SGI O2 MACE.
+
 I2C device interface
 CONFIG_I2C_CHARDEV
   Say Y here to use i2c-* device files, usually found in the /dev
@@ -26519,7 +26547,7 @@
 Include kgdb kernel debugger
 CONFIG_KGDB
   Include in-kernel hooks for kgdb, the Linux kernel source level
-  debugger.  This project has a web page at
+  debugger.  For i386 architecture there is project page at
   <http://kgdb.sourceforge.net/>.
 
 Include xmon kernel debugger
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/char/Config.in linux-2.4.22/drivers/char/Config.in
--- linux-2.4.22.clean/drivers/char/Config.in	2003-08-25 13:44:41.000000000 +0200
+++ linux-2.4.22/drivers/char/Config.in	2003-09-27 14:07:51.000000000 +0200
@@ -82,29 +82,49 @@
      fi
    fi
    if [ "$CONFIG_MIPS" = "y" ]; then
-     bool '  TX3912/PR31700 serial port support' CONFIG_SERIAL_TX3912
-     dep_bool '     Console on TX3912/PR31700 serial port' CONFIG_SERIAL_TX3912_CONSOLE $CONFIG_SERIAL_TX3912
-     bool '  Enable Au1000 UART Support' CONFIG_AU1000_UART
-     if [ "$CONFIG_AU1000_UART" = "y" ]; then
-        bool '        Enable Au1000 serial console' CONFIG_AU1000_SERIAL_CONSOLE
-     fi
-     bool 'TXx927 SIO support' CONFIG_TXX927_SERIAL 
-     if [ "$CONFIG_TXX927_SERIAL" = "y" ]; then
-        bool 'TXx927 SIO Console support' CONFIG_TXX927_SERIAL_CONSOLE  
-     fi                             
-     if [ "$CONFIG_SIBYTE_SB1250" = "y" ]; then
-        bool '  Support for sb1250 onchip DUART' CONFIG_SIBYTE_SB1250_DUART
-        if [ "$CONFIG_SIBYTE_SB1250_DUART" = "y" ]; then
-           bool '  Console on SB1250 DUART' CONFIG_SIBYTE_SB1250_DUART_CONSOLE
-	   if [ "$CONFIG_SIBYTE_SB1250_DUART_CONSOLE" = "y" ]; then
-	      define_bool CONFIG_SERIAL_CONSOLE y
-	   fi
-	   int  '  Output buffers size (in bytes)' CONFIG_SB1250_DUART_OUTPUT_BUF_SIZE 1024
-	   bool '  Leave port 1 alone (for kgdb or audio)' CONFIG_SIBYTE_SB1250_DUART_NO_PORT_1
-       fi
-     fi
-  fi
+      bool '  TX3912/PR31700 serial port support' CONFIG_SERIAL_TX3912
+      dep_bool '     Console on TX3912/PR31700 serial port' CONFIG_SERIAL_TX3912_CONSOLE $CONFIG_SERIAL_TX3912
+      bool '  TMPTX39XX/49XX serial port support' CONFIG_SERIAL_TXX9
+      dep_bool '     Console on TMPTX39XX/49XX serial port' CONFIG_SERIAL_TXX9_CONSOLE $CONFIG_SERIAL_TXX9
+      if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
+	 bool '  Enable Au1x00 UART Support' CONFIG_AU1X00_UART
+	 if [ "$CONFIG_AU1X00_UART" = "y" ]; then
+	    bool '        Enable Au1x00 serial console' CONFIG_AU1X00_SERIAL_CONSOLE
+         fi
+         dep_tristate '  Au1x00 USB TTY Device support' CONFIG_AU1X00_USB_TTY $CONFIG_SOC_AU1X00
+	    if [ "$CONFIG_AU1000_USB_TTY" != "y" ]; then
+	       dep_tristate '  Au1x00 USB Raw Device support' CONFIG_AU1X00_USB_RAW $CONFIG_SOC_AU1X00
+	    fi
+	    if [ "$CONFIG_AU1X00_USB_TTY" != "n" -o \
+	         "$CONFIG_AU1X00_USB_RAW" != "n" ]; then
+		 define_bool CONFIG_AU1X00_USB_DEVICE y
+	    fi
+      fi
+      bool '  TXx927 SIO support' CONFIG_TXX927_SERIAL 
+      if [ "$CONFIG_TXX927_SERIAL" = "y" ]; then
+         bool '    TXx927 SIO Console support' CONFIG_TXX927_SERIAL_CONSOLE  
+      fi                             
+      if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
+         bool '  Support for BCM1xxx onchip DUART' CONFIG_SIBYTE_SB1250_DUART
+         if [ "$CONFIG_SIBYTE_SB1250_DUART" = "y" ]; then
+            bool '    Console on BCM1xxx DUART' CONFIG_SIBYTE_SB1250_DUART_CONSOLE
+            if [ "$CONFIG_SIBYTE_SB1250_DUART_CONSOLE" = "y" ]; then
+               define_bool CONFIG_SERIAL_CONSOLE y
+            fi
+         fi
+      fi
+   fi
+   if [ "$CONFIG_DECSTATION" = "y" ]; then
+      bool '  DECstation serial support' CONFIG_SERIAL_DEC
+      dep_bool '    Support for console on a DECstation serial port' CONFIG_SERIAL_DEC_CONSOLE $CONFIG_SERIAL_DEC
+      dep_bool '    DZ11 serial support' CONFIG_DZ $CONFIG_SERIAL_DEC $CONFIG_MIPS32
+      dep_bool '    Z85C30 serial support' CONFIG_ZS $CONFIG_SERIAL_DEC $CONFIG_TC
+   fi
+   if [ "$CONFIG_SGI_IP22" = "y" ]; then
+      bool '  SGI Zilog85C30 serial support' CONFIG_IP22_SERIAL
+   fi
 fi
+
 if [ "$CONFIG_EXPERIMENTAL" = "y" -a "$CONFIG_ZORRO" = "y" ]; then
    tristate 'Commodore A2232 serial support (EXPERIMENTAL)' CONFIG_A2232
 fi
@@ -116,14 +136,6 @@
       fi
       bool '  Console on DC21285 serial port' CONFIG_SERIAL_21285_CONSOLE
    fi
-   if [ "$CONFIG_MIPS" = "y" ]; then
-     bool '  TMPTX3912/PR31700 serial port support' CONFIG_SERIAL_TX3912
-     dep_bool '     Console on TMPTX3912/PR31700 serial port' CONFIG_SERIAL_TX3912_CONSOLE $CONFIG_SERIAL_TX3912
-     bool '  Enable Au1000 UART Support' CONFIG_AU1000_UART
-     if [ "$CONFIG_AU1000_UART" = "y" ]; then
-         bool '        Enable Au1000 serial console' CONFIG_AU1000_SERIAL_CONSOLE
-     fi
-   fi
    if [ "$CONFIG_PARISC" = "y" ]; then
      bool '  PDC software console support' CONFIG_PDC_CONSOLE
    fi
@@ -177,6 +189,9 @@
    if [ "$CONFIG_ADB" = "y" -a "$CONFIG_ADB_KEYBOARD" = "y" ]; then
       dep_tristate '  Apple Desktop Bus mouse support (old driver)' CONFIG_ADBMOUSE $CONFIG_BUSMOUSE
    fi
+#   if [ "$CONFIG_DECSTATION" = "y" ]; then
+#      dep_bool '  MAXINE Access.Bus mouse (VSXXX-BB/GB) support' CONFIG_DTOP_MOUSE $CONFIG_ACCESSBUS
+#   fi
 fi
 
 tristate 'Mouse Support (not serial and bus mice)' CONFIG_MOUSE
@@ -228,9 +243,6 @@
    tristate '  Eurotech CPU-1220/1410 Watchdog Timer' CONFIG_EUROTECH_WDT
    tristate '  IB700 SBC Watchdog Timer' CONFIG_IB700_WDT
    tristate '  ICP ELectronics Wafer 5823 Watchdog' CONFIG_WAFER_WDT
-   if [ "$CONFIG_SGI_IP22" = "y" ]; then
-      dep_tristate '  Indy/I2 Hardware Watchdog' CONFIG_INDYDOG $CONFIG_SGI_IP22
-   fi
    tristate '  Intel i810 TCO timer / Watchdog' CONFIG_I810_TCO
    tristate '  Mixcom Watchdog' CONFIG_MIXCOMWD 
    tristate '  SBC-60XX Watchdog Timer' CONFIG_60XX_WDT
@@ -247,6 +259,7 @@
       fi
    fi
    tristate '  ZF MachZ Watchdog' CONFIG_MACHZ_WDT
+   dep_tristate '  Indy/I2 Hardware Watchdog' CONFIG_INDYDOG $CONFIG_SGI_IP22
    dep_tristate '  AMD 766/768 TCO Timer/Watchdog' CONFIG_AMD7XX_TCO $CONFIG_EXPERIMENTAL
 fi
 endmenu
@@ -276,6 +289,15 @@
 if [ "$CONFIG_OBSOLETE" = "y" -a "$CONFIG_ALPHA_BOOK1" = "y" ]; then
    bool 'Tadpole ANA H8 Support (OBSOLETE)'  CONFIG_H8
 fi
+if [ "$CONFIG_MIPS" = "y" -a "$CONFIG_NEW_TIME_C" = "y" ]; then
+   tristate 'Generic MIPS RTC Support' CONFIG_MIPS_RTC
+fi
+if [ "$CONFIG_SGI_IP22" = "y" ]; then
+   bool 'SGI DS1286 RTC support' CONFIG_SGI_DS1286
+fi
+if [ "$CONFIG_SGI_IP27" = "y" ]; then
+   bool 'SGI M48T35 RTC support' CONFIG_SGI_IP27_RTC
+fi
 
 tristate 'Double Talk PC internal speech card support' CONFIG_DTLK
 tristate 'Siemens R3964 line discipline' CONFIG_R3964
@@ -290,6 +312,7 @@
 if [ "$CONFIG_FTAPE" != "n" ]; then
    source drivers/char/ftape/Config.in
 fi
+
 endmenu
 
 if [ "$CONFIG_GART_IOMMU" = "y" ]; then
@@ -333,16 +356,11 @@
 if [ "$CONFIG_HOTPLUG" = "y" -a "$CONFIG_PCMCIA" != "n" ]; then
    source drivers/char/pcmcia/Config.in
 fi
-if [ "$CONFIG_MIPS_AU1000" = "y" ]; then
-   tristate ' Alchemy Au1000 GPIO device support' CONFIG_AU1000_GPIO
-   tristate ' Au1000/ADS7846 touchscreen support' CONFIG_TS_AU1000_ADS7846
+if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
+   tristate ' Alchemy Au1x00 GPIO device support' CONFIG_AU1X00_GPIO
+   tristate ' Au1000/ADS7846 touchscreen support' CONFIG_TS_AU1X00_ADS7846
 fi
 if [ "$CONFIG_MIPS_ITE8172" = "y" ]; then
   tristate ' ITE GPIO' CONFIG_ITE_GPIO
 fi
-
-if [ "$CONFIG_X86" = "y" ]; then
-   tristate 'ACP Modem (Mwave) support' CONFIG_MWAVE
-fi
-
 endmenu
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/char/defkeymap.c linux-2.4.22/drivers/char/defkeymap.c
--- linux-2.4.22.clean/drivers/char/defkeymap.c	1999-10-07 19:17:09.000000000 +0200
+++ linux-2.4.22/drivers/char/defkeymap.c	2003-09-27 14:07:51.000000000 +0200
@@ -37,7 +37,7 @@
 	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
 	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03e,	0xf10a,
 	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
 	0xf20b,	0xf601,	0xf602,	0xf117,	0xf600,	0xf20a,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
@@ -56,7 +56,7 @@
 	0xf912,	0xf913,	0xf30b,	0xf90e,	0xf90f,	0xf910,	0xf30a,	0xf90b,
 	0xf90c,	0xf90d,	0xf90a,	0xf310,	0xf206,	0xf200,	0xf07c,	0xf516,
 	0xf517,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
@@ -94,7 +94,7 @@
 	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
 	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf200,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
@@ -132,7 +132,7 @@
 	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
 	0xf302,	0xf303,	0xf300,	0xf20c,	0xf206,	0xf200,	0xf200,	0xf50a,
 	0xf50b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf20c,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/char/dz.c linux-2.4.22/drivers/char/dz.c
--- linux-2.4.22.clean/drivers/char/dz.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-2.4.22/drivers/char/dz.c	2003-09-27 14:07:51.000000000 +0200
@@ -21,7 +21,7 @@
  * [07-SEP-99] Bugfixes 
  */
 
-#define DEBUG_DZ 1
+#undef DEBUG_DZ
 
 #include <linux/config.h>
 #include <linux/version.h>
@@ -254,13 +254,19 @@
 
 			if (tmp & DZ_PERR) {
 				*tty->flip.flag_buf_ptr = TTY_PARITY;
+#ifdef DEBUG_DZ
 				debug_console("PERR\n", 5);
+#endif
 			} else if (tmp & DZ_FERR) {
 				*tty->flip.flag_buf_ptr = TTY_FRAME;
+#ifdef DEBUG_DZ
 				debug_console("FERR\n", 5);
+#endif
 			}
 			if (tmp & DZ_OERR) {
+#ifdef DEBUG_DZ
 				debug_console("OERR\n", 5);
+#endif
 				if (tty->flip.count < TTY_FLIPBUF_SIZE) {
 					tty->flip.count++;
 					tty->flip.flag_buf_ptr++;
@@ -1299,7 +1305,7 @@
 
 int __init dz_init(void)
 {
-	int i, tmp;
+	int i;
 	long flags;
 	struct dz_serial *info;
 
@@ -1413,7 +1419,7 @@
 	/* reset the chip */
 #ifndef CONFIG_SERIAL_DEC_CONSOLE
 	dz_out(info, DZ_CSR, DZ_CLR);
-	while ((tmp = dz_in(info, DZ_CSR)) & DZ_CLR);
+	while (dz_in(info, DZ_CSR) & DZ_CLR);
 	iob();
 
 	/* enable scanning */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/char/Makefile linux-2.4.22/drivers/char/Makefile
--- linux-2.4.22.clean/drivers/char/Makefile	2003-08-25 13:44:41.000000000 +0200
+++ linux-2.4.22/drivers/char/Makefile	2003-09-27 14:07:51.000000000 +0200
@@ -24,7 +24,7 @@
 export-objs     :=	busmouse.o console.o keyboard.o sysrq.o \
 			misc.o pty.o random.o selection.o serial.o \
 			sonypi.o tty_io.o tty_ioctl.o generic_serial.o \
-			au1000_gpio.o hp_psaux.o nvram.o scx200.o
+			au1000_gpio.o vac-serial.o hp_psaux.o nvram.o scx200.o
 
 mod-subdirs	:=	joystick ftape drm drm-4.0 pcmcia
 
@@ -140,12 +140,11 @@
 ifeq ($(CONFIG_DECSTATION),y)
   KEYMAP   =
   KEYBD    =
-  SERIAL   = decserial.o
 endif
 
 ifeq ($(CONFIG_BAGET_MIPS),y)
   KEYBD    =
-  SERIAL   =
+  SERIAL   = vac-serial.o
 endif
 
 ifeq ($(CONFIG_NINO),y)
@@ -171,7 +170,8 @@
 obj-$(CONFIG_SERIAL_21285) += serial_21285.o
 obj-$(CONFIG_SERIAL_SA1100) += serial_sa1100.o
 obj-$(CONFIG_SERIAL_AMBA) += serial_amba.o
-obj-$(CONFIG_TS_AU1000_ADS7846) += au1000_ts.o
+obj-$(CONFIG_TS_AU1X00_ADS7846) += au1000_ts.o
+obj-$(CONFIG_SERIAL_DEC) += decserial.o
 
 ifndef CONFIG_SUN_KEYBOARD
   obj-$(CONFIG_VT) += keyboard.o $(KEYMAP) $(KEYBD)
@@ -211,6 +211,9 @@
 obj-$(CONFIG_HVC_CONSOLE) += hvc_console.o
 obj-$(CONFIG_SERIAL_TX3912) += generic_serial.o serial_tx3912.o
 obj-$(CONFIG_TXX927_SERIAL) += serial_txx927.o
+obj-$(CONFIG_SERIAL_TXX9) += generic_serial.o serial_txx9.o
+obj-$(CONFIG_IP22_SERIAL) += sgiserial.o
+obj-$(CONFIG_AU1X00_UART) += au1x00-serial.o
 
 subdir-$(CONFIG_RIO) += rio
 subdir-$(CONFIG_INPUT) += joystick
@@ -239,6 +242,9 @@
 obj-$(CONFIG_RTC) += rtc.o
 obj-$(CONFIG_GEN_RTC) += genrtc.o
 obj-$(CONFIG_EFI_RTC) += efirtc.o
+obj-$(CONFIG_SGI_DS1286) += ds1286.o
+obj-$(CONFIG_MIPS_RTC) += mips_rtc.o
+obj-$(CONFIG_SGI_IP27_RTC) += ip27-rtc.o
 ifeq ($(CONFIG_PPC),)
   obj-$(CONFIG_NVRAM) += nvram.o
 endif
@@ -251,7 +257,9 @@
 obj-$(CONFIG_BRIQ_PANEL) += briq_panel.o
 
 obj-$(CONFIG_ITE_GPIO) += ite_gpio.o
-obj-$(CONFIG_AU1000_GPIO) += au1000_gpio.o
+obj-$(CONFIG_AU1X00_GPIO) += au1000_gpio.o
+obj-$(CONFIG_AU1X00_USB_TTY) += au1000_usbtty.o
+obj-$(CONFIG_AU1X00_USB_RAW) += au1000_usbraw.o
 obj-$(CONFIG_COBALT_LCD) += lcd.o
 
 obj-$(CONFIG_QIC02_TAPE) += tpqic02.o
@@ -302,6 +310,7 @@
 obj-$(CONFIG_WAFER_WDT) += wafer5823wdt.o
 obj-$(CONFIG_SOFT_WATCHDOG) += softdog.o
 obj-$(CONFIG_AMD7XX_TCO) += amd7xx_tco.o
+obj-$(CONFIG_INDYDOG) += indydog.o
 
 subdir-$(CONFIG_MWAVE) += mwave
 ifeq ($(CONFIG_MWAVE),y)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/char/rtc.c linux-2.4.22/drivers/char/rtc.c
--- linux-2.4.22.clean/drivers/char/rtc.c	2003-06-13 16:51:33.000000000 +0200
+++ linux-2.4.22/drivers/char/rtc.c	2003-07-05 05:23:35.000000000 +0200
@@ -35,17 +35,16 @@
  *	1.09a	Pete Zaitcev: Sun SPARC
  *	1.09b	Jeff Garzik: Modularize, init cleanup
  *	1.09c	Jeff Garzik: SMP cleanup
- *	1.10    Paul Barton-Davis: add support for async I/O
+ *	1.10	Paul Barton-Davis: add support for async I/O
  *	1.10a	Andrea Arcangeli: Alpha updates
  *	1.10b	Andrew Morton: SMP lock fix
  *	1.10c	Cesar Barros: SMP locking fixes and cleanup
  *	1.10d	Paul Gortmaker: delete paranoia check in rtc_exit
  *	1.10e	Maciej W. Rozycki: Handle DECstation's year weirdness.
+ *	1.10f	Maciej W. Rozycki: Handle memory-mapped chips properly.
  */
 
-#define RTC_VERSION		"1.10e"
-
-#define RTC_IO_EXTENT	0x10	/* Only really two ports, but...	*/
+#define RTC_VERSION		"1.10f"
 
 /*
  *	Note that *all* calls to CMOS_READ and CMOS_WRITE are done with
@@ -84,7 +83,9 @@
 static int rtc_irq = PCI_IRQ_NONE;
 #endif
 
+#if RTC_IRQ
 static int rtc_has_irq = 1;
+#endif
 
 /*
  *	We sponge a minor off of the misc major. No need slurping
@@ -97,7 +98,9 @@
 
 static DECLARE_WAIT_QUEUE_HEAD(rtc_wait);
 
+#if RTC_IRQ
 static struct timer_list rtc_irq_timer;
+#endif
 
 static ssize_t rtc_read(struct file *file, char *buf,
 			size_t count, loff_t *ppos);
@@ -238,7 +241,15 @@
 	if (rtc_has_irq == 0)
 		return -EIO;
 
-	if (count < sizeof(unsigned long))
+	/*
+	 * Historically this function used to assume that sizeof(unsigned long)
+	 * is the same in userspace and kernelspace.  This lead to problems
+	 * for configurations with multiple ABIs such a the MIPS o32 and 64
+	 * ABIs supported on the same kernel.  So now we support read of both
+	 * 4 and 8 bytes and assume that's the sizeof(unsigned long) in the
+	 * userspace ABI.
+	 */
+	if (count != sizeof(unsigned int) && count !=  sizeof(unsigned long))
 		return -EINVAL;
 
 	add_wait_queue(&rtc_wait, &wait);
@@ -268,9 +279,12 @@
 		schedule();
 	} while (1);
 
-	retval = put_user(data, (unsigned long *)buf); 
+	if (count == sizeof(unsigned int))
+		retval = put_user(data, (unsigned int *)buf); 
+	else
+		retval = put_user(data, (unsigned long *)buf);
 	if (!retval)
-		retval = sizeof(unsigned long); 
+		retval = count;
  out:
 	current->state = TASK_RUNNING;
 	remove_wait_queue(&rtc_wait, &wait);
@@ -706,6 +720,9 @@
 	struct isa_device *isa_dev;
 #endif
 #endif
+#ifndef __sparc__
+	void *r;
+#endif
 
 #ifdef __sparc__
 	for_each_ebus(ebus) {
@@ -752,18 +769,24 @@
 	}
 no_irq:
 #else
-	if (!request_region(RTC_PORT(0), RTC_IO_EXTENT, "rtc"))
-	{
-		printk(KERN_ERR "rtc: I/O port %d is not free.\n", RTC_PORT (0));
+	if (RTC_IOMAPPED)
+		r = request_region(RTC_PORT(0), RTC_IO_EXTENT, "rtc");
+	else
+		r = request_mem_region(RTC_PORT(0), RTC_IO_EXTENT, "rtc");
+	if (!r) {
+		printk(KERN_ERR "rtc: I/O resource %lx is not free.\n",
+		       (long)(RTC_PORT(0)));
 		return -EIO;
 	}
 
 #if RTC_IRQ
-	if(request_irq(RTC_IRQ, rtc_interrupt, SA_INTERRUPT, "rtc", NULL))
-	{
+	if(request_irq(RTC_IRQ, rtc_interrupt, SA_INTERRUPT, "rtc", NULL)) {
 		/* Yeah right, seeing as irq 8 doesn't even hit the bus. */
 		printk(KERN_ERR "rtc: IRQ %d is not free.\n", RTC_IRQ);
-		release_region(RTC_PORT(0), RTC_IO_EXTENT);
+		if (RTC_IOMAPPED)
+			release_region(RTC_PORT(0), RTC_IO_EXTENT);
+		else
+			release_mem_region(RTC_PORT(0), RTC_IO_EXTENT);
 		return -EIO;
 	}
 #endif
@@ -847,7 +870,10 @@
 	if (rtc_has_irq)
 		free_irq (rtc_irq, &rtc_port);
 #else
-	release_region (RTC_PORT (0), RTC_IO_EXTENT);
+	if (RTC_IOMAPPED)
+		release_region(RTC_PORT(0), RTC_IO_EXTENT);
+	else
+		release_mem_region(RTC_PORT(0), RTC_IO_EXTENT);
 #if RTC_IRQ
 	if (rtc_has_irq)
 		free_irq (RTC_IRQ, NULL);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/char/sb1250_duart.c linux-2.4.22/drivers/char/sb1250_duart.c
--- linux-2.4.22.clean/drivers/char/sb1250_duart.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-2.4.22/drivers/char/sb1250_duart.c	2003-09-27 14:07:51.000000000 +0200
@@ -910,6 +910,8 @@
 			     port->mode_2, i);
 		WRITE_SERCSR(V_DUART_BAUD_RATE(115200),
 			     port->clk_sel, i);
+		WRITE_SERCSR(M_DUART_RX_EN|M_DUART_TX_EN,
+			     port->cmd, i);
 	}
 	return 0;
 }
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/char/serial.c linux-2.4.22/drivers/char/serial.c
--- linux-2.4.22.clean/drivers/char/serial.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-2.4.22/drivers/char/serial.c	2003-09-27 14:07:52.000000000 +0200
@@ -62,6 +62,12 @@
  *        Robert Schwebel <robert@schwebel.de>,
  *        Juergen Beisert <jbeisert@eurodsn.de>,
  *        Theodore Ts'o <tytso@mit.edu>
+ *
+ * 10/00: Added suport for MIPS Atlas board.
+ * 11/00: Hooks for serial kernel debug port support added.
+ *        Kevin D. Kissell, kevink@mips.com and Carsten Langgaard,
+ *        carstenl@mips.com
+ *        Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
  */
 
 static char *serial_version = "5.05c";
@@ -413,6 +419,22 @@
 	return 0;
 }
 
+#if defined(CONFIG_MIPS_ATLAS) || defined(CONFIG_MIPS_SEAD)
+
+#include <asm/mips-boards/atlas.h>
+
+static _INLINE_ unsigned int serial_in(struct async_struct *info, int offset)
+{
+        return (*(volatile unsigned int *)(mips_io_port_base + ATLAS_UART_REGS_BASE + offset*8) & 0xff);
+}
+
+static _INLINE_ void serial_out(struct async_struct *info, int offset, int value)
+{
+        *(volatile unsigned int *)(mips_io_port_base + ATLAS_UART_REGS_BASE + offset*8) = value;
+}
+
+#else
+
 static _INLINE_ unsigned int serial_in(struct async_struct *info, int offset)
 {
 	switch (info->io_type) {
@@ -447,6 +469,8 @@
 		outb(value, info->port+offset);
 	}
 }
+#endif
+
 
 /*
  * We used to support using pause I/O for certain machines.  We
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/i2c/Config.in linux-2.4.22/drivers/i2c/Config.in
--- linux-2.4.22.clean/drivers/i2c/Config.in	2003-08-25 13:44:41.000000000 +0200
+++ linux-2.4.22/drivers/i2c/Config.in	2003-09-27 14:07:55.000000000 +0200
@@ -54,11 +54,12 @@
       dep_tristate '  MAX1617 Temperature Sensor' CONFIG_I2C_MAX1617 $CONFIG_I2C_ALGO_SIBYTE
    fi
 
+  dep_tristate 'I2C SGI interfaces' CONFIG_I2C_ALGO_SGI $CONFIG_I2C
+ 
 # This is needed for automatic patch generation: sensors code starts here
 # This is needed for automatic patch generation: sensors code ends here
 
    dep_tristate 'I2C device interface' CONFIG_I2C_CHARDEV $CONFIG_I2C
    dep_tristate 'I2C /proc interface (required for hardware sensors)' CONFIG_I2C_PROC $CONFIG_I2C
-
 fi
 endmenu
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/i2c/i2c-algo-sgi.c linux-2.4.22/drivers/i2c/i2c-algo-sgi.c
--- linux-2.4.22.clean/drivers/i2c/i2c-algo-sgi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/i2c/i2c-algo-sgi.c	2003-09-11 17:36:48.000000000 +0200
@@ -0,0 +1,211 @@
+/*
+ * i2c-algo-sgi.c: i2c driver algorithms for SGI adapters.
+ * 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License version 2 as published by the Free Software Foundation.
+ *
+ * Copyright (C) 2003 Ladislav Michl <ladis@linux-mips.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-sgi.h>
+
+
+#define SGI_I2C_FORCE_IDLE	(0 << 0)
+#define SGI_I2C_NOT_IDLE	(1 << 0)
+#define SGI_I2C_WRITE		(0 << 1)
+#define SGI_I2C_READ		(1 << 1)
+#define SGI_I2C_RELEASE_BUS	(0 << 2)
+#define SGI_I2C_HOLD_BUS	(1 << 2)
+#define SGI_I2C_XFER_DONE	(0 << 4)
+#define SGI_I2C_XFER_BUSY	(1 << 4)
+#define SGI_I2C_ACK		(0 << 5)
+#define SGI_I2C_NACK		(1 << 5)
+#define SGI_I2C_BUS_OK		(0 << 7)
+#define SGI_I2C_BUS_ERR		(1 << 7)
+
+#define get_control(adap)	adap->getctrl(adap->data)
+#define set_control(adap, val)	adap->setctrl(adap->data, val)
+#define read_data(adap)		adap->rdata(adap->data)
+#define write_data(adap, val)	adap->wdata(adap->data, val)
+
+/* I2C debugging? */
+#if 1
+#define DEBUGI2C(x...)     printk(x);
+#else
+#define DEBUGI2C(x...)
+#endif
+
+static int wait_xfer_done(struct i2c_algo_sgi_data *adap)
+{
+	int i;
+
+	for (i = 0; i < adap->xfer_timeout; i++) {
+		if ((get_control(adap) & SGI_I2C_XFER_BUSY) == 0)
+			return 0;
+		udelay(1);
+	}
+
+	DEBUGI2C("sgi_i2c: timeout waiting for xfer done.\n");
+
+	return -ETIMEDOUT;
+}
+
+static int wait_ack(struct i2c_algo_sgi_data *adap)
+{
+	int i;
+
+	if (wait_xfer_done(adap))
+		return -ETIMEDOUT;
+	for (i = 0; i < adap->ack_timeout; i++) {
+		if ((get_control(adap) & SGI_I2C_NACK) == 0)
+			return 0;
+		udelay(1);
+	}
+
+	DEBUGI2C("sgi_i2c: timeout waiting for ack.\n");
+
+	return -ETIMEDOUT;
+}
+
+static int force_idle(struct i2c_algo_sgi_data *adap)
+{
+	int i;
+
+	set_control(adap, SGI_I2C_FORCE_IDLE);
+	for (i = 0; i < adap->xfer_timeout; i++) {
+		if ((get_control(adap) & SGI_I2C_NOT_IDLE) == 0)
+			goto out;
+		udelay(1);
+	}
+	return -ETIMEDOUT;
+out:
+	if (get_control(adap) & SGI_I2C_BUS_ERR) {
+		return -EIO;
+	}
+	return 0;
+}
+
+static int do_address(struct i2c_algo_sgi_data *adap, unsigned int addr,
+		      int rd, int release)
+{
+	DEBUGI2C("preparing to %s %02x.\n", rd ? "read from" : "write to",
+		 addr);
+	/* Check if bus is idle, eventually force it to do so */
+	if ((get_control(adap) & SGI_I2C_NOT_IDLE) == 0)
+		if (force_idle(adap))
+	                return -EIO;
+	/* Write out the i2c chip address and specify operation */
+	set_control(adap, (release ? SGI_I2C_RELEASE_BUS : SGI_I2C_HOLD_BUS) |
+			  SGI_I2C_WRITE | SGI_I2C_NOT_IDLE);
+	write_data(adap, addr | (rd ? 1 : 0));
+	if (wait_ack(adap))
+		return -EIO;
+	return 0;
+}
+
+static int i2c_read(struct i2c_algo_sgi_data *adap, unsigned char *buf,
+		    unsigned int len, int last)
+{
+	int i;
+
+	DEBUGI2C("i2c_read\n");
+	set_control(adap, (last && len < 2 ?
+			  SGI_I2C_RELEASE_BUS : SGI_I2C_HOLD_BUS) |
+			  SGI_I2C_READ | SGI_I2C_NOT_IDLE);
+	for (i = 0; i < len; i++) {
+		if (last && len == i + 1)
+			set_control(adap, SGI_I2C_RELEASE_BUS |
+					  SGI_I2C_READ |
+					  SGI_I2C_NOT_IDLE);
+		if (wait_xfer_done(adap))
+			return -EIO;
+		buf[i] = read_data(adap);
+	}
+	return 0;
+
+}
+
+static int i2c_write(struct i2c_algo_sgi_data *adap, unsigned char *buf,
+		     unsigned int len, int last)
+{
+	int i;
+
+	DEBUGI2C("i2c_write\n");
+	/* We are already in write state */
+	for (i = 0; i < len; i++) {
+		if (last && len == i + 1)
+			set_control(adap, SGI_I2C_RELEASE_BUS |
+					  SGI_I2C_WRITE |
+					  SGI_I2C_NOT_IDLE);
+		DEBUGI2C("writing %02x\n", buf[i]);
+		write_data(adap, buf[i]);
+		if (wait_ack(adap))
+			return -EIO;
+	}
+	return 0;
+}
+
+static int sgi_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[],
+		    int num)
+{
+	struct i2c_algo_sgi_data *adap = i2c_adap->algo_data;
+	struct i2c_msg *p;
+	int i, err = 0;
+  
+	for (i = 0; !err && i < num; i++) {
+		p = &msgs[i];
+		err = do_address(adap, p->addr, p->flags & I2C_M_RD,
+				 p->len == 0);
+		if (err || p->len == 0)
+			continue;
+		if (p->flags & I2C_M_RD)
+			err = i2c_read(adap, p->buf, p->len, num == i + 1);
+		else
+			err = i2c_write(adap, p->buf, p->len, num == i + 1);
+	}
+
+	return err;
+}
+
+static u32 sgi_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_EMUL;
+}
+
+static struct i2c_algorithm sgi_algo = {
+	.name		= "SGI algorithm",
+	.id		= I2C_ALGO_SGI,
+	.master_xfer	= sgi_xfer,
+	.functionality	= sgi_func,
+};
+
+/* 
+ * registering functions to load algorithms at runtime 
+ */
+int i2c_sgi_add_bus(struct i2c_adapter *adap)
+{
+	adap->id |= sgi_algo.id;
+	adap->algo = &sgi_algo;
+
+	return i2c_add_adapter(adap);
+}
+
+
+int i2c_sgi_del_bus(struct i2c_adapter *adap)
+{
+	return i2c_del_adapter(adap);
+}
+
+EXPORT_SYMBOL(i2c_sgi_add_bus);
+EXPORT_SYMBOL(i2c_sgi_del_bus);
+
+MODULE_AUTHOR("Ladislav Michl <ladis@linux-mips.org>");
+MODULE_DESCRIPTION("I2C-Bus SGI algorithm");
+MODULE_LICENSE("GPL");
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/i2c/Makefile linux-2.4.22/drivers/i2c/Makefile
--- linux-2.4.22.clean/drivers/i2c/Makefile	2003-08-25 13:44:41.000000000 +0200
+++ linux-2.4.22/drivers/i2c/Makefile	2003-09-27 14:07:55.000000000 +0200
@@ -5,7 +5,8 @@
 O_TARGET := i2c.o
 
 export-objs	:= i2c-core.o i2c-algo-bit.o i2c-algo-pcf.o \
-		   i2c-algo-ite.o i2c-proc.o i2c-algo-sibyte.o
+		   i2c-algo-ite.o i2c-algo-sibyte.o i2c-algo-sgi.o \
+		   i2c-proc.o
 
 obj-$(CONFIG_I2C)		+= i2c-core.o
 obj-$(CONFIG_I2C_CHARDEV)	+= i2c-dev.o
@@ -23,6 +24,7 @@
 obj-$(CONFIG_I2C_KEYWEST)	+= i2c-keywest.o
 obj-$(CONFIG_I2C_ALGO_SIBYTE)	+= i2c-algo-sibyte.o i2c-sibyte.o
 obj-$(CONFIG_I2C_MAX1617)	+= i2c-max1617.o
+obj-$(CONFIG_I2C_ALGO_SGI)	+= i2c-algo-sgi.o
 
 # This is needed for automatic patch generation: sensors code starts here
 # This is needed for automatic patch generation: sensors code ends here
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/media/video/Config.in linux-2.4.22/drivers/media/video/Config.in
--- linux-2.4.22.clean/drivers/media/video/Config.in	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/media/video/Config.in	2003-09-27 14:08:00.000000000 +0200
@@ -39,7 +39,7 @@
 dep_tristate '  SAA5249 Teletext processor' CONFIG_VIDEO_SAA5249 $CONFIG_VIDEO_DEV $CONFIG_I2C
 dep_tristate '  SAB3036 tuner' CONFIG_TUNER_3036 $CONFIG_VIDEO_DEV $CONFIG_I2C
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-   if [ "$CONFIG_SGI_IP22" = "y" ]; then
+   if [ "$CONFIG_SGI_IP22" = "y" -a "$CONFIG_I2C_ALGOSGI" != "n" ]; then
       dep_tristate '  SGI Vino Video For Linux (EXPERIMENTAL)' CONFIG_VIDEO_VINO $CONFIG_VIDEO_DEV
    fi
    dep_tristate '  Stradis 4:2:2 MPEG-2 video driver  (EXPERIMENTAL)' CONFIG_VIDEO_STRADIS $CONFIG_VIDEO_DEV $CONFIG_PCI
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/media/video/vino.c linux-2.4.22/drivers/media/video/vino.c
--- linux-2.4.22.clean/drivers/media/video/vino.c	2002-08-03 02:39:44.000000000 +0200
+++ linux-2.4.22/drivers/media/video/vino.c	2003-09-27 14:08:00.000000000 +0200
@@ -1,257 +1,347 @@
 /*
- * (incomplete) Driver for the Vino Video input system found in SGI Indys.
+ * (incomplete) Driver for the VINO (Video In No Out) system found in SGI Indys.
+ * 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License version 2 as published by the Free Software Foundation.
  *
- * Copyright (C) 1999 Ulf Carlsson (ulfc@bun.falkenberg.se)
- *
- * This isn't complete yet, please don't expect any video until I've written
- * some more code.
+ * Copyright (C) 2003 Ladislav Michl <ladis@linux-mips.org>
  */
 
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/wrapper.h>
 #include <linux/errno.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
 #include <linux/videodev.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-sgi.h>
 
 #include <asm/addrspace.h>
 #include <asm/system.h>
+#include <asm/bootinfo.h>
+#include <asm/pgtable.h>
+#include <asm/paccess.h>
+#include <asm/io.h>
+#include <asm/sgi/ip22.h>
+#include <asm/sgi/hpc3.h>
+#include <asm/sgi/mc.h>
 
 #include "vino.h"
 
+/* debugging? */
+#if 1
+#define DEBUG(x...)     printk(x);
+#else
+#define DEBUG(x...)
+#endif
+
+
+/* VINO ASIC registers */
+struct sgi_vino *vino;
+
+static const char *vinostr = "VINO IndyCam/TV";
+static int threshold_a = 512;
+static int threshold_b = 512;
+
 struct vino_device {
 	struct video_device vdev;
+#define VINO_CHAN_A		1
+#define VINO_CHAN_B		2
+	int chan;
+};
 
-	unsigned long chan;
-#define VINO_CHAN_A		0
-#define VINO_CHAN_B		1
-
-	unsigned long flags;
-#define VINO_DMA_ACTIVE		(1<<0)
+struct vino_client {
+	struct i2c_client *driver;
+	int owner;
 };
 
-/* We can actually receive TV and IndyCam input at the same time. Believe it or
- * not..
- */
-static struct vino_device vino[2];
+struct vino_video {
+	struct vino_device chA;
+	struct vino_device chB;
+
+	struct vino_client decoder;
+	struct vino_client camera;
+
+	struct semaphore input_lock;
+
+	/* Loaded into VINO descriptors to clear End Of Descriptors table
+	 * interupt condition */
+	unsigned long dummy_page;
+	unsigned int dummy_buf[4] __attribute__((aligned(8)));
+};
 
-/* Those registers have to be accessed by either *one* 64 bit write or *one* 64
- * bit read. We need some asm to fix this. We can't use mips3 as standard
- * because we just save 32 bits at context switch.
- */
+static struct vino_video *Vino;
 
-static __inline__ unsigned long long vino_reg_read(unsigned long addr)
+unsigned i2c_vino_getctrl(void *data)
 {
-	unsigned long long ret __attribute__ ((aligned (64)));
-	unsigned long virt_addr = KSEG1ADDR(addr + VINO_BASE);
-	unsigned long flags;
-
-	save_and_cli(flags);
-	__asm__ __volatile__(
-		".set\tmips3\n\t"
-		".set\tnoat\n\t"
-		"ld\t$1,(%0)\n\t"
-		"sd\t$1,(%1)\n\t"
-		".set\tat\n\t"
-		".set\tmips0"
-		:
-		:"r" (virt_addr), "r" (&ret));
-	restore_flags(flags);
-
-	return ret;
+	return vino->i2c_control;
 }
 
-static __inline__ void vino_reg_write(unsigned long long value,
-				      unsigned long addr)
+void i2c_vino_setctrl(void *data, unsigned val)
 {
-	unsigned long virt_addr = KSEG1ADDR(addr + VINO_BASE);
-	unsigned long flags;
+	vino->i2c_control = val;
+}
 
-	/* we might lose the upper parts of the registers which are not saved
-	 * if there comes an interrupt in our way, play safe */
+unsigned i2c_vino_rdata(void *data)
+{
+	return vino->i2c_data;
+}
 
-	save_and_cli(flags);
-	__asm__ __volatile__(
-		".set\tmips3\n\t"
-		".set\tnoat\n\t"
-		"ld\t$1,(%0)\n\t"
-		"sd\t$1,(%1)\n\t"
-		".set\tat\n\t"
-		".set\tmips0"
-		:
-		:"r" (&value), "r" (virt_addr));
-	restore_flags(flags);
-}
-
-static __inline__ void vino_reg_and(unsigned long long value,
-				    unsigned long addr)
-{
-	unsigned long virt_addr = KSEG1ADDR(addr + VINO_BASE);
-	unsigned long tmp, flags;
-
-	__save_and_cli(flags);
-	__asm__ __volatile__(
-		".set\tmips3\t\t\t# vino_reg_and\n\t"
-		".set\tnoat\n\t"
-		"ld\t$1, (%1)\n\t"
-		"ld\t%0, (%2)\n\t"
-		"and\t$1, $1, %0\n\t"
-		"sd\t$1, (%1)\n\t"
-		".set\tat\n\t"
-		".set\tmips0"
-		: "=&r" (tmp)
-		: "r" (virt_addr), "r" (&value));
-	__restore_flags(flags);
-}
-
-static __inline__ void vino_reg_or(unsigned long long value,
-				   unsigned long addr)
-{
-	unsigned long virt_addr = KSEG1ADDR(addr + VINO_BASE);
-	unsigned long tmp, flags;
-
-	save_and_cli(flags);
-	__asm__ __volatile__(
-		".set\tmips3\n\t"
-		".set\tnoat\n\t"
-		"ld\t$1, (%1)\n\t"
-		"ld\t%0, (%2)\n\t"
-		"or\t$1, $1, %0\n\t"
-		"sd\t$1, (%1)\n\t"
-		".set\tat\n\t"
-		".set\tmips0"
-		: "=&r" (tmp)
-		: "r" (virt_addr), "r" (&value));
-	restore_flags(flags);
+void i2c_vino_wdata(void *data, unsigned val)
+{
+	vino->i2c_data = val;
 }
 
-static int vino_dma_setup(void)
+static struct i2c_algo_sgi_data i2c_sgi_vino_data =
 {
-	return 0;
+	.getctrl = &i2c_vino_getctrl,
+	.setctrl = &i2c_vino_setctrl,
+	.rdata   = &i2c_vino_rdata,
+	.wdata   = &i2c_vino_wdata,
+	.xfer_timeout = 200,
+	.ack_timeout  = 1000,
+};
+
+/*
+ * There are two possible clients on VINO I2C bus, so we limit usage only
+ * to them.
+ */
+static int i2c_vino_client_reg(struct i2c_client *client)
+{
+	int res = 0;
+
+	down(&Vino->input_lock);
+	switch (client->driver->id) {
+	case I2C_DRIVERID_SAA7191:
+		if (Vino->decoder.driver)
+			res = -EBUSY;
+		else
+			Vino->decoder.driver = client;
+		break;
+	case I2C_DRIVERID_INDYCAM:
+		if (Vino->camera.driver)
+			res = -EBUSY;
+		else
+			Vino->camera.driver = client;
+		break;
+	default:
+		res = -ENODEV;
+	}
+	up(&Vino->input_lock);
+
+	return res;
 }
 
-static void vino_dma_stop(void)
+static int i2c_vino_client_unreg(struct i2c_client *client)
 {
+	int res = 0;
+	
+	down(&Vino->input_lock);
+	if (client == Vino->decoder.driver) {
+		if (Vino->decoder.owner)
+			res = -EBUSY;
+		else
+			Vino->decoder.driver = NULL;
+	} else if (client == Vino->camera.driver) {
+		if (Vino->camera.owner)
+			res = -EBUSY;
+		else
+			Vino->camera.driver = NULL;
+	}
+	up(&Vino->input_lock);
 
+	return res;
 }
 
-static int vino_init(void)
+static struct i2c_adapter vino_i2c_adapter =
 {
-	unsigned long ret;
-	unsigned short rev, id;
-	unsigned long long foo;
-	unsigned long *bar;
-
-	bar = (unsigned long *) &foo;
-
-	ret = vino_reg_read(VINO_REVID);
-
-	rev = (ret & VINO_REVID_REV_MASK);
-	id = (ret & VINO_REVID_ID_MASK) >> 4;
-
-	printk("Vino: ID:%02hx Rev:%02hx\n", id, rev);
-
-	foo = vino_reg_read(VINO_A_DESC_DATA0);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_A_DESC_DATA1);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_A_DESC_DATA2);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_A_DESC_DATA3);
-	printk("0x%lx", bar[0]);
-	printk("%lx\n", bar[1]);
-	foo = vino_reg_read(VINO_B_DESC_DATA0);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_B_DESC_DATA1);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_B_DESC_DATA2);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_B_DESC_DATA3);
-	printk("0x%lx", bar[0]);
-	printk("%lx\n", bar[1]);
+	.name			= "VINO I2C bus",
+	.id			= I2C_HW_SGI_VINO,
+	.algo_data		= &i2c_sgi_vino_data,
+	.client_register	= &i2c_vino_client_reg,
+	.client_unregister	= &i2c_vino_client_unreg,
+};
 
-	return 0;
+static int vino_i2c_add_bus(void)
+{
+	return i2c_sgi_add_bus(&vino_i2c_adapter);
 }
 
-static void vino_dma_go(struct vino_device *v)
+static int vino_i2c_del_bus(void)
 {
-	
+	return i2c_sgi_del_bus(&vino_i2c_adapter);
 }
 
-/* Reset the vino back to default state */
 
-static void vino_setup(struct vino_device *v)
+static void vino_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	
 }
 
 static int vino_open(struct video_device *dev, int flags)
 {
+	struct vino_device *videv = (struct vino_device *)dev;
+
 	return 0;
 }
 
 static void vino_close(struct video_device *dev)
 {
+	struct vino_device *videv = (struct vino_device *)dev;
 }
 
-static int vino_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
+static int vino_mmap(struct video_device *dev, const char *adr,
+		     unsigned long size)
 {
-	return 0;
+	struct vino_device *videv = (struct vino_device *)dev;
+
+	return -EINVAL;
 }
 
-static int vino_mmap(struct video_device *dev, const char *adr,
-		     unsigned long size)
+static int vino_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
 {
-	return 0;
+	struct vino_device *videv = (struct vino_device *)dev;
+
+	return -EINVAL;
 }
 
-static struct video_device vino_dev = {
-	owner:		THIS_MODULE,
-	name:		"Vino IndyCam/TV",
-	type:		VID_TYPE_CAPTURE,
-	hardware:	VID_HARDWARE_VINO,
-	open:		vino_open,
-	close:		vino_close,
-	ioctl:		vino_ioctl,
-	mmap:		vino_mmap,
+static const struct video_device vino_device = {
+	.owner		= THIS_MODULE,
+	.type		= VID_TYPE_CAPTURE | VID_TYPE_SUBCAPTURE,
+	.hardware	= VID_HARDWARE_VINO,
+	.name		= "VINO",
+	.open		= vino_open,
+	.close		= vino_close,
+	.ioctl		= vino_ioctl,
+	.mmap		= vino_mmap,
 };
 
-int __init init_vino(struct video_device *dev)
+static int __init vino_init(void)
 {
-	int err;
-
-	err = vino_init();
-	if (err)
-		return err;
+	unsigned long rev;
+	int i, ret = 0;
+	
+	/* VINO is Indy specific beast */
+	if (ip22_is_fullhouse())
+		return -ENODEV;
 
-#if 0
-	if (video_register_device(&vinodev, VFL_TYPE_GRABBER) == -1) {
+	/*
+	 * VINO is in the EISA address space, so the sysid register will tell
+	 * us if the EISA_PRESENT pin on MC has been pulled low.
+	 * 
+	 * If EISA_PRESENT is not set we definitely don't have a VINO equiped
+	 * system.
+	 */
+	if (!(sgimc->systemid & SGIMC_SYSID_EPRESENT)) {
+		printk(KERN_ERR "VINO not found\n");
 		return -ENODEV;
 	}
-#endif
 
-	return 0;
-}
+	vino = (struct sgi_vino *)ioremap(VINO_BASE, sizeof(struct sgi_vino));
+	if (!vino)
+		return -EIO;
+
+	/* Okay, once we know that VINO is present we'll read its revision
+	 * safe way. One never knows... */
+	if (get_dbe(rev, &(vino->rev_id))) {
+		printk(KERN_ERR "VINO: failed to read revision register\n");
+		ret = -ENODEV;
+		goto out_unmap;
+	}
+	if (VINO_ID_VALUE(rev) != VINO_CHIP_ID) {
+		printk(KERN_ERR "VINO is not VINO (Rev/ID: 0x%04lx)\n", rev);
+		ret = -ENODEV;
+		goto out_unmap;
+	}
+	printk(KERN_INFO "VINO Rev: 0x%02lx\n", VINO_REV_NUM(rev));
 
-#ifdef MODULE
-int init_module(void)
-{
-	int err;
+	Vino = (struct vino_video *)
+		kmalloc(sizeof(struct vino_video), GFP_KERNEL);
+	if (!Vino) {
+		ret = -ENOMEM;
+		goto out_unmap;
+	}
 
-	err = vino_init();
-	if (err)
-		return err;
+	Vino->dummy_page = get_zeroed_page(GFP_KERNEL | GFP_DMA);
+	if (!Vino->dummy_page) {
+		ret = -ENOMEM;
+		goto out_free_vino;
+	}
+	for (i = 0; i < 4; i++)
+		Vino->dummy_buf[i] = PHYSADDR(Vino->dummy_page);
+
+	vino->control = 0;
+	/* prevent VINO from throwing spurious interrupts */
+	vino->a.next_4_desc = PHYSADDR(Vino->dummy_buf);
+	vino->b.next_4_desc = PHYSADDR(Vino->dummy_buf);
+	udelay(5);
+	vino->intr_status = 0;
+        /* set threshold level */
+        vino->a.fifo_thres = threshold_a;
+	vino->b.fifo_thres = threshold_b;
+
+	init_MUTEX(&Vino->input_lock);
+
+	if (request_irq(SGI_VINO_IRQ, vino_interrupt, 0, vinostr, NULL)) {
+		printk(KERN_ERR "VINO: irq%02d registration failed\n",
+		       SGI_VINO_IRQ);
+		ret = -EAGAIN;
+		goto out_free_page;
+	}
+
+	ret = vino_i2c_add_bus();
+	if (ret) {
+		printk(KERN_ERR "VINO: I2C bus registration failed\n");
+		goto out_free_irq;
+	}
+
+	if (video_register_device(&Vino->chA.vdev, VFL_TYPE_GRABBER, -1) < 0) {
+		printk("%s, chnl %d: device registration failed.\n",
+			Vino->chA.vdev.name, Vino->chA.chan);
+		ret = -EINVAL;
+		goto out_i2c_del_bus;
+	}
+	if (video_register_device(&Vino->chB.vdev, VFL_TYPE_GRABBER, -1) < 0) {
+		printk("%s, chnl %d: device registration failed.\n",
+			Vino->chB.vdev.name, Vino->chB.chan);
+		ret = -EINVAL;
+		goto out_unregister_vdev;
+	}
 
 	return 0;
+
+out_unregister_vdev:
+	video_unregister_device(&Vino->chA.vdev);
+out_i2c_del_bus:
+	vino_i2c_del_bus();
+out_free_irq:
+	free_irq(SGI_VINO_IRQ, NULL);
+out_free_page:
+	free_page(Vino->dummy_page);
+out_free_vino:
+	kfree(Vino);
+out_unmap:
+	iounmap(vino);
+
+	return ret;
 }
 
-void cleanup_module(void)
+static void __exit vino_exit(void)
 {
+	video_unregister_device(&Vino->chA.vdev);
+	video_unregister_device(&Vino->chB.vdev);
+	vino_i2c_del_bus();
+	free_irq(SGI_VINO_IRQ, NULL);
+	free_page(Vino->dummy_page);
+	kfree(Vino);
+	iounmap(vino);
 }
-#endif
+
+module_init(vino_init);
+module_exit(vino_exit);
+
+MODULE_DESCRIPTION("Video4Linux driver for SGI Indy VINO (IndyCam)");
+MODULE_LICENSE("GPL");
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/media/video/vino.h linux-2.4.22/drivers/media/video/vino.h
--- linux-2.4.22.clean/drivers/media/video/vino.h	2001-09-07 18:28:38.000000000 +0200
+++ linux-2.4.22/drivers/media/video/vino.h	2003-09-27 14:08:00.000000000 +0200
@@ -1,64 +1,116 @@
 /*
- * Copyright (C) 1999 Ulf Carlsson (ulfc@bun.falkenberg.se)
- * Copyright (C) 2001 Ralf Baechle (ralf@gnu.org)
+ * Copyright (C) 1999 Ulf Karlsson <ulfc@bun.falkenberg.se>
+ * Copyright (C) 2003 Ladislav Michl <ladis@linux-mips.org>
  */
 
-#define VINO_BASE		0x00080000	/* In EISA address space */
-
-#define VINO_REVID		0x0000
-#define VINO_CTRL		0x0008
-#define VINO_INTSTAT		0x0010	/* Interrupt status */
-#define VINO_I2C_CTRL		0x0018
-#define VINO_I2C_DATA		0x0020
-#define VINO_A_ALPHA		0x0028	/* Channel A ... */
-#define VINO_A_CLIPS		0x0030	/* Clipping start */
-#define VINO_A_CLIPE		0x0038	/* Clipping end */
-#define VINO_A_FRAMERT		0x0040	/* Framerate */
-#define VINO_A_FLDCNT		0x0048	/* Field counter */
-#define VINO_A_LNSZ		0x0050
-#define VINO_A_LNCNT		0x0058
-#define VINO_A_PGIX		0x0060	/* Page index */
-#define VINO_A_DESC_PTR		0x0068	/* Ptr to next four descriptors */
-#define VINO_A_DESC_TLB_PTR	0x0070	/* Ptr to start of descriptor table */
-#define VINO_A_DESC_DATA0	0x0078	/* Descriptor data 0 */
-#define VINO_A_DESC_DATA1	0x0080	/* ... */
-#define VINO_A_DESC_DATA2	0x0088
-#define VINO_A_DESC_DATA3	0x0090
-#define VINO_A_FIFO_THRESHOLD	0x0098	/* FIFO threshold */
-#define VINO_A_FIFO_RP		0x00a0
-#define VINO_A_FIFO_WP		0x00a8
-#define VINO_B_ALPHA		0x00b0	/* Channel B ... */
-#define VINO_B_CLIPS		0x00b8
-#define VINO_B_CLIPE		0x00c0
-#define VINO_B_FRAMERT		0x00c8
-#define VINO_B_FLDCNT		0x00d0
-#define VINO_B_LNSZ		0x00d8
-#define VINO_B_LNCNT		0x00e0
-#define VINO_B_PGIX		0x00e8
-#define VINO_B_DESC_PTR		0x00f0
-#define VINO_B_DESC_TLB_PTR	0x00f8
-#define VINO_B_DESC_DATA0	0x0100
-#define VINO_B_DESC_DATA1	0x0108
-#define VINO_B_DESC_DATA2	0x0110
-#define VINO_B_DESC_DATA3	0x0118
-#define VINO_B_FIFO_THRESHOLD	0x0120
-#define VINO_B_FIFO_RP		0x0128
-#define VINO_B_FIFO_WP		0x0130
-
-/* Bits in the VINO_REVID register */
-
-#define VINO_REVID_REV_MASK		0x000f	/* bits 0:3 */
-#define VINO_REVID_ID_MASK		0x00f0	/* bits 4:7 */
-
-/* Bits in the VINO_CTRL register */
+#ifndef _vino_h_
+#define _vino_h_
 
+/* VINO AISIC register definitions */
+#define VINO_BASE	0x00080000	/* Vino is in the EISA address space,
+					 * but it is not an EISA bus card */
+
+typedef volatile unsigned long	vino_reg;
+
+#ifdef __mips64
+struct sgi_vino_channel {
+	vino_reg	alpha;
+	vino_reg	clip_start;
+	vino_reg	clip_end;
+	vino_reg	frame_rate;
+	vino_reg	field_counter;
+	vino_reg	line_size;
+	vino_reg	line_count;
+	vino_reg	page_index;
+	vino_reg	next_4_desc;
+	vino_reg	start_desc_tbl;
+	vino_reg	desc_0;
+	vino_reg	desc_1;
+	vino_reg	desc_2;
+	vino_reg	desc_3;
+	vino_reg	fifo_thres;
+	vino_reg	fifo_read;
+	vino_reg	fifo_write;
+};
+
+struct sgi_vino {
+	vino_reg	rev_id;
+	vino_reg	control;
+	vino_reg	intr_status;
+	vino_reg	i2c_control;
+	vino_reg	i2c_data;
+	struct sgi_vino_channel	a;
+	struct sgi_vino_channel	b;
+};
+
+#else
+
+struct sgi_vino_channel {
+	vino_reg	alpha_;
+	vino_reg	alpha;
+	vino_reg	clip_start_;
+	vino_reg	clip_start;
+	vino_reg	clip_end_;
+	vino_reg	clip_end;
+	vino_reg	frame_rate_;
+	vino_reg	frame_rate;
+	vino_reg	field_counter_;
+	vino_reg	field_counter;
+	vino_reg	line_size_;
+	vino_reg	line_size;
+	vino_reg	line_count_;
+	vino_reg	line_count;
+	vino_reg	page_index_;
+	vino_reg	page_index;
+	vino_reg	next_4_desc_;
+	vino_reg	next_4_desc;
+	vino_reg	start_desc_tbl_;
+	vino_reg	start_desc_tbl;
+	vino_reg	desc_0_;
+	vino_reg	desc_0;
+	vino_reg	desc_1_;
+	vino_reg	desc_1;
+	vino_reg	desc_2_;
+	vino_reg	desc_2;
+	vino_reg	desc_3_;
+	vino_reg	desc_3;
+	vino_reg	fifo_thres_;
+	vino_reg	fifo_thres;
+	vino_reg	fifo_read_;
+	vino_reg	fifo_read;
+	vino_reg	fifo_write_;
+	vino_reg	fifo_write;
+};
+
+struct sgi_vino {
+	vino_reg	rev_id_;
+	vino_reg	rev_id;
+	vino_reg	control_;
+	vino_reg	control;
+	vino_reg	intr_status_;
+	vino_reg	intr_status;
+	vino_reg	i2c_control_;
+	vino_reg	i2c_control;
+	vino_reg	i2c_data_;
+	vino_reg	i2c_data;
+	struct sgi_vino_channel	a;
+	struct sgi_vino_channel	b;
+};
+#endif
+
+/* Bits in the rev_id register */
+#define VINO_CHIP_ID		0xb
+#define VINO_REV_NUM(x)		((x) & 0x0f)
+#define VINO_ID_VALUE(x)	(((x) & 0xf0) >> 4)
+	
+/* Bits in the control register */
 #define VINO_CTRL_LITTLE_ENDIAN		(1<<0)
 #define VINO_CTRL_A_FIELD_TRANS_INT	(1<<1)	/* Field transferred int */
 #define VINO_CTRL_A_FIFO_OF_INT		(1<<2)	/* FIFO overflow int */
 #define VINO_CTRL_A_END_DESC_TBL_INT	(1<<3)	/* End of desc table int */
 #define VINO_CTRL_B_FIELD_TRANS_INT	(1<<4)	/* Field transferred int */
 #define VINO_CTRL_B_FIFO_OF_INT		(1<<5)	/* FIFO overflow int */
-#define VINO_CTRL_B_END_DESC_TLB_INT	(1<<6)	/* End of desc table int */
+#define VINO_CTRL_B_END_DESC_TBL_INT	(1<<6)	/* End of desc table int */
 #define VINO_CTRL_A_DMA_ENBL		(1<<7)
 #define VINO_CTRL_A_INTERLEAVE_ENBL	(1<<8)
 #define VINO_CTRL_A_SYNC_ENBL		(1<<9)
@@ -73,15 +125,19 @@
 #define VINO_CTRL_B_INTERLEAVE_ENBL	(1<<20)
 #define VINO_CTRL_B_SYNC_ENBL		(1<<21)
 #define VINO_CTRL_B_SELECT		(1<<22)	/* 1=D1 0=Philips */
-#define VINO_CTRL_B_RGB			(1<<22)	/* 1=RGB 0=YUV */
-#define VINO_CTRL_B_LUMA_ONLY		(1<<23)
-#define VINO_CTRL_B_DEC_ENBL		(1<<24)	/* Decimation */
+#define VINO_CTRL_B_RGB			(1<<23)	/* 1=RGB 0=YUV */
+#define VINO_CTRL_B_LUMA_ONLY		(1<<24)
+#define VINO_CTRL_B_DEC_ENBL		(1<<25)	/* Decimation */
 #define VINO_CTRL_B_DEC_SCALE_MASK	0x1c000000	/* bits 25:28 */
 #define VINO_CTRL_B_DEC_HOR_ONLY	(1<<29)	/* Decimation horizontal only */
 #define VINO_CTRL_B_DITHER		(1<<30)	/* ChanB 24 -> 8 bit dither */
 
-/* Bits in the Interrupt and Status register */
+/* Bits in the Descriptor data register */
+#define VINO_DESC_JUMP			(1<<30)
+#define VINO_DESC_STOP			(1<<31)
+#define VINO_DESC_VALID			(1<<32)
 
+/* Bits in the Interrupt and Status register */
 #define VINO_INTSTAT_A_FIELD_TRANS	(1<<0)	/* Field transferred int */
 #define VINO_INTSTAT_A_FIFO_OF		(1<<1)	/* FIFO overflow int */
 #define VINO_INTSTAT_A_END_DESC_TBL	(1<<2)	/* End of desc table int */
@@ -89,29 +145,13 @@
 #define VINO_INTSTAT_B_FIFO_OF		(1<<4)	/* FIFO overflow int */
 #define VINO_INTSTAT_B_END_DESC_TBL	(1<<5)	/* End of desc table int */
 
-/* Bits in the Clipping Start register */
-
-#define VINO_CLIPS_START		0x3ff		/* bits 0:9 */
-#define VINO_CLIPS_ODD_MASK		0x7fc00		/* bits 10:18 */
-#define VINO_CLIPS_EVEN_MASK		0xff80000	/* bits 19:27 */
-
-/* Bits in the Clipping End register */
-
-#define VINO_CLIPE_END			0x3ff		/* bits 0:9 */
-#define VINO_CLIPE_ODD_MASK		0x7fc00		/* bits 10:18 */
-#define VINO_CLIPE_EVEN_MASK		0xff80000	/* bits 19:27 */
+/* Bits in the Clipping register */
+#define VINO_CLIP_START(x)		((x) & 0x3ff)		/* bits 0:9 */
+#define VINO_CLIP_ODD(x)		(((x) & 0x1ff) << 10)	/* bits 10:18 */
+#define VINO_CLIP_EVEN(x)		(((x) & 0x1ff) << 19)	/* bits 19:27 */
 
 /* Bits in the Frame Rate register */
+#define VINO_FRAMERT_PAL		(1<<0)			/* 0=NTSC 1=PAL */
+#define VINO_FRAMERT_RT(x)		(((x) & 0x1fff) << 1)	/* bits 1:12 */
 
-#define VINO_FRAMERT_PAL		(1<<0)	/* 0=NTSC 1=PAL */
-#define VINO_FRAMERT_RT_MASK		0x1ffe		/* bits 1:12 */
-
-/* Bits in the VINO_I2C_CTRL */
-
-#define VINO_CTRL_I2C_IDLE		(1<<0)	/* write: 0=force idle
-						 * read: 0=idle 1=not idle */
-#define VINO_CTRL_I2C_DIR		(1<<1)	/* 0=read 1=write */
-#define VINO_CTRL_I2C_MORE_BYTES	(1<<2)	/* 0=last byte 1=more bytes */
-#define VINO_CTRL_I2C_TRANS_BUSY	(1<<4)	/* 0=trans done 1=trans busy */
-#define VINO_CTRL_I2C_ACK		(1<<5)	/* 0=ack received 1=ack not */
-#define VINO_CTRL_I2C_BUS_ERROR		(1<<7)	/* 0=no bus err 1=bus err */
+#endif
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/mtd/devices/docprobe.c linux-2.4.22/drivers/mtd/devices/docprobe.c
--- linux-2.4.22.clean/drivers/mtd/devices/docprobe.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.22/drivers/mtd/devices/docprobe.c	2003-06-16 01:42:21.000000000 +0200
@@ -89,10 +89,10 @@
 	0xe4000000,
 #elif defined(CONFIG_MOMENCO_OCELOT)
 	0x2f000000,
-        0xff000000,
+	0xff000000,
 #elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
-        0xff000000,
-##else
+	0xff000000,
+#else
 #warning Unknown architecture for DiskOnChip. No default probe locations defined
 #endif
 	0 };
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/mtd/devices/ms02-nv.c linux-2.4.22/drivers/mtd/devices/ms02-nv.c
--- linux-2.4.22.clean/drivers/mtd/devices/ms02-nv.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.22/drivers/mtd/devices/ms02-nv.c	2003-07-16 15:24:18.000000000 +0200
@@ -1,10 +1,10 @@
 /*
- *      Copyright (c) 2001 Maciej W. Rozycki
+ *	Copyright (c) 2001 Maciej W. Rozycki
  *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
  *
  *	$Id: update-2.4.22-mipsorg-0.030928.1.patch,v 1.1 2004/06/06 14:10:43 rpm Exp $
  */
@@ -29,7 +29,7 @@
 
 
 static char version[] __initdata =
-        "ms02-nv.c: v.1.0.0  13 Aug 2001  Maciej W. Rozycki.\n";
+	"ms02-nv.c: v.1.0.0  13 Aug 2001  Maciej W. Rozycki.\n";
 
 MODULE_AUTHOR("Maciej W. Rozycki <macro@ds2.pg.gda.pl>");
 MODULE_DESCRIPTION("DEC MS02-NV NVRAM module driver");
@@ -293,12 +293,12 @@
 
 	switch (mips_machtype) {
 	case MACH_DS5000_200:
-		csr = (volatile u32 *)KN02_CSR_ADDR;
+		csr = (volatile u32 *)KN02_CSR_BASE;
 		if (*csr & KN02_CSR_BNK32M)
 			stride = 2;
 		break;
 	case MACH_DS5000_2X0:
-	case MACH_DS5000:
+	case MACH_DS5900:
 		csr = (volatile u32 *)KN03_MCR_BASE;
 		if (*csr & KN03_MCR_BNK32M)
 			stride = 2;
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/mtd/devices/ms02-nv.h linux-2.4.22/drivers/mtd/devices/ms02-nv.h
--- linux-2.4.22.clean/drivers/mtd/devices/ms02-nv.h	2002-11-29 00:53:13.000000000 +0100
+++ linux-2.4.22/drivers/mtd/devices/ms02-nv.h	2003-07-16 15:24:18.000000000 +0200
@@ -1,32 +1,94 @@
 /*
- *      Copyright (c) 2001 Maciej W. Rozycki
+ *	Copyright (c) 2001, 2003  Maciej W. Rozycki
  *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
+ *	DEC MS02-NV (54-20948-01) battery backed-up NVRAM module for
+ *	DECstation/DECsystem 5000/2x0 and DECsystem 5900 and 5900/260
+ *	systems.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
  */
 
 #include <linux/ioport.h>
 #include <linux/mtd/mtd.h>
 
+/*
+ * Addresses are decoded as follows:
+ *
+ * 0x000000 - 0x3fffff	SRAM
+ * 0x400000 - 0x7fffff	CSR
+ *
+ * Within the SRAM area the following ranges are forced by the system
+ * firmware:
+ *
+ * 0x000000 - 0x0003ff	diagnostic area, destroyed upon a reboot
+ * 0x000400 - ENDofRAM	storage area, available to operating systems
+ *
+ * but we can't really use the available area right from 0x000400 as
+ * the first word is used by the firmware as a status flag passed
+ * from an operating system.  If anything but the valid data magic
+ * ID value is found, the firmware considers the SRAM clean, i.e.
+ * containing no valid data, and disables the battery resulting in
+ * data being erased as soon as power is switched off.  So the choice
+ * for the start address of the user-available is 0x001000 which is
+ * nicely page aligned.  The area between 0x000404 and 0x000fff may
+ * be used by the driver for own needs.
+ *
+ * The diagnostic area defines two status words to be read by an
+ * operating system, a magic ID to distinguish a MS02-NV board from
+ * anything else and a status information providing results of tests
+ * as well as the size of SRAM available, which can be 1MB or 2MB
+ * (that's what the firmware handles; no idea if 2MB modules ever
+ * existed).
+ *
+ * The firmware only handles the MS02-NV board if installed in the
+ * last (15th) slot, so for any other location the status information
+ * stored in the SRAM cannot be relied upon.  But from the hardware
+ * point of view there is no problem using up to 14 such boards in a
+ * system -- only the 1st slot needs to be filled with a DRAM module.
+ * The MS02-NV board is ECC-protected, like other MS02 memory boards.
+ *
+ * The state of the battery as provided by the CSR is reflected on
+ * the two onboard LEDs.  When facing the battery side of the board,
+ * with the LEDs at the top left and the battery at the bottom right
+ * (i.e. looking from the back side of the system box), their meaning
+ * is as follows (the system has to be powered on):
+ *
+ * left LED		battery disable status: lit = enabled
+ * right LED		battery condition status: lit = OK
+ */
+
 /* MS02-NV iomem register offsets. */
 #define MS02NV_CSR		0x400000	/* control & status register */
 
+/* MS02-NV CSR status bits. */
+#define MS02NV_CSR_BATT_OK	0x01		/* battery OK */
+#define MS02NV_CSR_BATT_OFF	0x02		/* battery disabled */
+
+
 /* MS02-NV memory offsets. */
 #define MS02NV_DIAG		0x0003f8	/* diagnostic status */
 #define MS02NV_MAGIC		0x0003fc	/* MS02-NV magic ID */
-#define MS02NV_RAM		0x000400	/* general-purpose RAM start */
+#define MS02NV_VALID		0x000400	/* valid data magic ID */
+#define MS02NV_RAM		0x001000	/* user-exposed RAM start */
 
-/* MS02-NV diagnostic status constants. */
-#define MS02NV_DIAG_SIZE_MASK	0xf0		/* RAM size mask */
-#define MS02NV_DIAG_SIZE_SHIFT	0x10		/* RAM size shift (left) */
+/* MS02-NV diagnostic status bits. */
+#define MS02NV_DIAG_TEST	0x01		/* SRAM test done (?) */
+#define MS02NV_DIAG_RO		0x02		/* SRAM r/o test done */
+#define MS02NV_DIAG_RW		0x04		/* SRAM r/w test done */
+#define MS02NV_DIAG_FAIL	0x08		/* SRAM test failed */
+#define MS02NV_DIAG_SIZE_MASK	0xf0		/* SRAM size mask */
+#define MS02NV_DIAG_SIZE_SHIFT	0x10		/* SRAM size shift (left) */
 
 /* MS02-NV general constants. */
 #define MS02NV_ID		0x03021966	/* MS02-NV magic ID value */
+#define MS02NV_VALID_ID		0xbd100248	/* valid data magic ID value */
 #define MS02NV_SLOT_SIZE	0x800000	/* size of the address space
 						   decoded by the module */
 
+
 typedef volatile u32 ms02nv_uint;
 
 struct ms02nv_private {
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/mtd/maps/Config.in linux-2.4.22/drivers/mtd/maps/Config.in
--- linux-2.4.22.clean/drivers/mtd/maps/Config.in	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.22/drivers/mtd/maps/Config.in	2003-06-27 02:04:27.000000000 +0200
@@ -51,11 +51,19 @@
    dep_tristate '  Pb1000 MTD support' CONFIG_MTD_PB1000 $CONFIG_MIPS_PB1000
    dep_tristate '  Pb1500 MTD support' CONFIG_MTD_PB1500 $CONFIG_MIPS_PB1500
    dep_tristate '  Pb1100 MTD support' CONFIG_MTD_PB1100 $CONFIG_MIPS_PB1100
+   dep_tristate '  Bosporus MTD support' CONFIG_MTD_BOSPORUS $CONFIG_MIPS_BOSPORUS
+   dep_tristate '  XXS1500 boot flash device' CONFIG_MTD_XXS1500 $CONFIG_MIPS_XXS1500
+   dep_tristate '  MTX-1 flash device' CONFIG_MTD_MTX1 $CONFIG_MIPS_MTX1
    if [ "$CONFIG_MTD_PB1500" = "y" -o "$CONFIG_MTD_PB1500" = "m" \
 	-o "$CONFIG_MTD_PB1100" = "y" -o "$CONFIG_MTD_PB1100" = "m" ]; then
       bool '  Pb[15]00 boot flash device' CONFIG_MTD_PB1500_BOOT 
       bool '  Pb[15]00 user flash device (2nd 32MiB bank)' CONFIG_MTD_PB1500_USER
    fi
+   tristate '  Db1x00 MTD support' CONFIG_MTD_DB1X00
+   if [ "$CONFIG_MTD_DB1X00" = "y" -o "$CONFIG_MTD_DB1X00" = "m" ]; then
+      bool '  Db1x00 boot flash device' CONFIG_MTD_DB1X00_BOOT 
+      bool '  Db1x00 user flash device (2nd bank)' CONFIG_MTD_DB1X00_USER
+   fi
    dep_tristate '  Flash chip mapping on ITE QED-4N-S01B, Globespan IVR or custom board' CONFIG_MTD_CSTM_MIPS_IXX $CONFIG_MTD_CFI $CONFIG_MTD_JEDEC $CONFIG_MTD_PARTITIONS 
    if [ "$CONFIG_MTD_CSTM_MIPS_IXX" = "y" -o "$CONFIG_MTD_CSTM_MIPS_IXX" = "m" ]; then
       hex '    Physical start address of flash mapping' CONFIG_MTD_CSTM_MIPS_IXX_START 0x8000000
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/mtd/maps/db1x00-flash.c linux-2.4.22/drivers/mtd/maps/db1x00-flash.c
--- linux-2.4.22.clean/drivers/mtd/maps/db1x00-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/mtd/maps/db1x00-flash.c	2003-02-16 07:25:24.000000000 +0100
@@ -0,0 +1,285 @@
+/*
+ * Flash memory access on Alchemy Db1xxx boards
+ * 
+ * (C) 2003 Pete Popov <ppopov@pacbell.net>
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+#include <asm/db1x00.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+static unsigned long window_addr;
+static unsigned long window_size;
+static unsigned long flash_size;
+
+static BCSR * const bcsr = (BCSR *)0xAE000000;
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+static struct map_info db1x00_map = {
+	name:		"Db1x00 flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+static unsigned char flash_buswidth = 4;
+
+/* 
+ * The Db1x boards support different flash densities. We setup
+ * the mtd_partition structures below for default of 64Mbit 
+ * flash densities, and override the partitions sizes, if
+ * necessary, after we check the board status register.
+ */
+
+#ifdef DB1X00_BOTH_BANKS
+/* both banks will be used. Combine the first bank and the first 
+ * part of the second bank together into a single jffs/jffs2
+ * partition.
+ */
+static struct mtd_partition db1x00_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x1c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000-0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#elif defined(DB1X00_BOOT_ONLY)
+static struct mtd_partition db1x00_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x00c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000-0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#elif defined(DB1X00_USER_ONLY)
+static struct mtd_partition db1x00_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x0e00000,
+                offset: 0x0000000
+        },{
+                name: "raw kernel",
+		size: MTDPART_SIZ_FULL,
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#else
+#error MTD_DB1X00 define combo error /* should never happen */
+#endif
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+/*
+ * Probe the flash density and setup window address and size
+ * based on user CONFIG options. There are times when we don't
+ * want the MTD driver to be probing the boot or user flash,
+ * so having the option to enable only one bank is important.
+ */
+int setup_flash_params()
+{
+	switch ((bcsr->status >> 14) & 0x3) {
+		case 0: /* 64Mbit devices */
+			flash_size = 0x800000; /* 8MB per part */
+#if defined(DB1X00_BOTH_BANKS)
+			window_addr = 0x1E000000;
+			window_size = 0x2000000; 
+#elif defined(DB1X00_BOOT_ONLY)
+			window_addr = 0x1F000000;
+			window_size = 0x1000000; 
+#else /* USER ONLY */
+			window_addr = 0x1E000000;
+			window_size = 0x1000000; 
+#endif
+			break;
+		case 1:
+			/* 128 Mbit devices */
+			flash_size = 0x1000000; /* 16MB per part */
+#if defined(DB1X00_BOTH_BANKS)
+			window_addr = 0x1C000000;
+			window_size = 0x4000000;
+			/* USERFS from 0x1C00 0000 to 0x1FC0 0000 */
+			db1x00_partitions[0].size = 0x3C00000;
+#elif defined(DB1X00_BOOT_ONLY)
+			window_addr = 0x1E000000;
+			window_size = 0x2000000;
+			/* USERFS from 0x1E00 0000 to 0x1FC0 0000 */
+			db1x00_partitions[0].size = 0x1C00000;
+#else /* USER ONLY */
+			window_addr = 0x1C000000;
+			window_size = 0x2000000;
+			/* USERFS from 0x1C00 0000 to 0x1DE00000 */
+			db1x00_partitions[0].size = 0x1DE0000;
+#endif
+			break;
+		case 2:
+			/* 256 Mbit devices */
+			flash_size = 0x4000000; /* 64MB per part */
+#if defined(DB1X00_BOTH_BANKS)
+			return 1;
+#elif defined(DB1X00_BOOT_ONLY)
+			/* Boot ROM flash bank only; no user bank */
+			window_addr = 0x1C000000;
+			window_size = 0x4000000;
+			/* USERFS from 0x1C00 0000 to 0x1FC00000 */
+			db1x00_partitions[0].size = 0x3C00000;
+#else /* USER ONLY */
+			return 1;
+#endif
+			break;
+		default:
+			return 1;
+	}
+	return 0;
+}
+
+int __init db1x00_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	db1x00_map.buswidth = flash_buswidth;
+
+	if (setup_flash_params()) 
+		return -ENXIO;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = db1x00_partitions;
+	nb_parts = NB_OF(db1x00_partitions);
+	db1x00_map.size = window_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "Db1xxx flash: probing %d-bit flash bus\n", 
+			db1x00_map.buswidth*8);
+	db1x00_map.map_priv_1 = 
+		(unsigned long)ioremap(window_addr, window_size);
+	mymtd = do_map_probe("cfi_probe", &db1x00_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit db1x00_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(db1x00_mtd_init);
+module_exit(db1x00_mtd_cleanup);
+
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("Db1x00 mtd map driver");
+MODULE_LICENSE("GPL");
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/mtd/maps/lasat.c linux-2.4.22/drivers/mtd/maps/lasat.c
--- linux-2.4.22.clean/drivers/mtd/maps/lasat.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.22/drivers/mtd/maps/lasat.c	2003-09-27 14:08:01.000000000 +0200
@@ -1,15 +1,6 @@
 /*
  * Flash device on lasat 100 and 200 boards
  *
- * Presumably (C) 2002 Brian Murphy <brian@murphy.dk> or whoever he
- * works for.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * $Id: update-2.4.22-mipsorg-0.030928.1.patch,v 1.1 2004/06/06 14:10:43 rpm Exp $
- *
  */
 
 #include <linux/module.h>
@@ -21,7 +12,6 @@
 #include <linux/mtd/partitions.h>
 #include <linux/config.h>
 #include <asm/lasat/lasat.h>
-#include <asm/lasat/lasat_mtd.h>
 
 static struct mtd_info *mymtd;
 
@@ -69,30 +59,33 @@
 }
 
 static struct map_info sp_map = {
-	.name = "SP flash",
-	.buswidth = 4,
-	.read8 = sp_read8,
-	.read16 = sp_read16,
-	.read32 = sp_read32,
-	.copy_from = sp_copy_from,
-	.write8 = sp_write8,
-	.write16 = sp_write16,
-	.write32 = sp_write32,
-	.copy_to = sp_copy_to
+	name: "SP flash",
+	buswidth: 4,
+	read8: sp_read8,
+	read16: sp_read16,
+	read32: sp_read32,
+	copy_from: sp_copy_from,
+	write8: sp_write8,
+	write16: sp_write16,
+	write32: sp_write32,
+	copy_to: sp_copy_to
 };
 
 static struct mtd_partition partition_info[LASAT_MTD_LAST];
-static char *lasat_mtd_partnames[] = {"Bootloader", "Service", "Normal", "Filesystem", "Config"};
+static char *lasat_mtd_partnames[] = {"Bootloader", "Service", "Normal", "Config", "Filesystem"};
 
 static int __init init_sp(void)
 {
 	int i;
+	int nparts = 0;
 	/* this does not play well with the old flash code which 
 	 * protects and uprotects the flash when necessary */
        	printk(KERN_NOTICE "Unprotecting flash\n");
 	*lasat_misc->flash_wp_reg |= 1 << lasat_misc->flash_wp_bit;
 
-	sp_map.map_priv_1 = lasat_flash_partition_start(LASAT_MTD_BOOTLOADER);
+	sp_map.map_priv_1 = ioremap_nocache(
+		lasat_flash_partition_start(LASAT_MTD_BOOTLOADER),
+		lasat_board_info.li_flash_size);
 	sp_map.size = lasat_board_info.li_flash_size;
 
        	printk(KERN_NOTICE "sp flash device: %lx at %lx\n", 
@@ -109,12 +102,15 @@
 
 		for (i=0; i < LASAT_MTD_LAST; i++) {
 			size = lasat_flash_partition_size(i);
-			partition_info[i].size = size;
-			partition_info[i].offset = offset;
-			offset += size;
+			if (size != 0) {
+				nparts++;
+				partition_info[i].size = size;
+				partition_info[i].offset = offset;
+				offset += size;
+			}
 		}
 
-		add_mtd_partitions( mymtd, partition_info, LASAT_MTD_LAST );
+		add_mtd_partitions( mymtd, partition_info, nparts );
 		return 0;
 	}
 
@@ -124,11 +120,11 @@
 static void __exit cleanup_sp(void)
 {
 	if (mymtd) {
-		del_mtd_partitions(mymtd);
-		map_destroy(mymtd);
+	  del_mtd_partitions(mymtd);
+	  map_destroy(mymtd);
 	}
 	if (sp_map.map_priv_1) {
-		sp_map.map_priv_1 = 0;
+	  sp_map.map_priv_1 = 0;
 	}
 }
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/mtd/maps/Makefile linux-2.4.22/drivers/mtd/maps/Makefile
--- linux-2.4.22.clean/drivers/mtd/maps/Makefile	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.22/drivers/mtd/maps/Makefile	2003-06-27 02:04:34.000000000 +0200
@@ -52,7 +52,11 @@
 obj-$(CONFIG_MTD_PB1000)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_PB1100)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_PB1500)	+= pb1xxx-flash.o
+obj-$(CONFIG_MTD_XXS1500)       += xxs1500.o
+obj-$(CONFIG_MTD_MTX1)		+= mtx-1.o
 obj-$(CONFIG_MTD_LASAT)		+= lasat.o
+obj-$(CONFIG_MTD_DB1X00)        += db1x00-flash.o
+obj-$(CONFIG_MTD_BOSPORUS)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_EDB7312)	+= edb7312.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/mtd/maps/mtx-1.c linux-2.4.22/drivers/mtd/maps/mtx-1.c
--- linux-2.4.22.clean/drivers/mtd/maps/mtx-1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/mtd/maps/mtx-1.c	2003-06-27 02:04:35.000000000 +0200
@@ -0,0 +1,181 @@
+/*
+ * Flash memory access on 4G Systems MTX-1 board
+ * 
+ * (C) 2003 Pete Popov <ppopov@mvista.com>
+ *	    Bruno Randolf <bruno.randolf@4g-systems.de>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+#ifdef CONFIG_MIPS_MTX1
+#define WINDOW_ADDR 0x1E000000
+#define WINDOW_SIZE 0x2000000
+#endif
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+
+
+static struct map_info mtx1_map = {
+	name:		"MTX-1 flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+
+static unsigned long flash_size = 0x01000000;
+static unsigned char flash_buswidth = 4;
+static struct mtd_partition mtx1_partitions[] = {
+        {
+                name: "user fs",
+                size: 0x1c00000,
+                offset: 0,
+        },{
+                name: "yamon",
+                size: 0x0100000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+                size: 0x02c0000,
+                offset: MTDPART_OFS_APPEND,
+        },{
+                name: "yamon env vars",
+                size: 0x0040000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        }
+};
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init mtx1_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	mtx1_map.buswidth = flash_buswidth;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = mtx1_partitions;
+	nb_parts = NB_OF(mtx1_partitions);
+	mtx1_map.size = flash_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "MTX-1 flash: probing %d-bit flash bus\n",
+			mtx1_map.buswidth*8);
+	mtx1_map.map_priv_1 =
+		(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	mymtd = do_map_probe("cfi_probe", &mtx1_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit mtx1_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(mtx1_mtd_init);
+module_exit(mtx1_mtd_cleanup);
+
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("MTX-1 CFI map driver");
+MODULE_LICENSE("GPL");
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/mtd/maps/pb1xxx-flash.c linux-2.4.22/drivers/mtd/maps/pb1xxx-flash.c
--- linux-2.4.22.clean/drivers/mtd/maps/pb1xxx-flash.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.22/drivers/mtd/maps/pb1xxx-flash.c	2003-05-19 08:27:22.000000000 +0200
@@ -192,6 +192,34 @@
 #else
 #error MTD_PB1500 define combo error /* should never happen */
 #endif
+#elif defined(CONFIG_MTD_BOSPORUS)
+static unsigned char flash_buswidth = 2;
+static unsigned long flash_size 	= 0x02000000;
+#define WINDOW_ADDR 0x1F000000
+#define WINDOW_SIZE 0x2000000
+static struct mtd_partition pb1xxx_partitions[] = {
+        {
+                name:   "User FS",
+                size:   0x00400000,
+                offset: 0x00000000,
+        },{
+                name:   "Yamon-2",
+                size:   0x00100000,
+                offset: 0x00400000,
+        },{
+                name:   "Root FS",
+                size:   0x00700000,
+                offset: 0x00500000,
+        },{
+                name:   "Yamon-1",
+                size:   0x00100000,
+                offset: 0x00C00000,
+        },{
+                name:   "Kernel",
+                size:   0x00300000,
+                offset: 0x00D00000,
+        }
+};
 #else
 #error Unsupported board
 #endif
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/mtd/maps/xxs1500.c linux-2.4.22/drivers/mtd/maps/xxs1500.c
--- linux-2.4.22.clean/drivers/mtd/maps/xxs1500.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/mtd/maps/xxs1500.c	2003-08-02 04:06:01.000000000 +0200
@@ -0,0 +1,186 @@
+/*
+ * Flash memory access on MyCable XXS1500 board
+ * 
+ * (C) 2003 Pete Popov <ppopov@mvista.com>
+ * 
+ * $Id: update-2.4.22-mipsorg-0.030928.1.patch,v 1.1 2004/06/06 14:10:43 rpm Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+#ifdef CONFIG_MIPS_XXS1500
+#define WINDOW_ADDR 0x1F000000
+#define WINDOW_SIZE 0x1000000
+#endif
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+
+
+static struct map_info xxs1500_map = {
+	name:		"XXS1500 flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+
+static unsigned long flash_size = 0x00800000;
+static unsigned char flash_buswidth = 4;
+static struct mtd_partition xxs1500_partitions[] = {
+        {
+                name: "kernel image",
+                size: 0x00200000,
+                offset: 0,
+        },{
+                name: "user fs 0",
+                size: (0x00C00000-0x200000),
+                offset: MTDPART_OFS_APPEND,
+        },{
+                name: "yamon",
+                size: 0x00100000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "user fs 1",
+                size: 0x2c0000,
+                offset: MTDPART_OFS_APPEND,
+        },{
+                name: "yamon env vars",
+                size: 0x040000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        }
+};
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init xxs1500_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	xxs1500_map.buswidth = flash_buswidth;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = xxs1500_partitions;
+	nb_parts = NB_OF(xxs1500_partitions);
+	xxs1500_map.size = flash_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "XXS1500 flash: probing %d-bit flash bus\n", 
+			xxs1500_map.buswidth*8);
+	xxs1500_map.map_priv_1 = 
+		(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	mymtd = do_map_probe("cfi_probe", &xxs1500_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit xxs1500_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(xxs1500_mtd_init);
+module_exit(xxs1500_mtd_cleanup);
+
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("XXS1500 CFI map driver");
+MODULE_LICENSE("GPL");
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/au1000_eth.c linux-2.4.22/drivers/net/au1000_eth.c
--- linux-2.4.22.clean/drivers/net/au1000_eth.c	2002-11-29 00:53:13.000000000 +0100
+++ linux-2.4.22/drivers/net/au1000_eth.c	2003-08-09 22:19:13.000000000 +0200
@@ -1,8 +1,9 @@
 /*
  *
- * Alchemy Semi Au1000 ethernet driver
+ * Alchemy Au1x00 ethernet driver
  *
- * Copyright 2001 MontaVista Software Inc.
+ * Copyright 2001,2002,2003 MontaVista Software Inc.
+ * Copyright 2002 TimeSys Corp.
  * Author: MontaVista Software, Inc.
  *         	ppopov@mvista.com or source@mvista.com
  *
@@ -22,8 +23,15 @@
  *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
  *
  * ########################################################################
+ *
+ * 
  */
-#include <linux/config.h>
+
+#ifndef __mips__
+#error This driver only works with MIPS architectures!
+#endif
+
+
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -44,22 +52,27 @@
 #include <asm/irq.h>
 #include <asm/bitops.h>
 #include <asm/io.h>
+#include <asm/processor.h>
 
 #include <asm/au1000.h>
+#include <asm/cpu.h>
 #include "au1000_eth.h"
 
+
 #ifdef AU1000_ETH_DEBUG
-static int au1000_debug = 10;
+static int au1000_debug = 5;
 #else
 static int au1000_debug = 3;
 #endif
 
+MODULE_LICENSE("GPL");
+
 // prototypes
 static void *dma_alloc(size_t, dma_addr_t *);
 static void dma_free(void *, size_t);
 static void hard_stop(struct net_device *);
 static void enable_rx_tx(struct net_device *dev);
-static int __init au1000_probe1(struct net_device *, long, int, int);
+static struct net_device * au1000_probe(u32 ioaddr, int irq, int port_num);
 static int au1000_init(struct net_device *);
 static int au1000_open(struct net_device *);
 static int au1000_close(struct net_device *);
@@ -101,27 +114,8 @@
  */
 
 
-/*
- * Base address and interupt of the Au1xxx ethernet macs
- */
-static struct {
-	unsigned int port;
-	int irq;
-} au1000_iflist[NUM_INTERFACES] = {
-		{AU1000_ETH0_BASE, AU1000_ETH0_IRQ}, 
-		{AU1000_ETH1_BASE, AU1000_ETH1_IRQ}
-	},
-  au1500_iflist[NUM_INTERFACES] = {
-		{AU1500_ETH0_BASE, AU1000_ETH0_IRQ}, 
-		{AU1500_ETH1_BASE, AU1000_ETH1_IRQ}
-	},
-  au1100_iflist[NUM_INTERFACES] = {
-		{AU1000_ETH0_BASE, AU1000_ETH0_IRQ}, 
-		{NULL, NULL}
-	};
-
 static char version[] __devinitdata =
-    "au1000eth.c:1.0 ppopov@mvista.com\n";
+    "au1000eth.c:1.4 ppopov@mvista.com\n";
 
 /* These addresses are only used if yamon doesn't tell us what
  * the mac address is, and the mac address is not passed on the
@@ -138,6 +132,7 @@
 #define cpu_to_dma32 cpu_to_be32
 #define dma32_to_cpu be32_to_cpu
 
+struct au1000_private *au_macs[NUM_ETH_INTERFACES];
 
 /* FIXME 
  * All of the PHY code really should be detached from the MAC 
@@ -156,7 +151,6 @@
 	s16 data;
 	
 	/* Stop auto-negotiation */
-	//printk("bcm_5201_init\n");
 	data = mdio_read(dev, phy_addr, MII_CONTROL);
 	mdio_write(dev, phy_addr, MII_CONTROL, data & ~MII_CNTL_AUTO);
 
@@ -171,12 +165,8 @@
 	data |= MII_CNTL_RST_AUTO | MII_CNTL_AUTO;
 	mdio_write(dev, phy_addr, MII_CONTROL, data);
 
-	/* Enable TX LED instead of FDX */
-	data = mdio_read(dev, phy_addr, MII_INT);
-	data &= ~MII_FDX_LED;
-	mdio_write(dev, phy_addr, MII_INT, data);
-
-	if (au1000_debug > 4) dump_mii(dev, phy_addr);
+	if (au1000_debug > 4) 
+		dump_mii(dev, phy_addr);
 	return 0;
 }
 
@@ -184,7 +174,6 @@
 {
 	s16 mii_control, timeout;
 	
-	//printk("bcm_5201_reset\n");
 	mii_control = mdio_read(dev, phy_addr, MII_CONTROL);
 	mdio_write(dev, phy_addr, MII_CONTROL, mii_control | MII_CNTL_RESET);
 	mdelay(1);
@@ -247,8 +236,8 @@
 		printk("lsi_80227_init\n");
 
 	/* restart auto-negotiation */
-	mdio_write(dev, phy_addr, 0, 0x3200);
-
+	mdio_write(dev, phy_addr, MII_CONTROL,
+		   MII_CNTL_F100 | MII_CNTL_AUTO | MII_CNTL_RST_AUTO); // | MII_CNTL_FDX);
 	mdelay(1);
 
 	/* set up LEDs to correct display */
@@ -299,9 +288,9 @@
 	mii_data = mdio_read(dev, aup->phy_addr, MII_STATUS);
 	if (mii_data & MII_STAT_LINK) {
 		*link = 1;
-		mii_data = mdio_read(dev, aup->phy_addr, MII_LSI_STAT);
-		if (mii_data & MII_LSI_STAT_SPD) {
-			if (mii_data & MII_LSI_STAT_FDX) {
+		mii_data = mdio_read(dev, aup->phy_addr, MII_LSI_PHY_STAT);
+		if (mii_data & MII_LSI_PHY_STAT_SPD) {
+			if (mii_data & MII_LSI_PHY_STAT_FDX) {
 				*speed = IF_PORT_100BASEFX;
 				dev->if_port = IF_PORT_100BASEFX;
 			}
@@ -342,12 +331,303 @@
 	return 0;
 }
 
+int am79c874_init(struct net_device *dev, int phy_addr)
+{
+	s16 data;
+
+	/* 79c874 has quit resembled bit assignments to BCM5201 */
+	if (au1000_debug > 4)
+		printk("am79c847_init\n");
+
+	/* Stop auto-negotiation */
+	data = mdio_read(dev, phy_addr, MII_CONTROL);
+	mdio_write(dev, phy_addr, MII_CONTROL, data & ~MII_CNTL_AUTO);
+
+	/* Set advertisement to 10/100 and Half/Full duplex
+	 * (full capabilities) */
+	data = mdio_read(dev, phy_addr, MII_ANADV);
+	data |= MII_NWAY_TX | MII_NWAY_TX_FDX | MII_NWAY_T_FDX | MII_NWAY_T;
+	mdio_write(dev, phy_addr, MII_ANADV, data);
+	
+	/* Restart auto-negotiation */
+	data = mdio_read(dev, phy_addr, MII_CONTROL);
+	data |= MII_CNTL_RST_AUTO | MII_CNTL_AUTO;
+
+	mdio_write(dev, phy_addr, MII_CONTROL, data);
+
+	if (au1000_debug > 4) dump_mii(dev, phy_addr);
+	return 0;
+}
+
+int am79c874_reset(struct net_device *dev, int phy_addr)
+{
+	s16 mii_control, timeout;
+	
+	if (au1000_debug > 4)
+		printk("am79c874_reset\n");
+
+	mii_control = mdio_read(dev, phy_addr, MII_CONTROL);
+	mdio_write(dev, phy_addr, MII_CONTROL, mii_control | MII_CNTL_RESET);
+	mdelay(1);
+	for (timeout = 100; timeout > 0; --timeout) {
+		mii_control = mdio_read(dev, phy_addr, MII_CONTROL);
+		if ((mii_control & MII_CNTL_RESET) == 0)
+			break;
+		mdelay(1);
+	}
+	if (mii_control & MII_CNTL_RESET) {
+		printk(KERN_ERR "%s PHY reset timeout !\n", dev->name);
+		return -1;
+	}
+	return 0;
+}
+
+int 
+am79c874_status(struct net_device *dev, int phy_addr, u16 *link, u16 *speed)
+{
+	u16 mii_data;
+	struct au1000_private *aup;
+
+	// printk("am79c874_status\n");
+	if (!dev) {
+		printk(KERN_ERR "am79c874_status error: NULL dev\n");
+		return -1;
+	}
+
+	aup = (struct au1000_private *) dev->priv;
+	mii_data = mdio_read(dev, aup->phy_addr, MII_STATUS);
+
+	if (mii_data & MII_STAT_LINK) {
+		*link = 1;
+		mii_data = mdio_read(dev, aup->phy_addr, MII_AMD_PHY_STAT);
+		if (mii_data & MII_AMD_PHY_STAT_SPD) {
+			if (mii_data & MII_AMD_PHY_STAT_FDX) {
+				*speed = IF_PORT_100BASEFX;
+				dev->if_port = IF_PORT_100BASEFX;
+			}
+			else {
+				*speed = IF_PORT_100BASETX;
+				dev->if_port = IF_PORT_100BASETX;
+			}
+		}
+		else {
+			*speed = IF_PORT_10BASET;
+			dev->if_port = IF_PORT_10BASET;
+		}
+
+	}
+	else {
+		*link = 0;
+		*speed = 0;
+		dev->if_port = IF_PORT_UNKNOWN;
+	}
+	return 0;
+}
+
+int lxt971a_init(struct net_device *dev, int phy_addr)
+{
+	if (au1000_debug > 4)
+		printk("lxt971a_init\n");
+
+	/* restart auto-negotiation */
+	mdio_write(dev, phy_addr, MII_CONTROL,
+		   MII_CNTL_F100 | MII_CNTL_AUTO | MII_CNTL_RST_AUTO | MII_CNTL_FDX);
+
+	/* set up LEDs to correct display */
+	mdio_write(dev, phy_addr, 20, 0x0422);
+
+	if (au1000_debug > 4)
+		dump_mii(dev, phy_addr);
+	return 0;
+}
+
+int lxt971a_reset(struct net_device *dev, int phy_addr)
+{
+	s16 mii_control, timeout;
+	
+	if (au1000_debug > 4) {
+		printk("lxt971a_reset\n");
+		dump_mii(dev, phy_addr);
+	}
+
+	mii_control = mdio_read(dev, phy_addr, MII_CONTROL);
+	mdio_write(dev, phy_addr, MII_CONTROL, mii_control | MII_CNTL_RESET);
+	mdelay(1);
+	for (timeout = 100; timeout > 0; --timeout) {
+		mii_control = mdio_read(dev, phy_addr, MII_CONTROL);
+		if ((mii_control & MII_CNTL_RESET) == 0)
+			break;
+		mdelay(1);
+	}
+	if (mii_control & MII_CNTL_RESET) {
+		printk(KERN_ERR "%s PHY reset timeout !\n", dev->name);
+		return -1;
+	}
+	return 0;
+}
+
+int
+lxt971a_status(struct net_device *dev, int phy_addr, u16 *link, u16 *speed)
+{
+	u16 mii_data;
+	struct au1000_private *aup;
+
+	if (!dev) {
+		printk(KERN_ERR "lxt971a_status error: NULL dev\n");
+		return -1;
+	}
+	aup = (struct au1000_private *) dev->priv;
+
+	mii_data = mdio_read(dev, aup->phy_addr, MII_STATUS);
+	if (mii_data & MII_STAT_LINK) {
+		*link = 1;
+		mii_data = mdio_read(dev, aup->phy_addr, MII_INTEL_PHY_STAT);
+		if (mii_data & MII_INTEL_PHY_STAT_SPD) {
+			if (mii_data & MII_INTEL_PHY_STAT_FDX) {
+				*speed = IF_PORT_100BASEFX;
+				dev->if_port = IF_PORT_100BASEFX;
+			}
+			else {
+				*speed = IF_PORT_100BASETX;
+				dev->if_port = IF_PORT_100BASETX;
+			}
+		}
+		else  {
+			*speed = IF_PORT_10BASET;
+			dev->if_port = IF_PORT_10BASET;
+		}
+
+	}
+	else {
+		*link = 0;
+		*speed = 0;
+		dev->if_port = IF_PORT_UNKNOWN;
+	}
+	return 0;
+}
+
+int ks8995m_init(struct net_device *dev, int phy_addr)
+{
+	s16 data;
+	
+//	printk("ks8995m_init\n");
+	/* Stop auto-negotiation */
+	data = mdio_read(dev, phy_addr, MII_CONTROL);
+	mdio_write(dev, phy_addr, MII_CONTROL, data & ~MII_CNTL_AUTO);
+
+	/* Set advertisement to 10/100 and Half/Full duplex
+	 * (full capabilities) */
+	data = mdio_read(dev, phy_addr, MII_ANADV);
+	data |= MII_NWAY_TX | MII_NWAY_TX_FDX | MII_NWAY_T_FDX | MII_NWAY_T;
+	mdio_write(dev, phy_addr, MII_ANADV, data);
+	
+	/* Restart auto-negotiation */
+	data = mdio_read(dev, phy_addr, MII_CONTROL);
+	data |= MII_CNTL_RST_AUTO | MII_CNTL_AUTO;
+	mdio_write(dev, phy_addr, MII_CONTROL, data);
+
+	if (au1000_debug > 4) dump_mii(dev, phy_addr);
+
+	return 0;
+}
+
+int ks8995m_reset(struct net_device *dev, int phy_addr)
+{
+	s16 mii_control, timeout;
+	
+//	printk("ks8995m_reset\n");
+	mii_control = mdio_read(dev, phy_addr, MII_CONTROL);
+	mdio_write(dev, phy_addr, MII_CONTROL, mii_control | MII_CNTL_RESET);
+	mdelay(1);
+	for (timeout = 100; timeout > 0; --timeout) {
+		mii_control = mdio_read(dev, phy_addr, MII_CONTROL);
+		if ((mii_control & MII_CNTL_RESET) == 0)
+			break;
+		mdelay(1);
+	}
+	if (mii_control & MII_CNTL_RESET) {
+		printk(KERN_ERR "%s PHY reset timeout !\n", dev->name);
+		return -1;
+	}
+	return 0;
+}
+
+int ks8995m_status(struct net_device *dev, int phy_addr, u16 *link, u16 *speed)
+{
+	u16 mii_data;
+	struct au1000_private *aup;
+
+	if (!dev) {
+		printk(KERN_ERR "ks8995m_status error: NULL dev\n");
+		return -1;
+	}
+	aup = (struct au1000_private *) dev->priv;
+
+	mii_data = mdio_read(dev, aup->phy_addr, MII_STATUS);
+	if (mii_data & MII_STAT_LINK) {
+		*link = 1;
+		mii_data = mdio_read(dev, aup->phy_addr, MII_AUX_CNTRL);
+		if (mii_data & MII_AUX_100) {
+			if (mii_data & MII_AUX_FDX) {
+				*speed = IF_PORT_100BASEFX;
+				dev->if_port = IF_PORT_100BASEFX;
+			}
+			else {
+				*speed = IF_PORT_100BASETX;
+				dev->if_port = IF_PORT_100BASETX;
+			}
+		}
+		else  {											
+			*speed = IF_PORT_10BASET;
+			dev->if_port = IF_PORT_10BASET;
+		}
+
+	}
+	else {
+		*link = 0;
+		*speed = 0;
+		dev->if_port = IF_PORT_UNKNOWN;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_MIPS_BOSPORUS
+int stub_init(struct net_device *dev, int phy_addr)
+{
+	//printk("PHY stub_init\n");
+	return 0;
+}
+
+int stub_reset(struct net_device *dev, int phy_addr)
+{
+	//printk("PHY stub_reset\n");
+	return 0;
+}
+
+int 
+stub_status(struct net_device *dev, int phy_addr, u16 *link, u16 *speed)
+{
+	//printk("PHY stub_status\n");
+	*link = 1;
+	/* hmmm, revisit */
+	*speed = IF_PORT_100BASEFX;
+	dev->if_port = IF_PORT_100BASEFX;
+	return 0;
+}
+#endif
+
 struct phy_ops bcm_5201_ops = {
 	bcm_5201_init,
 	bcm_5201_reset,
 	bcm_5201_status,
 };
 
+struct phy_ops am79c874_ops = {
+	am79c874_init,
+	am79c874_reset,
+	am79c874_status,
+};
+
 struct phy_ops am79c901_ops = {
 	am79c901_init,
 	am79c901_reset,
@@ -360,26 +640,82 @@
 	lsi_80227_status,
 };
 
+struct phy_ops lxt971a_ops = { 
+	lxt971a_init,
+	lxt971a_reset,
+	lxt971a_status,
+};
+
+struct phy_ops ks8995m_ops = {
+	ks8995m_init,
+	ks8995m_reset,
+	ks8995m_status,
+};
+
+#ifdef CONFIG_MIPS_BOSPORUS
+struct phy_ops stub_ops = {
+	stub_init,
+	stub_reset,
+	stub_status,
+};
+#endif
+
 static struct mii_chip_info {
 	const char * name;
 	u16 phy_id0;
 	u16 phy_id1;
 	struct phy_ops *phy_ops;	
+	int dual_phy;
 } mii_chip_table[] = {
-	{"Broadcom BCM5201 10/100 BaseT PHY",  0x0040, 0x6212, &bcm_5201_ops },
-	{"AMD 79C901 HomePNA PHY",  0x0000, 0x35c8, &am79c901_ops },
-	{"LSI 80227 10/100 BaseT PHY", 0x0016, 0xf840, &lsi_80227_ops },
-	{"Broadcom BCM5221 10/100 BaseT PHY",  0x0040, 0x61e4, &bcm_5201_ops },
+	{"Broadcom BCM5201 10/100 BaseT PHY",0x0040,0x6212, &bcm_5201_ops,0},
+	{"Broadcom BCM5221 10/100 BaseT PHY",0x0040,0x61e4, &bcm_5201_ops,0},
+	{"Broadcom BCM5222 10/100 BaseT PHY",0x0040,0x6322, &bcm_5201_ops,1},
+	{"AMD 79C901 HomePNA PHY",0x0000,0x35c8, &am79c901_ops,0},
+	{"AMD 79C874 10/100 BaseT PHY",0x0022,0x561b, &am79c874_ops,0},
+	{"LSI 80227 10/100 BaseT PHY",0x0016,0xf840, &lsi_80227_ops,0},
+	{"Intel LXT971A Dual Speed PHY",0x0013,0x78e2, &lxt971a_ops,0},
+	{"Kendin KS8995M 10/100 BaseT PHY",0x0022,0x1450, &ks8995m_ops,0},
+#ifdef CONFIG_MIPS_BOSPORUS
+	{"Stub", 0x1234, 0x5678, &stub_ops },
+#endif
 	{0,},
 };
 
 static int mdio_read(struct net_device *dev, int phy_id, int reg)
 {
 	struct au1000_private *aup = (struct au1000_private *) dev->priv;
+	volatile u32 *mii_control_reg;
+	volatile u32 *mii_data_reg;
 	u32 timedout = 20;
 	u32 mii_control;
 
-	while (aup->mac->mii_control & MAC_MII_BUSY) {
+	#ifdef CONFIG_BCM5222_DUAL_PHY
+	/* First time we probe, it's for the mac0 phy.
+	 * Since we haven't determined yet that we have a dual phy,
+	 * aup->mii->mii_control_reg won't be setup and we'll
+	 * default to the else statement.
+	 * By the time we probe for the mac1 phy, the mii_control_reg
+	 * will be setup to be the address of the mac0 phy control since
+	 * both phys are controlled through mac0.
+	 */
+	if (aup->mii && aup->mii->mii_control_reg) {
+		mii_control_reg = aup->mii->mii_control_reg;
+		mii_data_reg = aup->mii->mii_data_reg;
+	}
+	else if (au_macs[0]->mii && au_macs[0]->mii->mii_control_reg) {
+		/* assume both phys are controlled through mac0 */
+		mii_control_reg = au_macs[0]->mii->mii_control_reg;
+		mii_data_reg = au_macs[0]->mii->mii_data_reg;
+	}
+	else 
+	#endif
+	{
+		/* default control and data reg addresses */
+		mii_control_reg = &aup->mac->mii_control;
+		mii_data_reg = &aup->mac->mii_data;
+	}
+
+	while (*mii_control_reg & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			printk(KERN_ERR "%s: read_MII busy timeout!!\n", 
@@ -391,10 +727,10 @@
 	mii_control = MAC_SET_MII_SELECT_REG(reg) | 
 		MAC_SET_MII_SELECT_PHY(phy_id) | MAC_MII_READ;
 
-	aup->mac->mii_control = mii_control;
+	*mii_control_reg = mii_control;
 
 	timedout = 20;
-	while (aup->mac->mii_control & MAC_MII_BUSY) {
+	while (*mii_control_reg & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			printk(KERN_ERR "%s: mdio_read busy timeout!!\n", 
@@ -402,16 +738,36 @@
 			return -1;
 		}
 	}
-	return (int)aup->mac->mii_data;
+	return (int)*mii_data_reg;
 }
 
 static void mdio_write(struct net_device *dev, int phy_id, int reg, u16 value)
 {
 	struct au1000_private *aup = (struct au1000_private *) dev->priv;
+	volatile u32 *mii_control_reg;
+	volatile u32 *mii_data_reg;
 	u32 timedout = 20;
 	u32 mii_control;
 
-	while (aup->mac->mii_control & MAC_MII_BUSY) {
+	#ifdef CONFIG_BCM5222_DUAL_PHY
+	if (aup->mii && aup->mii->mii_control_reg) {
+		mii_control_reg = aup->mii->mii_control_reg;
+		mii_data_reg = aup->mii->mii_data_reg;
+	}
+	else if (au_macs[0]->mii && au_macs[0]->mii->mii_control_reg) {
+		/* assume both phys are controlled through mac0 */
+		mii_control_reg = au_macs[0]->mii->mii_control_reg;
+		mii_data_reg = au_macs[0]->mii->mii_data_reg;
+	}
+	else 
+	#endif
+	{
+		/* default control and data reg addresses */
+		mii_control_reg = &aup->mac->mii_control;
+		mii_data_reg = &aup->mac->mii_data;
+	}
+
+	while (*mii_control_reg & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			printk(KERN_ERR "%s: mdio_write busy timeout!!\n", 
@@ -423,8 +779,8 @@
 	mii_control = MAC_SET_MII_SELECT_REG(reg) | 
 		MAC_SET_MII_SELECT_PHY(phy_id) | MAC_MII_WRITE;
 
-	aup->mac->mii_data = value;
-	aup->mac->mii_control = mii_control;
+	*mii_data_reg = value;
+	*mii_control_reg = mii_control;
 }
 
 
@@ -442,12 +798,13 @@
 	}
 }
 
-static int __init mii_probe (struct net_device * dev)
+static int mii_probe (struct net_device * dev)
 {
 	struct au1000_private *aup = (struct au1000_private *) dev->priv;
 	int phy_addr;
-
-	aup->mii = NULL;
+#ifdef CONFIG_MIPS_BOSPORUS
+	int phy_found=0;
+#endif
 
 	/* search for total of 32 possible mii phy addresses */
 	for (phy_addr = 0; phy_addr < 32; phy_addr++) {
@@ -455,6 +812,14 @@
 		u16 phy_id0, phy_id1;
 		int i;
 
+		#ifdef CONFIG_BCM5222_DUAL_PHY
+		/* Mask the already found phy, try next one */
+		if (au_macs[0]->mii && au_macs[0]->mii->mii_control_reg) {
+			if (au_macs[0]->phy_addr == phy_addr)
+				continue;
+		}
+		#endif
+
 		mii_status = mdio_read(dev, phy_addr, MII_STATUS);
 		if (mii_status == 0xffff || mii_status == 0x0000)
 			/* the mii is not accessable, try next one */
@@ -467,6 +832,65 @@
 		for (i = 0; mii_chip_table[i].phy_id1; i++) {
 			if (phy_id0 == mii_chip_table[i].phy_id0 &&
 			    phy_id1 == mii_chip_table[i].phy_id1) {
+				struct mii_phy * mii_phy = aup->mii;
+
+				printk(KERN_INFO "%s: %s at phy address %d\n",
+				       dev->name, mii_chip_table[i].name, 
+				       phy_addr);
+#ifdef CONFIG_MIPS_BOSPORUS
+				phy_found = 1;
+#endif
+				mii_phy->chip_info = mii_chip_table+i;
+				aup->phy_addr = phy_addr;
+				aup->phy_ops = mii_chip_table[i].phy_ops;
+				aup->phy_ops->phy_init(dev,phy_addr);
+
+				// Check for dual-phy and then store required 
+				// values and set indicators. We need to do 
+				// this now since mdio_{read,write} need the 
+				// control and data register addresses.
+				#ifdef CONFIG_BCM5222_DUAL_PHY
+				if ( mii_chip_table[i].dual_phy) {
+
+					/* assume both phys are controlled 
+					 * through MAC0. Board specific? */
+					
+					/* sanity check */
+					if (!au_macs[0] || !au_macs[0]->mii)
+						return -1;
+					aup->mii->mii_control_reg = (u32 *)
+						&au_macs[0]->mac->mii_control;
+					aup->mii->mii_data_reg = (u32 *)
+						&au_macs[0]->mac->mii_data;
+				}
+				#endif
+				goto found;
+			}
+		}
+	}
+found:
+
+#ifdef CONFIG_MIPS_BOSPORUS
+	/* This is a workaround for the Micrel/Kendin 5 port switch
+	   The second MAC doesn't see a PHY connected... so we need to
+	   trick it into thinking we have one.
+		
+	   If this kernel is run on another Au1500 development board
+	   the stub will be found as well as the actual PHY. However,
+	   the last found PHY will be used... usually at Addr 31 (Db1500).	
+	*/
+	if ( (!phy_found) )
+	{
+		u16 phy_id0, phy_id1;
+		int i;
+
+		phy_id0 = 0x1234;
+		phy_id1 = 0x5678;
+
+		/* search our mii table for the current mii */ 
+		for (i = 0; mii_chip_table[i].phy_id1; i++) {
+			if (phy_id0 == mii_chip_table[i].phy_id0 &&
+			    phy_id1 == mii_chip_table[i].phy_id1) {
 				struct mii_phy * mii_phy;
 
 				printk(KERN_INFO "%s: %s at phy address %d\n",
@@ -476,31 +900,39 @@
 						GFP_KERNEL);
 				if (mii_phy) {
 					mii_phy->chip_info = mii_chip_table+i;
-					mii_phy->phy_addr = phy_addr;
+					aup->phy_addr = phy_addr;
 					mii_phy->next = aup->mii;
 					aup->phy_ops = 
 						mii_chip_table[i].phy_ops;
 					aup->mii = mii_phy;
 					aup->phy_ops->phy_init(dev,phy_addr);
 				} else {
-					printk(KERN_ERR "%s: out of memory\n",
+					printk(KERN_ERR "%s: out of memory\n", 
 							dev->name);
 					return -1;
 				}
-				/* the current mii is on our mii_info_table,
-				   try next address */
+				mii_phy->chip_info = mii_chip_table+i;
+				aup->phy_addr = phy_addr;
+				aup->phy_ops = mii_chip_table[i].phy_ops;
+				aup->phy_ops->phy_init(dev,phy_addr);
 				break;
 			}
 		}
 	}
+	if (aup->mac_id == 0) {
+		/* the Bosporus phy responds to addresses 0-5 but 
+		 * 5 is the correct one.
+		 */
+		aup->phy_addr = 5;
+	}
+#endif
 
 	if (aup->mii == NULL) {
-		printk(KERN_ERR "%s: No MII transceivers found!\n", dev->name);
+		printk(KERN_ERR "%s: Au1x No MII transceivers found!\n",
+				dev->name);
 		return -1;
 	}
 
-	/* use last PHY */
-	aup->phy_addr = aup->mii->phy_addr;
 	printk(KERN_INFO "%s: Using %s as default\n", 
 			dev->name, aup->mii->chip_info->name);
 
@@ -521,7 +953,6 @@
 	if (pDB) {
 		aup->pDBfree = pDB->pnext;
 	}
-	//printk("GetFreeDB: %x\n", pDB);
 	return pDB;
 }
 
@@ -587,6 +1018,7 @@
 
 static void reset_mac(struct net_device *dev)
 {
+	int i;
 	u32 flags;
 	struct au1000_private *aup = (struct au1000_private *) dev->priv;
 
@@ -597,11 +1029,27 @@
 	spin_lock_irqsave(&aup->lock, flags);
 	del_timer(&aup->timer);
 	hard_stop(dev);
-	*aup->enable = MAC_EN_CLOCK_ENABLE;
-	au_sync_delay(2);
-       	*aup->enable = 0;
-	au_sync_delay(2);
+	#ifdef CONFIG_BCM5222_DUAL_PHY
+	if (aup->mac_id != 0) {
+	#endif
+		/* If BCM5222, we can't leave MAC0 in reset because then 
+		 * we can't access the dual phy for ETH1 */
+		*aup->enable = MAC_EN_CLOCK_ENABLE;
+		au_sync_delay(2);
+		*aup->enable = 0;
+		au_sync_delay(2);
+	#ifdef CONFIG_BCM5222_DUAL_PHY
+	}
+	#endif
 	aup->tx_full = 0;
+	for (i = 0; i < NUM_RX_DMA; i++) {
+		/* reset control bits */
+		aup->rx_dma_ring[i]->buff_stat &= ~0xf;
+	}
+	for (i = 0; i < NUM_TX_DMA; i++) {
+		/* reset control bits */
+		aup->tx_dma_ring[i]->buff_stat &= ~0xf;
+	}
 	spin_unlock_irqrestore(&aup->lock, flags);
 }
 
@@ -616,95 +1064,110 @@
 {
 	int i;
 
-	for (i=0; i<NUM_RX_DMA; i++) {
+	for (i = 0; i < NUM_RX_DMA; i++) {
 		aup->rx_dma_ring[i] = 
 			(volatile rx_dma_t *) (rx_base + sizeof(rx_dma_t)*i);
 	}
-	for (i=0; i<NUM_TX_DMA; i++) {
+	for (i = 0; i < NUM_TX_DMA; i++) {
 		aup->tx_dma_ring[i] = 
 			(volatile tx_dma_t *) (tx_base + sizeof(tx_dma_t)*i);
 	}
 }
 
+static struct {
+	int port;
+	u32 base_addr;
+	int irq;
+	struct net_device *dev;
+} iflist[2];
+
+static int num_ifs;
+
+/*
+ * Setup the base address and interupt of the Au1xxx ethernet macs
+ * based on cpu type and whether the interface is enabled in sys_pinfunc
+ * register. The last interface is enabled if SYS_PF_NI2 (bit 4) is 0.
+ */
 static int __init au1000_init_module(void)
 {
-	int i;
-	int prid;
-	int base_addr, irq;
-
-	prid = read_32bit_cp0_register(CP0_PRID);
-	for (i=0; i<NUM_INTERFACES; i++) {
-		if ( (prid & 0xffff0000) == 0x00030000 ) {
-			base_addr = au1000_iflist[i].port;
-			irq = au1000_iflist[i].irq;
-		} else if ( (prid & 0xffff0000) == 0x01030000 ) {
-			base_addr = au1500_iflist[i].port;
-			irq = au1500_iflist[i].irq;
-		} else if ( (prid & 0xffff0000) == 0x02030000 ) {
-			base_addr = au1100_iflist[i].port;
-			irq = au1100_iflist[i].irq;
-		} else {
-			printk(KERN_ERR "au1000 eth: unknown Processor ID\n");
-			return -ENODEV;
-		}
-		// check for valid entries, au1100 only has one entry
-		if (base_addr && irq) {
-		if (au1000_probe1(NULL, base_addr, irq, i) != 0) {
-			return -ENODEV;
-		}
+	struct cpuinfo_mips *c = &current_cpu_data;
+	int ni = (int)((au_readl(SYS_PINFUNC) & (u32)(SYS_PF_NI2)) >> 4);
+	struct net_device *dev;
+	int i, found_one = 0;
+
+	iflist[0].irq = AU1000_ETH0_IRQ;
+	iflist[1].irq = AU1000_ETH1_IRQ;
+	switch (c->cputype) {
+	case CPU_AU1000:
+		num_ifs = 2 - ni;
+		iflist[0].base_addr = AU1000_ETH0_BASE;
+		iflist[1].base_addr = AU1000_ETH1_BASE;
+		break;
+	case CPU_AU1100:
+		num_ifs = 1 - ni;
+		iflist[0].base_addr = AU1000_ETH0_BASE;
+		break;
+	case CPU_AU1500:
+		num_ifs = 2 - ni;
+		iflist[0].base_addr = AU1500_ETH0_BASE;
+		iflist[1].base_addr = AU1500_ETH1_BASE;
+		break;
+	default:
+		num_ifs = 0;
 	}
+	for(i = 0; i < num_ifs; i++) {
+		dev = au1000_probe(iflist[i].base_addr, iflist[i].irq, i);
+		iflist[i].dev = dev;
+		if (dev)
+			found_one++;
 	}
+	if (!found_one)
+		return -ENODEV;
 	return 0;
 }
 
-static int __init
-au1000_probe1(struct net_device *dev, long ioaddr, int irq, int port_num)
+static struct net_device *
+au1000_probe(u32 ioaddr, int irq, int port_num)
 {
 	static unsigned version_printed = 0;
 	struct au1000_private *aup = NULL;
-	int i, retval = 0;
+	struct net_device *dev = NULL;
 	db_dest_t *pDB, *pDBfree;
 	char *pmac, *argptr;
 	char ethaddr[6];
+	int i, err;
 
-	if (!request_region(ioaddr, MAC_IOSIZE, "Au1000 ENET")) {
-		 return -ENODEV;
-	}
+	if (!request_region(ioaddr, MAC_IOSIZE, "Au1x00 ENET"))
+		return NULL;
 
-	if (version_printed++ == 0) printk(version);
+	if (version_printed++ == 0) 
+		printk(version);
 
+	dev = alloc_etherdev(sizeof(struct au1000_private));
 	if (!dev) {
-		dev = init_etherdev(0, sizeof(struct au1000_private));
+		printk (KERN_ERR "au1000 eth: alloc_etherdev failed\n");  
+		return NULL;
 	}
-	if (!dev) {
-		 printk (KERN_ERR "au1000 eth: init_etherdev failed\n");  
-		 return -ENODEV;
+
+	if ((err = register_netdev(dev))) {
+		printk(KERN_ERR "Au1x_eth Cannot register net device err %d\n",
+				err);
+		kfree(dev);
+		return NULL;
 	}
 
-	printk("%s: Au1xxx ethernet found at 0x%lx, irq %d\n", 
+	printk("%s: Au1x Ethernet found at 0x%x, irq %d\n", 
 			dev->name, ioaddr, irq);
 
-	/* Initialize our private structure */
-	if (dev->priv == NULL) {
-		aup = (struct au1000_private *) 
-			kmalloc(sizeof(*aup), GFP_KERNEL);
-		if (aup == NULL) {
-			retval = -ENOMEM;
-			goto free_region;
-		}
-		dev->priv = aup;
-	}
-
 	aup = dev->priv;
-	memset(aup, 0, sizeof(*aup));
-
 
 	/* Allocate the data buffers */
 	aup->vaddr = (u32)dma_alloc(MAX_BUF_SIZE * 
 			(NUM_TX_BUFFS+NUM_RX_BUFFS), &aup->dma_addr);
 	if (!aup->vaddr) {
-		retval = -ENOMEM;
-		goto free_region;
+		kfree(dev);
+		release_region(ioaddr, MAC_IOSIZE);
+		return NULL;
 	}
 
 	/* aup->mac is the base address of the MAC's registers */
@@ -737,7 +1200,10 @@
 				((unsigned long)AU1500_MAC0_ENABLE);
 		memcpy(dev->dev_addr, au1000_mac_addr, sizeof(dev->dev_addr));
 		setup_hw_rings(aup, MAC0_RX_DMA_ADDR, MAC0_TX_DMA_ADDR);
+		aup->mac_id = 0;
+		au_macs[0] = aup;
 			break;
+
 	case AU1000_ETH1_BASE:
 	case AU1500_ETH1_BASE:
 		if (ioaddr == AU1000_ETH1_BASE)
@@ -749,15 +1215,16 @@
 		memcpy(dev->dev_addr, au1000_mac_addr, sizeof(dev->dev_addr));
 		dev->dev_addr[4] += 0x10;
 		setup_hw_rings(aup, MAC1_RX_DMA_ADDR, MAC1_TX_DMA_ADDR);
+		aup->mac_id = 1;
+		au_macs[1] = aup;
 			break;
+
 	default:
 		printk(KERN_ERR "%s: bad ioaddr\n", dev->name);
 		break;
 
 	}
 
-	aup->phy_addr = PHY_ADDRESS;
-
 	/* bring the device out of reset, otherwise probing the mii
 	 * will hang */
 	*aup->enable = MAC_EN_CLOCK_ENABLE;
@@ -766,14 +1233,22 @@
 		MAC_EN_RESET2 | MAC_EN_CLOCK_ENABLE;
 	au_sync_delay(2);
 
+	aup->mii = kmalloc(sizeof(struct mii_phy), GFP_KERNEL);
+	if (!aup->mii) {
+		printk(KERN_ERR "%s: out of memory\n", dev->name);
+		goto err_out;
+	}
+	aup->mii->mii_control_reg = 0;
+	aup->mii->mii_data_reg = 0;
+
 	if (mii_probe(dev) != 0) {
-		 goto free_region;
+		goto err_out;
 	}
 
 	pDBfree = NULL;
 	/* setup the data buffer descriptors and attach a buffer to each one */
 	pDB = aup->db;
-	for (i=0; i<(NUM_TX_BUFFS+NUM_RX_BUFFS); i++) {
+	for (i = 0; i < (NUM_TX_BUFFS+NUM_RX_BUFFS); i++) {
 		pDB->pnext = pDBfree;
 		pDBfree = pDB;
 		pDB->vaddr = (u32 *)((unsigned)aup->vaddr + MAX_BUF_SIZE*i);
@@ -782,15 +1257,19 @@
 	}
 	aup->pDBfree = pDBfree;
 
-	for (i=0; i<NUM_RX_DMA; i++) {
+	for (i = 0; i < NUM_RX_DMA; i++) {
 		pDB = GetFreeDB(aup);
-		if (!pDB) goto free_region;
+		if (!pDB) {
+			goto err_out;
+		}
 		aup->rx_dma_ring[i]->buff_stat = (unsigned)pDB->dma_addr;
 		aup->rx_db_inuse[i] = pDB;
 	}
-	for (i=0; i<NUM_TX_DMA; i++) {
+	for (i = 0; i < NUM_TX_DMA; i++) {
 		pDB = GetFreeDB(aup);
-		if (!pDB) goto free_region;
+		if (!pDB) {
+			goto err_out;
+		}
 		aup->tx_dma_ring[i]->buff_stat = (unsigned)pDB->dma_addr;
 		aup->tx_dma_ring[i]->len = 0;
 		aup->tx_db_inuse[i] = pDB;
@@ -809,32 +1288,36 @@
 	dev->tx_timeout = au1000_tx_timeout;
 	dev->watchdog_timeo = ETH_TX_TIMEOUT;
 
-
-	/* Fill in the fields of the device structure with ethernet values. */
-	ether_setup(dev);
-
 	/* 
 	 * The boot code uses the ethernet controller, so reset it to start 
 	 * fresh.  au1000_init() expects that the device is in reset state.
 	 */
 	reset_mac(dev);
-	return 0;
 
-free_region:
-	release_region(ioaddr, MAC_IOSIZE);
+	return dev;
+
+err_out:
+	/* here we should have a valid dev plus aup-> register addresses
+	 * so we can reset the mac properly.*/
+	reset_mac(dev);
+	if (aup->mii)
+		kfree(aup->mii);
+	for (i = 0; i < NUM_RX_DMA; i++) {
+		if (aup->rx_db_inuse[i])
+			ReleaseDB(aup, aup->rx_db_inuse[i]);
+	}
+	for (i = 0; i < NUM_TX_DMA; i++) {
+		if (aup->tx_db_inuse[i])
+			ReleaseDB(aup, aup->tx_db_inuse[i]);
+	}
+	dma_free((void *)aup->vaddr, MAX_BUF_SIZE * 
+			(NUM_TX_BUFFS+NUM_RX_BUFFS));
 	unregister_netdev(dev);
-	if (aup->vaddr) 
-		dma_free((void *)aup->vaddr, 
-				MAX_BUF_SIZE * (NUM_TX_BUFFS+NUM_RX_BUFFS));
-	if (dev->priv != NULL)
-		kfree(dev->priv);
-	printk(KERN_ERR "%s: au1000_probe1 failed.  Returns %d\n",
-	       dev->name, retval);
 	kfree(dev);
-	return retval;
+	release_region(ioaddr, MAC_IOSIZE);
+	return NULL;
 }
 
-
 /* 
  * Initialize the interface.
  *
@@ -852,7 +1335,8 @@
 	u32 control;
 	u16 link, speed;
 
-	if (au1000_debug > 4) printk("%s: au1000_init\n", dev->name);
+	if (au1000_debug > 4) 
+		printk("%s: au1000_init\n", dev->name);
 
 	spin_lock_irqsave(&aup->lock, flags);
 
@@ -872,7 +1356,7 @@
 	aup->mac->mac_addr_low = dev->dev_addr[3]<<24 | dev->dev_addr[2]<<16 |
 		dev->dev_addr[1]<<8 | dev->dev_addr[0];
 
-	for (i=0; i<NUM_RX_DMA; i++) {
+	for (i = 0; i < NUM_RX_DMA; i++) {
 		aup->rx_dma_ring[i]->buff_stat |= RX_DMA_ENABLE;
 	}
 	au_sync();
@@ -992,24 +1476,48 @@
 	if (au1000_debug > 4)
 		printk("%s: close: dev=%p\n", dev->name, dev);
 
+	reset_mac(dev);
+
 	spin_lock_irqsave(&aup->lock, flags);
 	
 	/* stop the device */
-	if (netif_device_present(dev)) {
-		netif_stop_queue(dev);
-	}
+	netif_stop_queue(dev);
 
 	/* disable the interrupt */
 	free_irq(dev->irq, dev);
 	spin_unlock_irqrestore(&aup->lock, flags);
 
-	reset_mac(dev);
 	MOD_DEC_USE_COUNT;
 	return 0;
 }
 
 static void __exit au1000_cleanup_module(void)
 {
+	int i, j;
+	struct net_device *dev;
+	struct au1000_private *aup;
+
+	for (i = 0; i < num_ifs; i++) {
+		dev = iflist[i].dev;
+		if (dev) {
+			aup = (struct au1000_private *) dev->priv;
+			unregister_netdev(dev);
+			if (aup->mii)
+				kfree(aup->mii);
+			for (j = 0; j < NUM_RX_DMA; j++) {
+				if (aup->rx_db_inuse[j])
+					ReleaseDB(aup, aup->rx_db_inuse[j]);
+			}
+			for (j = 0; j < NUM_TX_DMA; j++) {
+				if (aup->tx_db_inuse[j])
+					ReleaseDB(aup, aup->tx_db_inuse[j]);
+			}
+			dma_free((void *)aup->vaddr, MAX_BUF_SIZE * 
+					(NUM_TX_BUFFS+NUM_RX_BUFFS));
+			kfree(dev);
+			release_region(iflist[i].base_addr, MAC_IOSIZE);
+		}
+	}
 }
 
 
@@ -1081,7 +1589,7 @@
 	db_dest_t *pDB;
 	int i;
 
-	if (au1000_debug > 4)
+	if (au1000_debug > 5)
 		printk("%s: tx: aup %x len=%d, data=%p, head %d\n", 
 				dev->name, (unsigned)aup, skb->len, 
 				skb->data, aup->tx_head);
@@ -1106,11 +1614,11 @@
 
 	pDB = aup->tx_db_inuse[aup->tx_head];
 	memcpy((void *)pDB->vaddr, skb->data, skb->len);
-	if (skb->len < MAC_MIN_PKT_SIZE) {
-		for (i=skb->len; i<MAC_MIN_PKT_SIZE; i++) { 
+	if (skb->len < ETH_ZLEN) {
+		for (i=skb->len; i<ETH_ZLEN; i++) { 
 			((char *)pDB->vaddr)[i] = 0;
 		}
-		ptxd->len = MAC_MIN_PKT_SIZE;
+		ptxd->len = ETH_ZLEN;
 	}
 	else
 		ptxd->len = skb->len;
@@ -1159,8 +1667,9 @@
 	volatile rx_dma_t *prxd;
 	u32 buff_stat, status;
 	db_dest_t *pDB;
+	u32	frmlen;
 
-	if (au1000_debug > 4)
+	if (au1000_debug > 5)
 		printk("%s: au1000_rx head %d\n", dev->name, aup->rx_head);
 
 	prxd = aup->rx_dma_ring[aup->rx_head];
@@ -1172,7 +1681,9 @@
 		if (!(status & RX_ERROR))  {
 
 			/* good frame */
-			skb = dev_alloc_skb((status & RX_FRAME_LEN_MASK) + 2);
+			frmlen = (status & RX_FRAME_LEN_MASK);
+			frmlen -= 4; /* Remove FCS */
+			skb = dev_alloc_skb(frmlen + 2);
 			if (skb == NULL) {
 				printk(KERN_ERR
 				       "%s: Memory squeeze, dropping packet.\n",
@@ -1182,9 +1693,9 @@
 			}
 			skb->dev = dev;
 			skb_reserve(skb, 2);	/* 16 byte IP header align */
-			eth_copy_and_sum(skb, (unsigned char *)pDB->vaddr, 
-					status & RX_FRAME_LEN_MASK, 0);
-			skb_put(skb, status & RX_FRAME_LEN_MASK);
+			eth_copy_and_sum(skb,
+				(unsigned char *)pDB->vaddr, frmlen, 0);
+			skb_put(skb, frmlen);
 			skb->protocol = eth_type_trans(skb, dev);
 			netif_rx(skb);	/* pass the packet to upper layers */
 		}
@@ -1236,8 +1747,11 @@
 		printk(KERN_ERR "%s: isr: null dev ptr\n", dev->name);
 		return;
 	}
-	au1000_tx_ack(dev);
+
+	/* Handle RX interrupts first to minimize chance of overrun */
+
 	au1000_rx(dev);
+	au1000_tx_ack(dev);
 }
 
 
@@ -1250,6 +1764,8 @@
 	printk(KERN_ERR "%s: au1000_tx_timeout: dev=%p\n", dev->name, dev);
 	reset_mac(dev);
 	au1000_init(dev);
+	dev->trans_start = jiffies;
+	netif_wake_queue(dev);
 }
 
 
@@ -1305,27 +1821,19 @@
 
 static int au1000_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
-	u16 *data = (u16 *)&rq->ifr_data;
+	//u16 *data = (u16 *)&rq->ifr_data;
 
 	/* fixme */
-	switch (cmd) { 
-	case SIOCGMIIPHY:		/* Get the address of the PHY in use. */
-	case SIOCDEVPRIVATE:		/* binary compat, remove in 2.5 */
-		data[0] = PHY_ADDRESS;
-
-	case SIOCGMIIREG:		/* Read the specified MII register. */
-	case SIOCDEVPRIVATE+1:		/* binary compat, remove in 2.5 */
+	switch(cmd) { 
+		case SIOCDEVPRIVATE:	/* Get the address of the PHY in use. */
+		//data[0] = PHY_ADDRESS;
+		case SIOCDEVPRIVATE+1:	/* Read the specified MII register. */
 		//data[3] = mdio_read(ioaddr, data[0], data[1]); 
 		return 0;
-
-	case SIOCSMIIREG:		/* Write the specified MII register */
-	case SIOCDEVPRIVATE+2:		/* binary compat, remove in 2.5 */
-		if (!capable(CAP_NET_ADMIN))
-			return -EPERM;
+		case SIOCDEVPRIVATE+2:	/* Write the specified MII register */
 		//mdio_write(ioaddr, data[0], data[1], data[2]);
 		return 0;
-
-	default:
+		default:
 		return -EOPNOTSUPP;
 	}
 }
@@ -1389,7 +1897,6 @@
 			/* set Speed to 100Mbps, Half Duplex */
 			/* disable auto negotiation and enable 100MBit Mode */
 			control = mdio_read(dev, aup->phy_addr, MII_CONTROL);
-			printk("read control %x\n", control);
 			control &= ~(MII_CNTL_AUTO | MII_CNTL_FDX);
 			control |= MII_CNTL_F100;
 			mdio_write(dev, aup->phy_addr, MII_CONTROL, control);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/au1000_eth.h linux-2.4.22/drivers/net/au1000_eth.h
--- linux-2.4.22.clean/drivers/net/au1000_eth.h	2002-11-29 00:53:13.000000000 +0100
+++ linux-2.4.22/drivers/net/au1000_eth.h	2003-06-05 02:00:35.000000000 +0200
@@ -1,10 +1,13 @@
 /*
- * Alchemy Semi Au1000 ethernet driver include file
+ *
+ * Alchemy Au1x00 ethernet driver include file
  *
  * Author: Pete Popov <ppopov@mvista.com>
  *
  * Copyright 2001 MontaVista Software Inc.
  *
+ * ########################################################################
+ *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
  *  published by the Free Software Foundation.
@@ -17,14 +20,16 @@
  *  You should have received a copy of the GNU General Public License along
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * 
  */
-#include <linux/config.h>
 
 
-#define NUM_INTERFACES 2
 #define MAC_IOSIZE 0x10000
-#define NUM_RX_DMA 4       /* Au1000 has 4 rx hardware descriptors */
-#define NUM_TX_DMA 4       /* Au1000 has 4 tx hardware descriptors */
+#define NUM_RX_DMA 4       /* Au1x00 has 4 rx hardware descriptors */
+#define NUM_TX_DMA 4       /* Au1x00 has 4 tx hardware descriptors */
 
 #define NUM_RX_BUFFS 4
 #define NUM_TX_BUFFS 4
@@ -33,12 +38,6 @@
 #define ETH_TX_TIMEOUT HZ/4
 #define MAC_MIN_PKT_SIZE 64
 
-#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_PB1500) || defined(CONFIG_MIPS_PB1100)
-#define PHY_ADDRESS              0
-#define PHY_CONTROL_DEFAULT 0x3000
-#define PHY_CONTROL_REG_ADDR     0
-#endif
-
 #define MULTICAST_FILTER_LIMIT 64
 
 /* FIXME 
@@ -54,11 +53,13 @@
 #define MII_ANLPAR  0x0005
 #define MII_AEXP    0x0006
 #define MII_ANEXT   0x0007
-#define MII_LSI_CONFIG 0x0011
-#define MII_LSI_STAT   0x0012
-#define MII_AUX_CNTRL  0x0018
-#define MII_INT        0x001A
+#define MII_LSI_PHY_CONFIG 0x0011
+/* Status register */
+#define MII_LSI_PHY_STAT   0x0012
+#define MII_AMD_PHY_STAT   MII_LSI_PHY_STAT
+#define MII_INTEL_PHY_STAT 0x0011
 
+#define MII_AUX_CNTRL  0x0018
 /* mii registers specific to AMD 79C901 */
 #define	MII_STATUS_SUMMARY = 0x0018
 
@@ -121,23 +122,30 @@
 #define	MII_STSSUM_AUTO  0x0002
 #define MII_STSSUM_SPD   0x0001
 
-/* lsi status register */
-
-#define MII_LSI_STAT_FDX	0x0040
-#define MII_LSI_STAT_SPD	0x0080
+/* lsi phy status register */
+#define MII_LSI_PHY_STAT_FDX	0x0040
+#define MII_LSI_PHY_STAT_SPD	0x0080
+
+/* amd phy status register */
+#define MII_AMD_PHY_STAT_FDX	0x0800
+#define MII_AMD_PHY_STAT_SPD	0x0400
+
+/* intel phy status register */
+#define MII_INTEL_PHY_STAT_FDX	0x0200
+#define MII_INTEL_PHY_STAT_SPD	0x4000
 
 /* Auxilliary Control/Status Register */
 #define MII_AUX_FDX      0x0001
 #define MII_AUX_100      0x0002
 #define MII_AUX_F100     0x0004
 #define MII_AUX_ANEG     0x0008
-#define MII_FDX_LED	 0x8000
 
 typedef struct mii_phy {
 	struct mii_phy * next;
 	struct mii_chip_info * chip_info;
-	int phy_addr;
 	u16 status;
+	u32 *mii_control_reg;
+	u32 *mii_data_reg;
 } mii_phy_t;
 
 struct phy_ops {
@@ -204,6 +212,7 @@
 	u32 tx_tail;
 	u32 tx_full;
 
+	int mac_id;
 	mii_phy_t *mii;
 	struct phy_ops *phy_ops;
 	
@@ -217,7 +226,7 @@
 	u8 *hash_table;
 	u32 hash_mode;
 	u32 intr_work_done; /* number of Rx and Tx pkts processed in the isr */
-	u32 phy_addr;          /* PHY address */
+	int phy_addr;          /* phy address */
 	u32 options;           /* User-settable misc. driver options. */
 	u32 drv_flags;
 	struct net_device_stats stats;
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/Config.in linux-2.4.22/drivers/net/Config.in
--- linux-2.4.22.clean/drivers/net/Config.in	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/net/Config.in	2003-09-27 14:08:03.000000000 +0200
@@ -62,18 +62,18 @@
    if [ "$CONFIG_MIPS_GT96100" = "y" ]; then
       bool '  MIPS GT96100 Ethernet support' CONFIG_MIPS_GT96100ETH
    fi
-   if [ "$CONFIG_MIPS_AU1000" = "y" ]; then
-      bool '  MIPS AU1000 Ethernet support' CONFIG_MIPS_AU1000_ENET
+   if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
+      tristate '  MIPS Au1x00 Ethernet support' CONFIG_MIPS_AU1X00_ENET
+      if [ "$CONFIG_MIPS_AU1X00_ENET" = "y" ]; then
+         bool '   Broadcom 5222 Dual Phy Support' CONFIG_BCM5222_DUAL_PHY
+      fi
    fi
-   if [ "$CONFIG_SIBYTE_SB1250" = "y" ]; then
+   if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
       tristate '  SB1250 Ethernet support' CONFIG_NET_SB1250_MAC
    fi
    if [ "$CONFIG_SGI_IP27" = "y" ]; then
       bool '  SGI IOC3 Ethernet' CONFIG_SGI_IOC3_ETH
    fi
-   if [ "$CONFIG_SGI_IP32" = "y" ]; then
-      tristate '  SGI O2 MACE Fast Ethernet support' CONFIG_SGI_O2MACE_ETH
-   fi
    if [ "$CONFIG_IA64_SGI_SN1" = "y" ]; then
       bool '  SGI IOC3 Ethernet' CONFIG_SGI_IOC3_ETH
    fi
@@ -211,7 +211,7 @@
          tristate '    TI ThunderLAN support' CONFIG_TLAN
       fi
       if [ "$CONFIG_TOSHIBA_JMR3927" = "y" ]; then
-         dep_tristate '    TOSHIBA TC35815 Ethernet support' CONFIG_TC35815 $CONFIG_PCI
+	 dep_tristate '    TOSHIBA TC35815 Ethernet support' CONFIG_TC35815 $CONFIG_PCI
       fi
       dep_tristate '    VIA Rhine support' CONFIG_VIA_RHINE $CONFIG_PCI
       dep_mbool '      Use MMIO instead of PIO (EXPERIMENTAL)' CONFIG_VIA_RHINE_MMIO $CONFIG_VIA_RHINE $CONFIG_EXPERIMENTAL
@@ -232,11 +232,14 @@
       dep_tristate '    D-Link DE620 pocket adapter support' CONFIG_DE620 $CONFIG_ISA
    fi
    if [ "$CONFIG_SGI_IP22" = "y" ]; then
-      bool '  SGI Seeq ethernet controller support' CONFIG_SGISEEQ
+      tristate '  SGI Seeq ethernet controller support' CONFIG_SGISEEQ
    fi
    if [ "$CONFIG_DECSTATION" = "y" ]; then
       tristate '  DEC LANCE ethernet controller support' CONFIG_DECLANCE
    fi
+   if [ "$CONFIG_DECSTATION" = "y" ]; then
+      tristate '  PMAD-AA TC ethernet controller support' CONFIG_PMADAA
+   fi
    if [ "$CONFIG_BAGET_MIPS" = "y" ]; then
       tristate '  Baget AMD LANCE support' CONFIG_BAGETLANCE
    fi
@@ -271,6 +274,12 @@
 dep_tristate 'SysKonnect SK-98xx and SK-95xx Gigabit Ethernet Adapter family support' CONFIG_SK98LIN $CONFIG_PCI
 dep_tristate 'Broadcom Tigon3 support' CONFIG_TIGON3 $CONFIG_PCI
 
+if [ "$CONFIG_MOMENCO_OCELOT_C" = "y" -o "$CONFIG_MOMENCO_JAGUAR_ATX" = "y" ]; then
+   bool '  MV-64340 Ethernet support' CONFIG_MV64340_ETH
+   dep_bool '    MV-64340 Port 0' CONFIG_MV64340_ETH_0 $CONFIG_MV64340_ETH
+   dep_bool '    MV-64340 Port 1' CONFIG_MV64340_ETH_1 $CONFIG_MV64340_ETH
+   dep_bool '    MV-64340 Port 2' CONFIG_MV64340_ETH_2 $CONFIG_MV64340_ETH
+fi
 endmenu
 
 if [ "$CONFIG_PPC_ISERIES" = "y" ]; then
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/de4x5.c linux-2.4.22/drivers/net/de4x5.c
--- linux-2.4.22.clean/drivers/net/de4x5.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.22/drivers/net/de4x5.c	2003-02-25 23:03:07.000000000 +0100
@@ -999,7 +999,7 @@
 static void    srom_repair(struct net_device *dev, int card);
 static int     test_bad_enet(struct net_device *dev, int status);
 static int     an_exception(struct de4x5_bus_type *lp);
-#if !defined(__sparc_v9__) && !defined(__powerpc__) && !defined(__alpha__)
+#ifdef CONFIG_EISA
 static void    eisa_probe(struct net_device *dev, u_long iobase);
 #endif
 static void    pci_probe(struct net_device *dev, u_long iobase);
@@ -1053,7 +1053,7 @@
 #endif /* MODULE */
 
 static char name[DE4X5_NAME_LENGTH + 1];
-#if !defined(__sparc_v9__) && !defined(__powerpc__) && !defined(__alpha__)
+#ifdef CONFIG_EISA
 static u_char de4x5_irq[] = EISA_ALLOWED_IRQ_LIST;
 static int lastEISA;
 #  ifdef DE4X5_FORCE_EISA                 /* Force an EISA bus probe or not */
@@ -1131,7 +1131,7 @@
     u_long iobase = dev->base_addr;
 
     pci_probe(dev, iobase);
-#if !defined(__sparc_v9__) && !defined(__powerpc__) && !defined(__alpha__)
+#ifdef CONFIG_EISA
     if ((lastPCI == NO_MORE_PCI) && ((num_de4x5s == 0) || forceEISA)) {
         eisa_probe(dev, iobase);
     }
@@ -2093,7 +2093,7 @@
     return;
 }
 
-#if !defined(__sparc_v9__) && !defined(__powerpc__) && !defined(__alpha__)
+#ifdef CONFIG_EISA
 /*
 ** EISA bus I/O device probe. Probe from slot 1 since slot 0 is usually
 ** the motherboard. Upto 15 EISA devices are supported.
@@ -5363,7 +5363,7 @@
 	t = *q;
 	*q = '\0';
 
-#if !defined(__sparc_v9__) && !defined(__powerpc__) && !defined(__alpha__)
+#ifdef CONFIG_EISA
 	if (strstr(p, "force_eisa") || strstr(p, "FORCE_EISA")) forceEISA = 1;
 #endif
 	if (strstr(p, "fdx") || strstr(p, "FDX")) lp->params.fdx = 1;
@@ -5865,7 +5865,7 @@
     u_int class = DE4X5_CLASS_CODE;
     u_int device;
 
-#if !defined(__sparc_v9__) && !defined(__powerpc__) && !defined(__alpha__)
+#ifdef CONFIG_EISA
     char name[DE4X5_STRLEN];
     u_long iobase = 0x1000;
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/declance.c linux-2.4.22/drivers/net/declance.c
--- linux-2.4.22.clean/drivers/net/declance.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.22/drivers/net/declance.c	2003-09-21 03:01:50.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *      adopted from sunlance.c by Richard van den Berg
  *
- *      Copyright (C) 2002  Maciej W. Rozycki
+ *      Copyright (C) 2002, 2003  Maciej W. Rozycki
  *
  *      additional sources:
  *      - PMAD-AA TURBOchannel Ethernet Module Functional Specification,
@@ -52,6 +52,7 @@
 #include <linux/module.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
+#include <linux/spinlock.h>
 #include <linux/stddef.h>
 #include <linux/string.h>
 
@@ -271,7 +272,7 @@
 			lp->tx_old - lp->tx_new-1)
 
 /* The lance control ports are at an absolute address, machine and tc-slot
- * dependant.
+ * dependent.
  * DECstations do only 32-bit access and the LANCE uses 16 bit addresses,
  * so we have to give the structure an extra member making rap pointing
  * at the right address
@@ -783,19 +784,29 @@
 
 	/* Associate IRQ with lance_interrupt */
 	if (request_irq(dev->irq, &lance_interrupt, 0, "lance", dev)) {
-		printk("lance: Can't get IRQ %d\n", dev->irq);
+		printk("%s: Can't get IRQ %d\n", dev->name, dev->irq);
 		return -EAGAIN;
 	}
 	if (lp->dma_irq >= 0) {
+		unsigned long flags;
+
 		if (request_irq(lp->dma_irq, &lance_dma_merr_int, 0,
 				"lance error", dev)) {
 			free_irq(dev->irq, dev);
-			printk("lance: Can't get DMA IRQ %d\n", lp->dma_irq);
+			printk("%s: Can't get DMA IRQ %d\n", dev->name,
+				lp->dma_irq);
 			return -EAGAIN;
 		}
+
+		spin_lock_irqsave(&ioasic_ssr_lock, flags);
+
+		fast_mb();
 		/* Enable I/O ASIC LANCE DMA.  */
-		fast_wmb();
-		ioasic_write(SSR, ioasic_read(SSR) | LANCE_DMA_EN);
+		ioasic_write(IO_REG_SSR,
+			     ioasic_read(IO_REG_SSR) | IO_SSR_LANCE_DMA_EN);
+
+		fast_mb();
+		spin_unlock_irqrestore(&ioasic_ssr_lock, flags);
 	}
 
 	status = init_restart_lance(lp);
@@ -821,9 +832,18 @@
 	writereg(&ll->rdp, LE_C0_STOP);
 
 	if (lp->dma_irq >= 0) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&ioasic_ssr_lock, flags);
+
+		fast_mb();
 		/* Disable I/O ASIC LANCE DMA.  */
-		ioasic_write(SSR, ioasic_read(SSR) & ~LANCE_DMA_EN);
+		ioasic_write(IO_REG_SSR,
+			     ioasic_read(IO_REG_SSR) & ~IO_SSR_LANCE_DMA_EN);
+
 		fast_iob();
+		spin_unlock_irqrestore(&ioasic_ssr_lock, flags);
+
 		free_irq(lp->dma_irq, dev);
 	}
 	free_irq(dev->irq, dev);
@@ -856,8 +876,8 @@
 	volatile struct lance_regs *ll = lp->ll;
 
 	printk(KERN_ERR "%s: transmit timed out, status %04x, reset\n",
-			       dev->name, ll->rdp);
-			lance_reset(dev);
+		dev->name, ll->rdp);
+	lance_reset(dev);
 	netif_wake_queue(dev);
 }
 
@@ -872,10 +892,9 @@
 
 	len = skblen;
 	
-	if(len < ETH_ZLEN)
-	{
+	if (len < ETH_ZLEN) {
 		skb = skb_padto(skb, ETH_ZLEN);
-		if(skb == NULL)
+		if (skb == NULL)
 			return 0;
 		len = ETH_ZLEN;
 	}
@@ -890,7 +909,7 @@
 		  skblen);
 
 	/* Clear the slack of the packet, do I need this? */
-	/* For a firewall its a good idea - AC */
+	/* For a firewall it's a good idea - AC */
 /*
    if (len != skblen)
    memset ((char *) &ib->tx_buf [entry][skblen], 0, (len - skblen) << 1);
@@ -927,7 +946,7 @@
 	volatile u16 *mcast_table = (u16 *) & ib->filter;
 	struct dev_mc_list *dmi = dev->mc_list;
 	char *addrs;
-	int i, j, bit, byte;
+	int i;
 	u32 crc;
 
 	/* set all multicast bits */
@@ -1005,6 +1024,8 @@
 static int __init dec_lance_init(const int type, const int slot)
 {
 	static unsigned version_printed;
+	static const char fmt[] = "declance%d";
+	char name[10];
 	struct net_device *dev;
 	struct lance_private *lp;
 	volatile struct lance_regs *ll;
@@ -1019,13 +1040,26 @@
 	if (dec_lance_debug && version_printed++ == 0)
 		printk(version);
 
-	dev = init_etherdev(NULL, sizeof(struct lance_private));
-	if (!dev)
-		return -ENOMEM;
+	i = 0;
+	dev = root_lance_dev;
+	while (dev) {
+		i++;
+		lp = (struct lance_private *)dev->priv;
+		dev = lp->next;
+	}
+	snprintf(name, sizeof(name), fmt, i);
+
+	dev = alloc_etherdev(sizeof(struct lance_private));
+	if (!dev) {
+		printk(KERN_ERR "%s: Unable to allocate etherdev, aborting.\n",
+			name);
+		ret = -ENOMEM;
+		goto err_out;
+	}
 	SET_MODULE_OWNER(dev);
 
 	/*
-	 * init_etherdev ensures the data structures used by the LANCE
+	 * alloc_etherdev ensures the data structures used by the LANCE
 	 * are aligned.
 	 */
 	lp = (struct lance_private *) dev->priv;
@@ -1036,7 +1070,7 @@
 	switch (type) {
 #ifdef CONFIG_TC
 	case ASIC_LANCE:
-		dev->base_addr = system_base + LANCE;
+		dev->base_addr = system_base + IOASIC_LANCE;
 
 		/* buffer space for the on-board LANCE shared memory */
 		/*
@@ -1045,7 +1079,7 @@
 		dev->mem_start = KSEG1ADDR(0x00020000);
 		dev->mem_end = dev->mem_start + 0x00020000;
 		dev->irq = dec_interrupt[DEC_IRQ_LANCE];
-		esar_base = system_base + ESAR;
+		esar_base = system_base + IOASIC_ESAR;
 
 		/* Workaround crash with booting KN04 2.1k from Disk */
 		memset((void *)dev->mem_start, 0,
@@ -1074,7 +1108,8 @@
 
 		/* Setup I/O ASIC LANCE DMA.  */
 		lp->dma_irq = dec_interrupt[DEC_IRQ_LANCE_MERR];
-		ioasic_write(LANCE_DMA_P, PHYSADDR(dev->mem_start) << 3);
+		ioasic_write(IO_REG_LANCE_DMA_P,
+			     PHYSADDR(dev->mem_start) << 3);
 
 		break;
 
@@ -1139,9 +1174,10 @@
 		break;
 
 	default:
-		printk("declance_init called with unknown type\n");
+		printk(KERN_ERR "%s: declance_init called with unknown type\n",
+			name);
 		ret = -ENODEV;
-		goto err_out;
+		goto err_out_free_dev;
 	}
 
 	ll = (struct lance_regs *) dev->base_addr;
@@ -1151,19 +1187,21 @@
 	/* First, check for test pattern */
 	if (esar[0x60] != 0xff && esar[0x64] != 0x00 &&
 	    esar[0x68] != 0x55 && esar[0x6c] != 0xaa) {
-		printk("Ethernet station address prom not found!\n");
+		printk(KERN_ERR
+			"%s: Ethernet station address prom not found!\n",
+			name);
 		ret = -ENODEV;
-		goto err_out;
+		goto err_out_free_dev;
 	}
 	/* Check the prom contents */
 	for (i = 0; i < 8; i++) {
 		if (esar[i * 4] != esar[0x3c - i * 4] &&
 		    esar[i * 4] != esar[0x40 + i * 4] &&
 		    esar[0x3c - i * 4] != esar[0x40 + i * 4]) {
-			printk("Something is wrong with the ethernet "
-			       "station address prom!\n");
+			printk(KERN_ERR "%s: Something is wrong with the "
+				"ethernet station address prom!\n", name);
 			ret = -ENODEV;
-			goto err_out;
+			goto err_out_free_dev;
 		}
 	}
 
@@ -1176,13 +1214,13 @@
 	 */
 	switch (type) {
 	case ASIC_LANCE:
-		printk("%s: IOASIC onboard LANCE, addr = ", dev->name);
+		printk("%s: IOASIC onboard LANCE, addr = ", name);
 		break;
 	case PMAD_LANCE:
-		printk("%s: PMAD-AA, addr = ", dev->name);
+		printk("%s: PMAD-AA, addr = ", name);
 		break;
 	case PMAX_LANCE:
-		printk("%s: PMAX onboard LANCE, addr = ", dev->name);
+		printk("%s: PMAX onboard LANCE, addr = ", name);
 		break;
 	}
 	for (i = 0; i < 6; i++) {
@@ -1219,11 +1257,20 @@
 	lp->multicast_timer.data = (unsigned long) dev;
 	lp->multicast_timer.function = &lance_set_multicast_retry;
 
+	ret = register_netdev(dev);
+	if (ret) {
+		printk(KERN_ERR
+			"%s: Unable to register netdev, aborting.\n", name);
+		goto err_out_free_dev;
+	}
+
+	printk("%s: registered as %s.\n", name, dev->name);
 	return 0;
 
-err_out:
-	unregister_netdev(dev);
+err_out_free_dev:
 	kfree(dev);
+
+err_out:
 	return ret;
 }
 
@@ -1233,6 +1280,9 @@
 {
 	int count = 0;
 
+#if 0
+  /* We use this driver for the onboard LANCE only */
+
 	/* Scan slots for PMAD-AA cards first. */
 #ifdef CONFIG_TC
 	if (TURBOCHANNEL) {
@@ -1245,6 +1295,7 @@
 		}
 	}
 #endif
+#endif
 
 	/* Then handle onboard devices. */
 	if (dec_interrupt[DEC_IRQ_LANCE] >= 0) {
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/gt96100eth.c linux-2.4.22/drivers/net/gt96100eth.c
--- linux-2.4.22.clean/drivers/net/gt96100eth.c	2002-11-29 00:53:13.000000000 +0100
+++ linux-2.4.22/drivers/net/gt96100eth.c	2003-07-05 15:17:04.000000000 +0200
@@ -700,7 +700,8 @@
 	struct net_device *dev = NULL;
     
 	if (gtif->irq < 0) {
-		printk(KERN_ERR "%s: irq unknown - probing not supported\n", __FUNCTION_);
+		printk(KERN_ERR "%s: irq unknown - probing not supported\n",
+		       __FUNCTION__);
 		return -ENODEV;
 	}
     
@@ -1363,7 +1364,8 @@
 			gp->tx_full = 0;
 			if (gp->last_psr & psrLink) {
 				netif_wake_queue(dev);
-				dbg(2, "%s: Tx Ring was full, queue waked\n", __FUNCTION_);
+				dbg(2, "%s: Tx Ring was full, queue waked\n",
+				    __FUNCTION__);
 			}
 		}
 	
@@ -1444,7 +1446,7 @@
 				if ((psr & psrLink) && !gp->tx_full &&
 				    netif_queue_stopped(dev)) {
 					dbg(0, ": Link up, waking queue.\n",
-					    __FUNCTION_);
+					    __FUNCTION__);
 					netif_wake_queue(dev);
 				} else if (!(psr & psrLink) &&
 					   !netif_queue_stopped(dev)) {
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/ioc3-eth.c linux-2.4.22/drivers/net/ioc3-eth.c
--- linux-2.4.22.clean/drivers/net/ioc3-eth.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/net/ioc3-eth.c	2003-09-27 14:08:05.000000000 +0200
@@ -377,82 +377,6 @@
 		ip->dev->dev_addr[i - 2] = nic[i];
 }
 
-#if defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_SGI_SN2)
-/*
- * Get the ether-address on SN1 nodes
- */
-static void ioc3_get_eaddr_sn(struct ioc3_private *ip)
-{
-	int ibrick_mac_addr_get(nasid_t, char *);
-	struct ioc3 *ioc3 = ip->regs;
-	nasid_t nasid_of_ioc3;
-	char io7eaddr[20];
-	long mac;
-	int err_val;
-
-	/*
-	 * err_val = ibrick_mac_addr_get(get_nasid(), io7eaddr );
-	 * 
-	 * BAD!!  The above call uses get_nasid() and assumes that
-	 * the ioc3 pointed to by struct ioc3 is hooked up to the
-	 * cbrick that we're running on.  The proper way to make this call
-	 * is to figure out which nasid the ioc3 is connected to
-	 * and use that to call ibrick_mac_addr_get.  Below is
-	 * a hack to do just that.
-	 */
-
-	/*
-	 * Get the nasid of the ioc3 from the ioc3's base addr.
-	 * FIXME: the 8 at the end assumes we're in memory mode, 
-	 * not node mode (for that, we'd change it to a 9).
-	 * Is there a call to extract this info from a physical
-	 * addr somewhere in an sn header file already?  If so,
-	 * we should probably use that, or restructure this routine
-	 * to use pci_dev and generic numa nodeid getting stuff.
-	 */
-	nasid_of_ioc3 = (((unsigned long)ioc3 >> 33) & ~(-1 << 8));
-	err_val = ibrick_mac_addr_get(nasid_of_ioc3, io7eaddr );
-
-
-	if (err_val) {
-		/* Couldn't read the eeprom; try OSLoadOptions. */
-		printk("WARNING: ibrick_mac_addr_get failed: %d\n", err_val);
-
-		/* this is where we hardwire the mac address
- 		 * 1st ibrick had 08:00:69:11:34:75
- 		 * 2nd ibrick had 08:00:69:11:35:35
- 		 *
- 		 * Eagan Machines:
- 		 *      mankato1 08:00:69:11:BE:95
- 		 *      warroad  08:00:69:11:bd:60
- 		 *      duron    08:00:69:11:34:60
- 		 *
- 		 * an easy way to get the mac address is to hook
- 		 * up an ip35, then from L1 do 'cti serial'
- 		 * and then look for MAC line XXX THIS DOESN"T QUITE WORK!!
- 		 */
-		printk("ioc3_get_eaddr: setting ethernet address to:\n -----> ");
-		ip->dev->dev_addr[0] = 0x8;
-		ip->dev->dev_addr[1] = 0x0;
-		ip->dev->dev_addr[2] = 0x69;
-		ip->dev->dev_addr[3] = 0x11;
-		ip->dev->dev_addr[4] = 0x34;
-		ip->dev->dev_addr[5] = 0x60;
-	}
-	else {
-		long simple_strtol(const char *,char **,unsigned int);
-
-		mac = simple_strtol(io7eaddr, (char **)0, 16);
-		ip->dev->dev_addr[0] = (mac >> 40) & 0xff;
-		ip->dev->dev_addr[1] = (mac >> 32) & 0xff;
-		ip->dev->dev_addr[2] = (mac >> 24) & 0xff;
-		ip->dev->dev_addr[3] = (mac >> 16) & 0xff;
-		ip->dev->dev_addr[4] = (mac >> 8) & 0xff;
-		ip->dev->dev_addr[5] = mac & 0xff;
-	}
-}
-#endif
-
 /*
  * Ok, this is hosed by design.  It's necessary to know what machine the
  * NIC is in in order to know how to read the NIC address.  We also have
@@ -460,30 +384,15 @@
  */
 static void ioc3_get_eaddr(struct ioc3_private *ip)
 {
-	void (*do_get_eaddr)(struct ioc3_private *ip) = NULL;
 	int i;
 
-	/*
-	 * We should also use this code for PCI cards, no matter what host
-	 * machine but how to know that we're a PCI card?
-	 */
-#ifdef CONFIG_SGI_IP27
-	do_get_eaddr = ioc3_get_eaddr_nic;
-#endif
-#if defined(CONFIG_IA64_SGI_SN1) || defined(CONFIG_IA64_SGI_SN2)
-	do_get_eaddr = ioc3_get_eaddr_sn;
-#endif
 
-	if (!do_get_eaddr) {
-		printk(KERN_ERR "Don't know how to read MAC address of this "
-		       "IOC3 NIC\n");
-		return;
-	}
+	ioc3_get_eaddr_nic(ip);
 
 	printk("Ethernet address is ");
 	for (i = 0; i < 6; i++) {
 		printk("%02x", ip->dev->dev_addr[i]);
-		if (i < 7)
+		if (i < 5)
 			printk(":");
 	}
 	printk(".\n");
@@ -588,7 +497,7 @@
 			ip->stats.rx_frame_errors++;
 next:
 		ip->rx_skbs[n_entry] = new_skb;
-		rxr[n_entry] = cpu_to_be32((0xa5UL << 56) |
+		rxr[n_entry] = cpu_to_be64((0xa5UL << 56) |
 		                         ((unsigned long) rxb & TO_PHYS_MASK));
 		rxb->w0 = 0;				/* Clear valid flag */
 		n_entry = (n_entry + 1) & 511;		/* Update erpir */
@@ -1610,6 +1519,7 @@
 	struct ioc3_private *ip = dev->priv;
 	struct ioc3 *ioc3 = ip->regs;
 
+	unregister_netdev(dev);
 	iounmap(ioc3);
 	pci_release_regions(pdev);
 	kfree(dev);
@@ -1622,10 +1532,10 @@
 MODULE_DEVICE_TABLE(pci, ioc3_pci_tbl);
 
 static struct pci_driver ioc3_driver = {
-	name:		"ioc3-eth",
-	id_table:	ioc3_pci_tbl,
-	probe:		ioc3_probe,
-	remove:		__devexit_p(ioc3_remove_one),
+	.name		= "ioc3-eth",
+	.id_table	= ioc3_pci_tbl,
+	.probe		= ioc3_probe,
+	.remove		= __devexit_p(ioc3_remove_one),
 };
 
 static int __init ioc3_init_module(void)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/irda/au1k_ir.c linux-2.4.22/drivers/net/irda/au1k_ir.c
--- linux-2.4.22.clean/drivers/net/irda/au1k_ir.c	2002-08-03 02:39:44.000000000 +0200
+++ linux-2.4.22/drivers/net/irda/au1k_ir.c	2003-07-09 22:05:55.000000000 +0200
@@ -46,7 +46,13 @@
 #include <asm/bitops.h>
 #include <asm/io.h>
 #include <asm/au1000.h>
+#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_PB1100)
 #include <asm/pb1000.h>
+#elif defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100)
+#include <asm/db1x00.h>
+#else 
+#error au1k_ir: unsupported board
+#endif
 
 #include <net/irda/irda.h>
 #include <net/irda/irmod.h>
@@ -71,10 +77,16 @@
 static int qos_mtt_bits = 0x07;  /* 1 ms or more */
 static struct net_device *ir_devs[NUM_IR_IFF];
 static char version[] __devinitdata =
-    "au1k_ircc:1.0 ppopov@mvista.com\n";
+    "au1k_ircc:1.2 ppopov@mvista.com\n";
 
 #define RUN_AT(x) (jiffies + (x))
 
+#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100)
+static BCSR * const bcsr = (BCSR *)0xAE000000;
+#endif
+
+static spinlock_t ir_lock = SPIN_LOCK_UNLOCKED;
+
 /*
  * IrDA peripheral bug. You have to read the register
  * twice to get the right value.
@@ -126,7 +138,7 @@
 	if (ret != NULL) {
 		memset(ret, 0, size);
 		*dma_handle = virt_to_bus(ret);
-		ret = KSEG0ADDR(ret);
+		ret = (void *)KSEG0ADDR(ret);
 	}
 	return ret;
 }
@@ -134,7 +146,7 @@
 
 static void dma_free(void *vaddr, size_t size)
 {
-	vaddr = KSEG0ADDR(vaddr);
+	vaddr = (void *)KSEG0ADDR(vaddr);
 	free_pages((unsigned long) vaddr, get_order(size));
 }
 
@@ -211,7 +223,7 @@
 	struct au1k_private *aup = NULL;
 	int i, retval = 0, err;
 	db_dest_t *pDB, *pDBfree;
-	unsigned long temp;
+	dma_addr_t temp;
 
 	dev->priv = kmalloc(sizeof(struct au1k_private), GFP_KERNEL);
 	if (dev->priv == NULL) {
@@ -292,6 +304,14 @@
 		aup->tx_ring[i]->flags = 0;
 		aup->tx_db_inuse[i] = pDB;
 	}
+
+#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100)
+	/* power on */
+	bcsr->resets &= ~BCSR_RESETS_IRDA_MODE_MASK;
+	bcsr->resets |= BCSR_RESETS_IRDA_MODE_FULL;
+	au_sync();
+#endif
+
 	return 0;
 
 out:
@@ -532,13 +552,13 @@
 	flags = ptxd->flags;
 
 	if (flags & AU_OWN) {
-		printk(KERN_INFO "%s: tx_full\n", dev->name);
+		printk(KERN_DEBUG "%s: tx_full\n", dev->name);
 		netif_stop_queue(dev);
 		aup->tx_full = 1;
 		return 1;
 	}
 	else if (((aup->tx_head + 1) & (NUM_IR_DESC - 1)) == aup->tx_tail) {
-		printk(KERN_INFO "%s: tx_full\n", dev->name);
+		printk(KERN_DEBUG "%s: tx_full\n", dev->name);
 		netif_stop_queue(dev);
 		aup->tx_full = 1;
 		return 1;
@@ -558,6 +578,7 @@
 		memcpy((void *)pDB->vaddr, skb->data, skb->len);
 		ptxd->count_0 = skb->len & 0xff;
 		ptxd->count_1 = (skb->len >> 8) & 0xff;
+
 	}
 	else {
 		/* SIR */
@@ -565,6 +586,7 @@
 		ptxd->count_0 = len & 0xff;
 		ptxd->count_1 = (len >> 8) & 0xff;
 		ptxd->flags |= IR_DIS_CRC;
+		au_writel(au_readl(0xae00000c) & ~(1<<13), 0xae00000c);
 	}
 	ptxd->flags |= AU_OWN;
 	au_sync();
@@ -699,12 +721,14 @@
 	u32 control;
 	int ret = 0, timeout = 10, i;
 	volatile ring_dest_t *ptxd;
+#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100)
+	unsigned long irda_resets;
+#endif
 
 	if (speed == aup->speed)
 		return ret;
 
-	save_flags(flags);
-	cli();
+	spin_lock_irqsave(&ir_lock, flags);
 
 	/* disable PHY first */
 	writel(read_ir_reg(IR_ENABLE) & ~0x8000, IR_ENABLE);
@@ -745,10 +769,20 @@
 		ptxd->flags = AU_OWN;
 	}
 
-	if (speed == 4000000)
+	if (speed == 4000000) {
+#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100)
+		bcsr->resets |= BCSR_RESETS_FIR_SEL;
+#else /* Pb1000 and Pb1100 */
 		writel(1<<13, CPLD_AUX1);
-	else
+#endif
+	}
+	else {
+#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100)
+		bcsr->resets &= ~BCSR_RESETS_FIR_SEL;
+#else /* Pb1000 and Pb1100 */
 		writel(readl(CPLD_AUX1) & ~(1<<13), CPLD_AUX1);
+#endif
+	}
 
 	switch (speed) {
 	case 9600:	
@@ -794,18 +828,18 @@
 	}
 	else {
 		if (control & (1<<11))
-			printk(KERN_INFO "%s Valid SIR config\n", dev->name);
+			printk(KERN_DEBUG "%s Valid SIR config\n", dev->name);
 		if (control & (1<<12))
-			printk(KERN_INFO "%s Valid MIR config\n", dev->name);
+			printk(KERN_DEBUG "%s Valid MIR config\n", dev->name);
 		if (control & (1<<13))
-			printk(KERN_INFO "%s Valid FIR config\n", dev->name);
+			printk(KERN_DEBUG "%s Valid FIR config\n", dev->name);
 		if (control & (1<<10))
-			printk(KERN_INFO "%s TX enabled\n", dev->name);
+			printk(KERN_DEBUG "%s TX enabled\n", dev->name);
 		if (control & (1<<9))
-			printk(KERN_INFO "%s RX enabled\n", dev->name);
+			printk(KERN_DEBUG "%s RX enabled\n", dev->name);
 	}
 
-	restore_flags(flags);
+	spin_unlock_irqrestore(&ir_lock, flags);
 	return ret;
 }
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/Makefile linux-2.4.22/drivers/net/Makefile
--- linux-2.4.22.clean/drivers/net/Makefile	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/net/Makefile	2003-09-29 20:40:26.000000000 +0200
@@ -115,6 +115,7 @@
 # end link order section
 #
 
+obj-$(CONFIG_MV64340_ETH)	+= mv64340_eth.o
 obj-$(CONFIG_AIRONET4500) 	+= aironet4500_core.o
 obj-$(CONFIG_AIRONET4500_CS) 	+= aironet4500_core.o
 obj-$(CONFIG_AIRONET4500_NONCS)  += aironet4500_card.o
@@ -175,7 +176,6 @@
 obj-$(CONFIG_SUN3LANCE) += sun3lance.o
 obj-$(CONFIG_DEFXX) += defxx.o
 obj-$(CONFIG_SGISEEQ) += sgiseeq.o
-obj-$(CONFIG_SGI_O2MACE_ETH) += meth.o
 obj-$(CONFIG_AT1700) += at1700.o
 obj-$(CONFIG_FMV18X) += fmv18x.o
 obj-$(CONFIG_EL1) += 3c501.o
@@ -218,7 +218,7 @@
 obj-$(CONFIG_EQUALIZER) += eql.o
 obj-$(CONFIG_MIPS_JAZZ_SONIC) += jazzsonic.o
 obj-$(CONFIG_MIPS_GT96100ETH) += gt96100eth.o
-obj-$(CONFIG_MIPS_AU1000_ENET) += au1000_eth.o
+obj-$(CONFIG_MIPS_AU1X00_ENET) += au1000_eth.o
 obj-$(CONFIG_SGI_IOC3_ETH) += ioc3-eth.o
 obj-$(CONFIG_BAGETLANCE) += bagetlance.o
 obj-$(CONFIG_DECLANCE) += declance.o
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/meth.c linux-2.4.22/drivers/net/meth.c
--- linux-2.4.22.clean/drivers/net/meth.c	2002-11-29 00:53:14.000000000 +0100
+++ linux-2.4.22/drivers/net/meth.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,863 +0,0 @@
-/*
- * meth.c -- O2 Builtin 10/100 Ethernet driver
- *
- * Copyright (C) 2001 Ilya Volynets
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License
- *	as published by the Free Software Foundation; either version
- *	2 of the License, or (at your option) any later version.
- */
-#include <linux/module.h>
-#include <linux/init.h>
-
-#include <linux/sched.h>
-#include <linux/kernel.h> /* printk() */
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/errno.h>  /* error codes */
-#include <linux/types.h>  /* size_t */
-#include <linux/interrupt.h> /* mark_bh */
-#include <linux/pci.h>
-
-#include <linux/in.h>
-#include <linux/netdevice.h>   /* struct device, and other headers */
-#include <linux/etherdevice.h> /* eth_type_trans */
-#include <linux/ip.h>          /* struct iphdr */
-#include <linux/tcp.h>         /* struct tcphdr */
-#include <linux/skbuff.h>
-#include <linux/mii.h> /*MII definitions */
-
-#include <asm/ip32/crime.h>
-#include <asm/ip32/mace.h>
-#include <asm/ip32/ip32_ints.h>
-
-#include "meth.h"
-
-#include <linux/in6.h>
-#include <asm/checksum.h>
-
-#ifndef MFE_DEBUG
-#define MFE_DEBUG 0
-#endif
-
-#if MFE_DEBUG>=1
-#define DPRINTK(str,args...) printk (KERN_DEBUG "meth(%ld): %s: " str, jiffies, __FUNCTION__ , ## args)
-#define MFE_RX_DEBUG 2
-#else
-#define DPRINTK(str,args...)
-#define MFE_RX_DEBUG 0
-#endif
-
-
-static const char *version="meth.c: Ilya Volynets (ilya@theIlya.com)";
-static const char *meth_str="SGI O2 Fast Ethernet";
-MODULE_AUTHOR("Ilya Volynets");
-MODULE_DESCRIPTION("SGI O2 Builtin Fast Ethernet driver");
-
-/* This is a load-time options */
-/*static int eth = 0;
-MODULE_PARM(eth, "i");*/
-
-#define HAVE_TX_TIMEOUT
-/* The maximum time waited (in jiffies) before assuming a Tx failed. (400ms) */
-#define TX_TIMEOUT (400*HZ/1000)
-
-#ifdef HAVE_TX_TIMEOUT
-static int timeout = TX_TIMEOUT;
-MODULE_PARM(timeout, "i");
-#endif
-
-int meth_eth;
-
-
-/*
- * This structure is private to each device. It is used to pass
- * packets in and out, so there is place for a packet
- */
-
-typedef struct meth_private {
-    struct net_device_stats stats;
-	volatile struct meth_regs *regs;
-	u64 mode; /* in-memory copy of MAC control register */
-	int  phy_addr; /* address of phy, used by mdio_* functions, initialized in mdio_probe*/
-	tx_packet *tx_ring;
-	dma_addr_t tx_ring_dma;
-	int free_space;
-	struct sk_buff *tx_skbs[TX_RING_ENTRIES];
-	dma_addr_t      tx_skb_dmas[TX_RING_ENTRIES];
-	int tx_read,tx_write;
-	int tx_count;
-
-	rx_packet *rx_ring[RX_RING_ENTRIES];
-	dma_addr_t rx_ring_dmas[RX_RING_ENTRIES];
-	int rx_write;
-
-    spinlock_t meth_lock;
-} meth_private;
-
-extern struct net_device meth_devs[];
-void meth_tx_timeout (struct net_device *dev);
-void meth_interrupt(int irq, void *dev_id, struct pt_regs *pregs);
-        
-/* global, initialized in ip32-setup.c */
-char o2meth_eaddr[8]={0,0,0,0,0,0,0,0};
-
-static inline void load_eaddr(struct net_device *dev,
-			      volatile struct meth_regs *regs)
-{
-	int i;
-	DPRINTK("Loading MAC Address: %02x:%02x:%02x:%02x:%02x:%02x\n",
-		(int)o2meth_eaddr[0]&0xFF,(int)o2meth_eaddr[1]&0xFF,(int)o2meth_eaddr[2]&0xFF,
-		(int)o2meth_eaddr[3]&0xFF,(int)o2meth_eaddr[4]&0xFF,(int)o2meth_eaddr[5]&0xFF);
-	//memcpy(dev->dev_addr,o2meth_eaddr+2,6);
-	for (i=0; i<6; i++)
-		dev->dev_addr[i]=o2meth_eaddr[i];
-	regs->mac_addr= //dev->dev_addr[0]|(dev->dev_addr[1]<<8)|
-					//dev->dev_addr[2]<<16|(dev->dev_addr[3]<<24)|
-					//dev->dev_addr[4]<<32|(dev->dev_addr[5]<<40);
-	(*(u64*)o2meth_eaddr)>>16;
-	DPRINTK("MAC, finally is %0lx\n",regs->mac_addr);
-}
-
-/*
- *Waits for BUSY status of mdio bus to clear
- */
-#define WAIT_FOR_PHY(___regs, ___rval)			\
-	while((___rval=___regs->phy_data)&MDIO_BUSY){	\
-		udelay(25);								\
-	}
-/*read phy register, return value read */
-static int mdio_read(meth_private *priv,int phyreg)
-{
-	volatile meth_regs* regs=priv->regs;
-	volatile u32 rval;
-	WAIT_FOR_PHY(regs,rval)
-	regs->phy_registers=(priv->phy_addr<<5)|(phyreg&0x1f);
-	udelay(25);
-	regs->phy_trans_go=1;
-	udelay(25);
-	WAIT_FOR_PHY(regs,rval)
-	return rval&MDIO_DATA_MASK;
-}
-
-/*write phy register */
-static void mdio_write(meth_private* priv,int pfyreg,int val)
-{
-	volatile meth_regs* regs=priv->regs;
-	int rval;
-///	DPRINTK("Trying to write value %i to reguster %i\n",val, pfyreg);
-	spin_lock_irq(&priv->meth_lock);
-	WAIT_FOR_PHY(regs,rval)
-	regs->phy_registers=(priv->phy_addr<<5)|(pfyreg&0x1f);
-	regs->phy_data=val;
-	udelay(25);
-	WAIT_FOR_PHY(regs,rval)
-	spin_unlock_irq(&priv->meth_lock);
-}
-
-/* Modify phy register using given mask and value */
-static void mdio_update(meth_private* priv,int phyreg, int val, int mask)
-{
-	int rval;
-	DPRINTK("RMW value %i to PHY register %i with mask %i\n",val,phyreg,mask);
-	rval=mdio_read(priv,phyreg);
-	rval=(rval&~mask)|(val&mask);
-	mdio_write(priv,phyreg,rval);
-}
-
-/* handle errata data on MDIO bus */
-//static void mdio_errata(meth_private *priv)
-//{
-	/* Hmmm... what the hell is phyerrata? does it come from sys init parameters in IRIX */
-//}
-static int mdio_probe(meth_private *priv)
-{
-	int i, p2, p3;
-	DPRINTK("Detecting PHY kind\n");
-	/* check if phy is detected already */
-	if(priv->phy_addr>=0&&priv->phy_addr<32)
-		return 0;
-	spin_lock_irq(&priv->meth_lock);
-	for (i=0;i<32;++i){
-		priv->phy_addr=(char)i;
-		p2=mdio_read(priv,2);
-#ifdef MFE_DEBUG
-		p3=mdio_read(priv,3);
-		switch ((p2<<12)|(p3>>4)){
-			case PHY_QS6612X:
-				DPRINTK("PHY is QS6612X\n");
-				break;
-			case PHY_ICS1889:
-				DPRINTK("PHY is ICS1889\n");
-				break;
-			case PHY_ICS1890:
-				DPRINTK("PHY is ICS1890\n");
-				break;
-			case PHY_DP83840:
-				DPRINTK("PHY is DP83840\n");
-				break;
-		}
-#endif
-		if(p2!=0xffff&&p2!=0x0000){
-			DPRINTK("PHY code: %x\n",(p2<<12)|(p3>>4));
-			break;
-		}
-	}
-	spin_unlock_irq(&priv->meth_lock);
-	if(priv->phy_addr<32) {
-		return 0;
-	}
-	DPRINTK("Oopsie! PHY is not known!\n");
-	priv->phy_addr=-1;
-	return -ENODEV;
-}
-
-static void meth_check_link(struct net_device *dev)
-{
-	struct meth_private *priv = (struct meth_private *) dev->priv;
-	int mii_partner = mdio_read(priv, 5);
-	int mii_advertising = mdio_read(priv, 4);
-	int negotiated = mii_advertising & mii_partner;
-	int duplex, speed;
-
-	if (mii_partner == 0xffff)
-		return;
-
-	duplex = ((negotiated & 0x0100) || (negotiated & 0x01C0) == 0x0040)?METH_PHY_FDX:0;
-	speed = (negotiated & 0x0380)?METH_100MBIT:0;
-
-	if ((priv->mode & METH_PHY_FDX) ^ duplex)
-	{
-		DPRINTK("Setting %s-duplex\n", duplex ? "full" : "half");
-		if (duplex)
-			priv->mode |= METH_PHY_FDX;
-		else
-			priv->mode &= ~METH_PHY_FDX;
-		priv->regs->mac_ctrl = priv->mode;
-	}
-
-	if ((priv->mode & METH_100MBIT) ^ speed)
-	{
-		DPRINTK("Setting %dMbs mode\n", speed ? 100 : 10);
-		if (duplex)
-			priv->mode |= METH_100MBIT;
-		else
-			priv->mode &= ~METH_100MBIT;
-		priv->regs->mac_ctrl = priv->mode;
-	}
-}
-
-
-static int meth_init_tx_ring(meth_private *priv)
-{
-	/* Init TX ring */
-	DPRINTK("Initializing TX ring\n");
-	priv->tx_ring = (tx_packet *) pci_alloc_consistent(NULL,TX_RING_BUFFER_SIZE,&(priv->tx_ring_dma));
-	if(!priv->tx_ring)
-		return -ENOMEM;
-	memset(priv->tx_ring, 0, TX_RING_BUFFER_SIZE);
-	priv->tx_count = priv->tx_read = priv->tx_write = 0;
-	priv->regs->tx_ring_base = priv->tx_ring_dma;
-	priv->free_space = TX_RING_ENTRIES;
-	/* Now init skb save area */
-	memset(priv->tx_skbs,0,sizeof(priv->tx_skbs));
-	memset(priv->tx_skb_dmas,0,sizeof(priv->tx_skb_dmas));
-	DPRINTK("Done with TX ring init\n");
-	return 0;
-}
-
-static int meth_init_rx_ring(meth_private *priv)
-{
-	int i;
-	DPRINTK("Initializing RX ring\n");
-	for(i=0;i<RX_RING_ENTRIES;i++){
-		DPRINTK("\t1:\t%i\t",i);
-		/*if(!(priv->rx_ring[i]=get_free_page(GFP_KERNEL)))
-			return -ENOMEM;
-		DPRINTK("\t2:\t%i\n",i);*/
-		priv->rx_ring[i]=(rx_packet*)pci_alloc_consistent(NULL,METH_RX_BUFF_SIZE,&(priv->rx_ring_dmas[i]));
-		/* I'll need to re-sync it after each RX */
-		DPRINTK("\t%p\n",priv->rx_ring[i]);
-		priv->regs->rx_fifo=priv->rx_ring_dmas[i];
-	}
-	priv->rx_write = 0;
-	DPRINTK("Done with RX ring\n");
-	return 0;
-}
-static void meth_free_tx_ring(meth_private *priv)
-{
-	int i;
-
-	/* Remove any pending skb */
-	for (i = 0; i < TX_RING_ENTRIES; i++) {
-	  if (priv->tx_skbs[i])
-		dev_kfree_skb(priv->tx_skbs[i]);
-		priv->tx_skbs[i] = NULL;
-	}
-	pci_free_consistent(NULL,
-			    TX_RING_BUFFER_SIZE,
-			    priv->tx_ring,
-			    priv->tx_ring_dma);
-}
-static void meth_free_rx_ring(meth_private *priv)
-{
-	int i;
-
-	for(i=0;i<RX_RING_ENTRIES;i++)
-		pci_free_consistent(NULL,
-				    METH_RX_BUFF_SIZE,
-				    priv->rx_ring[i],
-				    priv->rx_ring_dmas[i]);
-}
-
-int meth_reset(struct net_device *dev)
-{
-	struct meth_private *priv = (struct meth_private *) dev->priv;
-
-	/* Reset card */
-	priv->regs->mac_ctrl = SGI_MAC_RESET;
-	priv->regs->mac_ctrl = 0;
-	udelay(25);
-	DPRINTK("MAC control after reset: %016lx\n", priv->regs->mac_ctrl);
-
-	/* Load ethernet address */
-	load_eaddr(dev, priv->regs);
-	/* Should load some "errata", but later */
-	
-	/* Check for device */
-	if(mdio_probe(priv) < 0) {
-		DPRINTK("Unable to find PHY\n");
-		return -ENODEV;
-	}
-
-	/* Initial mode -- 10|Half-duplex|Accept normal packets */
-	priv->mode=METH_ACCEPT_MCAST|METH_DEFAULT_IPG;
-	if(dev->flags | IFF_PROMISC)
-		priv->mode |= METH_PROMISC;
-	priv->regs->mac_ctrl = priv->mode;
-
-	/* Autonegociate speed and duplex mode */
-	meth_check_link(dev);
-
-	/* Now set dma control, but don't enable DMA, yet */
-	priv->regs->dma_ctrl= (4 << METH_RX_OFFSET_SHIFT) |
-		              (RX_RING_ENTRIES << METH_RX_DEPTH_SHIFT);
-
-	return(0);
-}
-
-/*============End Helper Routines=====================*/
-
-/*
- * Open and close
- */
-
-int meth_open(struct net_device *dev)
-{
-	meth_private *priv=dev->priv;
-	volatile meth_regs *regs=priv->regs;
-
-	MOD_INC_USE_COUNT;
-
-	/* Start DMA */
-	regs->dma_ctrl|=
-	        METH_DMA_TX_EN|/*METH_DMA_TX_INT_EN|*/
-		METH_DMA_RX_EN|METH_DMA_RX_INT_EN;
-
-	if(request_irq(dev->irq,meth_interrupt,SA_SHIRQ,meth_str,dev)){
-		printk(KERN_ERR "%s: Can't get irq %d\n", dev->name, dev->irq);
-		return -EAGAIN;
-	}
-	netif_start_queue(dev);
-	DPRINTK("Opened... DMA control=0x%08lx\n", regs->dma_ctrl);
-	return 0;
-}
-
-int meth_release(struct net_device *dev)
-{
-    netif_stop_queue(dev); /* can't transmit any more */
-	/* shut down dma */
-	((meth_private*)(dev->priv))->regs->dma_ctrl&=
-		~(METH_DMA_TX_EN|METH_DMA_TX_INT_EN|
-		METH_DMA_RX_EN|METH_DMA_RX_INT_EN);
-	free_irq(dev->irq, dev);
-    MOD_DEC_USE_COUNT;
-    return 0;
-}
-
-/*
- * Configuration changes (passed on by ifconfig)
- */
-int meth_config(struct net_device *dev, struct ifmap *map)
-{
-    if (dev->flags & IFF_UP) /* can't act on a running interface */
-        return -EBUSY;
-
-    /* Don't allow changing the I/O address */
-    if (map->base_addr != dev->base_addr) {
-        printk(KERN_WARNING "meth: Can't change I/O address\n");
-        return -EOPNOTSUPP;
-    }
-
-    /* Allow changing the IRQ */
-    if (map->irq != dev->irq) {
-        printk(KERN_WARNING "meth: Can't change IRQ\n");
-        return -EOPNOTSUPP;
-    }
-	DPRINTK("Configured\n");
-
-    /* ignore other fields */
-    return 0;
-}
-
-/*
- * Receive a packet: retrieve, encapsulate and pass over to upper levels
- */
-void meth_rx(struct net_device* dev)
-{
-    struct sk_buff *skb;
-    struct meth_private *priv = (struct meth_private *) dev->priv;
-	rx_packet *rxb;
-	DPRINTK("RX...\n");
-	// TEMP	while((rxb=priv->rx_ring[priv->rx_write])->status.raw&0x8000000000000000){
-	while((rxb=priv->rx_ring[priv->rx_write])->status.raw&0x8000000000000000){
-	        int len=rxb->status.parsed.rx_len - 4; /* omit CRC */
-		DPRINTK("(%i)\n",priv->rx_write);
-		/* length sanity check */
-		if(len < 60 || len > 1518) {
-		  printk(KERN_DEBUG "%s: bogus packet size: %d, status=%#2x.\n",
-			 dev->name, priv->rx_write, rxb->status.raw);
-		  priv->stats.rx_errors++;
-		  priv->stats.rx_length_errors++;
-		}
-		if(!(rxb->status.raw&METH_RX_STATUS_ERRORS)){
-			skb=alloc_skb(len+2,GFP_ATOMIC);/* Should be atomic -- we are in interrupt */
-			if(!skb){
-				/* Ouch! No memory! Drop packet on the floor */
-				DPRINTK("!!!>>>Ouch! Not enough Memory for RX buffer!\n");
-				priv->stats.rx_dropped++;
-			} else {
-				skb_reserve(skb, 2); /* align IP on 16B boundary */  
-    			memcpy(skb_put(skb, len), rxb->buf, len);
-			    /* Write metadata, and then pass to the receive level */
-			    skb->dev = dev;
-			    skb->protocol = eth_type_trans(skb, dev);
-				//skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
-			   
-				DPRINTK("passing packet\n");
-				DPRINTK("len = %d rxb->status = %x\n",
-					len, rxb->status.raw);
-				netif_rx(skb);
-				dev->last_rx = jiffies;
-				priv->stats.rx_packets++;
-				priv->stats.rx_bytes+=len;
-				DPRINTK("There we go... Whew...\n");
-			}
-		}
-		priv->regs->rx_fifo=priv->rx_ring_dmas[priv->rx_write];
-		rxb->status.raw=0;		
-		priv->rx_write=(priv->rx_write+1)&(RX_RING_ENTRIES-1);
-	}
-}
-
-static int meth_tx_full(struct net_device *dev)
-{
-	struct meth_private *priv = (struct meth_private *) dev->priv;
-
-	return(priv->tx_count >= TX_RING_ENTRIES-1);
-}
-
-void meth_tx_cleanup(struct net_device* dev, int rptr)
-{
-	meth_private *priv=dev->priv;
-	tx_packet* status;
-	struct sk_buff *skb;
-
-	spin_lock(&priv->meth_lock);
-
-	/* Stop DMA */
-	priv->regs->dma_ctrl &= ~(METH_DMA_TX_INT_EN);
-
-	while(priv->tx_read != rptr){
-		skb = priv->tx_skbs[priv->tx_read];
-		status = &priv->tx_ring[priv->tx_read];
-		if(!status->header.res.sent)
-			break;
-		if(status->header.raw & METH_TX_STATUS_DONE) {
-			priv->stats.tx_packets++;
-			priv->stats.tx_bytes += skb->len;
-		}
-		dev_kfree_skb_irq(skb);
-		priv->tx_skbs[priv->tx_read] = NULL;
-		status->header.raw = 0;
-		priv->tx_read = (priv->tx_read+1)&(TX_RING_ENTRIES-1);
-		priv->tx_count --;
-	}
-
-	/* wake up queue if it was stopped */
-	if (netif_queue_stopped(dev) && ! meth_tx_full(dev)) {
-		netif_wake_queue(dev);
-	}
-
-	spin_unlock(priv->meth_lock);
-}
-
-/*
- * The typical interrupt entry point
- */
-void meth_interrupt(int irq, void *dev_id, struct pt_regs *pregs)
-{
-	struct meth_private *priv;
-	union {
-		u32	reg; /*Whole status register */
-		struct {
-			u32			:	2,
-				rx_seq	:	5,
-				tx_read	:	9,
-				
-				rx_read	:	8,
-				int_mask:	8;
-		} parsed;
-	} status;
-	/*
-	 * As usual, check the "device" pointer for shared handlers.
-	 * Then assign "struct device *dev"
-	 */
-	struct net_device *dev = (struct net_device *)dev_id;
-	/* ... and check with hw if it's really ours */
-
-	if (!dev /*paranoid*/ ) return;
-
-	/* Lock the device */
-	priv = (struct meth_private *) dev->priv;
-
-	status.reg = priv->regs->int_flags;
-    
-	DPRINTK("Interrupt, status %08x...\n",status.reg);
-	if (status.parsed.int_mask & METH_INT_RX_THRESHOLD) {
-		/* send it to meth_rx for handling */
-		meth_rx(dev);
-	}
-
-	if (status.parsed.int_mask & (METH_INT_TX_EMPTY|METH_INT_TX_PKT)) {
-		/* a transmission is over: free the skb */
-		meth_tx_cleanup(dev, status.parsed.tx_read);
-	}
-	/* check for errors too... */
-	if (status.parsed.int_mask & (METH_INT_TX_LINK_FAIL))
-		printk(KERN_WARNING "meth: link failure\n");
-	if (status.parsed.int_mask & (METH_INT_MEM_ERROR))
-		printk(KERN_WARNING "meth: memory error\n");
-	if (status.parsed.int_mask & (METH_INT_TX_ABORT))
-		printk(KERN_WARNING "meth: aborted\n");
-	DPRINTK("Interrupt handling done...\n");
-	
-	priv->regs->int_flags=status.reg&0xff; /* clear interrupts */
-}
-
-/*
- * Transmits packets that fit into TX descriptor (are <=120B)
- */
-static void meth_tx_short_prepare(meth_private* priv, struct sk_buff* skb)
-{
-	tx_packet *desc=&priv->tx_ring[priv->tx_write];
-	int len = (skb->len<ETH_ZLEN)?ETH_ZLEN:skb->len;
-
-	DPRINTK("preparing short packet\n");
-	/* maybe I should set whole thing to 0 first... */
-	memcpy(desc->data.dt+(120-len),skb->data,skb->len);
-	if(skb->len < len)
-		memset(desc->data.dt+120-len+skb->len,0,len-skb->len);
-	desc->header.raw=METH_TX_CMD_INT_EN|(len-1)|((128-len)<<16);
-	DPRINTK("desc=%016lx\n",desc->header.raw);
-}
-#define TX_CATBUF1 BIT(25)
-static void meth_tx_1page_prepare(meth_private* priv, struct sk_buff* skb)
-{
-	tx_packet *desc=&priv->tx_ring[priv->tx_write];
-	void *buffer_data = (void *)(((u64)skb->data + 7ULL) & (~7ULL));
-	int unaligned_len = (int)((u64)buffer_data - (u64)skb->data);
-	int buffer_len = skb->len - unaligned_len;
-	dma_addr_t catbuf;
-
-	DPRINTK("preparing 1 page...\n");
-	DPRINTK("length=%d data=%p\n", skb->len, skb->data);
-	DPRINTK("unaligned_len=%d\n", unaligned_len);
-	DPRINTK("buffer_data=%p buffer_len=%d\n",
-	       buffer_data,
-	       buffer_len);
-
-	desc->header.raw=METH_TX_CMD_INT_EN|TX_CATBUF1|(skb->len-1);
-
-	/* unaligned part */
-	if(unaligned_len){
-		memcpy(desc->data.dt+(120-unaligned_len),
-		       skb->data, unaligned_len);
-		desc->header.raw |= (128-unaligned_len) << 16;
-	}
-
-	/* first page */
-	catbuf = pci_map_single(NULL,
-				buffer_data,
-				buffer_len,
-				PCI_DMA_TODEVICE);
-	DPRINTK("catbuf=%x\n", catbuf);
-	desc->data.cat_buf[0].form.start_addr = catbuf >> 3;
-	desc->data.cat_buf[0].form.len = buffer_len-1;
-	DPRINTK("desc=%016lx\n",desc->header.raw);
-	DPRINTK("cat_buf[0].raw=%016lx\n",desc->data.cat_buf[0].raw);
-}
-#define TX_CATBUF2 BIT(26)
-static void meth_tx_2page_prepare(meth_private* priv, struct sk_buff* skb)
-{
-	tx_packet *desc=&priv->tx_ring[priv->tx_write];
-	void *buffer1_data = (void *)(((u64)skb->data + 7ULL) & (~7ULL));
-	void *buffer2_data = (void *)PAGE_ALIGN((u64)skb->data);
-	int unaligned_len = (int)((u64)buffer1_data - (u64)skb->data);
-	int buffer1_len = (int)((u64)buffer2_data - (u64)buffer1_data);
-	int buffer2_len = skb->len - buffer1_len - unaligned_len;
-	dma_addr_t catbuf1, catbuf2;
-
-	DPRINTK("preparing 2 pages... \n");
-	DPRINTK("length=%d data=%p\n", skb->len, skb->data);
-	DPRINTK("unaligned_len=%d\n", unaligned_len);
-	DPRINTK("buffer1_data=%p buffer1_len=%d\n",
-	       buffer1_data,
-	       buffer1_len);
-	DPRINTK("buffer2_data=%p buffer2_len=%d\n",
-	       buffer2_data,
-	       buffer2_len);
-
-	desc->header.raw=METH_TX_CMD_INT_EN|TX_CATBUF1|TX_CATBUF2|(skb->len-1);
-	/* unaligned part */
-	if(unaligned_len){
-		memcpy(desc->data.dt+(120-unaligned_len),
-		       skb->data, unaligned_len);
-		desc->header.raw |= (128-unaligned_len) << 16;
-	}
-
-	/* first page */
-	catbuf1 = pci_map_single(NULL,
-				 buffer1_data,
-				 buffer1_len,
-				 PCI_DMA_TODEVICE);
-	DPRINTK("catbuf1=%x\n", catbuf1);
-	desc->data.cat_buf[0].form.start_addr = catbuf1 >> 3;
-	desc->data.cat_buf[0].form.len = buffer1_len-1;
-	/* second page */
-	catbuf2 = pci_map_single(NULL,
-				 buffer2_data,
-				 buffer2_len,
-				 PCI_DMA_TODEVICE);
-	DPRINTK("catbuf2=%x\n", catbuf2);
-	desc->data.cat_buf[1].form.start_addr = catbuf2 >> 3;
-	desc->data.cat_buf[1].form.len = buffer2_len-1;
-	DPRINTK("desc=%016lx\n",desc->header.raw);
-	DPRINTK("cat_buf[0].raw=%016lx\n",desc->data.cat_buf[0].raw);
-	DPRINTK("cat_buf[1].raw=%016lx\n",desc->data.cat_buf[1].raw);
-}
-
-
-void meth_add_to_tx_ring(meth_private *priv, struct sk_buff* skb)
-{
-	DPRINTK("Transmitting data...\n");
-	if(skb->len <= 120) {
-		/* Whole packet fits into descriptor */
-		meth_tx_short_prepare(priv,skb);
-	} else if(PAGE_ALIGN((u64)skb->data) !=
-		  PAGE_ALIGN((u64)skb->data+skb->len-1)) {
-		/* Packet crosses page boundary */
-		meth_tx_2page_prepare(priv,skb);
-	} else {
-		/* Packet is in one page */
-		meth_tx_1page_prepare(priv,skb);
-	}
-
-	/* Remember the skb, so we can free it at interrupt time */
-	priv->tx_skbs[priv->tx_write] = skb;
-	priv->tx_write = (priv->tx_write+1) & (TX_RING_ENTRIES-1);
-	priv->regs->tx_info.wptr = priv->tx_write;
-	priv->tx_count ++;
-	/* Enable DMA transfer */
-	priv->regs->dma_ctrl |= METH_DMA_TX_INT_EN;
-}
-
-/*
- * Transmit a packet (called by the kernel)
- */
-int meth_tx(struct sk_buff *skb, struct net_device *dev)
-{
-	struct meth_private *priv = (struct meth_private *) dev->priv;
-
-	spin_lock_irq(&priv->meth_lock);
-
-	meth_add_to_tx_ring(priv, skb);
-	dev->trans_start = jiffies; /* save the timestamp */
-
-	/* If TX ring is full, tell the upper layer to stop sending packets */
-	if (meth_tx_full(dev)) {
-	        DPRINTK("TX full: stopping\n");
-		netif_stop_queue(dev);
-	}
-
-	spin_unlock_irq(&priv->meth_lock);
-
-	return 0;
-}
-
-/*
- * Deal with a transmit timeout.
- */
-
-void meth_tx_timeout (struct net_device *dev)
-{
-	struct meth_private *priv = (struct meth_private *) dev->priv;
-	
-	printk(KERN_WARNING "%s: transmit timed out\n", dev->name);
-
-	/* Protect against concurrent rx interrupts */
-	spin_lock_irq(&priv->meth_lock);
-
-	/* Try to reset the adaptor. */
-	meth_reset(dev);
-
-	priv->stats.tx_errors++;
-
-	/* Clear all rings */
-	meth_free_tx_ring(priv);
-	meth_free_rx_ring(priv);
-	meth_init_tx_ring(priv);
-	meth_init_rx_ring(priv);
-
-	/* Restart dma */
-	priv->regs->dma_ctrl|=METH_DMA_TX_EN|METH_DMA_RX_EN|METH_DMA_RX_INT_EN;
-
-	/* Enable interrupt */
-	spin_unlock_irq(&priv->meth_lock);
-
-	dev->trans_start = jiffies;
-	netif_wake_queue(dev);
-
-	return;
-}
-
-/*
- * Ioctl commands 
- */
-int meth_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
- 
-    DPRINTK("ioctl\n");
-    return 0;
-}
-
-/*
- * Return statistics to the caller
- */
-struct net_device_stats *meth_stats(struct net_device *dev)
-{
-    struct meth_private *priv = (struct meth_private *) dev->priv;
-    return &priv->stats;
-}
-
-/*
- * The init function (sometimes called probe).
- * It is invoked by register_netdev()
- */
-int meth_init(struct net_device *dev)
-{
-	meth_private *priv;
-	int ret;
-	/* 
-	 * Then, assign other fields in dev, using ether_setup() and some
-	 * hand assignments
-	 */
-	ether_setup(dev); /* assign some of the fields */
-
-	dev->open            = meth_open;
-	dev->stop            = meth_release;
-	dev->set_config      = meth_config;
-	dev->hard_start_xmit = meth_tx;
-	dev->do_ioctl        = meth_ioctl;
-	dev->get_stats       = meth_stats;
-#ifdef HAVE_TX_TIMEOUT
-	dev->tx_timeout      = meth_tx_timeout;
-	dev->watchdog_timeo  = timeout;
-#endif
-	dev->irq		 = MACE_ETHERNET_IRQ;
-	SET_MODULE_OWNER(dev);
-
-	/*
-	 * Then, allocate the priv field. This encloses the statistics
-	 * and a few private fields.
-	 */
-	priv = kmalloc(sizeof(struct meth_private), GFP_KERNEL);
-	if (priv == NULL)
-		return -ENOMEM;
-	dev->priv=priv;
-	memset(priv, 0, sizeof(struct meth_private));
-	spin_lock_init(&((struct meth_private *) dev->priv)->meth_lock);
-	/*
-	 * Make the usual checks: check_region(), probe irq, ...  -ENODEV
-	 * should be returned if no device found.  No resource should be
-	 * grabbed: this is done on open(). 
-	 */
-	priv->regs=(meth_regs*)SGI_MFE;
-	dev->base_addr=SGI_MFE;
-	priv->phy_addr = -1; /* No phy is known yet... */
-
-	/* Initialize the hardware */
-	if((ret=meth_reset(dev)) < 0)
-	        return ret;
-
-	/* Allocate the ring buffers */
-	if((ret=meth_init_tx_ring(priv))<0||(ret=meth_init_rx_ring(priv))<0){
-		meth_free_tx_ring(priv);
-		meth_free_rx_ring(priv);
-		return ret;
-	}
-
-	printk("SGI O2 Fast Ethernet rev. %ld\n", priv->regs->mac_ctrl >> 29);
-
-    return 0;
-}
-
-/*
- * The devices
- */
-
-struct net_device meth_devs[1] = {
-    { init: meth_init, }  /* init, nothing more */
-};
-
-/*
- * Finally, the module stuff
- */
-
-int meth_init_module(void)
-{
-	int result, device_present = 0;
-
-	strcpy(meth_devs[0].name, "eth%d");
-
-	if ( (result = register_netdev(meth_devs)) )
-		printk("meth: error %i registering device \"%s\"\n",
-		       result, meth_devs->name);
-	else device_present++;
-#ifndef METH_DEBUG
-	EXPORT_NO_SYMBOLS;
-#endif
-	
-	return device_present ? 0 : -ENODEV;
-}
-
-void meth_cleanup(void)
-{
-    kfree(meth_devs->priv);
-    unregister_netdev(meth_devs);
-    return;
-}
-
-module_init(meth_init_module);
-module_exit(meth_cleanup);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/meth.h linux-2.4.22/drivers/net/meth.h
--- linux-2.4.22.clean/drivers/net/meth.h	2002-11-29 00:53:14.000000000 +0100
+++ linux-2.4.22/drivers/net/meth.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,273 +0,0 @@
-
-/*
- * snull.h -- definitions for the network module
- *
- * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
- * Copyright (C) 2001 O'Reilly & Associates
- *
- * The source code in this file can be freely used, adapted,
- * and redistributed in source or binary form, so long as an
- * acknowledgment appears in derived source files.  The citation
- * should list that the code comes from the book "Linux Device
- * Drivers" by Alessandro Rubini and Jonathan Corbet, published
- * by O'Reilly & Associates.   No warranty is attached;
- * we cannot take responsibility for errors or fitness for use.
- */
-
-/* version dependencies have been confined to a separate file */
-
-#define SGI_MFE		(MACE_BASE+MACE_ENET)
-/*		(0xBF280000)*/
-
-/* Tunable parameters */
-#define TX_RING_ENTRIES 64	/* 64-512?*/
-
-#define RX_RING_ENTRIES 16 /* Do not change */
-/* Internal constants */
-#define TX_RING_BUFFER_SIZE	(TX_RING_ENTRIES*sizeof(tx_packet))
-#define RX_BUFFER_SIZE 1546 /* ethenet packet size */
-#define METH_RX_BUFF_SIZE 4096
-#define RX_BUFFER_OFFSET (sizeof(rx_status_vector)+2) /* staus vector + 2 bytes of padding */
-#define RX_BUCKET_SIZE 256
-
-
-
-/* For more detailed explanations of what each field menas,
-   see Nick's great comments to #defines below (or docs, if
-   you are lucky enough toget hold of them :)*/
-
-/* tx status vector is written over tx command header upon
-   dma completion. */
-
-typedef struct tx_status_vector {
-	u64		sent:1; /* always set to 1...*/
-	u64		pad0:34;/* always set to 0 */
-	u64		flags:9;			/*I'm too lazy to specify each one separately at the moment*/
-	u64		col_retry_cnt:4;	/*collision retry count*/
-	u64		len:16;				/*Transmit length in bytes*/
-} tx_status_vector;
-
-/*
- * Each packet is 128 bytes long.
- * It consists of header, 0-3 concatination
- * buffer pointers and up to 120 data bytes.
- */
-typedef struct tx_packet_hdr {
-	u64		pad1:36; /*should be filled with 0 */
-	u64		cat_ptr3_valid:1,	/*Concatination pointer valid flags*/
-			cat_ptr2_valid:1,
-			cat_ptr1_valid:1;
-	u64		tx_int_flag:1;		/*Generate TX intrrupt when packet has been sent*/
-	u64		term_dma_flag:1;	/*Terminate transmit DMA on transmit abort conditions*/
-	u64		data_offset:7;		/*Starting byte offset in ring data block*/
-	u64		data_len:16;		/*Length of valid data in bytes-1*/
-} tx_packet_hdr;
-typedef union tx_cat_ptr {
-	struct {
-		u64		pad2:16; /* should be 0 */
-		u64		len:16;				/*length of buffer data - 1*/
-		u64		start_addr:29;		/*Physical starting address*/
-		u64		pad1:3; /* should be zero */
-	} form;
-	u64 raw;
-} tx_cat_ptr;
-
-typedef struct tx_packet {
-	union {
-		tx_packet_hdr header;
-		tx_status_vector res;
-		u64 raw;
-	}header;
-	union {
-		tx_cat_ptr cat_buf[3];
-		char dt[120];
-	} data;
-} tx_packet;
-
-typedef union rx_status_vector {
-	struct {
-		u64		pad1:1;/*fill it with ones*/
-		u64		pad2:15;/*fill with 0*/
-		u64		ip_chk_sum:16;
-		u64		seq_num:5;
-		u64		mac_addr_match:1;
-		u64		mcast_addr_match:1;
-		u64		carrier_event_seen:1;
-		u64		bad_packet:1;
-		u64		long_event_seen:1;
-		u64		invalid_preamble:1;
-		u64		broadcast:1;
-		u64		multicast:1;
-		u64		crc_error:1;
-		u64		huh:1;/*???*/
-		u64		rx_code_violation:1;
-		u64		rx_len:16;
-	} parsed;
-	u64 raw;
-} rx_status_vector;
-
-typedef struct rx_packet {
-	rx_status_vector status;
-        u64 pad[3]; /* For whatever reason, there needs to be 4 double-word offset */
-        u16 pad2;
-	char buf[METH_RX_BUFF_SIZE-sizeof(rx_status_vector)-3*sizeof(u64)-sizeof(u16)];/* data */
-} rx_packet;
-
-typedef struct meth_regs {
-	u64		mac_ctrl;		/*0x00,rw,31:0*/
-	u64		int_flags;		/*0x08,rw,30:0*/
-	u64		dma_ctrl;		/*0x10,rw,15:0*/
-	u64		timer;			/*0x18,rw,5:0*/
-	u64		int_tx;			/*0x20,wo,0:0*/
-	u64		int_rx;			/*0x28,wo,9:4*/
-	struct {
-		u32 tx_info_pad;
-		u32 rptr:16,wptr:16;
-	}		tx_info;		/*0x30,rw,31:0*/
-	u64		tx_info_al;		/*0x38,rw,31:0*/
-	struct {
-		u32	rx_buff_pad1;
-		u32	rx_buff_pad2:8,
-			wptr:8,
-			rptr:8,
-			depth:8;
-	}		rx_buff;		/*0x40,ro,23:0*/
-	u64		rx_buff_al1;	/*0x48,ro,23:0*/
-	u64		rx_buff_al2;	/*0x50,ro,23:0*/
-	u64		int_update;		/*0x58,wo,31:0*/
-	u32		phy_data_pad;
-	u32		phy_data;		/*0x60,rw,16:0*/
-	u32		phy_reg_pad;
-	u32		phy_registers;	/*0x68,rw,9:0*/
-	u64		phy_trans_go;	/*0x70,wo,0:0*/
-	u64		backoff_seed;	/*0x78,wo,10:0*/
-	u64		imq_reserved[4];/*0x80,ro,64:0(x4)*/
-	/*===================================*/
-	u64		mac_addr;		/*0xA0,rw,47:0, I think it's MAC address, but I'm not sure*/
-	u64		mcast_addr;		/*0xA8,rw,47:0, This seems like secondary MAC address*/
-	u64		mcast_filter;	/*0xB0,rw,63:0*/
-	u64		tx_ring_base;	/*0xB8,rw,31:13*/
-	/* Following are read-only debugging info register */
-	u64		tx_pkt1_hdr;	/*0xC0,ro,63:0*/
-	u64		tx_pkt1_ptr[3];	/*0xC8,ro,63:0(x3)*/
-	u64		tx_pkt2_hdr;	/*0xE0,ro,63:0*/
-	u64		tx_pkt2_ptr[3];	/*0xE8,ro,63:0(x3)*/
-	/*===================================*/
-	u32		rx_pad;
-	u32		rx_fifo;
-	u64		reserved[31];
-}meth_regs;
-
-	/* Bits in METH_MAC */
-
-#define SGI_MAC_RESET		BIT(0)	/* 0: MAC110 active in run mode, 1: Global reset signal to MAC110 core is active */
-#define METH_PHY_FDX		BIT(1) /* 0: Disable full duplex, 1: Enable full duplex */
-#define METH_PHY_LOOP	BIT(2) /* 0: Normal operation, follows 10/100mbit and M10T/MII select, 1: loops internal MII bus */
-				       /*    selects ignored */
-#define METH_100MBIT		BIT(3) /* 0: 10meg mode, 1: 100meg mode */
-#define METH_PHY_MII		BIT(4) /* 0: MII selected, 1: SIA selected */
-				       /*   Note: when loopback is set this bit becomes collision control.  Setting this bit will */
-				       /*         cause a collision to be reported. */
-
-				       /* Bits 5 and 6 are used to determine the the Destination address filter mode */
-#define METH_ACCEPT_MY 0			/* 00: Accept PHY address only */
-#define METH_ACCEPT_MCAST 0x20	/* 01: Accept physical, broadcast, and multicast filter matches only */
-#define METH_ACCEPT_AMCAST 0x40	/* 10: Accept physical, broadcast, and all multicast packets */
-#define METH_PROMISC 0x60		/* 11: Promiscious mode */
-
-#define METH_PHY_LINK_FAIL	BIT(7) /* 0: Link failure detection disabled, 1: Hardware scans for link failure in PHY */
-
-#define METH_MAC_IPG	0x1ffff00
-
-#define METH_DEFAULT_IPG ((17<<15) | (11<<22) | (21<<8))
-						/* 0x172e5c00 */ /* 23, 23, 23 */ /*0x54A9500 *//*21,21,21*/
-				       /* Bits 8 through 14 are used to determine Inter-Packet Gap between "Back to Back" packets */
-				       /* The gap depends on the clock speed of the link, 80ns per increment for 100baseT, 800ns  */
-				       /* per increment for 10BaseT */
-
-				       /* Bits 15 through 21 are used to determine IPGR1 */
-
-				       /* Bits 22 through 28 are used to determine IPGR2 */
-
-#define METH_REV_SHIFT 29       /* Bits 29 through 31 are used to determine the revision */
-				       /* 000: Inital revision */
-				       /* 001: First revision, Improved TX concatenation */
-
-
-/* DMA control bits */
-#define METH_RX_OFFSET_SHIFT 12 /* Bits 12:14 of DMA control register indicate starting offset of packet data for RX operation */
-#define METH_RX_DEPTH_SHIFT 4 /* Bits 8:4 define RX fifo depth -- when # of RX fifo entries != depth, interrupt is generted */
-
-#define METH_DMA_TX_EN BIT(1) /* enable TX DMA */
-#define METH_DMA_TX_INT_EN BIT(0) /* enable TX Buffer Empty interrupt */
-#define METH_DMA_RX_EN BIT(15) /* Enable RX */
-#define METH_DMA_RX_INT_EN BIT(9) /* Enable interrupt on RX packet */
-
-
-/* RX status bits */
-
-#define METH_RX_ST_RCV_CODE_VIOLATION BIT(16)
-#define METH_RX_ST_DRBL_NBL BIT(17)
-#define METH_RX_ST_CRC_ERR BIT(18)
-#define METH_RX_ST_MCAST_PKT BIT(19)
-#define METH_RX_ST_BCAST_PKT BIT(20)
-#define METH_RX_ST_INV_PREAMBLE_CTX BIT(21)
-#define METH_RX_ST_LONG_EVT_SEEN BIT(22)
-#define METH_RX_ST_BAD_PACKET BIT(23)
-#define METH_RX_ST_CARRIER_EVT_SEEN BIT(24)
-#define METH_RX_ST_MCAST_FILTER_MATCH BIT(25)
-#define METH_RX_ST_PHYS_ADDR_MATCH BIT(26)
-
-#define METH_RX_STATUS_ERRORS \
-	( \
-	METH_RX_ST_RCV_CODE_VIOLATION| \
-	METH_RX_ST_CRC_ERR| \
-	METH_RX_ST_INV_PREAMBLE_CTX| \
-	METH_RX_ST_LONG_EVT_SEEN| \
-	METH_RX_ST_BAD_PACKET| \
-	METH_RX_ST_CARRIER_EVT_SEEN \
-	)
-	/* Bits in METH_INT */
-	/* Write _1_ to corresponding bit to clear */
-#define METH_INT_TX_EMPTY	BIT(0)	/* 0: No interrupt pending, 1: The TX ring buffer is empty */
-#define METH_INT_TX_PKT		BIT(1)	/* 0: No interrupt pending */
-					      	/* 1: A TX message had the INT request bit set, the packet has been sent. */
-#define METH_INT_TX_LINK_FAIL	BIT(2)	/* 0: No interrupt pending, 1: PHY has reported a link failure */
-#define METH_INT_MEM_ERROR	BIT(3)	/* 0: No interrupt pending */
-						/* 1: A memory error occurred durring DMA, DMA stopped, Fatal */
-#define METH_INT_TX_ABORT		BIT(4)	/* 0: No interrupt pending, 1: The TX aborted operation, DMA stopped, FATAL */
-#define METH_INT_RX_THRESHOLD	BIT(5)	/* 0: No interrupt pending, 1: Selected receive threshold condition Valid */
-#define METH_INT_RX_UNDERFLOW	BIT(6)	/* 0: No interrupt pending, 1: FIFO was empty, packet could not be queued */
-#define METH_INT_RX_OVERFLOW		BIT(7)	/* 0: No interrupt pending, 1: DMA FIFO Overflow, DMA stopped, FATAL */
-
-#define METH_INT_RX_RPTR_MASK 0x0001F00		/* Bits 8 through 12 alias of RX read-pointer */
-
-						/* Bits 13 through 15 are always 0. */
-
-#define METH_INT_TX_RPTR_MASK 0x1FF0000	        /* Bits 16 through 24 alias of TX read-pointer */
-
-#define METH_INT_SEQ_MASK    0x2E000000	        /* Bits 25 through 29 are the starting seq number for the message at the */
-						/* top of the queue */
-
-#define METH_ERRORS ( \
-	METH_INT_RX_OVERFLOW|	\
-	METH_INT_RX_UNDERFLOW|	\
-	METH_INT_MEM_ERROR|			\
-	METH_INT_TX_ABORT)
-
-#define METH_INT_MCAST_HASH		BIT(30) /* If RX DMA is enabled the hash select logic output is latched here */
-
-/* TX status bits */
-#define METH_TX_STATUS_DONE BIT(23) /* Packet was transmitted successfully */
-
-/* Tx command header bits */
-#define METH_TX_CMD_INT_EN BIT(24) /* Generate TX interrupt when packet is sent */
-
-/* Phy MDIO interface busy flag */
-#define MDIO_BUSY    BIT(16)
-#define MDIO_DATA_MASK 0xFFFF
-/* PHY defines */
-#define PHY_QS6612X    0x0181441    /* Quality TX */
-#define PHY_ICS1889    0x0015F41    /* ICS FX */
-#define PHY_ICS1890    0x0015F42    /* ICS TX */
-#define PHY_DP83840    0x20005C0    /* National TX */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/mv64340_eth.c linux-2.4.22/drivers/net/mv64340_eth.c
--- linux-2.4.22.clean/drivers/net/mv64340_eth.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/net/mv64340_eth.c	2003-09-09 01:00:28.000000000 +0200
@@ -0,0 +1,3003 @@
+/*
+ * drivers/net/mv64340_eth.c - Driver for MV64340X ethernet ports
+ * Copyright (C) 2002 Matthew Dharm <mdharm@momenco.com>
+ *
+ * Based on the 64360 driver from:
+ * Copyright (C) 2002 rabeeh@galileo.co.il
+ *
+ * Copyright (C) 2003 Ralf Baechle <ralf@linux-mips.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/fcntl.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/ip.h>
+#include <linux/init.h>
+#include <linux/in.h>
+#include <linux/pci.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/ip.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+
+#include "mv64340_eth.h"
+
+/*************************************************************************
+**************************************************************************
+**************************************************************************
+*  The first part is the high level driver of the gigE ethernet ports.   *
+**************************************************************************
+**************************************************************************
+*************************************************************************/
+
+/* Definition for configuring driver */
+#undef MV64340_RX_QUEUE_FILL_ON_TASK
+
+/* Constants */
+#define EXTRA_BYTES 32
+#define WRAP       ETH_HLEN + 2 + 4 + 16
+#define BUFFER_MTU dev->mtu + WRAP
+#define INT_CAUSE_UNMASK_ALL		0x0007ffff
+#define INT_CAUSE_UNMASK_ALL_EXT	0x0011ffff
+#ifdef MV64340_RX_FILL_ON_TASK
+#define INT_CAUSE_MASK_ALL		0x00000000
+#define INT_CAUSE_CHECK_BITS		INT_CAUSE_UNMASK_ALL
+#define INT_CAUSE_CHECK_BITS_EXT	INT_CAUSE_UNMASK_ALL_EXT
+#endif
+
+/* Static function declarations */
+static int mv64340_eth_real_open(struct net_device *);
+static int mv64340_eth_real_stop(struct net_device *);
+static int mv64340_eth_change_mtu(struct net_device *, int);
+static struct net_device_stats *mv64340_eth_get_stats(struct net_device *);
+static void eth_port_init_mac_tables(ETH_PORT eth_port_num);
+#ifdef MV64340_NAPI
+static int mv64340_poll(struct net_device *dev, int *budget);
+#endif
+
+static unsigned char prom_mac_addr_base[6];
+
+/************************************************** 
+ * Helper functions - used inside the driver only *
+ **************************************************/
+
+static inline void __netif_rx_complete(struct net_device *dev)
+{
+        if (!test_bit(__LINK_STATE_RX_SCHED, &dev->state)) BUG();
+        list_del(&dev->poll_list);
+        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
+}
+
+static void *mv64340_eth_malloc_ring(unsigned int size)
+{
+	dma_addr_t dma_handle;
+	void *result;
+	/* Assumes allocated buffer is cache line alligned */
+	result = pci_alloc_consistent(NULL, size, &dma_handle);
+	memset(result, 0, size);
+	return result;
+}
+
+/**********************************************************************
+ * mv64340_eth_change_mtu
+ *								       
+ * Changes MTU (maximum transfer unit) of the gigabit ethenret port
+ *
+ * Input : pointer to ethernet interface network device structure
+ *         new mtu size 
+ * Output : 0 upon success, -EINVAL upon failure
+ **********************************************************************/
+static int mv64340_eth_change_mtu(struct net_device *dev, int new_mtu)
+{
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+	unsigned long flags;
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+
+	spin_lock_irqsave(&port_private->lock, flags);
+
+	if ((new_mtu > 9500) || (new_mtu < 64)) {
+		spin_unlock_irqrestore(&port_private->lock, flags);
+		return -EINVAL;
+	}
+
+	dev->mtu = new_mtu;
+	/* 
+	 * Stop then re-open the interface. This will allocate RX skb's with
+	 * the new MTU.
+	 * There is a possible danger that the open will not successed, due
+	 * to memory is full, which might fail the open function.
+	 */
+	if (netif_running(dev)) {
+		if (mv64340_eth_real_stop(dev))
+			printk(KERN_ERR
+			       "%s: Fatal error on stopping device\n",
+			       dev->name);
+		if (mv64340_eth_real_open(dev))
+			printk(KERN_ERR
+			       "%s: Fatal error on opening device\n",
+			       dev->name);
+	}
+
+	spin_unlock_irqrestore(&port_private->lock, flags);
+	return 0;
+}
+
+/**********************************************************************
+ * mv64340_eth_rx_task
+ *								       
+ * Fills / refills RX queue on a certain gigabit ethernet port
+ *
+ * Input : pointer to ethernet interface network device structure
+ * Output : N/A
+ **********************************************************************/
+static void mv64340_eth_rx_task(void *data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+	PKT_INFO pkt_info;
+	struct sk_buff *skb;
+
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+
+	if (test_and_set_bit(0, &port_private->rx_task_busy)) {
+		panic("%s: Error in test_set_bit / clear_bit\n", dev->name);
+	}
+	
+	while (port_private->rx_ring_skbs < (port_private->rx_ring_size - 5)) {
+		/* The +8 for buffer allignment and another 32 byte extra */
+		skb = dev_alloc_skb(BUFFER_MTU + 8 + EXTRA_BYTES);
+		if (!skb)
+			break;
+		port_private->rx_ring_skbs++;
+		pkt_info.cmd_sts = ETH_RX_ENABLE_INTERRUPT;
+		pkt_info.byte_cnt = dev->mtu + ETH_HLEN + 4 + 2 + EXTRA_BYTES;
+		/* Allign buffer to 8 bytes */
+		if (pkt_info.byte_cnt & ~0x7) {
+			pkt_info.byte_cnt &= ~0x7;
+			pkt_info.byte_cnt += 8;
+		}
+		pkt_info.buf_ptr =
+		    pci_map_single(0, skb->data,
+				   dev->mtu + ETH_HLEN + 4 + 2 + EXTRA_BYTES,
+				   PCI_DMA_FROMDEVICE);
+		pkt_info.return_info = skb;
+		if (eth_rx_return_buff(ethernet_private, &pkt_info) != ETH_OK) {
+			printk(KERN_ERR
+			       "%s: Error allocating RX Ring\n", dev->name);
+			break;
+		}
+		skb_reserve(skb, 2);
+	}
+	clear_bit(0, &port_private->rx_task_busy);
+	/*
+	 * If RX ring is empty of SKB, set a timer to try allocating
+	 * again in a later time .
+	 */
+	if ((port_private->rx_ring_skbs == 0) &&
+	    (port_private->rx_timer_flag == 0)) {
+		printk(KERN_INFO "%s: Rx ring is empty\n", dev->name);
+		/* After 100mSec */
+		port_private->timeout.expires = jiffies + (HZ / 10);
+		add_timer(&port_private->timeout);
+		port_private->rx_timer_flag = 1;
+	}
+#if MV64340_RX_QUEUE_FILL_ON_TASK
+	else {
+		/* Return interrupts */
+		MV_WRITE(MV64340_ETH_INTERRUPT_MASK_REG(port_num),
+			 INT_CAUSE_UNMASK_ALL);
+	}
+#endif
+}
+
+
+/**********************************************************************
+ * mv64340_eth_rx_task_timer_wrapper
+ *								       
+ * Timer routine to wake up RX queue filling task. This function is
+ * used only in case the RX queue is empty, and all alloc_skb has
+ * failed (due to out of memory event).
+ *
+ * Input : pointer to ethernet interface network device structure
+ * Output : N/A
+ **********************************************************************/
+static void mv64340_eth_rx_task_timer_wrapper(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+
+	port_private->rx_timer_flag = 0;
+	mv64340_eth_rx_task((void *) data);
+}
+
+
+/**********************************************************************
+ * mv64340_eth_update_mac_address
+ *								       
+ * Update the MAC address of the port in the address table
+ *
+ * Input : pointer to ethernet interface network device structure
+ * Output : N/A
+ **********************************************************************/
+static void mv64340_eth_update_mac_address(struct net_device *dev)
+{
+	ETH_PORT_INFO *ethernet_private = dev->priv;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+
+	eth_port_init_mac_tables(port_num);
+	memcpy(ethernet_private->port_mac_addr, dev->dev_addr, 6);
+	eth_port_uc_addr_set(port_num, ethernet_private->port_mac_addr);
+}
+
+/**********************************************************************
+ * mv64340_eth_set_rx_mode
+ *								       
+ * Change from promiscuos to regular rx mode
+ *
+ * Input : pointer to ethernet interface network device structure
+ * Output : N/A
+ **********************************************************************/
+static void mv64340_eth_set_rx_mode(struct net_device *dev)
+{
+	ETH_PORT_INFO *ethernet_private = (ETH_PORT_INFO *) dev->priv;
+
+	if (dev->flags & IFF_PROMISC) {
+		ethernet_set_config_reg
+		    (ethernet_private->port_num,
+		     ethernet_get_config_reg(ethernet_private->port_num) |
+		     ETH_UNICAST_PROMISCUOUS_MODE);
+	} else {
+		ethernet_set_config_reg
+		    (ethernet_private->port_num,
+		     ethernet_get_config_reg(ethernet_private->port_num) &
+		     ~(unsigned int) ETH_UNICAST_PROMISCUOUS_MODE);
+	}
+}
+
+
+/**********************************************************************
+ * mv64340_eth_set_mac_address
+ *								       
+ * Change the interface's mac address.
+ * No special hardware thing should be done because interface is always
+ * put in promiscuous mode.
+ *
+ * Input : pointer to ethernet interface network device structure and
+ *         a pointer to the designated entry to be added to the cache.
+ * Output : zero upon success, negative upon failure
+ **********************************************************************/
+static int mv64340_eth_set_mac_address(struct net_device *dev, void *addr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++)
+		/* +2 is for the offset of the HW addr type */
+		dev->dev_addr[i] = ((unsigned char *) addr)[i + 2];
+	mv64340_eth_update_mac_address(dev);
+	return 0;
+}
+
+/**********************************************************************
+ * mv64340_eth_tx_timeout
+ *								       
+ * Called upon a timeout on transmitting a packet
+ *
+ * Input : pointer to ethernet interface network device structure.
+ * Output : N/A
+ **********************************************************************/
+static void mv64340_eth_tx_timeout(struct net_device *dev)
+{
+	ETH_PORT_INFO *ethernet_private = dev->priv;
+	printk(KERN_INFO "%s: TX timeout  ", dev->name);
+	printk(KERN_INFO "Resetting card \n");
+
+	/* Do the reset outside of interrupt context */
+        schedule_task(&ethernet_private->tx_timeout_task);
+}
+
+/**********************************************************************
+ * mv64340_eth_tx_timeout_task
+ *
+ * Actual routine to reset the adapter when a timeout on Tx has occurred
+ **********************************************************************/
+static void mv64340_eth_tx_timeout_task(struct net_device *dev)
+{
+        ETH_PORT_INFO *ethernet_private = dev->priv;
+
+        netif_device_detach(dev);
+        eth_port_reset(ethernet_private->port_num);
+        eth_port_start(ethernet_private);
+        netif_device_attach(dev);
+}
+
+/**********************************************************************
+ * mv64340_eth_free_tx_queue
+ *
+ * Input : dev - a pointer to the required interface
+ *
+ * Output : 0 if was able to release skb , nonzero otherwise
+ **********************************************************************/
+
+static int mv64340_eth_free_tx_queue(struct net_device *dev,
+			      unsigned int eth_int_cause_ext)
+{
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+	PKT_INFO pkt_info;
+	int released = 1;
+	struct net_device_stats *stats;
+
+	spin_lock(&(port_private->lock));
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+	stats = &port_private->stats;
+
+	/* Check only queue 0 */
+	if (eth_int_cause_ext & (BIT0 | BIT8))
+		while (eth_tx_return_desc(ethernet_private, &pkt_info) ==
+		       ETH_OK) {
+			if (pkt_info.cmd_sts & BIT0) {
+				printk("%s: Error in TX\n", dev->name);
+				stats->tx_errors++;
+			}
+			/* 
+			 * If return_info is different than 0, release the skb.
+			 * The case where return_info is not 0 is only in case
+			 * when transmitted a scatter/gather packet, where only
+			 * last skb releases the whole chain.
+			 */
+			if (pkt_info.return_info) {
+				dev_kfree_skb_irq((struct sk_buff *)
+						  pkt_info.return_info);
+				released = 0;
+				if (skb_shinfo(pkt_info.return_info)->nr_frags)
+					pci_unmap_page(0, pkt_info.buf_ptr,
+						pkt_info.byte_cnt,
+						PCI_DMA_TODEVICE);
+
+				if (port_private->tx_ring_skbs != 1)
+					port_private->tx_ring_skbs--;
+			}
+			else 
+				pci_unmap_page(0, pkt_info.buf_ptr,
+						pkt_info.byte_cnt,
+						PCI_DMA_TODEVICE);
+
+			/* 
+			 * Decrement the number of outstanding skbs counter on the
+			 * TX queue.
+			 */
+			if (port_private->tx_ring_skbs == 0)
+				panic
+				    ("ERROR - TX outstanding SKBs counter is corrupted\n");
+
+		}
+
+	spin_unlock(&(port_private->lock));
+	return released;
+}
+
+/**********************************************************************
+ * mv64340_eth_receive
+ *
+ * This function is forward packets that are received from the port's
+ * queues toward kernel core or FastRoute them to another interface.
+ *
+ * Input : dev - a pointer to the required interface
+ *         max - maximum number to receive (0 means unlimted)
+ *
+ * Output : number of served packets
+ **********************************************************************/
+#ifdef MV64340_NAPI
+static int mv64340_eth_receive_queue(struct net_device *dev, unsigned int max,
+								int budget)
+#else
+static int mv64340_eth_receive_queue(struct net_device *dev, unsigned int max)
+#endif
+{
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+	PKT_INFO pkt_info;
+	struct sk_buff *skb;
+	unsigned int received_packets = 0;
+	struct net_device_stats *stats;
+
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+	stats = &port_private->stats;
+
+#ifdef MV64340_NAPI
+	while ((eth_port_receive(ethernet_private, &pkt_info) == ETH_OK) 
+		&&
+		budget > 0) {
+#else
+	while ((--max)
+	       && (eth_port_receive(ethernet_private, &pkt_info) ==
+		   ETH_OK)) {
+#endif
+		port_private->rx_ring_skbs--;
+		received_packets++;
+#ifdef MV64340_NAPI
+		budget--;
+#endif
+		/* Update statistics. Note byte count includes 4 byte CRC count */
+		stats->rx_packets++;
+		stats->rx_bytes += pkt_info.byte_cnt;
+		skb = (struct sk_buff *) pkt_info.return_info;
+		/*
+		 * In case received a packet without first / last bits on OR the error
+		 * summary bit is on, the packets needs to be dropeed.
+		 */
+		if (
+		    ((pkt_info.cmd_sts
+		      & (ETH_RX_FIRST_DESC | ETH_RX_LAST_DESC)) !=
+		     (ETH_RX_FIRST_DESC | ETH_RX_LAST_DESC))
+		    || (pkt_info.cmd_sts & ETH_ERROR_SUMMARY)) {
+			stats->rx_dropped++;
+			if (
+			    (pkt_info.cmd_sts & (ETH_RX_FIRST_DESC |
+						 ETH_RX_LAST_DESC)) !=
+			    (ETH_RX_FIRST_DESC | ETH_RX_LAST_DESC)) {
+				if (net_ratelimit())
+					printk(KERN_ERR
+					       "%s: Received packet spread on multiple"
+					       " descriptors\n",
+					       dev->name);
+			}
+			if (pkt_info.cmd_sts & ETH_ERROR_SUMMARY) {
+				stats->rx_errors++;
+			}
+			dev_kfree_skb_irq(skb);
+		} else {
+			struct ethhdr *eth_h;
+			struct iphdr *ip_h;
+
+			/*
+			 * The -4 is for the CRC in the trailer of the
+			 * received packet
+			 */
+			skb_put(skb, pkt_info.byte_cnt - 4);
+			skb->dev = dev;
+
+			eth_h = (struct ethhdr *) skb->data;
+			ip_h = (struct iphdr *) (skb->data + ETH_HLEN);
+			if (pkt_info.cmd_sts & ETH_LAYER_4_CHECKSUM_OK) {
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+				skb->csum = htons((pkt_info.cmd_sts
+							& 0x0007fff8) >> 3);
+			}
+			else 
+				skb->ip_summed = CHECKSUM_NONE;
+			skb->protocol = eth_type_trans(skb, dev);
+#ifdef MV64340_NAPI
+			netif_receive_skb(skb);
+#else
+			netif_rx(skb);
+#endif
+		}
+	}
+
+	return received_packets;
+}
+
+/**********************************************************************
+ * mv64340_eth_int_handler
+ *
+ * Main interrupt handler for the gigbit ethernet ports
+ *
+ * Input : irq - irq number (not used)
+ *         dev_id - a pointer to the required interface's data structure
+ *         regs   - not used
+ * Output : N/A
+ **********************************************************************/
+
+static void mv64340_eth_int_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	u32 eth_int_cause = 0, eth_int_cause_ext = 0;
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+
+	/* Read interrupt cause registers */
+	eth_int_cause =
+	    MV_READ_DATA(MV64340_ETH_INTERRUPT_CAUSE_REG(port_num));
+	if (eth_int_cause & BIT1)
+		eth_int_cause_ext =
+		    MV_READ_DATA(MV64340_ETH_INTERRUPT_CAUSE_EXTEND_REG
+				 (port_num));
+	else
+		eth_int_cause_ext = 0;
+
+	/* Mask with shadowed mask registers */
+#ifdef MV64340_RX_QUEUE_FILL_ON_TASK
+	eth_int_cause &= INT_CAUSE_CHECK_BITS;
+	eth_int_cause_ext &= INT_CAUSE_CHECK_BITS_EXT;
+#else
+	eth_int_cause &= INT_CAUSE_UNMASK_ALL;
+	eth_int_cause_ext &= INT_CAUSE_UNMASK_ALL_EXT;
+#endif
+
+	/*
+	 * If no real interrupt occured, exit.
+	 * This can happen when using gigE interrupt coalescing mechanism.
+	 */
+	if ((eth_int_cause == 0x0) && (eth_int_cause_ext == 0x0)) {
+		return;
+	}
+
+#ifdef MV64340_NAPI
+	if (!(eth_int_cause & 0x0007fffd)) {
+	/* Dont ack the Rx interrupt */
+#endif
+		/*
+	 	 * Clear specific ethernet port intrerrupt registers by acknowleding
+	 	 * relevant bits.
+   	 	 */
+		MV_WRITE(MV64340_ETH_INTERRUPT_CAUSE_REG(port_num),
+			 ~eth_int_cause);
+		if (eth_int_cause_ext != 0x0)
+			MV_WRITE(MV64340_ETH_INTERRUPT_CAUSE_EXTEND_REG(port_num),
+				 ~eth_int_cause_ext);
+#ifdef MV64340_NAPI
+	}
+#endif
+
+	if (eth_int_cause_ext & 0x0000ffff) {
+		/* 
+		 * Check if released more than one packet.
+		 * Otherwise don't wake up queue
+		 */
+		if (mv64340_eth_free_tx_queue(dev, eth_int_cause_ext) == 0) {
+			/*
+			 * If the interface was stopped before, and link is up,
+			 * wakeup TX queue. Note that this might be a problematic
+			 * issue since the multiple TX queues in the system controller,
+			 * and in which few queues are stucked.
+			 * If this is the case, then a TX packet to a stucked queue is
+			 * forwarded to another TX queue of the interface ; BUT in the
+			 * current implementation only one TX / RX queues are used.
+			 */
+			if (netif_queue_stopped(dev)
+			     && (dev->flags & IFF_RUNNING)
+			    &&
+			    (MV64340_TX_QUEUE_SIZE > port_private->tx_ring_skbs + 1)) {
+				netif_wake_queue(dev);
+			}
+		}
+	}
+	if (eth_int_cause & 0x0007fffd) {	
+		unsigned int total_received = 0;
+		/* Rx Return Buffer / Resource Error Priority queue 0 */
+#ifdef MV64340_NAPI
+		if (eth_int_cause & (BIT2 | BIT11)) {
+			if (netif_rx_schedule_prep(dev)) {
+				/* Mask all the interrupts */
+				MV_WRITE(MV64340_ETH_INTERRUPT_MASK_REG(port_num),0);
+				MV_WRITE(MV64340_ETH_INTERRUPT_EXTEND_MASK_REG(port_num), 0);
+				__netif_rx_schedule(dev);
+			}
+		}
+#else
+		if (eth_int_cause & (BIT2 | BIT11)) {
+			total_received +=
+			    mv64340_eth_receive_queue(dev, 0);
+		}
+		/*
+		 * After forwarded received packets to upper layer, add a task in an
+		 * interrupts enabled context that refills the RX ring with skb's.
+		 */
+#if MV64340_RX_QUEUE_FILL_ON_TASK
+		/* Unmask all interrupts on ethernet port */
+		MV_WRITE(MV64340_ETH_INTERRUPT_MASK_REG(port_num),
+			 INT_CAUSE_MASK_ALL);
+		queue_task(&port_private->rx_task, &tq_immediate);
+		mark_bh(IMMEDIATE_BH);
+#else
+		port_private->rx_task.routine(dev);
+#endif
+#endif
+
+	}
+
+	/* PHY status changed */
+	if (eth_int_cause_ext & (BIT16 | BIT20)) {
+		unsigned int phy_reg_data;
+
+		/* Check Link status on ethernet port */
+		eth_port_read_smi_reg(port_num, 1, &phy_reg_data);
+		if (!(phy_reg_data & 0x20)) {
+			netif_stop_queue(dev);
+			dev->flags &= ~(IFF_RUNNING);
+		} else {
+			netif_wake_queue(dev);
+			dev->flags |= (IFF_RUNNING);
+
+	/*
+	 * Start all TX queues on ethernet port. This is good in case of
+	 * previous packets where not transmitted, due to link down and
+	 * this command re-enables all TX queues.
+	 * Note that it is possible to get a TX resource error interrupt
+	 * after issuing this, since not all TX queues are enabled,
+	 * or has anything to send.
+	 */
+			MV_WRITE(MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG(port_num), 1);
+		}
+	}
+	return;
+}
+
+/**********************************************************************
+ * mv64340_eth_open
+ *
+ * This function is called when openning the network device. The function
+ * should initialize all the hardware, initialize cyclic Rx/Tx
+ * descriptors chain and buffers and allocate an IRQ to the network
+ * device.
+ *
+ * Input : a pointer to the network device structure
+ *
+ * Output : zero of success , nonzero if fails.
+ **********************************************************************/
+
+static int mv64340_eth_open(struct net_device *dev)
+{
+	int retval;
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+
+	spin_lock_irq(&(port_private->lock));
+
+	retval =
+	    request_irq(ETH_PORT0_IRQ_NUM + port_num, mv64340_eth_int_handler,
+			(SA_INTERRUPT | SA_SAMPLE_RANDOM), dev->name, dev);
+
+	if (retval != 0) {
+		printk(KERN_ERR "Can not assign IRQ number to MV64340_eth%d\n",
+		       port_num);
+		return -1;
+	} else {
+		dev->irq = ETH_PORT0_IRQ_NUM + port_num;
+	}
+
+	if (mv64340_eth_real_open(dev)) {
+		printk("%s: Error opening interface\n", dev->name);
+		free_irq(dev->irq, dev);
+		spin_unlock_irq(&ethernet_priv->lock);
+		return -EBUSY;
+	}
+	MOD_INC_USE_COUNT;
+	spin_unlock_irq(&ethernet_priv->lock);
+	return 0;
+}
+
+/* Helper function for mv64340_eth_open */
+static int mv64340_eth_real_open(struct net_device *dev)
+{
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+	u32 phy_reg_data;
+	unsigned int size;
+
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+
+	/* Stop RX Queues */
+	MV_WRITE(MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG(port_num),
+		 0x0000ff00);
+
+	/* Clear the ethernet port interrupts */
+	MV_WRITE(MV64340_ETH_INTERRUPT_CAUSE_REG(port_num), 0);
+	MV_WRITE(MV64340_ETH_INTERRUPT_CAUSE_EXTEND_REG(port_num), 0);
+
+	/* Unmask RX buffer and TX end interrupt */
+	MV_WRITE(MV64340_ETH_INTERRUPT_MASK_REG(port_num),
+		 INT_CAUSE_UNMASK_ALL);
+
+	/* Unmask phy and link status changes interrupts */
+	MV_WRITE(MV64340_ETH_INTERRUPT_EXTEND_MASK_REG(port_num),
+		 INT_CAUSE_UNMASK_ALL_EXT);
+
+	/* Set the MAC Address */
+	memcpy(ethernet_private->port_mac_addr, dev->dev_addr, 6);
+	eth_port_init(ethernet_private);
+
+	/* Set rx_task pointers */
+	port_private->rx_task.sync = 0;
+	port_private->rx_task.routine = mv64340_eth_rx_task;
+	port_private->rx_task.data = dev;
+
+	memset(&port_private->timeout, 0, sizeof(struct timer_list));
+	port_private->timeout.function = mv64340_eth_rx_task_timer_wrapper;
+	port_private->timeout.data = (unsigned long) dev;
+
+	port_private->rx_task_busy = 0;
+	port_private->rx_timer_flag = 0;
+
+	/* Allocate TX ring */
+	port_private->tx_ring_skbs = 0;
+	port_private->tx_ring_size = MV64340_TX_QUEUE_SIZE;
+	size = port_private->tx_ring_size * sizeof(ETH_TX_DESC);
+	ethernet_private->tx_desc_area_size = size;
+
+	/* Assumes allocated ring is 16 bytes alligned */
+	ethernet_private->p_tx_desc_area =
+	    (ETH_TX_DESC *) MV64340_NIC_SRAM_BASE_TX;
+	if (!ethernet_private->p_tx_desc_area) {
+		printk(KERN_ERR
+		       "%s: Cannot allocate Tx Ring (size %d bytes)\n",
+		       dev->name, size);
+		return -ENOMEM;
+	}
+	memset((void *) ethernet_private->p_tx_desc_area, 0,
+	       ethernet_private->tx_desc_area_size);
+
+	/* Dummy will be replaced upon real tx */
+	ether_init_tx_desc_ring(ethernet_private,
+				port_private->tx_ring_size,
+				(unsigned long)ethernet_private->p_tx_desc_area);
+
+	/* Allocate RX ring */
+	/* Meantime RX Ring are fixed - but must be configurable by user */
+	port_private->rx_ring_size = MV64340_RX_QUEUE_SIZE;
+	port_private->rx_ring_skbs = 0;
+	size = port_private->rx_ring_size * sizeof(ETH_RX_DESC);
+	ethernet_private->rx_desc_area_size = size;
+
+	/* Assumes allocated ring is 16 bytes alligned */
+	ethernet_private->p_rx_desc_area =
+	    (ETH_RX_DESC *) mv64340_eth_malloc_ring(size);
+	if (!ethernet_private->p_rx_desc_area) {
+		printk(KERN_ERR
+		       "%s: Cannot allocate Rx ring (size %d bytes)\n",
+		       dev->name, size);
+		printk(KERN_ERR
+		       "%s: Freeing previously allocated TX queues...",
+		       dev->name);
+		pci_free_consistent(0, ethernet_private->tx_desc_area_size,
+				    (void *)
+				    ethernet_private->p_tx_desc_area,
+				    virt_to_bus(ethernet_private->
+							    p_tx_desc_area));
+		return -ENOMEM;
+	}
+	memset((void *) ethernet_private->p_rx_desc_area, 0,
+	       ethernet_private->rx_desc_area_size);
+	if (
+	    (ether_init_rx_desc_ring(ethernet_private, port_private->rx_ring_size, 1536,	/* Dummy, will be replaced later */
+				     (unsigned long) ethernet_private->p_rx_desc_area,
+				     0)) == false)
+		panic("%s: Error initializing RX Ring\n", dev->name);
+
+	/* Fill RX ring with skb's */
+	mv64340_eth_rx_task(dev);
+
+	eth_port_start(ethernet_private);
+
+	/* Interrupt Coalescing */
+
+	port_private->rx_int_coal =
+		eth_port_set_rx_coal (port_num, 133000000, MV64340_RX_COAL);
+
+	port_private->tx_int_coal =
+		eth_port_set_tx_coal (port_num, 133000000, MV64340_TX_COAL); 
+
+	/* Increase the Rx side buffer size */
+
+	MV_WRITE (MV64340_ETH_PORT_SERIAL_CONTROL_REG(port_num), (0x5 << 17) |
+			(MV_READ_DATA (MV64340_ETH_PORT_SERIAL_CONTROL_REG(port_num))
+			 				& 0xfff1ffff));
+
+	/* Check Link status on phy */
+	eth_port_read_smi_reg(port_num, 1, &phy_reg_data);
+	if (!(phy_reg_data & 0x20)) {
+		netif_stop_queue(dev);
+		dev->flags &= ~(IFF_RUNNING);
+	} else {
+		netif_start_queue(dev);
+		dev->flags |= (IFF_RUNNING);
+	}
+	return 0;
+}
+
+
+static void mv64340_eth_free_tx_rings(struct net_device *dev)
+{
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num, curr;
+
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+
+	/* Stop Tx Queues */
+	MV_WRITE(MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG(port_num),
+		 0x0000ff00);
+
+	/* Free TX rings */
+	/* Free outstanding skb's on TX rings */
+	for (curr = 0;
+	     (port_private->tx_ring_skbs) && (curr < MV64340_TX_QUEUE_SIZE);
+	     curr++) {
+		if (ethernet_private->tx_skb[curr]) {
+			dev_kfree_skb(ethernet_private->tx_skb[curr]);
+			port_private->tx_ring_skbs--;
+		}
+	}
+	if (port_private->tx_ring_skbs != 0)
+		printk
+		    ("%s: Error on Tx descriptor free - could not free %d"
+		     " descriptors\n", dev->name,
+		     port_private->tx_ring_skbs);
+	pci_free_consistent(0, ethernet_private->tx_desc_area_size,
+			    (void *) ethernet_private->p_tx_desc_area,
+			    virt_to_bus(ethernet_private->p_tx_desc_area));
+}
+
+static void mv64340_eth_free_rx_rings(struct net_device *dev)
+{
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+	int curr;
+
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+
+
+	/* Stop RX Queues */
+	MV_WRITE(MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG(port_num),
+		 0x0000ff00);
+
+	/* Free RX rings */
+	/* Free preallocated skb's on RX rings */
+	for (curr = 0;
+		port_private->rx_ring_skbs && (curr < MV64340_RX_QUEUE_SIZE);
+		curr++) {
+		if (ethernet_private->rx_skb[curr]) {
+			dev_kfree_skb(ethernet_private->rx_skb[curr]);
+			port_private->rx_ring_skbs--;
+		}
+	}
+
+	if (port_private->rx_ring_skbs != 0)
+		printk(KERN_ERR
+		       "%s: Error in freeing Rx Ring. %d skb's still"
+		       " stuck in RX Ring - ignoring them\n", dev->name,
+		       port_private->rx_ring_skbs);
+	pci_free_consistent(0, ethernet_private->rx_desc_area_size,
+			    (void *) ethernet_private->p_rx_desc_area,
+			    virt_to_bus(ethernet_private->p_rx_desc_area));
+}
+
+/**********************************************************************
+ * mv64340_eth_stop
+ *
+ * This function is used when closing the network device. 
+ * It updates the hardware, 
+ * release all memory that holds buffers and descriptors and release the IRQ.
+ * Input : a pointer to the device structure
+ * Output : zero if success , nonzero if fails
+ *********************************************************************/
+
+static int mv64340_eth_stop(struct net_device *dev)
+{
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+
+	spin_lock_irq(&(port_private->lock));
+
+	mv64340_eth_real_stop(dev);
+
+	free_irq(dev->irq, dev);
+	MOD_DEC_USE_COUNT;
+	spin_unlock_irq(&ethernet_priv->lock);
+	return 0;
+};
+
+/* Helper function for mv64340_eth_stop */
+
+static int mv64340_eth_real_stop(struct net_device *dev)
+{
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+
+	netif_stop_queue(dev);
+
+	mv64340_eth_free_tx_rings(dev);
+	mv64340_eth_free_rx_rings(dev);
+
+	eth_port_reset(ethernet_private->port_num);
+
+	/* Disable ethernet port interrupts */
+	MV_WRITE(MV64340_ETH_INTERRUPT_CAUSE_REG(port_num), 0);
+	MV_WRITE(MV64340_ETH_INTERRUPT_CAUSE_EXTEND_REG(port_num), 0);
+
+	/* Mask RX buffer and TX end interrupt */
+	MV_WRITE(MV64340_ETH_INTERRUPT_MASK_REG(port_num), 0);
+
+	/* Mask phy and link status changes interrupts */
+	MV_WRITE(MV64340_ETH_INTERRUPT_EXTEND_MASK_REG(port_num), 0);
+
+	return 0;
+}
+
+#ifdef MV64340_NAPI
+static void mv64340_tx(struct net_device *dev)
+{
+	ETH_PORT_INFO *ethernet_private;
+        struct mv64340_eth_priv *port_private;
+        unsigned int port_num;
+        PKT_INFO pkt_info;
+
+	ethernet_private = dev->priv;
+	port_private =
+            (struct mv64340_eth_priv *) ethernet_private->port_private;
+
+	port_num = port_private->port_num;
+
+	while (eth_tx_return_desc(ethernet_private, &pkt_info) == ETH_OK) {
+		if (pkt_info.return_info) {
+			dev_kfree_skb_irq((struct sk_buff *)
+                                                  pkt_info.return_info);
+			if (skb_shinfo(pkt_info.return_info)->nr_frags) 
+                                 pci_unmap_page(0, pkt_info.buf_ptr,
+                                             pkt_info.byte_cnt,
+                                             PCI_DMA_TODEVICE);
+
+                         if (port_private->tx_ring_skbs != 1)
+                                  port_private->tx_ring_skbs--;
+                } else 
+                       pci_unmap_page(0, pkt_info.buf_ptr,
+                             pkt_info.byte_cnt,
+                             PCI_DMA_TODEVICE);
+	}
+
+	if (netif_queue_stopped(dev) &&
+		(dev->flags & IFF_RUNNING) &&
+                (MV64340_TX_QUEUE_SIZE > port_private->tx_ring_skbs + 1)) {
+                       netif_wake_queue(dev);
+	}
+}
+
+/**********************************************************************
+ * mv64340_poll
+ *
+ * This function is used in case of NAPI
+ ***********************************************************************/
+static int mv64340_poll(struct net_device *netdev, int *budget)
+{
+	ETH_PORT_INFO *ethernet_private = netdev->priv;
+	struct mv64340_eth_priv *port_private = 
+		(struct mv64340_eth_priv *) ethernet_private->port_private;
+	int	done = 1, orig_budget, work_done;
+	unsigned long	flags;
+	unsigned int	port_num = port_private->port_num;
+
+	spin_lock_irqsave(&port_private->lock, flags);
+	mv64340_tx(netdev);
+
+	orig_budget = *budget;
+	if (orig_budget > netdev->quota)
+		orig_budget = netdev->quota;
+	work_done = mv64340_eth_receive_queue(netdev, 0, orig_budget);
+	port_private->rx_task.routine(netdev);
+	*budget -= work_done;
+	netdev->quota -= work_done;
+	if (work_done >= orig_budget)
+		done = 0;
+
+	if (done) {
+		__netif_rx_complete(netdev);
+		MV_WRITE(MV64340_ETH_INTERRUPT_CAUSE_REG(port_num),0);
+                MV_WRITE(MV64340_ETH_INTERRUPT_CAUSE_EXTEND_REG(port_num),0);
+		MV_WRITE(MV64340_ETH_INTERRUPT_MASK_REG(port_num), 
+						INT_CAUSE_UNMASK_ALL);
+		MV_WRITE(MV64340_ETH_INTERRUPT_EXTEND_MASK_REG(port_num),
+				                 INT_CAUSE_UNMASK_ALL_EXT);
+	}
+
+	spin_unlock_irqrestore(&port_private->lock, flags);
+	return (done ? 0 : 1);
+}
+#endif
+
+/**********************************************************************
+ * mv64340_eth_start_xmit
+ *
+ * This function is queues a packet in the Tx descriptor for 
+ * required port.
+ *
+ * Input : skb - a pointer to socket buffer
+ *         dev - a pointer to the required port
+ *
+ * Output : zero upon success
+ **********************************************************************/
+
+static int mv64340_eth_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+	PKT_INFO pkt_info;
+	unsigned long flags;
+	ETH_FUNC_RET_STATUS status;
+	struct net_device_stats *stats;
+
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+	stats = &port_private->stats;
+
+	if (netif_queue_stopped(dev)) {
+		printk(KERN_ERR
+		       "%s: Tried sending packet when interface is stopped\n",
+		       dev->name);
+		return 1;
+	}
+
+	/* This is a hard error, log it. */
+	if ((MV64340_TX_QUEUE_SIZE - port_private->tx_ring_skbs) <=
+	    (skb_shinfo(skb)->nr_frags + 1)) {
+		netif_stop_queue(dev);
+		printk(KERN_ERR
+		       "%s: Bug in mv64340_eth - Trying to transmit when"
+		       " queue full !\n", dev->name);
+		return 1;
+	}
+
+	/* Paranoid check - this shouldn't happen */
+	if (skb == NULL) {
+		stats->tx_dropped++;
+		return 1;
+	}
+
+	spin_lock_irqsave(&port_private->lock, flags);
+
+	/* Update packet info data structure -- DMA owned, first last */
+#ifdef MV64340_CHECKSUM_OFFLOAD_TX
+	if (!skb_shinfo(skb)->nr_frags) {
+#endif
+		pkt_info.cmd_sts = ETH_TX_ENABLE_INTERRUPT |
+	    				ETH_TX_FIRST_DESC | ETH_TX_LAST_DESC;
+
+		pkt_info.byte_cnt = skb->len;
+		pkt_info.buf_ptr = pci_map_single
+			    (0, skb->data, skb->len, PCI_DMA_TODEVICE);
+
+		pkt_info.return_info = skb;
+		status = eth_port_send(ethernet_private, &pkt_info);
+		if ((status == ETH_ERROR) || (status == ETH_QUEUE_FULL))
+			printk(KERN_ERR "%s: Error on transmitting packet\n",
+				       dev->name);
+		port_private->tx_ring_skbs++;
+#ifdef MV64340_CHECKSUM_OFFLOAD_TX
+	} 
+	else {
+		unsigned int    frag;
+		u32		ipheader;
+
+                /* first frag which is skb header */
+                pkt_info.byte_cnt = skb_headlen(skb);
+                pkt_info.buf_ptr = pci_map_single(0, skb->data,
+                                        skb_headlen(skb), PCI_DMA_TODEVICE);
+                pkt_info.return_info = 0;
+                pkt_info.cmd_sts =  ETH_TX_FIRST_DESC;
+
+                ipheader =  ( (skb->nh.iph->ihl << 11) & (BIT14
+                                                        | BIT13
+                                                        | BIT12
+                                                        | BIT11));
+
+                if (skb->ip_summed == CHECKSUM_HW)  {
+                        /* Fly baby fly */
+                        pkt_info.cmd_sts |= ETH_GEN_TCP_UDP_CHECKSUM |
+					ETH_GEN_IP_V_4_CHECKSUM |
+					BIT10 |
+                                        ipheader;
+                        pkt_info.l4i_chk = 0x0000;
+                }
+                status = eth_port_send(ethernet_private, &pkt_info);
+                if ((status == ETH_ERROR))
+                        printk(KERN_ERR "%s: Error on transmitting packet\n", dev->name);
+                if (status == ETH_QUEUE_FULL)
+                        printk("Error on Queue Full \n");
+                if (status == ETH_QUEUE_LAST_RESOURCE)
+                        printk("Tx resource error \n");
+
+                /* Check for the remaining frags */
+                for (frag = 0; frag < skb_shinfo(skb)->nr_frags; frag++) {
+                        skb_frag_t *this_frag = &skb_shinfo(skb)->frags[frag];
+                        pkt_info.l4i_chk = 0x0000;
+                        pkt_info.cmd_sts = 0x00000000;
+
+                        /* Last Frag enables interrupt and frees the skb */
+                        if (frag == (skb_shinfo(skb)->nr_frags - 1)) {
+                                pkt_info.cmd_sts |= ETH_TX_ENABLE_INTERRUPT |
+                                                        ETH_TX_LAST_DESC;
+                                pkt_info.return_info = skb;
+                                port_private->tx_ring_skbs++;
+                        }
+                        else {
+                                pkt_info.return_info = 0;
+                        }
+                        pkt_info.byte_cnt = this_frag->size;
+                        if (this_frag->size < 8)
+                                printk("%d : \n", skb_shinfo(skb)->nr_frags);
+
+                        pkt_info.buf_ptr = pci_map_page(0,
+                                        this_frag->page,
+                                        this_frag->page_offset,
+                                        this_frag->size,
+                                        PCI_DMA_TODEVICE);
+
+                        status = eth_port_send(ethernet_private, &pkt_info);
+                        if ((status == ETH_ERROR))
+                                printk(KERN_ERR "%s: Error on transmitting packet\n",
+                                        dev->name);
+
+                        if (status == ETH_QUEUE_LAST_RESOURCE)
+                                printk("Tx resource error \n");
+
+                        if (status == ETH_QUEUE_FULL)
+                                printk("Queue is full \n");
+
+                }
+        }
+#endif
+
+	/* Check if TX queue can handle another skb. If not, then
+	 * signal higher layers to stop requesting TX
+	 */
+	if (MV64340_TX_QUEUE_SIZE <= (port_private->tx_ring_skbs + 1))
+		/* 
+		 * Stop getting skb's from upper layers.
+		 * Getting skb's from upper layers will be enabled again after
+		 * packets are released.
+		 */
+		netif_stop_queue(dev);
+
+
+	/* Update statistics and start of transmittion time */
+	stats->tx_bytes += skb->len;
+	stats->tx_packets++;
+	dev->trans_start = jiffies;
+
+	spin_unlock_irqrestore(&ethernet_priv->lock, flags);
+	return 0;		/* success */
+}
+
+/**********************************************************************
+ * mv64340_eth_get_stats
+ *
+ * Returns a pointer to the interface statistics.
+ *
+ * Input : dev - a pointer to the required interface
+ *
+ * Output : a pointer to the interface's statistics
+ **********************************************************************/
+
+static struct net_device_stats *mv64340_eth_get_stats(struct net_device
+						      *dev)
+{
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	unsigned int port_num;
+
+	ethernet_private = dev->priv;
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_num = port_private->port_num;
+
+	return &port_private->stats;
+}
+
+/**********************************************************************
+ * mv64340_eth_init
+ *								       
+ * First function called after registering the network device. 
+ * It's purpose is to initialize the device as an ethernet device, 
+ * fill the structure that was given in registration with pointers
+ * to functions, and setting the MAC address of the interface
+ *
+ * Input : number of port to initialize
+ * Output : -ENONMEM if failed , 0 if success
+ **********************************************************************/
+static int mv64340_eth_init(int port_num)
+{
+	ETH_PORT_INFO *ethernet_private;
+	struct mv64340_eth_priv *port_private;
+	struct net_device *dev;
+	int err;
+
+	dev = alloc_etherdev(sizeof(ETH_PORT_INFO));
+	if (!dev)
+		return -ENOMEM;
+
+	dev->open = mv64340_eth_open;
+	dev->stop = mv64340_eth_stop;
+	dev->hard_start_xmit = mv64340_eth_start_xmit;
+	dev->get_stats = mv64340_eth_get_stats;
+	dev->set_mac_address = mv64340_eth_set_mac_address;
+	dev->set_multicast_list = mv64340_eth_set_rx_mode;
+
+	/* No need to Tx Timeout */
+	dev->tx_timeout = mv64340_eth_tx_timeout;
+#ifdef MV64340_NAPI
+        dev->poll = mv64340_poll;
+        dev->weight = 64;
+#endif
+	dev->watchdog_timeo = 2 * HZ;
+	dev->tx_queue_len = MV64340_TX_QUEUE_SIZE;
+	dev->flags &= ~(IFF_RUNNING);
+	dev->base_addr = 0;
+	dev->change_mtu = &mv64340_eth_change_mtu;
+
+#ifdef MV64340_CHECKSUM_OFFLOAD_TX
+#ifdef MAX_SKB_FRAGS
+#ifndef CONFIG_JAGUAR_DMALOW
+        /*
+         * Zero copy can only work if we use Discovery II memory. Else, we will
+         * have to map the buffers to ISA memory which is only 16 MB
+         */
+        dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_HW_CSUM;
+#endif
+#endif
+#endif
+
+	ethernet_private = dev->priv;
+
+	/* Allocate memory for stats data structure and spinlock etc... */
+	ethernet_private->port_private = (void *)
+	    kmalloc(sizeof(struct mv64340_eth_priv), GFP_KERNEL);
+	if (!ethernet_private->port_private) {
+		err = -ENOMEM;
+		goto out_free_dev;
+	}
+	memset(ethernet_private->port_private, 0,
+	       sizeof(struct mv64340_eth_priv));
+	if (port_num == 0)
+		ethernet_private->port_num = ETH_0;
+	else if (port_num == 1)
+		ethernet_private->port_num = ETH_1;
+	else if (port_num == 2)
+		ethernet_private->port_num = ETH_2;
+	else {
+		printk(KERN_ERR "%s: Invalid port number\n", dev->name);
+		kfree(ethernet_private->port_private);
+
+		err = -ENODEV;
+		goto out_free_dev;
+	}
+
+	port_private =
+	    (struct mv64340_eth_priv *) ethernet_private->port_private;
+	port_private->port_num = port_num;
+
+	memset(&port_private->stats, 0, sizeof(struct net_device_stats));
+
+	/* Configure the timeout task */
+        INIT_TQUEUE(&ethernet_private->tx_timeout_task,
+                        (void (*)(void *))mv64340_eth_tx_timeout_task, dev);
+
+	/* Init spinlock */
+	spin_lock_init(&port_private->lock);
+
+	/* set MAC addresses */
+	memcpy(dev->dev_addr, prom_mac_addr_base, 6);
+	dev->dev_addr[5] += port_num;
+
+	err = register_netdev(dev);
+	if (err)
+		goto out_free_dev;
+
+	printk(KERN_NOTICE "%s: port %d with MAC address %02x:%02x:%02x:%02x:%02x:%02x\n",
+		dev->name, port_num,
+		dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+		dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	if (dev->features & NETIF_F_SG)
+		printk("Scatter Gather Enabled  ");
+
+	if (dev->features & NETIF_F_IP_CSUM)
+		printk("TX TCP/IP Checksumming Supported  \n");
+
+	printk("RX TCP/UDP Checksum Offload ON, \n");
+	printk("TX and RX Interrupt Coalescing ON \n");
+
+#ifdef MV64340_NAPI
+	printk("RX NAPI Enabled \n");
+#endif
+
+	return 0;
+
+out_free_dev:
+	kfree(dev->priv);		/* free_netdev(dev) in 2.6 */
+	kfree(dev);
+
+	return err;
+}
+
+/**********************************************************************
+ * mv64340_init_module
+ *
+ * Registers the network drivers into the Linux kernel
+ *
+ * Input : N/A
+ *
+ * Output : N/A
+ **********************************************************************/
+static int __init mv64340_init_module(void)
+{
+	printk(KERN_NOTICE "MV-64340 10/100/1000 Ethernet Driver\n");
+#ifdef CONFIG_MV64340_ETH_0
+	if (mv64340_eth_init(0)) {
+		printk(KERN_ERR
+		       "Error registering MV-64360 ethernet port 0\n");
+	}
+#endif
+#ifdef CONFIG_MV64340_ETH_1
+	if (mv64340_eth_init(1)) {
+		printk(KERN_ERR
+		       "Error registering MV-64360 ethernet port 1\n");
+	}
+#endif
+#ifdef CONFIG_MV64340_ETH_2
+	if (mv64340_eth_init(2)) {
+		printk(KERN_ERR
+		       "Error registering MV-64360 ethernet port 2\n");
+	}
+#endif
+	return 0;
+}
+
+/**********************************************************************
+ * mv64340_cleanup_module
+ *
+ * Registers the network drivers into the Linux kernel
+ *
+ * Input : N/A
+ *
+ * Output : N/A
+ **********************************************************************/
+static void __init mv64340_cleanup_module(void)
+{
+	/* Nothing to do here ! it's not a removable module */
+}
+
+module_init(mv64340_init_module);
+module_exit(mv64340_cleanup_module);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Rabeeh Khoury, Assaf Hoffman, and Matthew Dharm");
+MODULE_DESCRIPTION("Ethernet driver for Marvell MV64340");
+
+/*************************************************************************
+**************************************************************************
+**************************************************************************
+*  The second part is the low level driver of the gigE ethernet ports.   *
+**************************************************************************
+**************************************************************************
+*************************************************************************/
+
+
+
+
+/********************************************************************************
+ * Marvell's Gigabit Ethernet controller low level driver
+ *
+ * DESCRIPTION:
+ *       This file introduce low level API to Marvell's Gigabit Ethernet
+ *		controller. This Gigabit Ethernet Controller driver API controls
+ *		1) Operations (i.e. port init, start, reset etc').
+ *		2) Data flow (i.e. port send, receive etc').
+ *		Each Gigabit Ethernet port is controlled via ETH_PORT_INFO
+ *		struct.
+ *		This struct includes user configuration information as well as
+ *		driver internal data needed for its operations.
+ *
+ *		Supported Features:  
+ *		- This low level driver is OS independent. Allocating memory for
+ *		  the descriptor rings and buffers are not within the scope of
+ *		  this driver.
+ *		- The user is free from Rx/Tx queue managing.
+ *		- This low level driver introduce functionality API that enable
+ *		  the to operate Marvell's Gigabit Ethernet Controller in a
+ *		  convenient way.
+ *		- Simple Gigabit Ethernet port operation API.
+ *		- Simple Gigabit Ethernet port data flow API.
+ *		- Data flow and operation API support per queue functionality.
+ *		- Support cached descriptors for better performance.
+ *		- Enable access to all four DRAM banks and internal SRAM memory
+ *		  spaces.
+ *		- PHY access and control API.
+ *		- Port control register configuration API.
+ *		- Full control over Unicast and Multicast MAC configurations.
+ *								   
+ *		Operation flow:
+ *
+ *		Initialization phase
+ *		This phase complete the initialization of the ETH_PORT_INFO
+ *		struct. 
+ *		User information regarding port configuration has to be set
+ *		prior to calling the port initialization routine.
+ *
+ *		In this phase any port Tx/Rx activity is halted, MIB counters
+ *		are cleared, PHY address is set according to user parameter and
+ *		access to DRAM and internal SRAM memory spaces.
+ *
+ *		Driver ring initialization
+ *		Allocating memory for the descriptor rings and buffers is not 
+ *		within the scope of this driver. Thus, the user is required to
+ *		allocate memory for the descriptors ring and buffers. Those
+ *		memory parameters are used by the Rx and Tx ring initialization
+ *		routines in order to curve the descriptor linked list in a form
+ *		of a ring.
+ *		Note: Pay special attention to alignment issues when using
+ *		cached descriptors/buffers. In this phase the driver store
+ *		information in the ETH_PORT_INFO struct regarding each queue
+ *		ring.
+ *
+ *		Driver start 
+ *		This phase prepares the Ethernet port for Rx and Tx activity.
+ *		It uses the information stored in the ETH_PORT_INFO struct to 
+ *		initialize the various port registers.
+ *
+ *		Data flow:
+ *		All packet references to/from the driver are done using PKT_INFO
+ *		struct.
+ *		This struct is a unified struct used with Rx and Tx operations. 
+ *		This way the user is not required to be familiar with neither
+ *		Tx nor Rx descriptors structures.
+ *		The driver's descriptors rings are management by indexes.
+ *		Those indexes controls the ring resources and used to indicate
+ *		a SW resource error:
+ *		'current' 
+ *		This index points to the current available resource for use. For 
+ *		example in Rx process this index will point to the descriptor  
+ *		that will be passed to the user upon calling the receive routine.
+ *		In Tx process, this index will point to the descriptor
+ *		that will be assigned with the user packet info and transmitted.
+ *		'used'    
+ *		This index points to the descriptor that need to restore its 
+ *		resources. For example in Rx process, using the Rx buffer return
+ *		API will attach the buffer returned in packet info to the
+ *		descriptor pointed by 'used'. In Tx process, using the Tx
+ *		descriptor return will merely return the user packet info with
+ *		the command status of  the transmitted buffer pointed by the
+ *		'used' index. Nevertheless, it is essential to use this routine
+ *		to update the 'used' index.
+ *		'first'
+ *		This index supports Tx Scatter-Gather. It points to the first 
+ *		descriptor of a packet assembled of multiple buffers. For example
+ *		when in middle of Such packet we have a Tx resource error the 
+ *		'curr' index get the value of 'first' to indicate that the ring 
+ *		returned to its state before trying to transmit this packet.
+ *
+ *		Receive operation:
+ *		The eth_port_receive API set the packet information struct,
+ *		passed by the caller, with received information from the 
+ *		'current' SDMA descriptor. 
+ *		It is the user responsibility to return this resource back
+ *		to the Rx descriptor ring to enable the reuse of this source.
+ *		Return Rx resource is done using the eth_rx_return_buff API.
+ *
+ *		Transmit operation:
+ *		The eth_port_send API supports Scatter-Gather which enables to
+ *		send a packet spanned over multiple buffers. This means that
+ *		for each packet info structure given by the user and put into
+ *		the Tx descriptors ring, will be transmitted only if the 'LAST'
+ *		bit will be set in the packet info command status field. This
+ *		API also consider restriction regarding buffer alignments and
+ *		sizes.
+ *		The user must return a Tx resource after ensuring the buffer
+ *		has been transmitted to enable the Tx ring indexes to update.
+ *
+ *		BOARD LAYOUT
+ *		This device is on-board.  No jumper diagram is necessary.
+ *
+ *		EXTERNAL INTERFACE
+ *
+ *       Prior to calling the initialization routine eth_port_init() the user
+ *	 must set the following fields under ETH_PORT_INFO struct:
+ *       port_num             User Ethernet port number.
+ *       port_mac_addr[6]	    User defined port MAC address.
+ *       port_config          User port configuration value.
+ *       port_config_extend    User port config extend value.
+ *       port_sdma_config      User port SDMA config value.
+ *       port_serial_control   User port serial control value.
+ *       *port_private        User scratch pad for user specific data structures.
+ *		                                                                       
+ *       This driver introduce a set of default values:
+ *       PORT_CONFIG_VALUE           Default port configuration value
+ *       PORT_CONFIG_EXTEND_VALUE    Default port extend configuration value
+ *       PORT_SDMA_CONFIG_VALUE      Default sdma control value
+ *       PORT_SERIAL_CONTROL_VALUE   Default port serial control value
+ *
+ *		This driver data flow is done using the PKT_INFO struct which is
+ *		a unified struct for Rx and Tx operations:
+ *		byte_cnt	Tx/Rx descriptor buffer byte count.
+ *		l4i_chk		CPU provided TCP Checksum. For Tx operation only.
+ *		cmd_sts		Tx/Rx descriptor command status.
+ *		buf_ptr		Tx/Rx descriptor buffer pointer.
+ *		return_info	Tx/Rx user resource return information.
+ *
+ *******************************************************************************/
+/* includes */
+
+/* defines */
+/* SDMA command macros */
+#define ETH_ENABLE_TX_QUEUE(eth_port) \
+ MV_WRITE(MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG(eth_port), 1)
+
+#define ETH_DISABLE_TX_QUEUE(eth_port) \
+ MV_WRITE(MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG(eth_port), (1 << 8))
+
+#define ETH_ENABLE_RX_QUEUE(rx_queue, eth_port) \
+MV_WRITE(MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG(eth_port), (1 << rx_queue))
+
+#define ETH_DISABLE_RX_QUEUE(rx_queue, eth_port) \
+MV_WRITE(MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG(eth_port), (1 << (8 + rx_queue)))
+
+#define LINK_UP_TIMEOUT		100000
+#define PHY_BUSY_TIMEOUT	10000000
+
+/* locals */
+
+/* PHY routines */
+#ifdef MDD_CUT
+static void ethernet_phy_set(ETH_PORT eth_port_num, int phy_addr);
+#endif
+static int ethernet_phy_get(ETH_PORT eth_port_num);
+
+/* Ethernet Port routines */
+static bool eth_port_uc_addr(ETH_PORT eth_port_num,
+			     unsigned char uc_nibble, int option);
+
+#ifdef MDD_CUT
+static void eth_b_copy(unsigned int src_addr, unsigned int dst_addr,
+		       int byte_count);
+#endif
+
+/*******************************************************************************
+* eth_port_init - Initialize the Ethernet port driver
+*
+* DESCRIPTION:
+*       This function prepares the ethernet port to start its activity:
+*       1) Completes the ethernet port driver struct initialization toward port
+*           start routine.
+*       2) Resets the device to a quiescent state in case of warm reboot.
+*       3) Enable SDMA access to all four DRAM banks as well as internal SRAM.
+*       4) Clean MAC tables. The reset status of those tables is unknown.
+*       5) Set PHY address. 
+*       Note: Call this routine prior to eth_port_start routine and after setting
+*       user values in the user fields of Ethernet port control struct.
+*
+* INPUT:
+*       ETH_PORT_INFO 	*p_eth_port_ctrl       Ethernet port control struct
+*
+* OUTPUT:
+*       See description.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+static void eth_port_init(ETH_PORT_INFO * p_eth_port_ctrl)
+{
+	p_eth_port_ctrl->port_config = PORT_CONFIG_VALUE;
+	p_eth_port_ctrl->port_config_extend = PORT_CONFIG_EXTEND_VALUE;
+#if defined(__BIG_ENDIAN)
+	p_eth_port_ctrl->port_sdma_config = PORT_SDMA_CONFIG_VALUE;
+#elif defined(__LITTLE_ENDIAN)
+	p_eth_port_ctrl->port_sdma_config = PORT_SDMA_CONFIG_VALUE |
+		ETH_BLM_RX_NO_SWAP | ETH_BLM_TX_NO_SWAP;
+#else
+#error One of __LITTLE_ENDIAN or __BIG_ENDIAN must be defined!
+#endif
+	p_eth_port_ctrl->port_serial_control = PORT_SERIAL_CONTROL_VALUE;
+
+	p_eth_port_ctrl->port_rx_queue_command = 0;
+	p_eth_port_ctrl->port_tx_queue_command = 0;
+
+	p_eth_port_ctrl->rx_resource_err = false;
+	p_eth_port_ctrl->tx_resource_err = false;
+
+	eth_port_reset(p_eth_port_ctrl->port_num);
+
+	eth_port_init_mac_tables(p_eth_port_ctrl->port_num);
+
+	ethernet_phy_reset(p_eth_port_ctrl->port_num);
+}
+
+/*******************************************************************************
+* eth_port_start - Start the Ethernet port activity.
+*
+* DESCRIPTION:
+*       This routine prepares the Ethernet port for Rx and Tx activity:
+*       1. Initialize Tx and Rx Current Descriptor Pointer for each queue that
+*           has been initialized a descriptor's ring (using ether_init_tx_desc_ring 
+*           for Tx and ether_init_rx_desc_ring for Rx)
+*       2. Initialize and enable the Ethernet configuration port by writing to 
+*           the port's configuration and command registers.
+*       3. Initialize and enable the SDMA by writing to the SDMA's 
+*    configuration and command registers.
+*       After completing these steps, the ethernet port SDMA can starts to 
+*       perform Rx and Tx activities.
+*
+*       Note: Each Rx and Tx queue descriptor's list must be initialized prior  
+*       to calling this function (use ether_init_tx_desc_ring for Tx queues and 
+*       ether_init_rx_desc_ring for Rx queues).
+*
+* INPUT:
+*       ETH_PORT_INFO 	*p_eth_port_ctrl       Ethernet port control struct
+*
+* OUTPUT:
+*       Ethernet port is ready to receive and transmit.
+*
+* RETURN:
+*       false if the port PHY is not up.
+*       true otherwise.
+*
+*******************************************************************************/
+static bool eth_port_start(ETH_PORT_INFO * p_eth_port_ctrl)
+{
+	int tx_curr_desc;
+	int rx_curr_desc;
+	unsigned int phy_reg_data;
+	ETH_PORT eth_port_num = p_eth_port_ctrl->port_num;
+
+	/* Assignment of Tx CTRP of given queue */
+	tx_curr_desc = p_eth_port_ctrl->tx_curr_desc_q;
+	MV_WRITE(MV64340_ETH_TX_CURRENT_QUEUE_DESC_PTR_0(eth_port_num),
+		 (u32)&(p_eth_port_ctrl->p_tx_desc_area[tx_curr_desc]));
+
+	/* Assignment of Rx CRDP of given queue */
+	rx_curr_desc = p_eth_port_ctrl->rx_curr_desc_q;
+	MV_WRITE(MV64340_ETH_RX_CURRENT_QUEUE_DESC_PTR_0(eth_port_num),
+		 virt_to_bus(&(p_eth_port_ctrl->p_rx_desc_area[rx_curr_desc])));
+
+	/* Add the assigned Ethernet address to the port's address table */
+	eth_port_uc_addr_set(p_eth_port_ctrl->port_num,
+			     p_eth_port_ctrl->port_mac_addr);
+
+	/* Assign port configuration and command. */
+	MV_WRITE(MV64340_ETH_PORT_CONFIG_REG(eth_port_num),
+		 p_eth_port_ctrl->port_config);
+
+	MV_WRITE(MV64340_ETH_PORT_CONFIG_EXTEND_REG(eth_port_num),
+		 p_eth_port_ctrl->port_config_extend);
+
+	MV_WRITE(MV64340_ETH_PORT_SERIAL_CONTROL_REG(eth_port_num),
+		 p_eth_port_ctrl->port_serial_control);
+
+	MV_SET_REG_BITS(MV64340_ETH_PORT_SERIAL_CONTROL_REG(eth_port_num),
+			ETH_SERIAL_PORT_ENABLE);
+
+	/* Assign port SDMA configuration */
+	MV_WRITE(MV64340_ETH_SDMA_CONFIG_REG(eth_port_num),
+		 p_eth_port_ctrl->port_sdma_config);
+
+	/* Enable port Rx. */
+	MV_WRITE(MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG(eth_port_num),
+		 p_eth_port_ctrl->port_rx_queue_command);
+
+	/* Check if link is up */
+	eth_port_read_smi_reg(eth_port_num, 1, &phy_reg_data);
+
+	if (!(phy_reg_data & 0x20))
+		return false;
+
+	return true;
+}
+
+/*******************************************************************************
+* eth_port_uc_addr_set - This function Set the port Unicast address.
+*
+* DESCRIPTION:
+*		This function Set the port Ethernet MAC address.
+*
+* INPUT:
+*	ETH_PORT eth_port_num     Port number.
+*	char *        p_addr		Address to be set 
+*
+* OUTPUT:
+*	Set MAC address low and high registers. also calls eth_port_uc_addr() 
+*       To set the unicast table with the proper information.
+*
+* RETURN:
+*	N/A.
+*
+*******************************************************************************/
+static void eth_port_uc_addr_set(ETH_PORT eth_port_num,
+				 unsigned char *p_addr)
+{
+	unsigned int mac_h;
+	unsigned int mac_l;
+
+	mac_l = (p_addr[4] << 8) | (p_addr[5]);
+	mac_h = (p_addr[0] << 24) | (p_addr[1] << 16) |
+	    (p_addr[2] << 8) | (p_addr[3] << 0);
+
+	MV_WRITE(MV64340_ETH_MAC_ADDR_LOW(eth_port_num), mac_l);
+	MV_WRITE(MV64340_ETH_MAC_ADDR_HIGH(eth_port_num), mac_h);
+
+	/* Accept frames of this address */
+	eth_port_uc_addr(eth_port_num, p_addr[5], ACCEPT_MAC_ADDR);
+
+	return;
+}
+
+/*******************************************************************************
+* eth_port_uc_addr - This function Set the port unicast address table
+*
+* DESCRIPTION:
+*	This function locates the proper entry in the Unicast table for the 
+*	specified MAC nibble and sets its properties according to function 
+*	parameters.
+*
+* INPUT:
+*	ETH_PORT 	eth_port_num      Port number.
+*	unsigned char uc_nibble		Unicast MAC Address last nibble. 
+*	int 			option      0 = Add, 1 = remove address.
+*
+* OUTPUT:
+*	This function add/removes MAC addresses from the port unicast address
+*	table. 
+*
+* RETURN:
+*	true is output succeeded.
+*	false if option parameter is invalid.
+*
+*******************************************************************************/
+static bool eth_port_uc_addr(ETH_PORT eth_port_num,
+			     unsigned char uc_nibble, int option)
+{
+	unsigned int unicast_reg;
+	unsigned int tbl_offset;
+	unsigned int reg_offset;
+
+	/* Locate the Unicast table entry */
+	uc_nibble = (0xf & uc_nibble);
+	tbl_offset = (uc_nibble / 4) * 4;	/* Register offset from unicast table base */
+	reg_offset = uc_nibble % 4;	/* Entry offset within the above register */
+
+	switch (option) {
+	case REJECT_MAC_ADDR:
+		/* Clear accepts frame bit at specified unicast DA table entry */
+		unicast_reg =
+		    MV_READ_DATA(
+				 (MV64340_ETH_DA_FILTER_UNICAST_TABLE_BASE
+				  (eth_port_num) + tbl_offset));
+
+		unicast_reg &= (0x0E << (8 * reg_offset));
+
+		MV_WRITE(
+			 (MV64340_ETH_DA_FILTER_UNICAST_TABLE_BASE
+			  (eth_port_num) + tbl_offset), unicast_reg);
+		break;
+
+	case ACCEPT_MAC_ADDR:
+		/* Set accepts frame bit at unicast DA filter table entry */
+		unicast_reg =
+		    MV_READ_DATA(
+				 (MV64340_ETH_DA_FILTER_UNICAST_TABLE_BASE
+				  (eth_port_num) + tbl_offset));
+
+		unicast_reg |= (0x01 << (8 * reg_offset));
+
+		MV_WRITE(
+			 (MV64340_ETH_DA_FILTER_UNICAST_TABLE_BASE
+			  (eth_port_num) + tbl_offset), unicast_reg);
+
+		break;
+
+	default:
+		return false;
+	}
+	return true;
+}
+
+/*******************************************************************************
+* eth_port_init_mac_tables - Clear all entrance in the UC, SMC and OMC tables
+*
+* DESCRIPTION:
+*       Go through all the DA filter tables (Unicast, Special Multicast & Other 
+*       Multicast) and set each entry to 0.
+*
+* INPUT:
+*	ETH_PORT    eth_port_num   Ethernet Port number. See ETH_PORT enum. 
+*
+* OUTPUT:
+*       Multicast and Unicast packets are rejected.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+static void eth_port_init_mac_tables(ETH_PORT eth_port_num)
+{
+	int table_index;
+
+	/* Clear DA filter unicast table (Ex_dFUT) */
+	for (table_index = 0; table_index <= 0xC; table_index += 4)
+		MV_WRITE(
+			 (MV64340_ETH_DA_FILTER_UNICAST_TABLE_BASE
+			  (eth_port_num) + table_index), 0);
+
+	for (table_index = 0; table_index <= 0xFC; table_index += 4) {
+		/* Clear DA filter special multicast table (Ex_dFSMT) */
+		MV_WRITE(
+			 (MV64340_ETH_DA_FILTER_SPECIAL_MULTICAST_TABLE_BASE
+			  (eth_port_num) + table_index), 0);
+		/* Clear DA filter other multicast table (Ex_dFOMT) */
+		MV_WRITE((MV64340_ETH_DA_FILTER_OTHER_MULTICAST_TABLE_BASE
+			  (eth_port_num) + table_index), 0);
+	}
+}
+
+/*******************************************************************************
+* eth_clear_mib_counters - Clear all MIB counters
+*
+* DESCRIPTION:
+*       This function clears all MIB counters of a specific ethernet port.
+*       A read from the MIB counter will reset the counter.
+*
+* INPUT:
+*	ETH_PORT    eth_port_num   Ethernet Port number. See ETH_PORT enum. 
+*
+* OUTPUT:
+*       After reading all MIB counters, the counters resets.
+*
+* RETURN:
+*       MIB counter value.
+*
+*******************************************************************************/
+static void eth_clear_mib_counters(ETH_PORT eth_port_num)
+{
+	int i;
+	unsigned int dummy;
+
+	/* Perform dummy reads from MIB counters */
+	for (i = ETH_MIB_GOOD_OCTETS_RECEIVED_LOW;
+	     i < ETH_MIB_LATE_COLLISION; i += 4)
+		dummy =
+		    MV_READ_DATA(
+				 (MV64340_ETH_MIB_COUNTERS_BASE
+				  (eth_port_num) + i));
+
+	return;
+}
+
+
+#ifdef MDD_CUT
+/*******************************************************************************
+* ethernet_phy_set - Set the ethernet port PHY address.
+*
+* DESCRIPTION:
+*       This routine set the ethernet port PHY address according to given 
+*       parameter.
+*
+* INPUT:
+*		ETH_PORT   eth_port_num   Ethernet Port number. See ETH_PORT enum. 
+*
+* OUTPUT:
+*       Set PHY Address Register with given PHY address parameter.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+static void ethernet_phy_set(ETH_PORT eth_port_num, int phy_addr)
+{
+	unsigned int reg_data;
+
+	reg_data = MV_READ_DATA(MV64340_ETH_PHY_ADDR_REG);
+
+	reg_data &= ~(0x1F << (5 * eth_port_num));
+	reg_data |= (phy_addr << (5 * eth_port_num));
+
+	MV_WRITE(MV64340_ETH_PHY_ADDR_REG, reg_data);
+
+	return;
+}
+#endif
+
+/*******************************************************************************
+ * ethernet_phy_get - Get the ethernet port PHY address.
+ *
+ * DESCRIPTION:
+ *       This routine returns the given ethernet port PHY address.
+ *
+ * INPUT:
+ *		ETH_PORT   eth_port_num   Ethernet Port number. See ETH_PORT enum. 
+ *
+ * OUTPUT:
+ *       None.
+ *
+ * RETURN:
+ *       PHY address.
+ *
+ *******************************************************************************/
+static int ethernet_phy_get(ETH_PORT eth_port_num)
+{
+	unsigned int reg_data;
+
+	reg_data = MV_READ_DATA(MV64340_ETH_PHY_ADDR_REG);
+
+	return ((reg_data >> (5 * eth_port_num)) & 0x1f);
+}
+
+/*******************************************************************************
+ * ethernet_phy_reset - Reset Ethernet port PHY.
+ *
+ * DESCRIPTION:
+ *       This routine utilize the SMI interface to reset the ethernet port PHY.
+ *       The routine waits until the link is up again or link up is timeout.
+ *
+ * INPUT:
+ *	ETH_PORT   eth_port_num   Ethernet Port number. See ETH_PORT enum. 
+ *
+ * OUTPUT:
+ *       The ethernet port PHY renew its link.
+ *
+ * RETURN:
+ *       None.
+ *
+*******************************************************************************/
+static bool ethernet_phy_reset(ETH_PORT eth_port_num)
+{
+	unsigned int time_out = 50;
+	unsigned int phy_reg_data;
+
+	/* Reset the PHY */
+	eth_port_read_smi_reg(eth_port_num, 0, &phy_reg_data);
+	phy_reg_data |= 0x8000;	/* Set bit 15 to reset the PHY */
+	eth_port_write_smi_reg(eth_port_num, 0, phy_reg_data);
+
+	/* Poll on the PHY LINK */
+	do {
+		eth_port_read_smi_reg(eth_port_num, 1, &phy_reg_data);
+
+		if (time_out-- == 0)
+			return false;
+	}
+	while (!(phy_reg_data & 0x20));
+
+	return true;
+}
+
+/*******************************************************************************
+ * eth_port_reset - Reset Ethernet port
+ *
+ * DESCRIPTION:
+ * 	This routine resets the chip by aborting any SDMA engine activity and
+ *      clearing the MIB counters. The Receiver and the Transmit unit are in 
+ *      idle state after this command is performed and the port is disabled.
+ *
+ * INPUT:
+ *	ETH_PORT   eth_port_num   Ethernet Port number. See ETH_PORT enum. 
+ *
+ * OUTPUT:
+ *       Channel activity is halted.
+ *
+ * RETURN:
+ *       None.
+ *
+ *******************************************************************************/
+static void eth_port_reset(ETH_PORT eth_port_num)
+{
+	unsigned int reg_data;
+
+	/* Stop Tx port activity. Check port Tx activity. */
+	reg_data =
+	    MV_READ_DATA(MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG(eth_port_num));
+
+	if (reg_data & 0xFF) {
+		/* Issue stop command for active channels only */
+		MV_WRITE(MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG
+			 (eth_port_num), (reg_data << 8));
+
+		/* Wait for all Tx activity to terminate. */
+		do {
+			/* Check port cause register that all Tx queues are stopped */
+			reg_data =
+			    MV_READ_DATA
+			    (MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG
+			     (eth_port_num));
+		}
+		while (reg_data & 0xFF);
+	}
+
+	/* Stop Rx port activity. Check port Rx activity. */
+	reg_data =
+	    MV_READ_DATA(MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG
+			 (eth_port_num));
+
+	if (reg_data & 0xFF) {
+		/* Issue stop command for active channels only */
+		MV_WRITE(MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG
+			 (eth_port_num), (reg_data << 8));
+
+		/* Wait for all Rx activity to terminate. */
+		do {
+			/* Check port cause register that all Rx queues are stopped */
+			reg_data =
+			    MV_READ_DATA
+			    (MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG
+			     (eth_port_num));
+		}
+		while (reg_data & 0xFF);
+	}
+
+
+	/* Clear all MIB counters */
+	eth_clear_mib_counters(eth_port_num);
+
+	/* Reset the Enable bit in the Configuration Register */
+	reg_data =
+	    MV_READ_DATA(MV64340_ETH_PORT_SERIAL_CONTROL_REG (eth_port_num));
+	reg_data &= ~ETH_SERIAL_PORT_ENABLE;
+	MV_WRITE(MV64340_ETH_PORT_SERIAL_CONTROL_REG(eth_port_num), reg_data);
+
+	return;
+}
+
+/*******************************************************************************
+ * ethernet_set_config_reg - Set specified bits in configuration register.
+ *
+ * DESCRIPTION:
+ *       This function sets specified bits in the given ethernet 
+ *       configuration register. 
+ *
+ * INPUT:
+ *	ETH_PORT   eth_port_num   Ethernet Port number. See ETH_PORT enum. 
+ *      unsigned int    value   32 bit value.
+ *
+ * OUTPUT:
+ *      The set bits in the value parameter are set in the configuration 
+ *      register.
+ *
+ * RETURN:
+ *      None.
+ *
+ *******************************************************************************/
+static void ethernet_set_config_reg(ETH_PORT eth_port_num,
+				    unsigned int value)
+{
+	unsigned int eth_config_reg;
+
+	eth_config_reg =
+	    MV_READ_DATA(MV64340_ETH_PORT_CONFIG_REG(eth_port_num));
+	eth_config_reg |= value;
+	MV_WRITE(MV64340_ETH_PORT_CONFIG_REG(eth_port_num),
+		 eth_config_reg);
+
+	return;
+}
+
+/*******************************************************************************
+ * ethernet_get_config_reg - Get the port configuration register
+ *
+ * DESCRIPTION:
+ *       This function returns the configuration register value of the given 
+ *       ethernet port.
+ *
+ * INPUT:
+ *	ETH_PORT   eth_port_num   Ethernet Port number. See ETH_PORT enum. 
+ *
+ * OUTPUT:
+ *       None.
+ *
+ * RETURN:
+ *       Port configuration register value.
+ *
+ *******************************************************************************/
+static unsigned int ethernet_get_config_reg(ETH_PORT eth_port_num)
+{
+	unsigned int eth_config_reg;
+
+	eth_config_reg = MV_READ_DATA(MV64340_ETH_PORT_CONFIG_EXTEND_REG
+				      (eth_port_num));
+	return eth_config_reg;
+}
+
+
+/*******************************************************************************
+ * eth_port_read_smi_reg - Read PHY registers
+ *
+ * DESCRIPTION:
+ *       This routine utilize the SMI interface to interact with the PHY in 
+ *       order to perform PHY register read.
+ *
+ * INPUT:
+ *	ETH_PORT   eth_port_num   Ethernet Port number. See ETH_PORT enum. 
+ *       unsigned int   phy_reg   PHY register address offset.
+ *       unsigned int   *value   Register value buffer.
+ *
+ * OUTPUT:
+ *       Write the value of a specified PHY register into given buffer.
+ *
+ * RETURN:
+ *       false if the PHY is busy or read data is not in valid state.
+ *       true otherwise.
+ *
+ *******************************************************************************/
+static bool eth_port_read_smi_reg(ETH_PORT eth_port_num,
+				  unsigned int phy_reg,
+				  unsigned int *value)
+{
+	unsigned int reg_value;
+	unsigned int time_out = PHY_BUSY_TIMEOUT;
+	int phy_addr;
+
+	phy_addr = ethernet_phy_get(eth_port_num);
+
+	/* first check that it is not busy */
+	do {
+		reg_value = MV_READ_DATA(MV64340_ETH_SMI_REG);
+		if (time_out-- == 0) {
+			return false;
+		}
+	}
+	while (reg_value & ETH_SMI_BUSY);
+
+	/* not busy */
+
+	MV_WRITE(MV64340_ETH_SMI_REG,
+		 (phy_addr << 16) | (phy_reg << 21) | ETH_SMI_OPCODE_READ);
+
+	time_out = PHY_BUSY_TIMEOUT;	/* initialize the time out var again */
+
+	do {
+		reg_value = MV_READ_DATA(MV64340_ETH_SMI_REG);
+		if (time_out-- == 0) {
+			return false;
+		}
+	}
+	while (reg_value & ETH_SMI_READ_VALID);
+
+	/* Wait for the data to update in the SMI register */
+	for (time_out = 0; time_out < PHY_BUSY_TIMEOUT; time_out++);
+
+	reg_value = MV_READ_DATA(MV64340_ETH_SMI_REG);
+
+	*value = reg_value & 0xffff;
+
+	return true;
+}
+
+/*******************************************************************************
+ * eth_port_write_smi_reg - Write to PHY registers
+ *
+ * DESCRIPTION:
+ *       This routine utilize the SMI interface to interact with the PHY in 
+ *       order to perform writes to PHY registers.
+ *
+ * INPUT:
+ *	ETH_PORT   eth_port_num   Ethernet Port number. See ETH_PORT enum. 
+ *      unsigned int   phy_reg   PHY register address offset.
+ *      unsigned int    value   Register value.
+ *
+ * OUTPUT:
+ *      Write the given value to the specified PHY register.
+ *
+ * RETURN:
+ *      false if the PHY is busy.
+ *      true otherwise.
+ *
+ *******************************************************************************/
+static bool eth_port_write_smi_reg(ETH_PORT eth_port_num,
+				   unsigned int phy_reg,
+				   unsigned int value)
+{
+	unsigned int reg_value;
+	unsigned int time_out = PHY_BUSY_TIMEOUT;
+	int phy_addr;
+
+	phy_addr = ethernet_phy_get(eth_port_num);
+
+	/* first check that it is not busy */
+	do {
+		reg_value = MV_READ_DATA(MV64340_ETH_SMI_REG);
+		if (time_out-- == 0) {
+			return false;
+		}
+	}
+	while (reg_value & ETH_SMI_BUSY);
+
+	/* not busy */
+	MV_WRITE(MV64340_ETH_SMI_REG, (phy_addr << 16) | (phy_reg << 21) |
+		 ETH_SMI_OPCODE_WRITE | (value & 0xffff));
+	return true;
+}
+
+/*******************************************************************************
+ * ether_init_rx_desc_ring - Curve a Rx chain desc list and buffer in memory.
+ *
+ * DESCRIPTION:
+ *       This function prepares a Rx chained list of descriptors and packet 
+ *       buffers in a form of a ring. The routine must be called after port 
+ *       initialization routine and before port start routine. 
+ *       The Ethernet SDMA engine uses CPU bus addresses to access the various 
+ *       devices in the system (i.e. DRAM). This function uses the ethernet 
+ *       struct 'virtual to physical' routine (set by the user) to set the ring 
+ *       with physical addresses.
+ *
+ * INPUT:
+ *	ETH_PORT_INFO   *p_eth_port_ctrl   Ethernet Port Control srtuct. 
+ *      int 			rx_desc_num       Number of Rx descriptors
+ *      int 			rx_buff_size      Size of Rx buffer
+ *      unsigned int    rx_desc_base_addr  Rx descriptors memory area base addr.
+ *      unsigned int    rx_buff_base_addr  Rx buffer memory area base addr.
+ *
+ * OUTPUT:
+ *      The routine updates the Ethernet port control struct with information 
+ *      regarding the Rx descriptors and buffers.
+ *
+ * RETURN:
+ *      false if the given descriptors memory area is not aligned according to
+ *      Ethernet SDMA specifications.
+ *      true otherwise.
+ *
+ *******************************************************************************/
+static bool ether_init_rx_desc_ring(ETH_PORT_INFO * p_eth_port_ctrl,
+				    int rx_desc_num,
+				    int rx_buff_size,
+				    unsigned long rx_desc_base_addr,
+				    unsigned long rx_buff_base_addr)
+{
+	volatile ETH_RX_DESC* p_rx_desc;
+	unsigned long buffer_addr;
+	int ix;			/* a counter */
+
+	buffer_addr = rx_buff_base_addr;
+
+	p_rx_desc = (ETH_RX_DESC *) rx_desc_base_addr;
+
+	/* Rx desc Must be 4LW aligned (i.e. Descriptor_Address[3:0]=0000). */
+	if (rx_buff_base_addr & 0xF)
+		return false;
+
+	/* Rx buffers are limited to 64K bytes and Minimum size is 8 bytes  */
+	if ((rx_buff_size < 8) || (rx_buff_size > RX_BUFFER_MAX_SIZE))
+		return false;
+
+	/* Rx buffers must be 64-bit aligned.       */
+	if ((rx_buff_base_addr + rx_buff_size) & 0x7)
+		return false;
+
+	/* initialize the Rx descriptors ring */
+	for (ix = 0; ix < rx_desc_num; ix++) {
+		p_rx_desc[ix].buf_size = rx_buff_size;
+		p_rx_desc[ix].byte_cnt = 0x0000;
+		p_rx_desc[ix].cmd_sts =
+		    ETH_BUFFER_OWNED_BY_DMA | ETH_RX_ENABLE_INTERRUPT;
+		p_rx_desc[ix].next_desc_ptr = virt_to_bus(&(p_rx_desc[ix+1]));
+		p_rx_desc[ix].buf_ptr = buffer_addr;
+
+		dma_cache_wback_inv((unsigned long)p_rx_desc, sizeof(ETH_RX_DESC));
+		p_eth_port_ctrl->rx_skb[ix] = NULL;
+		buffer_addr += rx_buff_size;
+	}
+
+	/* Closing Rx descriptors ring */
+	p_rx_desc[rx_desc_num-1].next_desc_ptr = virt_to_bus(&(p_rx_desc[0]));
+	dma_cache_wback_inv((unsigned long)p_rx_desc, sizeof(ETH_RX_DESC));
+
+	/* Save Rx desc pointer to driver struct. */
+	p_eth_port_ctrl->rx_curr_desc_q = 0;
+	p_eth_port_ctrl->rx_used_desc_q = 0;
+
+	p_eth_port_ctrl->p_rx_desc_area = (ETH_RX_DESC *) rx_desc_base_addr;
+	p_eth_port_ctrl->rx_desc_area_size = rx_desc_num * sizeof(ETH_RX_DESC);
+
+	p_eth_port_ctrl->port_rx_queue_command |= 1;
+
+	return true;
+}
+
+/*******************************************************************************
+ * ether_init_tx_desc_ring - Curve a Tx chain desc list and buffer in memory.
+ *
+ * DESCRIPTION:
+ *       This function prepares a Tx chained list of descriptors and packet 
+ *       buffers in a form of a ring. The routine must be called after port 
+ *       initialization routine and before port start routine. 
+ *       The Ethernet SDMA engine uses CPU bus addresses to access the various 
+ *       devices in the system (i.e. DRAM). This function uses the ethernet 
+ *       struct 'virtual to physical' routine (set by the user) to set the ring 
+ *       with physical addresses.
+ *
+ * INPUT:
+ *	ETH_PORT_INFO   *p_eth_port_ctrl   Ethernet Port Control srtuct. 
+ *      int 		tx_desc_num        Number of Tx descriptors
+ *      int 		tx_buff_size	   Size of Tx buffer
+ *      unsigned int    tx_desc_base_addr  Tx descriptors memory area base addr.
+ *
+ * OUTPUT:
+ *      The routine updates the Ethernet port control struct with information 
+ *      regarding the Tx descriptors and buffers.
+ *
+ * RETURN:
+ *      false if the given descriptors memory area is not aligned according to
+ *      Ethernet SDMA specifications.
+ *      true otherwise.
+ *
+ *******************************************************************************/
+static bool ether_init_tx_desc_ring(ETH_PORT_INFO * p_eth_port_ctrl,
+				    int tx_desc_num,
+				    unsigned long tx_desc_base_addr)
+{
+
+	ETH_TX_DESC *p_tx_desc;
+	int ix;			/* a counter */
+
+	/* Tx desc Must be 4LW aligned (i.e. Descriptor_Address[3:0]=0000). */
+	if (tx_desc_base_addr & 0xF)
+		return false;
+
+	/* save the first desc pointer to link with the last descriptor */
+	p_tx_desc = (ETH_TX_DESC *) tx_desc_base_addr;
+
+	/* Initialize the Tx descriptors ring */
+	for (ix = 0; ix < tx_desc_num; ix++) {
+		p_tx_desc[ix].byte_cnt = 0x0000;
+		p_tx_desc[ix].l4i_chk = 0x0000;
+		p_tx_desc[ix].cmd_sts = 0x00000000;
+		p_tx_desc[ix].next_desc_ptr = (u32)&(p_tx_desc[ix+1]);
+		p_tx_desc[ix].buf_ptr = 0x00000000;
+		dma_cache_wback_inv((unsigned long)&(p_tx_desc[ix]), sizeof(ETH_TX_DESC));
+		p_eth_port_ctrl->tx_skb[ix] = NULL;
+	}
+
+	/* Closing Tx descriptors ring */
+	p_tx_desc[tx_desc_num-1].next_desc_ptr = (u32)&(p_tx_desc[0]);
+	dma_cache_wback_inv((unsigned long)&(p_tx_desc[tx_desc_num-1]),
+			sizeof(ETH_TX_DESC));
+
+	/* Set Tx desc pointer in driver struct. */
+	p_eth_port_ctrl->tx_curr_desc_q = 0;
+	p_eth_port_ctrl->tx_used_desc_q = 0;
+#ifdef MV64340_CHECKSUM_OFFLOAD_TX
+        p_eth_port_ctrl->tx_first_desc_q = 0;
+#endif
+	/* Init Tx ring base and size parameters */
+	p_eth_port_ctrl->p_tx_desc_area = (ETH_TX_DESC*) tx_desc_base_addr;
+	p_eth_port_ctrl->tx_desc_area_size = tx_desc_num * sizeof(ETH_TX_DESC);
+
+	/* Add the queue to the list of Tx queues of this port */
+	p_eth_port_ctrl->port_tx_queue_command |= 1;
+
+	return true;
+}
+
+/*******************************************************************************
+ * eth_port_send - Send an Ethernet packet
+ *
+ * DESCRIPTION:
+ *	This routine send a given packet described by p_pktinfo parameter. It 
+ *      supports transmitting of a packet spaned over multiple buffers. The 
+ *      routine updates 'curr' and 'first' indexes according to the packet 
+ *      segment passed to the routine. In case the packet segment is first, 
+ *      the 'first' index is update. In any case, the 'curr' index is updated. 
+ *      If the routine get into Tx resource error it assigns 'curr' index as 
+ *      'first'. This way the function can abort Tx process of multiple 
+ *      descriptors per packet.
+ *
+ * INPUT:
+ *	ETH_PORT_INFO   *p_eth_port_ctrl   Ethernet Port Control srtuct. 
+ *	PKT_INFO        *p_pkt_info       User packet buffer.
+ *
+ * OUTPUT:
+ *	Tx ring 'curr' and 'first' indexes are updated. 
+ *
+ * RETURN:
+ *      ETH_QUEUE_FULL in case of Tx resource error.
+ *	ETH_ERROR in case the routine can not access Tx desc ring.
+ *	ETH_QUEUE_LAST_RESOURCE if the routine uses the last Tx resource.
+ *      ETH_OK otherwise.
+ *
+ *******************************************************************************/
+#ifdef  MV64340_CHECKSUM_OFFLOAD_TX
+/*
+ * Modified to include the first descriptor pointer in case of SG
+ */
+static ETH_FUNC_RET_STATUS eth_port_send(ETH_PORT_INFO * p_eth_port_ctrl,
+                                         PKT_INFO * p_pkt_info)
+{
+        int tx_desc_curr, tx_desc_used, tx_first_desc, tx_next_desc;
+        volatile ETH_TX_DESC* current_descriptor;
+        volatile ETH_TX_DESC* first_descriptor;
+        u32 command_status, first_chip_ptr;
+
+        /* Do not process Tx ring in case of Tx ring resource error */
+        if (p_eth_port_ctrl->tx_resource_err == true)
+                return ETH_QUEUE_FULL;
+
+        /* Get the Tx Desc ring indexes */
+        tx_desc_curr = p_eth_port_ctrl->tx_curr_desc_q;
+        tx_desc_used = p_eth_port_ctrl->tx_used_desc_q;
+
+        current_descriptor = &(p_eth_port_ctrl->p_tx_desc_area[tx_desc_curr]);
+        if (current_descriptor == NULL)
+                return ETH_ERROR;
+
+        tx_next_desc = (tx_desc_curr + 1) % MV64340_TX_QUEUE_SIZE;
+        command_status = p_pkt_info->cmd_sts | ETH_ZERO_PADDING | ETH_GEN_CRC;
+
+        if (command_status & ETH_TX_FIRST_DESC) {
+                tx_first_desc = tx_desc_curr;
+                p_eth_port_ctrl->tx_first_desc_q = tx_first_desc;
+
+                /* fill first descriptor */
+                first_descriptor = &(p_eth_port_ctrl->p_tx_desc_area[tx_desc_curr]);
+                first_descriptor->l4i_chk = p_pkt_info->l4i_chk;
+                first_descriptor->cmd_sts = command_status;
+                first_descriptor->byte_cnt = p_pkt_info->byte_cnt;
+                first_descriptor->buf_ptr = p_pkt_info->buf_ptr;
+                first_descriptor->next_desc_ptr = (u32)&(p_eth_port_ctrl->p_tx_desc_area[tx_next_desc]);
+                dma_cache_wback_inv((u32)first_descriptor, sizeof(ETH_TX_DESC));
+                wmb();
+        }
+        else {
+                tx_first_desc = p_eth_port_ctrl->tx_first_desc_q;
+                first_descriptor = &(p_eth_port_ctrl->p_tx_desc_area[tx_first_desc]);
+                if (first_descriptor == NULL) {
+                        printk("First desc is NULL !!\n");
+                        return ETH_ERROR;
+                }
+                if (command_status & ETH_TX_LAST_DESC)
+                        current_descriptor->next_desc_ptr = 0x00000000;
+                else {
+                        command_status |= ETH_BUFFER_OWNED_BY_DMA;
+                        current_descriptor->next_desc_ptr = (u32)&(p_eth_port_ctrl->p_tx_desc_area[tx_next_desc]);
+                }
+        }
+
+        if (p_pkt_info->byte_cnt < 8) {
+                printk(" < 8 problem \n");
+                return ETH_ERROR;
+        }
+
+        current_descriptor->buf_ptr = p_pkt_info->buf_ptr;
+        current_descriptor->byte_cnt = p_pkt_info->byte_cnt;
+        current_descriptor->l4i_chk = p_pkt_info->l4i_chk;
+        current_descriptor->cmd_sts = command_status;
+        dma_cache_wback_inv((u32)current_descriptor, sizeof(ETH_TX_DESC));
+
+        p_eth_port_ctrl->tx_skb[tx_desc_curr] =
+                (struct sk_buff*)p_pkt_info->return_info;
+
+        dma_cache_wback_inv((u32)p_eth_port_ctrl, sizeof(ETH_PORT_INFO));
+        wmb();
+
+        /* Set last desc with DMA ownership and interrupt enable. */
+        if (command_status & ETH_TX_LAST_DESC) {
+                current_descriptor->cmd_sts = command_status |
+                                        ETH_TX_ENABLE_INTERRUPT |
+                                        ETH_BUFFER_OWNED_BY_DMA;
+
+                if (!(command_status & ETH_TX_FIRST_DESC) ) {
+                        first_descriptor->cmd_sts |= ETH_BUFFER_OWNED_BY_DMA;
+                        dma_cache_wback_inv((u32)first_descriptor, sizeof(ETH_TX_DESC));
+                }
+                dma_cache_wback_inv((u32)current_descriptor, sizeof(ETH_TX_DESC));
+                wmb();
+
+                first_chip_ptr = MV_READ_DATA(MV64340_ETH_CURRENT_SERVED_TX_DESC_PTR(p_eth_port_ctrl->port_num));
+
+                /* Apply send command */
+                if (first_chip_ptr == 0x00000000) {
+                        MV_WRITE(MV64340_ETH_TX_CURRENT_QUEUE_DESC_PTR_0(p_eth_port_ctrl->port_num), (u32)&(p_eth_port_ctrl->p_tx_desc_area[tx_first_desc]));
+                }
+
+                ETH_ENABLE_TX_QUEUE(p_eth_port_ctrl->port_num);
+
+           /* Finish Tx packet. Update first desc in case of Tx resource error */
+                tx_first_desc = tx_next_desc;
+                p_eth_port_ctrl->tx_first_desc_q = tx_first_desc;
+        }
+        else {
+                if (! (command_status & ETH_TX_FIRST_DESC) ) {
+                        current_descriptor->cmd_sts = command_status;
+                        dma_cache_wback_inv((u32)current_descriptor,
+                                                        sizeof(ETH_TX_DESC));
+                        wmb();
+                }
+        }
+
+        /* Check for ring index overlap in the Tx desc ring */
+        if (tx_next_desc == tx_desc_used) {
+                p_eth_port_ctrl->tx_resource_err = true;
+                p_eth_port_ctrl->tx_curr_desc_q = tx_first_desc;
+                return ETH_QUEUE_LAST_RESOURCE;
+        }
+
+        p_eth_port_ctrl->tx_curr_desc_q = tx_next_desc;
+        dma_cache_wback_inv((u32) p_eth_port_ctrl, sizeof(ETH_PORT_INFO));
+        wmb();
+        return ETH_OK;
+}
+#else
+static ETH_FUNC_RET_STATUS eth_port_send(ETH_PORT_INFO * p_eth_port_ctrl,
+					 PKT_INFO * p_pkt_info)
+{
+	int tx_desc_curr;
+	int tx_desc_used;
+	volatile ETH_TX_DESC* current_descriptor;
+	unsigned int command_status;
+
+	/* Do not process Tx ring in case of Tx ring resource error */
+	if (p_eth_port_ctrl->tx_resource_err == true)
+		return ETH_QUEUE_FULL;
+
+	/* Get the Tx Desc ring indexes */
+	tx_desc_curr = p_eth_port_ctrl->tx_curr_desc_q;
+	tx_desc_used = p_eth_port_ctrl->tx_used_desc_q;
+	current_descriptor = &(p_eth_port_ctrl->p_tx_desc_area[tx_desc_curr]);
+
+	if (current_descriptor == NULL)
+		return ETH_ERROR;
+
+	command_status = p_pkt_info->cmd_sts | ETH_ZERO_PADDING | ETH_GEN_CRC;
+
+/* XXX Is this for real ?!?!? */
+	/* Buffers with a payload smaller than 8 bytes must be aligned to a
+	 * 64-bit boundary. We use the memory allocated for Tx descriptor.
+	 * This memory is located in TX_BUF_OFFSET_IN_DESC offset within the
+	 * Tx descriptor. */
+	if (p_pkt_info->byte_cnt <= 8) {
+		printk(KERN_ERR
+		       "You have failed in the < 8 bytes errata - fixme\n");
+		return ETH_ERROR;
+	}
+	current_descriptor->buf_ptr = p_pkt_info->buf_ptr;
+	current_descriptor->byte_cnt = p_pkt_info->byte_cnt;
+	p_eth_port_ctrl->tx_skb[tx_desc_curr] =
+		(struct sk_buff*)p_pkt_info->return_info;
+
+	mb();
+
+	/* Set last desc with DMA ownership and interrupt enable. */
+	current_descriptor->cmd_sts = command_status |
+	    ETH_BUFFER_OWNED_BY_DMA | ETH_TX_ENABLE_INTERRUPT;
+
+#if 0
+	/* Flush CPU pipe */
+	dma_cache_wback_inv(current_descriptor, sizeof(ETH_TX_DESC));
+	mb();
+#endif
+
+	/* Apply send command */
+	ETH_ENABLE_TX_QUEUE(p_eth_port_ctrl->port_num);
+
+	/* Finish Tx packet. Update first desc in case of Tx resource error */
+	tx_desc_curr = (tx_desc_curr + 1) % MV64340_TX_QUEUE_SIZE;
+
+	/* Update the current descriptor */
+ 	p_eth_port_ctrl->tx_curr_desc_q = tx_desc_curr;
+
+	/* Check for ring index overlap in the Tx desc ring */
+	if (tx_desc_curr == tx_desc_used) {
+		p_eth_port_ctrl->tx_resource_err = true;
+		return ETH_QUEUE_LAST_RESOURCE;
+	}
+
+	return ETH_OK;
+}
+#endif
+
+/*******************************************************************************
+ * eth_tx_return_desc - Free all used Tx descriptors
+ *
+ * DESCRIPTION:
+ *	This routine returns the transmitted packet information to the caller.
+ *      It uses the 'first' index to support Tx desc return in case a transmit 
+ *      of a packet spanned over multiple buffer still in process.
+ *      In case the Tx queue was in "resource error" condition, where there are 
+ *      no available Tx resources, the function resets the resource error flag.
+ *
+ * INPUT:
+ *	ETH_PORT_INFO   *p_eth_port_ctrl   Ethernet Port Control srtuct. 
+ *	PKT_INFO        *p_pkt_info       User packet buffer.
+ *
+ * OUTPUT:
+ *	Tx ring 'first' and 'used' indexes are updated. 
+ *
+ * RETURN:
+ *	ETH_ERROR in case the routine can not access Tx desc ring.
+ *      ETH_RETRY in case there is transmission in process.
+ *	ETH_END_OF_JOB if the routine has nothing to release.
+ *      ETH_OK otherwise.
+ *
+ *******************************************************************************/
+static ETH_FUNC_RET_STATUS eth_tx_return_desc(ETH_PORT_INFO * p_eth_port_ctrl,
+					      PKT_INFO * p_pkt_info)
+{
+	int tx_desc_used, tx_desc_curr;
+#ifdef MV64340_CHECKSUM_OFFLOAD_TX
+        int tx_first_desc;
+#endif
+	volatile ETH_TX_DESC *p_tx_desc_used;
+	unsigned int command_status;
+
+	/* Get the Tx Desc ring indexes */
+	tx_desc_curr = p_eth_port_ctrl->tx_curr_desc_q;
+	tx_desc_used = p_eth_port_ctrl->tx_used_desc_q;
+#ifdef MV64340_CHECKSUM_OFFLOAD_TX
+        tx_first_desc = p_eth_port_ctrl->tx_first_desc_q;
+#endif
+	p_tx_desc_used = &(p_eth_port_ctrl->p_tx_desc_area[tx_desc_used]);
+
+	/* XXX Sanity check */
+	if (p_tx_desc_used == NULL)
+		return ETH_ERROR;
+
+	command_status = p_tx_desc_used->cmd_sts;
+
+	/* Still transmitting... */
+#ifndef MV64340_CHECKSUM_OFFLOAD_TX
+	if (command_status & (ETH_BUFFER_OWNED_BY_DMA)) {
+	  dma_cache_wback_inv((unsigned long)p_tx_desc_used,
+				    sizeof(ETH_TX_DESC));
+		return ETH_RETRY;
+	}
+#endif
+	/* Stop release. About to overlap the current available Tx descriptor */
+#ifdef MV64340_CHECKSUM_OFFLOAD_TX
+	if ((tx_desc_used == tx_first_desc) &&
+#else
+	if ((tx_desc_used == tx_desc_curr) &&
+#endif
+	    (p_eth_port_ctrl->tx_resource_err == false)) {
+	    dma_cache_wback_inv((unsigned long)p_tx_desc_used,
+				    sizeof(ETH_TX_DESC));
+		return ETH_END_OF_JOB;
+	}
+
+	/* Pass the packet information to the caller */
+	p_pkt_info->cmd_sts = command_status;
+	p_pkt_info->return_info = p_eth_port_ctrl->tx_skb[tx_desc_used];
+	p_eth_port_ctrl->tx_skb[tx_desc_used] = NULL;
+
+	/* Update the next descriptor to release. */
+	p_eth_port_ctrl->tx_used_desc_q =
+		(tx_desc_used + 1) % MV64340_TX_QUEUE_SIZE;
+
+	/* Any Tx return cancels the Tx resource error status */
+	if (p_eth_port_ctrl->tx_resource_err == true)
+		p_eth_port_ctrl->tx_resource_err = false;
+
+	dma_cache_wback_inv((unsigned long)p_tx_desc_used, sizeof(ETH_TX_DESC));
+
+	return ETH_OK;
+}
+
+/*******************************************************************************
+ * eth_port_receive - Get received information from Rx ring.
+ *
+ * DESCRIPTION:
+ * 	This routine returns the received data to the caller. There is no 
+ *	data copying during routine operation. All information is returned 
+ *	using pointer to packet information struct passed from the caller. 
+ *      If the routine exhausts	Rx ring resources then the resource error flag 
+ *      is set.  
+ *
+ * INPUT:
+ *	ETH_PORT_INFO   *p_eth_port_ctrl   Ethernet Port Control srtuct. 
+ *	PKT_INFO        *p_pkt_info       User packet buffer.
+ *
+ * OUTPUT:
+ *	Rx ring current and used indexes are updated. 
+ *
+ * RETURN:
+ *	ETH_ERROR in case the routine can not access Rx desc ring.
+ *	ETH_QUEUE_FULL if Rx ring resources are exhausted.
+ *	ETH_END_OF_JOB if there is no received data.
+ *      ETH_OK otherwise.
+ *
+ *******************************************************************************/
+static ETH_FUNC_RET_STATUS eth_port_receive(ETH_PORT_INFO *
+					    p_eth_port_ctrl,
+					    PKT_INFO * p_pkt_info)
+{
+	int rx_curr_desc;
+	int rx_next_curr_desc;
+	int rx_used_desc;
+	unsigned int command_status;
+	volatile ETH_RX_DESC*	p_rx_desc;
+
+	/* Do not process Rx ring in case of Rx ring resource error */
+	if (p_eth_port_ctrl->rx_resource_err == true)
+		return ETH_QUEUE_FULL;
+
+	/* Get the Rx Desc ring 'curr and 'used' indexes */
+	rx_curr_desc = p_eth_port_ctrl->rx_curr_desc_q;
+	rx_used_desc = p_eth_port_ctrl->rx_used_desc_q;
+
+	p_rx_desc = &(p_eth_port_ctrl->p_rx_desc_area[rx_curr_desc]);
+
+	/* The following parameters are used to save readings from memory */
+	command_status = p_rx_desc->cmd_sts;
+
+	/* Nothing to receive... */
+	if (command_status & (ETH_BUFFER_OWNED_BY_DMA)) {
+		dma_cache_wback_inv((unsigned long)p_rx_desc, sizeof(ETH_RX_DESC));
+		return ETH_END_OF_JOB;
+	}
+
+	p_pkt_info->byte_cnt = (p_rx_desc->byte_cnt) - RX_BUF_OFFSET;
+	p_pkt_info->cmd_sts = command_status;
+	p_pkt_info->buf_ptr = (p_rx_desc->buf_ptr) + RX_BUF_OFFSET;
+	p_pkt_info->return_info = p_eth_port_ctrl->rx_skb[rx_curr_desc];
+	p_pkt_info->l4i_chk = p_rx_desc->buf_size;
+
+	/* Clean the return info field to indicate that the packet has been */
+	/* moved to the upper layers                                        */
+	p_eth_port_ctrl->rx_skb[rx_curr_desc] = NULL;
+
+	/* Update current index in data structure */
+	rx_next_curr_desc = (rx_curr_desc + 1) % MV64340_RX_QUEUE_SIZE;
+	p_eth_port_ctrl->rx_curr_desc_q = rx_next_curr_desc;
+
+	/* Rx descriptors exhausted. Set the Rx ring resource error flag */
+	if (rx_next_curr_desc == rx_used_desc)
+		p_eth_port_ctrl->rx_resource_err = true;
+
+	dma_cache_wback_inv((unsigned long)p_rx_desc, sizeof(ETH_RX_DESC));
+	mb();
+	return ETH_OK;
+}
+
+/*******************************************************************************
+ * eth_rx_return_buff - Returns a Rx buffer back to the Rx ring.
+ *
+ * DESCRIPTION:
+ *	This routine returns a Rx buffer back to the Rx ring. It retrieves the 
+ *      next 'used' descriptor and attached the returned buffer to it.
+ *      In case the Rx ring was in "resource error" condition, where there are 
+ *      no available Rx resources, the function resets the resource error flag.
+ *
+ * INPUT:
+ *	ETH_PORT_INFO   *p_eth_port_ctrl   Ethernet Port Control srtuct. 
+ *      PKT_INFO        *p_pkt_info       Information on the returned buffer.
+ *
+ * OUTPUT:
+ *	New available Rx resource in Rx descriptor ring.
+ *
+ * RETURN:
+ *	ETH_ERROR in case the routine can not access Rx desc ring.
+ *      ETH_OK otherwise.
+ *
+ *******************************************************************************/
+static ETH_FUNC_RET_STATUS eth_rx_return_buff(ETH_PORT_INFO * p_eth_port_ctrl,
+					      PKT_INFO * p_pkt_info)
+{
+	int used_rx_desc;	/* Where to return Rx resource */
+	volatile ETH_RX_DESC* p_used_rx_desc;
+
+	/* Get 'used' Rx descriptor */
+	used_rx_desc = p_eth_port_ctrl->rx_used_desc_q;
+	p_used_rx_desc = &(p_eth_port_ctrl->p_rx_desc_area[used_rx_desc]);
+
+	p_used_rx_desc->buf_ptr = p_pkt_info->buf_ptr;
+	p_used_rx_desc->buf_size = p_pkt_info->byte_cnt;
+	p_eth_port_ctrl->rx_skb[used_rx_desc] = p_pkt_info->return_info;
+
+	/* Flush the write pipe */
+	mb();
+
+	/* Return the descriptor to DMA ownership */
+	p_used_rx_desc->cmd_sts =
+	    ETH_BUFFER_OWNED_BY_DMA | ETH_RX_ENABLE_INTERRUPT;
+
+	/* Flush descriptor and CPU pipe */
+	dma_cache_wback_inv((unsigned long)p_used_rx_desc, sizeof(ETH_RX_DESC));
+	mb();
+
+	/* Move the used descriptor pointer to the next descriptor */
+	p_eth_port_ctrl->rx_used_desc_q =
+		(used_rx_desc + 1) % MV64340_RX_QUEUE_SIZE;
+
+	/* Any Rx return cancels the Rx resource error status */
+	if (p_eth_port_ctrl->rx_resource_err == true)
+		p_eth_port_ctrl->rx_resource_err = false;
+
+	return ETH_OK;
+}
+
+/*******************************************************************************
+ * eth_port_set_rx_coal - Sets coalescing interrupt mechanism on RX path
+ *
+ * DESCRIPTION:
+ *	This routine sets the RX coalescing interrupt mechanism parameter.
+ *	This parameter is a timeout counter, that counts in 64 t_clk
+ *	chunks ; that when timeout event occurs a maskable interrupt
+ *	occurs.
+ *	The parameter is calculated using the tClk of the MV-643xx chip
+ *	, and the required delay of the interrupt in usec.
+ *
+ * INPUT:
+ *	ETH_PORT eth_port_num      Ethernet port number
+ *	unsigned int t_clk        t_clk of the MV-643xx chip in HZ units
+ *	unsigned int delay       Delay in usec
+ *
+ * OUTPUT:
+ *	Interrupt coalescing mechanism value is set in MV-643xx chip.
+ *
+ * RETURN:
+ *	The interrupt coalescing value set in the gigE port.
+ *
+ *******************************************************************************/
+static unsigned int eth_port_set_rx_coal(ETH_PORT eth_port_num,
+					 unsigned int t_clk,
+					 unsigned int delay)
+{
+	unsigned int coal;
+	coal = ((t_clk / 1000000) * delay) / 64;
+	/* Set RX Coalescing mechanism */
+	MV_WRITE(MV64340_ETH_SDMA_CONFIG_REG(eth_port_num),
+		 ((coal & 0x3fff) << 8) |
+		 (MV_READ_DATA(MV64340_ETH_SDMA_CONFIG_REG(eth_port_num))
+		  & 0xffc000ff));
+	return coal;
+}
+
+/*******************************************************************************
+ * eth_port_set_tx_coal - Sets coalescing interrupt mechanism on TX path
+ *
+ * DESCRIPTION:
+ *	This routine sets the TX coalescing interrupt mechanism parameter.
+ *	This parameter is a timeout counter, that counts in 64 t_clk
+ *	chunks ; that when timeout event occurs a maskable interrupt
+ *	occurs.
+ *	The parameter is calculated using the t_cLK frequency of the 
+ *	MV-643xx chip and the required delay in the interrupt in uSec
+ *
+ * INPUT:
+ *	ETH_PORT eth_port_num      Ethernet port number
+ *	unsigned int t_clk        t_clk of the MV-643xx chip in HZ units
+ *	unsigned int delay       Delay in uSeconds
+ *
+ * OUTPUT:
+ *	Interrupt coalescing mechanism value is set in MV-643xx chip.
+ *
+ * RETURN:
+ *	The interrupt coalescing value set in the gigE port.
+ *
+ *******************************************************************************/
+static unsigned int eth_port_set_tx_coal(ETH_PORT eth_port_num,
+					 unsigned int t_clk,
+					 unsigned int delay)
+{
+	unsigned int coal;
+	coal = ((t_clk / 1000000) * delay) / 64;
+	/* Set TX Coalescing mechanism */
+	MV_WRITE(MV64340_ETH_TX_FIFO_URGENT_THRESHOLD_REG(eth_port_num),
+		 coal << 4);
+	return coal;
+}
+
+#ifdef MDD_CUT
+/*******************************************************************************
+ * eth_b_copy - Copy bytes from source to destination
+ *
+ * DESCRIPTION:
+ *       This function supports the eight bytes limitation on Tx buffer size. 
+ *       The routine will zero eight bytes starting from the destination address
+ *       followed by copying bytes from the source address to the destination.
+ *
+ * INPUT:
+ *       unsigned int src_addr    32 bit source address.
+ *       unsigned int dst_addr    32 bit destination address.
+ *       int        byte_count    Number of bytes to copy.
+ *
+ * OUTPUT:
+ *       See description.
+ *
+ * RETURN:
+ *       None.
+ *
+ *******************************************************************************/
+static void eth_b_copy(unsigned int src_addr, unsigned int dst_addr,
+		       int byte_count)
+{
+	/* Zero the dst_addr area */
+	*(unsigned int *) dst_addr = 0x0;
+
+	while (byte_count != 0) {
+		*(char *) dst_addr = *(char *) src_addr;
+		dst_addr++;
+		src_addr++;
+		byte_count--;
+	}
+}
+#endif
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/mv64340_eth.h linux-2.4.22/drivers/net/mv64340_eth.h
--- linux-2.4.22.clean/drivers/net/mv64340_eth.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/net/mv64340_eth.h	2003-09-09 01:00:28.000000000 +0200
@@ -0,0 +1,635 @@
+#ifndef __MV64340_ETH_H__
+#define __MV64340_ETH_H__
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/spinlock.h>
+
+#include <asm/mv64340.h>
+
+#define	BIT0	0x00000001
+#define	BIT1	0x00000002
+#define	BIT2	0x00000004
+#define	BIT3	0x00000008
+#define	BIT4	0x00000010
+#define	BIT5	0x00000020
+#define	BIT6	0x00000040
+#define	BIT7	0x00000080
+#define	BIT8	0x00000100
+#define	BIT9	0x00000200
+#define	BIT10	0x00000400
+#define	BIT11	0x00000800
+#define	BIT12	0x00001000
+#define	BIT13	0x00002000
+#define	BIT14	0x00004000
+#define	BIT15	0x00008000
+#define	BIT16	0x00010000
+#define	BIT17	0x00020000
+#define	BIT18	0x00040000
+#define	BIT19	0x00080000
+#define	BIT20	0x00100000
+#define	BIT21	0x00200000
+#define	BIT22	0x00400000
+#define	BIT23	0x00800000
+#define	BIT24	0x01000000
+#define	BIT25	0x02000000
+#define	BIT26	0x04000000
+#define	BIT27	0x08000000
+#define	BIT28	0x10000000
+#define	BIT29	0x20000000
+#define	BIT30	0x40000000
+#define	BIT31	0x80000000
+
+/*************************************************************************
+**************************************************************************
+**************************************************************************
+*  The first part is the high level driver of the gigE ethernet ports.   *
+**************************************************************************
+**************************************************************************
+*************************************************************************/
+
+#define ETH_PORT0_IRQ_NUM 48			/* main high register, bit0 */
+#define ETH_PORT1_IRQ_NUM ETH_PORT0_IRQ_NUM+1	/* main high register, bit1 */
+#define ETH_PORT2_IRQ_NUM ETH_PORT0_IRQ_NUM+2	/* main high register, bit1 */
+
+/* Checksum offload for Tx is broken */
+#define  MV64340_CHECKSUM_OFFLOAD_TX	1
+#define  MV64340_NIC_SRAM_BASE_TX       0xfe000000
+#define	 MV64340_NAPI	1
+
+/* 
+ * Number of RX / TX descriptors on RX / TX rings.
+ * Note that allocating RX descriptors is done by allocating the RX
+ * ring AND a preallocated RX buffers (skb's) for each descriptor.
+ * The TX descriptors only allocates the TX descriptors ring,
+ * with no pre allocated TX buffers (skb's are allocated by higher layers.
+ */
+
+/* Default TX ring size is 1000 descriptors */
+#define MV64340_TX_QUEUE_SIZE 1000
+
+/* Default RX ring size is 400 descriptors */
+#define MV64340_RX_QUEUE_SIZE 400
+
+#define MV64340_TX_COAL 100
+#define MV64340_RX_COAL 100
+
+/* Private data structure used for ethernet device */
+struct mv64340_eth_priv {
+	unsigned int port_num;
+	struct net_device_stats stats;
+	spinlock_t lock;
+	/* Size of Tx Ring per queue */
+	unsigned int tx_ring_size;
+	/* Ammont of SKBs outstanding on Tx queue */
+	unsigned int tx_ring_skbs;
+	/* Size of Rx Ring per queue */
+	unsigned int rx_ring_size;
+	/* Ammount of SKBs allocated to Rx Ring per queue */
+	unsigned int rx_ring_skbs;
+
+	/*
+	 * rx_task used to fill RX ring out of bottom half context 
+	 */
+	struct tq_struct rx_task;
+
+	/* 
+	 * Used in case RX Ring is empty, which can be caused when 
+	 * system does not have resources (skb's) 
+	 */
+	struct timer_list timeout;
+	long rx_task_busy __attribute__ ((aligned(SMP_CACHE_BYTES)));
+	unsigned rx_timer_flag;
+
+	u32 rx_int_coal;
+	u32 tx_int_coal;
+};
+
+
+/*************************************************************************
+**************************************************************************
+**************************************************************************
+*  The second part is the low level driver of the gigE ethernet ports.   *
+**************************************************************************
+**************************************************************************
+*************************************************************************/
+
+
+/********************************************************************************
+ * Header File for : MV-643xx network interface header 
+ *
+ * DESCRIPTION:
+ *       This header file contains macros typedefs and function declaration for
+ *       the Marvell Gig Bit Ethernet Controller. 
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ *******************************************************************************/
+
+typedef enum _bool { false, true } bool;
+
+/* defines  */
+
+/* Default port configuration value */
+#define PORT_CONFIG_VALUE                       \
+             ETH_UNICAST_NORMAL_MODE		|   \
+             ETH_DEFAULT_RX_QUEUE_0		|   \
+             ETH_DEFAULT_RX_ARP_QUEUE_0		|   \
+             ETH_RECEIVE_BC_IF_NOT_IP_OR_ARP	|   \
+             ETH_RECEIVE_BC_IF_IP		|   \
+             ETH_RECEIVE_BC_IF_ARP 		|   \
+             ETH_CAPTURE_TCP_FRAMES_DIS		|   \
+             ETH_CAPTURE_UDP_FRAMES_DIS		|   \
+             ETH_DEFAULT_RX_TCP_QUEUE_0		|   \
+             ETH_DEFAULT_RX_UDP_QUEUE_0		|   \
+             ETH_DEFAULT_RX_BPDU_QUEUE_0
+
+/* Default port extend configuration value */
+#define PORT_CONFIG_EXTEND_VALUE		\
+             ETH_SPAN_BPDU_PACKETS_AS_NORMAL	|   \
+             ETH_PARTITION_DISABLE
+
+
+/* Default sdma control value */
+#define PORT_SDMA_CONFIG_VALUE			\
+			 ETH_RX_BURST_SIZE_16_64BIT 	|	\
+			 GT_ETH_IPG_INT_RX(0) 		|	\
+			 ETH_TX_BURST_SIZE_16_64BIT;
+
+#define GT_ETH_IPG_INT_RX(value)                \
+            ((value & 0x3fff) << 8)
+
+/* Default port serial control value */
+#define PORT_SERIAL_CONTROL_VALUE		\
+			ETH_FORCE_LINK_PASS 			|	\
+			ETH_ENABLE_AUTO_NEG_FOR_DUPLX		|	\
+			ETH_DISABLE_AUTO_NEG_FOR_FLOW_CTRL 	|	\
+			ETH_ADV_SYMMETRIC_FLOW_CTRL 		|	\
+			ETH_FORCE_FC_MODE_NO_PAUSE_DIS_TX 	|	\
+			ETH_FORCE_BP_MODE_NO_JAM 		|	\
+			BIT9 					|	\
+			ETH_DO_NOT_FORCE_LINK_FAIL 		|	\
+			ETH_RETRANSMIT_16_ATTEMPTS 		|	\
+			ETH_ENABLE_AUTO_NEG_SPEED_GMII	 	|	\
+			ETH_DTE_ADV_0 				|	\
+			ETH_DISABLE_AUTO_NEG_BYPASS		|	\
+			ETH_AUTO_NEG_NO_CHANGE 			|	\
+			ETH_MAX_RX_PACKET_9700BYTE 		|	\
+			ETH_CLR_EXT_LOOPBACK 			|	\
+			ETH_SET_FULL_DUPLEX_MODE 		|	\
+			ETH_ENABLE_FLOW_CTRL_TX_RX_IN_FULL_DUPLEX
+
+#define RX_BUFFER_MAX_SIZE  0x4000000
+#define TX_BUFFER_MAX_SIZE  0x4000000
+
+/* MAC accepet/reject macros */
+#define ACCEPT_MAC_ADDR	    0
+#define REJECT_MAC_ADDR	    1
+
+/* Buffer offset from buffer pointer */
+#define RX_BUF_OFFSET				0x2
+
+/* Gigabit Ethernet Unit Global Registers */
+
+/* MIB Counters register definitions */
+#define ETH_MIB_GOOD_OCTETS_RECEIVED_LOW   0x0
+#define ETH_MIB_GOOD_OCTETS_RECEIVED_HIGH  0x4
+#define ETH_MIB_BAD_OCTETS_RECEIVED        0x8
+#define ETH_MIB_INTERNAL_MAC_TRANSMIT_ERR  0xc
+#define ETH_MIB_GOOD_FRAMES_RECEIVED       0x10
+#define ETH_MIB_BAD_FRAMES_RECEIVED        0x14
+#define ETH_MIB_BROADCAST_FRAMES_RECEIVED  0x18
+#define ETH_MIB_MULTICAST_FRAMES_RECEIVED  0x1c
+#define ETH_MIB_FRAMES_64_OCTETS           0x20
+#define ETH_MIB_FRAMES_65_TO_127_OCTETS    0x24
+#define ETH_MIB_FRAMES_128_TO_255_OCTETS   0x28
+#define ETH_MIB_FRAMES_256_TO_511_OCTETS   0x2c
+#define ETH_MIB_FRAMES_512_TO_1023_OCTETS  0x30
+#define ETH_MIB_FRAMES_1024_TO_MAX_OCTETS  0x34
+#define ETH_MIB_GOOD_OCTETS_SENT_LOW       0x38
+#define ETH_MIB_GOOD_OCTETS_SENT_HIGH      0x3c
+#define ETH_MIB_GOOD_FRAMES_SENT           0x40
+#define ETH_MIB_EXCESSIVE_COLLISION        0x44
+#define ETH_MIB_MULTICAST_FRAMES_SENT      0x48
+#define ETH_MIB_BROADCAST_FRAMES_SENT      0x4c
+#define ETH_MIB_UNREC_MAC_CONTROL_RECEIVED 0x50
+#define ETH_MIB_FC_SENT                    0x54
+#define ETH_MIB_GOOD_FC_RECEIVED           0x58
+#define ETH_MIB_BAD_FC_RECEIVED            0x5c
+#define ETH_MIB_UNDERSIZE_RECEIVED         0x60
+#define ETH_MIB_FRAGMENTS_RECEIVED         0x64
+#define ETH_MIB_OVERSIZE_RECEIVED          0x68
+#define ETH_MIB_JABBER_RECEIVED            0x6c
+#define ETH_MIB_MAC_RECEIVE_ERROR          0x70
+#define ETH_MIB_BAD_CRC_EVENT              0x74
+#define ETH_MIB_COLLISION                  0x78
+#define ETH_MIB_LATE_COLLISION             0x7c
+
+/* Port serial status reg (PSR) */
+#define ETH_INTERFACE_GMII_MII                          0
+#define ETH_INTERFACE_PCM                               BIT0
+#define ETH_LINK_IS_DOWN                                0
+#define ETH_LINK_IS_UP                                  BIT1
+#define ETH_PORT_AT_HALF_DUPLEX                         0
+#define ETH_PORT_AT_FULL_DUPLEX                         BIT2
+#define ETH_RX_FLOW_CTRL_DISABLED                       0
+#define ETH_RX_FLOW_CTRL_ENBALED                        BIT3
+#define ETH_GMII_SPEED_100_10                           0
+#define ETH_GMII_SPEED_1000                             BIT4
+#define ETH_MII_SPEED_10                                0
+#define ETH_MII_SPEED_100                               BIT5
+#define ETH_NO_TX                                       0
+#define ETH_TX_IN_PROGRESS                              BIT7
+#define ETH_BYPASS_NO_ACTIVE                            0
+#define ETH_BYPASS_ACTIVE                               BIT8
+#define ETH_PORT_NOT_AT_PARTITION_STATE                 0
+#define ETH_PORT_AT_PARTITION_STATE                     BIT9
+#define ETH_PORT_TX_FIFO_NOT_EMPTY                      0
+#define ETH_PORT_TX_FIFO_EMPTY                          BIT10
+
+
+/* These macros describes the Port configuration reg (Px_cR) bits */
+#define ETH_UNICAST_NORMAL_MODE                         0
+#define ETH_UNICAST_PROMISCUOUS_MODE                    BIT0
+#define ETH_DEFAULT_RX_QUEUE_0                          0
+#define ETH_DEFAULT_RX_QUEUE_1                          BIT1
+#define ETH_DEFAULT_RX_QUEUE_2                          BIT2
+#define ETH_DEFAULT_RX_QUEUE_3                          (BIT2 | BIT1)
+#define ETH_DEFAULT_RX_QUEUE_4                          BIT3
+#define ETH_DEFAULT_RX_QUEUE_5                          (BIT3 | BIT1)
+#define ETH_DEFAULT_RX_QUEUE_6                          (BIT3 | BIT2)
+#define ETH_DEFAULT_RX_QUEUE_7                          (BIT3 | BIT2 | BIT1)
+#define ETH_DEFAULT_RX_ARP_QUEUE_0                      0
+#define ETH_DEFAULT_RX_ARP_QUEUE_1                      BIT4
+#define ETH_DEFAULT_RX_ARP_QUEUE_2                      BIT5
+#define ETH_DEFAULT_RX_ARP_QUEUE_3                      (BIT5 | BIT4)
+#define ETH_DEFAULT_RX_ARP_QUEUE_4                      BIT6
+#define ETH_DEFAULT_RX_ARP_QUEUE_5                      (BIT6 | BIT4)
+#define ETH_DEFAULT_RX_ARP_QUEUE_6                      (BIT6 | BIT5)
+#define ETH_DEFAULT_RX_ARP_QUEUE_7                      (BIT6 | BIT5 | BIT4)
+#define ETH_RECEIVE_BC_IF_NOT_IP_OR_ARP                 0
+#define ETH_REJECT_BC_IF_NOT_IP_OR_ARP                  BIT7
+#define ETH_RECEIVE_BC_IF_IP                            0
+#define ETH_REJECT_BC_IF_IP                             BIT8
+#define ETH_RECEIVE_BC_IF_ARP                           0
+#define ETH_REJECT_BC_IF_ARP                            BIT9
+#define ETH_TX_AM_NO_UPDATE_ERROR_SUMMARY               BIT12
+#define ETH_CAPTURE_TCP_FRAMES_DIS                      0
+#define ETH_CAPTURE_TCP_FRAMES_EN                       BIT14
+#define ETH_CAPTURE_UDP_FRAMES_DIS                      0
+#define ETH_CAPTURE_UDP_FRAMES_EN                       BIT15
+#define ETH_DEFAULT_RX_TCP_QUEUE_0                      0
+#define ETH_DEFAULT_RX_TCP_QUEUE_1                      BIT16
+#define ETH_DEFAULT_RX_TCP_QUEUE_2                      BIT17
+#define ETH_DEFAULT_RX_TCP_QUEUE_3                      (BIT17 | BIT16)
+#define ETH_DEFAULT_RX_TCP_QUEUE_4                      BIT18
+#define ETH_DEFAULT_RX_TCP_QUEUE_5                      (BIT18 | BIT16)
+#define ETH_DEFAULT_RX_TCP_QUEUE_6                      (BIT18 | BIT17)
+#define ETH_DEFAULT_RX_TCP_QUEUE_7                      (BIT18 | BIT17 | BIT16)
+#define ETH_DEFAULT_RX_UDP_QUEUE_0                      0
+#define ETH_DEFAULT_RX_UDP_QUEUE_1                      BIT19
+#define ETH_DEFAULT_RX_UDP_QUEUE_2                      BIT20
+#define ETH_DEFAULT_RX_UDP_QUEUE_3                      (BIT20 | BIT19)
+#define ETH_DEFAULT_RX_UDP_QUEUE_4                      (BIT21
+#define ETH_DEFAULT_RX_UDP_QUEUE_5                      (BIT21 | BIT19)
+#define ETH_DEFAULT_RX_UDP_QUEUE_6                      (BIT21 | BIT20)
+#define ETH_DEFAULT_RX_UDP_QUEUE_7                      (BIT21 | BIT20 | BIT19)
+#define ETH_DEFAULT_RX_BPDU_QUEUE_0                      0
+#define ETH_DEFAULT_RX_BPDU_QUEUE_1                     BIT22
+#define ETH_DEFAULT_RX_BPDU_QUEUE_2                     BIT23
+#define ETH_DEFAULT_RX_BPDU_QUEUE_3                     (BIT23 | BIT22)
+#define ETH_DEFAULT_RX_BPDU_QUEUE_4                     BIT24
+#define ETH_DEFAULT_RX_BPDU_QUEUE_5                     (BIT24 | BIT22)
+#define ETH_DEFAULT_RX_BPDU_QUEUE_6                     (BIT24 | BIT23)
+#define ETH_DEFAULT_RX_BPDU_QUEUE_7                     (BIT24 | BIT23 | BIT22)
+
+
+/* These macros describes the Port configuration extend reg (Px_cXR) bits*/
+#define ETH_CLASSIFY_EN                                 BIT0
+#define ETH_SPAN_BPDU_PACKETS_AS_NORMAL                 0
+#define ETH_SPAN_BPDU_PACKETS_TO_RX_QUEUE_7             BIT1
+#define ETH_PARTITION_DISABLE                           0
+#define ETH_PARTITION_ENABLE                            BIT2
+
+
+/* Tx/Rx queue command reg (RQCR/TQCR)*/
+#define ETH_QUEUE_0_ENABLE                              BIT0
+#define ETH_QUEUE_1_ENABLE                              BIT1
+#define ETH_QUEUE_2_ENABLE                              BIT2
+#define ETH_QUEUE_3_ENABLE                              BIT3
+#define ETH_QUEUE_4_ENABLE                              BIT4
+#define ETH_QUEUE_5_ENABLE                              BIT5
+#define ETH_QUEUE_6_ENABLE                              BIT6
+#define ETH_QUEUE_7_ENABLE                              BIT7
+#define ETH_QUEUE_0_DISABLE                             BIT8
+#define ETH_QUEUE_1_DISABLE                             BIT9
+#define ETH_QUEUE_2_DISABLE                             BIT10
+#define ETH_QUEUE_3_DISABLE                             BIT11
+#define ETH_QUEUE_4_DISABLE                             BIT12
+#define ETH_QUEUE_5_DISABLE                             BIT13
+#define ETH_QUEUE_6_DISABLE                             BIT14
+#define ETH_QUEUE_7_DISABLE                             BIT15
+
+
+/* These macros describes the Port Sdma configuration reg (SDCR) bits */
+#define ETH_RIFB                                        BIT0
+#define ETH_RX_BURST_SIZE_1_64BIT                       0
+#define ETH_RX_BURST_SIZE_2_64BIT                       BIT1
+#define ETH_RX_BURST_SIZE_4_64BIT                       BIT2
+#define ETH_RX_BURST_SIZE_8_64BIT                       (BIT2 | BIT1)
+#define ETH_RX_BURST_SIZE_16_64BIT                      BIT3
+#define ETH_BLM_RX_NO_SWAP                              BIT4
+#define ETH_BLM_RX_BYTE_SWAP                            0
+#define ETH_BLM_TX_NO_SWAP                              BIT5
+#define ETH_BLM_TX_BYTE_SWAP                            0
+#define ETH_DESCRIPTORS_BYTE_SWAP                       BIT6
+#define ETH_DESCRIPTORS_NO_SWAP                         0
+#define ETH_TX_BURST_SIZE_1_64BIT                       0
+#define ETH_TX_BURST_SIZE_2_64BIT                       BIT22
+#define ETH_TX_BURST_SIZE_4_64BIT                       BIT23
+#define ETH_TX_BURST_SIZE_8_64BIT                       (BIT23 | BIT22)
+#define ETH_TX_BURST_SIZE_16_64BIT                      BIT24
+
+
+
+/* These macros describes the Port serial control reg (PSCR) bits */
+#define ETH_SERIAL_PORT_DISABLE                         0
+#define ETH_SERIAL_PORT_ENABLE                          BIT0
+#define ETH_FORCE_LINK_PASS                             BIT1
+#define ETH_DO_NOT_FORCE_LINK_PASS                      0
+#define ETH_ENABLE_AUTO_NEG_FOR_DUPLX                   0
+#define ETH_DISABLE_AUTO_NEG_FOR_DUPLX                  BIT2
+#define ETH_ENABLE_AUTO_NEG_FOR_FLOW_CTRL               0
+#define ETH_DISABLE_AUTO_NEG_FOR_FLOW_CTRL              BIT3
+#define ETH_ADV_NO_FLOW_CTRL                            0
+#define ETH_ADV_SYMMETRIC_FLOW_CTRL                     BIT4
+#define ETH_FORCE_FC_MODE_NO_PAUSE_DIS_TX               0
+#define ETH_FORCE_FC_MODE_TX_PAUSE_DIS                  BIT5
+#define ETH_FORCE_BP_MODE_NO_JAM                        0
+#define ETH_FORCE_BP_MODE_JAM_TX                        BIT7
+#define ETH_FORCE_BP_MODE_JAM_TX_ON_RX_ERR              BIT8
+#define ETH_FORCE_LINK_FAIL                             0
+#define ETH_DO_NOT_FORCE_LINK_FAIL                      BIT10
+#define ETH_RETRANSMIT_16_ATTEMPTS                      0
+#define ETH_RETRANSMIT_FOREVER                          BIT11
+#define ETH_DISABLE_AUTO_NEG_SPEED_GMII                 BIT13
+#define ETH_ENABLE_AUTO_NEG_SPEED_GMII                  0
+#define ETH_DTE_ADV_0                                   0
+#define ETH_DTE_ADV_1                                   BIT14
+#define ETH_DISABLE_AUTO_NEG_BYPASS                     0
+#define ETH_ENABLE_AUTO_NEG_BYPASS                      BIT15
+#define ETH_AUTO_NEG_NO_CHANGE                          0
+#define ETH_RESTART_AUTO_NEG                            BIT16
+#define ETH_MAX_RX_PACKET_1518BYTE                      0
+#define ETH_MAX_RX_PACKET_1522BYTE                      BIT17
+#define ETH_MAX_RX_PACKET_1552BYTE                      BIT18
+#define ETH_MAX_RX_PACKET_9022BYTE                      (BIT18 | BIT17)
+#define ETH_MAX_RX_PACKET_9192BYTE                      BIT19
+#define ETH_MAX_RX_PACKET_9700BYTE                      (BIT19 | BIT17)
+#define ETH_SET_EXT_LOOPBACK                            BIT20
+#define ETH_CLR_EXT_LOOPBACK                            0
+#define ETH_SET_FULL_DUPLEX_MODE                        BIT21
+#define ETH_SET_HALF_DUPLEX_MODE                        0
+#define ETH_ENABLE_FLOW_CTRL_TX_RX_IN_FULL_DUPLEX       BIT22
+#define ETH_DISABLE_FLOW_CTRL_TX_RX_IN_FULL_DUPLEX      0
+#define ETH_SET_GMII_SPEED_TO_10_100                    0
+#define ETH_SET_GMII_SPEED_TO_1000                      BIT23
+#define ETH_SET_MII_SPEED_TO_10                         0
+#define ETH_SET_MII_SPEED_TO_100                        BIT24
+
+
+/* SMI reg */
+#define ETH_SMI_BUSY        	BIT28	/* 0 - Write, 1 - Read          */
+#define ETH_SMI_READ_VALID  	BIT27	/* 0 - Write, 1 - Read          */
+#define ETH_SMI_OPCODE_WRITE	0	/* Completion of Read operation */
+#define ETH_SMI_OPCODE_READ 	BIT26	/* Operation is in progress             */
+
+/* SDMA command status fields macros */
+
+/* Tx & Rx descriptors status */
+#define ETH_ERROR_SUMMARY                   (BIT0)
+
+/* Tx & Rx descriptors command */
+#define ETH_BUFFER_OWNED_BY_DMA             (BIT31)
+
+/* Tx descriptors status */
+#define ETH_LC_ERROR                        (0	  )
+#define ETH_UR_ERROR                        (BIT1 )
+#define ETH_RL_ERROR                        (BIT2 )
+#define ETH_LLC_SNAP_FORMAT                 (BIT9 )
+
+/* Rx descriptors status */
+#define ETH_CRC_ERROR                       (0	  )
+#define ETH_OVERRUN_ERROR                   (BIT1 )
+#define ETH_MAX_FRAME_LENGTH_ERROR          (BIT2 )
+#define ETH_RESOURCE_ERROR                  ((BIT2 | BIT1))
+#define ETH_VLAN_TAGGED                     (BIT19)
+#define ETH_BPDU_FRAME                      (BIT20)
+#define ETH_TCP_FRAME_OVER_IP_V_4           (0    )
+#define ETH_UDP_FRAME_OVER_IP_V_4           (BIT21)
+#define ETH_OTHER_FRAME_TYPE                (BIT22)
+#define ETH_LAYER_2_IS_ETH_V_2              (BIT23)
+#define ETH_FRAME_TYPE_IP_V_4               (BIT24)
+#define ETH_FRAME_HEADER_OK                 (BIT25)
+#define ETH_RX_LAST_DESC                    (BIT26)
+#define ETH_RX_FIRST_DESC                   (BIT27)
+#define ETH_UNKNOWN_DESTINATION_ADDR        (BIT28)
+#define ETH_RX_ENABLE_INTERRUPT             (BIT29)
+#define ETH_LAYER_4_CHECKSUM_OK             (BIT30)
+
+/* Rx descriptors byte count */
+#define ETH_FRAME_FRAGMENTED                (BIT2)
+
+/* Tx descriptors command */
+#define ETH_LAYER_4_CHECKSUM_FIRST_DESC		(BIT10)
+#define ETH_FRAME_SET_TO_VLAN               (BIT15)
+#define ETH_TCP_FRAME                       (0	  )
+#define ETH_UDP_FRAME                       (BIT16)
+#define ETH_GEN_TCP_UDP_CHECKSUM            (BIT17)
+#define ETH_GEN_IP_V_4_CHECKSUM             (BIT18)
+#define ETH_ZERO_PADDING                    (BIT19)
+#define ETH_TX_LAST_DESC                    (BIT20)
+#define ETH_TX_FIRST_DESC                   (BIT21)
+#define ETH_GEN_CRC                         (BIT22)
+#define ETH_TX_ENABLE_INTERRUPT             (BIT23)
+#define ETH_AUTO_MODE                       (BIT30)
+
+/* typedefs */
+
+typedef enum _eth_port {
+	ETH_0 = 0,
+	ETH_1 = 1,
+	ETH_2 = 2
+} ETH_PORT;
+
+typedef enum _eth_func_ret_status {
+	ETH_OK,			/* Returned as expected.                    */
+	ETH_ERROR,		/* Fundamental error.                       */
+	ETH_RETRY,		/* Could not process request. Try later.    */
+	ETH_END_OF_JOB,		/* Ring has nothing to process.             */
+	ETH_QUEUE_FULL,		/* Ring resource error.                     */
+	ETH_QUEUE_LAST_RESOURCE	/* Ring resources about to exhaust.         */
+} ETH_FUNC_RET_STATUS;
+
+typedef enum _eth_target {
+	ETH_TARGET_DRAM,
+	ETH_TARGET_DEVICE,
+	ETH_TARGET_CBS,
+	ETH_TARGET_PCI0,
+	ETH_TARGET_PCI1
+} ETH_TARGET;
+
+/* These are for big-endian machines.  Little endian needs different
+ * definitions.
+ */
+#if defined(__BIG_ENDIAN)
+typedef struct _eth_rx_desc {
+	u16	byte_cnt;	/* Descriptor buffer byte count     */
+	u16	buf_size;	/* Buffer size                      */
+	u32	cmd_sts;	/* Descriptor command status        */
+	u32	next_desc_ptr;	/* Next descriptor pointer          */
+	u32	buf_ptr;	/* Descriptor buffer pointer        */
+} ETH_RX_DESC;
+
+typedef struct _eth_tx_desc {
+	u16	byte_cnt;	/* buffer byte count */
+	u16	l4i_chk;	/* CPU provided TCP checksum */
+	u32	cmd_sts;	/* Command/status field */
+	u32	next_desc_ptr;	/* Pointer to next descriptor */
+	u32	buf_ptr;	/* pointer to buffer for this descriptor */
+} ETH_TX_DESC;
+
+#elif defined(__LITTLE_ENDIAN)
+typedef struct _eth_rx_desc {
+	u32	cmd_sts;	/* Descriptor command status        */
+	u16	buf_size;	/* Buffer size                      */
+	u16	byte_cnt;	/* Descriptor buffer byte count     */
+	u32	buf_ptr;	/* Descriptor buffer pointer        */
+	u32	next_desc_ptr;	/* Next descriptor pointer          */
+} ETH_RX_DESC;
+
+typedef struct _eth_tx_desc {
+	u32	cmd_sts;	/* Command/status field */
+	u16	l4i_chk;	/* CPU provided TCP checksum */
+	u16	byte_cnt;	/* buffer byte count */
+	u32	buf_ptr;	/* pointer to buffer for this descriptor */
+	u32	next_desc_ptr;	/* Pointer to next descriptor */
+} ETH_TX_DESC;
+#else
+#error One of __BIG_ENDIAN or __LITTLE_ENDIAN must be defined
+#endif
+
+/* Unified struct for Rx and Tx operations. The user is not required to */
+/* be familier with neither Tx nor Rx descriptors.                       */
+typedef struct _pkt_info {
+	unsigned short byte_cnt;	/* Descriptor buffer byte count     */
+	unsigned short l4i_chk;	/* Tx CPU provided TCP Checksum     */
+	unsigned int cmd_sts;	/* Descriptor command status        */
+	unsigned int buf_ptr;	/* Descriptor buffer pointer        */
+	struct sk_buff* return_info;	/* User resource return information */
+} PKT_INFO;
+
+
+/* Ethernet port specific infomation */
+
+typedef struct _eth_port_ctrl {
+	ETH_PORT port_num;		/* User Ethernet port number */
+	u8	port_mac_addr[6];	/* User defined port MAC address. */
+	u32	port_config;		/* User port configuration value */
+	u32	port_config_extend;	/* User port config extend value */
+	u32	port_sdma_config;	/* User port SDMA config value */
+	u32	port_serial_control;	/* User port serial control value */
+	u32	port_tx_queue_command;	/* Port active Tx queues summary */
+	u32	port_rx_queue_command;	/* Port active Rx queues summary */
+
+	/* User scratch pad for user specific data structures */
+	void*	port_private;
+
+	bool	rx_resource_err;	/* Rx ring resource error flag */
+	bool	tx_resource_err;	/* Tx ring resource error flag */
+
+	/* Tx/Rx rings managment indexes fields. For driver use */
+
+	/* Next available and first returning Rx resource */
+	int rx_curr_desc_q, rx_used_desc_q;
+
+	/* Next available and first returning Tx resource */
+	int tx_curr_desc_q, tx_used_desc_q;
+#ifdef MV64340_CHECKSUM_OFFLOAD_TX
+        int tx_first_desc_q;
+#endif
+	/* Tx/Rx rings size and base variables fields. For driver use */
+	volatile ETH_RX_DESC *p_rx_desc_area;
+	unsigned int rx_desc_area_size;
+	struct sk_buff* rx_skb[MV64340_RX_QUEUE_SIZE];
+
+	volatile ETH_TX_DESC *p_tx_desc_area;
+	unsigned int tx_desc_area_size;
+	struct sk_buff* tx_skb[MV64340_TX_QUEUE_SIZE];
+	struct tq_struct tx_timeout_task;
+} ETH_PORT_INFO;
+
+
+/* ethernet.h API list */
+
+/* Port operation control routines */
+static void eth_port_init(ETH_PORT_INFO * p_eth_port_ctrl);
+static void eth_port_reset(ETH_PORT eth_port_num);
+static bool eth_port_start(ETH_PORT_INFO * p_eth_port_ctrl);
+
+static void ethernet_set_config_reg(ETH_PORT eth_port_num,
+				    unsigned int value);
+static unsigned int ethernet_get_config_reg(ETH_PORT eth_port_num);
+
+/* Interrupt Coalesting functions */
+static unsigned int eth_port_set_rx_coal(ETH_PORT, unsigned int,
+					 unsigned int);
+static unsigned int eth_port_set_tx_coal(ETH_PORT, unsigned int,
+					 unsigned int);
+
+/* Port MAC address routines */
+static void eth_port_uc_addr_set(ETH_PORT eth_port_num,
+				 unsigned char *p_addr);
+
+/* PHY and MIB routines */
+static bool ethernet_phy_reset(ETH_PORT eth_port_num);
+
+static bool eth_port_write_smi_reg(ETH_PORT eth_port_num,
+				   unsigned int phy_reg,
+				   unsigned int value);
+
+static bool eth_port_read_smi_reg(ETH_PORT eth_port_num,
+				  unsigned int phy_reg,
+				  unsigned int *value);
+
+static void eth_clear_mib_counters(ETH_PORT eth_port_num);
+
+/* Port data flow control routines */
+static ETH_FUNC_RET_STATUS eth_port_send(ETH_PORT_INFO * p_eth_port_ctrl,
+					 PKT_INFO * p_pkt_info);
+static ETH_FUNC_RET_STATUS eth_tx_return_desc(ETH_PORT_INFO *
+					      p_eth_port_ctrl,
+					      PKT_INFO * p_pkt_info);
+static ETH_FUNC_RET_STATUS eth_port_receive(ETH_PORT_INFO *
+					    p_eth_port_ctrl,
+					    PKT_INFO * p_pkt_info);
+static ETH_FUNC_RET_STATUS eth_rx_return_buff(ETH_PORT_INFO *
+					      p_eth_port_ctrl,
+					      PKT_INFO * p_pkt_info);
+
+
+static bool ether_init_tx_desc_ring(ETH_PORT_INFO * p_eth_port_ctrl,
+				    int tx_desc_num,
+				    unsigned long tx_desc_base_addr);
+
+static bool ether_init_rx_desc_ring(ETH_PORT_INFO * p_eth_port_ctrl,
+				    int rx_desc_num,
+				    int rx_buff_size,
+				    unsigned long rx_desc_base_addr,
+				    unsigned long rx_buff_base_addr);
+
+#endif				/* MV64340_ETH_ */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/pcnet32.c linux-2.4.22/drivers/net/pcnet32.c
--- linux-2.4.22.clean/drivers/net/pcnet32.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/net/pcnet32.c	2003-09-27 14:08:05.000000000 +0200
@@ -752,8 +752,12 @@
     if (irq_line) {
 	dev->irq = irq_line;
     }
-    
+
+#ifdef CONFIG_LASAT
+    if (dev->irq >= 0)
+#else
     if (dev->irq >= 2)
+#endif
 	printk(" assigned IRQ %d.\n", dev->irq);
     else {
 	unsigned long irq_mask = probe_irq_on();
@@ -808,7 +812,10 @@
     u16 val;
     int i;
 
-    if (dev->irq == 0 ||
+    if (
+#ifndef CONFIG_LASAT
+	dev->irq == 0 ||
+#endif
 	request_irq(dev->irq, &pcnet32_interrupt,
 		    lp->shared_irq ? SA_SHIRQ : 0, lp->name, (void *)dev)) {
 	return -EAGAIN;
@@ -1345,6 +1352,10 @@
 		if (!rx_in_place) {
 		    skb_reserve(skb,2); /* 16 byte align */
 		    skb_put(skb,pkt_len);	/* Make room */
+                    pci_dma_sync_single(lp->pci_dev, 
+				    lp->rx_dma_addr[entry],
+				    pkt_len,
+				    PCI_DMA_FROMDEVICE);
 		    eth_copy_and_sum(skb,
 				     (unsigned char *)(lp->rx_skbuff[entry]->tail),
 				     pkt_len,0);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/sb1250-mac.c linux-2.4.22/drivers/net/sb1250-mac.c
--- linux-2.4.22.clean/drivers/net/sb1250-mac.c	2002-11-29 00:53:14.000000000 +0100
+++ linux-2.4.22/drivers/net/sb1250-mac.c	2003-07-08 01:48:07.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2001 Broadcom Corporation
+ * Copyright (C) 2001,2002,2003 Broadcom Corporation
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -17,10 +17,10 @@
  */
 
 /*
-  This driver is designed for the Broadcom BCM12500 SOC chip's built-in
+  This driver is designed for the Broadcom SiByte SOC built-in
   Ethernet controllers.
   
-  The author may be reached as mpl@broadcom.com
+  Written by Mitch Lichtenberg at Broadcom Corp.
 */
 
 
@@ -31,6 +31,7 @@
    These may be modified when a driver module is loaded. */
 
 static int debug = 1;			/* 1 normal messages, 0 quiet .. 7 verbose. */
+static int noisy_mii = 1;		/* mii status msgs */
 
 /* Used to pass the media type, etc.
    Both 'options[]' and 'full_duplex[]' should exist for driver
@@ -44,8 +45,10 @@
 static int full_duplex[MAX_UNITS] = {-1, -1, -1};
 #endif
 
+#ifdef CONFIG_SBMAC_COALESCE
 static int int_pktcnt = 0;
 static int int_timeout = 0;
+#endif
 
 /* Operational parameters that usually are not changed. */
 
@@ -74,8 +77,7 @@
 #include <asm/processor.h>		/* Processor type for cache alignment. */
 #include <asm/bitops.h>
 #include <asm/io.h>
-#include <asm/sibyte/sb1250.h>
-#include <asm/sibyte/64bit.h>
+#include <asm/cache.h>
 
 /* This is only here until the firmware is ready.  In that case,
    the firmware leaves the ethernet address in the register for us. */
@@ -89,26 +91,29 @@
 /* These identify the driver base version and may not be removed. */
 #if 0
 static char version1[] __devinitdata =
-"sb1250-mac.c:1.00 1/11/2001 Written by Mitch Lichtenberg (mpl@broadcom.com)\n";
+"sb1250-mac.c:1.00 1/11/2001 Written by Mitch Lichtenberg\n";
 #endif
 
 
 
-MODULE_AUTHOR("Mitch Lichtenberg (mpl@broadcom.com)");
-MODULE_DESCRIPTION("Broadcom BCM12500 SOC GB Ethernet driver");
+MODULE_AUTHOR("Mitch Lichtenberg (Broadcom Corp.)");
+MODULE_DESCRIPTION("Broadcom SiByte SOC GB Ethernet driver");
 MODULE_PARM(debug, "i");
+MODULE_PARM(noisy_mii, "i");
 MODULE_PARM(options, "1-" __MODULE_STRING(MAX_UNITS) "i");
 MODULE_PARM(full_duplex, "1-" __MODULE_STRING(MAX_UNITS) "i");
 
 MODULE_PARM(int_pktcnt, "i");
 MODULE_PARM(int_timeout, "i");
 
+#include <asm/sibyte/sb1250.h>
 #include <asm/sibyte/sb1250_defs.h>
 #include <asm/sibyte/sb1250_regs.h>
 #include <asm/sibyte/sb1250_mac.h>
 #include <asm/sibyte/sb1250_dma.h>
 #include <asm/sibyte/sb1250_int.h>
-#include <asm/sibyte/sb1250_scd.h>		/* Only to check SOC part number. */
+#include <asm/sibyte/sb1250_scd.h>
+#include <asm/sibyte/64bit.h>
 
 
 /**********************************************************************
@@ -117,8 +122,6 @@
 
 
 typedef unsigned long sbmac_port_t;
-typedef uint64_t sbmac_physaddr_t;
-typedef uint64_t sbmac_enetaddr_t;
 
 typedef enum { sbmac_speed_auto, sbmac_speed_10,
 	       sbmac_speed_100, sbmac_speed_1000 } sbmac_speed_t;
@@ -142,17 +145,11 @@
 			  (d)->sbdma_dscrtable : (d)->f+1)
 
 
-#define CACHELINESIZE 32
-#define NUMCACHEBLKS(x) (((x)+CACHELINESIZE-1)/CACHELINESIZE)
-#define KMALLOC(x) kmalloc((x),GFP_KERNEL)
-#define KFREE(x) kfree(x)
-#define KVTOPHYS(x) virt_to_bus((void *)(x))
+#define NUMCACHEBLKS(x) (((x)+SMP_CACHE_BYTES-1)/SMP_CACHE_BYTES)
 
+#define SBMAC_READCSR(t)	in64((unsigned long)t)
+#define SBMAC_WRITECSR(t,v)	out64(v, (unsigned long)t)
  
-#define SBMAC_READCSR(t)    (in64((unsigned long)(t)))
-#define SBMAC_WRITECSR(t,v) (out64(v, (unsigned long)(t)))
-
-#define PKSEG1(x) ((sbmac_port_t) KSEG1ADDR(x))
 
 #define SBMAC_MAX_TXDESCR	32
 #define SBMAC_MAX_RXDESCR	32
@@ -172,7 +169,6 @@
 } sbdmadscr_t;
 
 typedef unsigned long paddr_t;
-typedef unsigned long vaddr_t;
 
 /**********************************************************************
  *  DMA Controller structure
@@ -190,8 +186,8 @@
 	int		 sbdma_txdir;       /* direction (1=transmit) */
 	int		 sbdma_maxdescr;	/* total # of descriptors in ring */
 #ifdef CONFIG_SBMAC_COALESCE
-        int              sbdma_int_pktcnt;  /* # descriptors rx before interrupt*/
-        int              sbdma_int_timeout; /* # usec rx interrupt */
+	int		 sbdma_int_pktcnt;  /* # descriptors rx/tx before interrupt*/
+	int		 sbdma_int_timeout; /* # usec rx/tx interrupt */
 #endif
 
 	sbmac_port_t     sbdma_config0;	/* DMA config register 0 */
@@ -212,7 +208,6 @@
 	paddr_t          sbdma_dscrtable_phys; /* and also the phys addr */
 	sbdmadscr_t     *sbdma_addptr;	/* next dscr for sw to add */
 	sbdmadscr_t     *sbdma_remptr;	/* next dscr for sw to remove */
-	
 } sbmacdma_t;
 
 
@@ -232,10 +227,10 @@
 	struct net_device_stats sbm_stats; 
 	int sbm_devflags;			/* current device flags */
 
-        int	     sbm_phy_oldbmsr;
-        int	     sbm_phy_oldanlpar;
-        int	     sbm_phy_oldk1stsr;
-        int          sbm_phy_oldlinkstat;
+	int	     sbm_phy_oldbmsr;
+	int	     sbm_phy_oldanlpar;
+	int	     sbm_phy_oldk1stsr;
+	int	     sbm_phy_oldlinkstat;
 	int sbm_buffersize;
 	
 	unsigned char sbm_phys[2];
@@ -244,7 +239,7 @@
 	 * Controller-specific things
 	 */
 	
-	sbmac_port_t     sbm_base;          /* MAC's base address */
+	unsigned long	sbm_base;          /* MAC's base address */
 	sbmac_state_t    sbm_state;         /* current state */
 	
 	sbmac_port_t     sbm_macenable;	/* MAC Enable Register */
@@ -260,13 +255,12 @@
 	sbmac_duplex_t   sbm_duplex;	/* current duplex */
 	sbmac_fc_t       sbm_fc;		/* current flow control setting */
 	
-	u_char           sbm_hwaddr[ETHER_ADDR_LEN];
+	unsigned char    sbm_hwaddr[ETHER_ADDR_LEN];
 	
 	sbmacdma_t       sbm_txdma;		/* for now, only use channel 0 */
 	sbmacdma_t       sbm_rxdma;
 	int              rx_hw_checksum;
 	int 		 sbe_idx;
-	
 };
 
 
@@ -295,12 +289,11 @@
 static void sbmac_channel_stop(struct sbmac_softc *s);
 static sbmac_state_t sbmac_set_channel_state(struct sbmac_softc *,sbmac_state_t);
 static void sbmac_promiscuous_mode(struct sbmac_softc *sc,int onoff);
-/*static void sbmac_init_and_start(struct sbmac_softc *sc);*/
 static uint64_t sbmac_addr2reg(unsigned char *ptr);
 static void sbmac_intr(int irq,void *dev_instance,struct pt_regs *rgs);
 static int sbmac_start_tx(struct sk_buff *skb, struct net_device *dev);
 static void sbmac_setmulti(struct sbmac_softc *sc);
-static int sbmac_init(struct net_device *dev);
+static int sbmac_init(struct net_device *dev, int idx);
 static int sbmac_set_speed(struct sbmac_softc *s,sbmac_speed_t speed);
 static int sbmac_set_duplex(struct sbmac_softc *s,sbmac_duplex_t duplex,sbmac_fc_t fc);
 
@@ -325,7 +318,6 @@
  ********************************************************************* */
 
 static uint64_t sbmac_orig_hwaddr[MAX_UNITS];
-static uint64_t chip_revision;
 
 
 /**********************************************************************
@@ -347,8 +339,8 @@
 #define BMCR_DUPLEX    0x0100
 #define BMCR_COLTEST   0x0080
 #define BMCR_SPEED1    0x0040
-#define BMCR_SPEED1000 (BMCR_SPEED1)
-#define BMCR_SPEED100  (BMCR_SPEED0)
+#define BMCR_SPEED1000	BMCR_SPEED1
+#define BMCR_SPEED100	BMCR_SPEED0
 #define BMCR_SPEED10 	0
 
 #define BMSR_100BT4	0x8000
@@ -511,7 +503,8 @@
 	curmask = 1 << (bitcnt - 1);
 	
 	for (i = 0; i < bitcnt; i++) {
-		if (data & curmask) bits |= M_MAC_MDIO_OUT;
+		if (data & curmask)
+			bits |= M_MAC_MDIO_OUT;
 		else bits &= ~M_MAC_MDIO_OUT;
 		SBMAC_WRITECSR(s->sbm_mdio,bits);
 		SBMAC_WRITECSR(s->sbm_mdio,bits | M_MAC_MDC);
@@ -533,7 +526,7 @@
  *  	   regidx = index of register to read
  *  	   
  *  Return value:
- *  	   value read, or 0 if an error occured.
+ *  	   value read, or 0 if an error occurred.
  ********************************************************************* */
 
 static unsigned int sbmac_mii_read(struct sbmac_softc *s,int phyaddr,int regidx)
@@ -575,7 +568,7 @@
 	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT);
 	
 	/* 
-	 * If an error occured, the PHY will signal '1' back
+	 * If an error occurred, the PHY will signal '1' back
 	 */
 	error = SBMAC_READCSR(s->sbm_mdio) & M_MAC_MDIO_IN;
 	
@@ -592,7 +585,8 @@
 		regval <<= 1;
 		
 		if (error == 0) {
-			if (SBMAC_READCSR(s->sbm_mdio) & M_MAC_MDIO_IN) regval |= 1;
+			if (SBMAC_READCSR(s->sbm_mdio) & M_MAC_MDIO_IN)
+				regval |= 1;
 		}
 		
 		SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT | M_MAC_MDC);
@@ -602,7 +596,8 @@
 	/* Switch back to output */
 	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_OUTPUT);
 	
-	if (error == 0) return regval;
+	if (error == 0)
+		return regval;
 	return 0;
 }
 
@@ -672,66 +667,68 @@
 	d->sbdma_channel   = chan;
 	d->sbdma_txdir     = txrx;
 	
+#if 0
 	/* RMON clearing */
 	s->sbe_idx =(s->sbm_base - A_MAC_BASE_0)/MAC_SPACING;
+#endif
 
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_BYTES)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_COLLISIONS)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_LATE_COL)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_EX_COL)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_FCS_ERROR)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_ABORT)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_BAD)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_GOOD)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_RUNT)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_OVERSIZE)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BYTES)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_MCAST)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BCAST)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BAD)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_GOOD)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_RUNT)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_OVERSIZE)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_FCS_ERROR)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_LENGTH_ERROR)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_CODE_ERROR)), 0);
-	SBMAC_WRITECSR(PKSEG1(
-        A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_ALIGN_ERROR)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_BYTES)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_COLLISIONS)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_LATE_COL)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_EX_COL)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_FCS_ERROR)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_ABORT)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_BAD)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_GOOD)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_RUNT)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_OVERSIZE)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BYTES)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_MCAST)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BCAST)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BAD)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_GOOD)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_RUNT)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_OVERSIZE)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_FCS_ERROR)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_LENGTH_ERROR)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_CODE_ERROR)), 0);
+	SBMAC_WRITECSR(KSEG1ADDR(
+	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_ALIGN_ERROR)), 0);
 
 	/* 
 	 * initialize register pointers 
 	 */
 	
 	d->sbdma_config0 = 
-		PKSEG1(s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CONFIG0));
+		s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CONFIG0);
 	d->sbdma_config1 = 
-		PKSEG1(s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CONFIG1));
+		s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CONFIG1);
 	d->sbdma_dscrbase = 
-		PKSEG1(s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_DSCR_BASE));
+		s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_DSCR_BASE);
 	d->sbdma_dscrcnt = 
-		PKSEG1(s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_DSCR_CNT));
+		s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_DSCR_CNT);
 	d->sbdma_curdscr = 	
-		PKSEG1(s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CUR_DSCRADDR));
+		s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CUR_DSCRADDR);
 	
 	/*
 	 * Allocate memory for the ring
@@ -740,47 +737,39 @@
 	d->sbdma_maxdescr = maxdescr;
 	
 	d->sbdma_dscrtable = (sbdmadscr_t *) 
-		KMALLOC(d->sbdma_maxdescr*sizeof(sbdmadscr_t));
+		kmalloc(d->sbdma_maxdescr*sizeof(sbdmadscr_t), GFP_KERNEL);
 	
 	memset(d->sbdma_dscrtable,0,d->sbdma_maxdescr*sizeof(sbdmadscr_t));
 	
 	d->sbdma_dscrtable_end = d->sbdma_dscrtable + d->sbdma_maxdescr;
 	
-	d->sbdma_dscrtable_phys = KVTOPHYS(d->sbdma_dscrtable);
+	d->sbdma_dscrtable_phys = virt_to_phys(d->sbdma_dscrtable);
 	
 	/*
 	 * And context table
 	 */
 	
 	d->sbdma_ctxtable = (struct sk_buff **) 
-		KMALLOC(d->sbdma_maxdescr*sizeof(struct sk_buff *));
+		kmalloc(d->sbdma_maxdescr*sizeof(struct sk_buff *), GFP_KERNEL);
 	
 	memset(d->sbdma_ctxtable,0,d->sbdma_maxdescr*sizeof(struct sk_buff *));
 	
 #ifdef CONFIG_SBMAC_COALESCE
-        /*
-         * Setup Rx DMA coalescing defaults
-         */
-
-        if ( txrx == DMA_RX ) {
-		if ( int_pktcnt ) {
-                	d->sbdma_int_pktcnt = int_pktcnt;
-		        }
-		else {
-                	d->sbdma_int_pktcnt = 1;
-		        }
+	/*
+	 * Setup Rx/Tx DMA coalescing defaults
+	 */
 
-		if ( int_timeout ) {
-		        d->sbdma_int_timeout = int_timeout;
-		        }
-		else {
-		        d->sbdma_int_timeout = 0;
-		    }
-	        }
-        else {
-                d->sbdma_int_pktcnt = 0;
-                d->sbdma_int_timeout = 0;
-	        }
+	if ( int_pktcnt ) {
+		d->sbdma_int_pktcnt = int_pktcnt;
+	} else {
+		d->sbdma_int_pktcnt = 1;
+	}
+	
+	if ( int_timeout ) {
+		d->sbdma_int_timeout = int_timeout;
+	} else {
+		d->sbdma_int_timeout = 0;
+	}
 #endif
 
 }
@@ -800,43 +789,34 @@
 
 static void sbdma_channel_start(sbmacdma_t *d, int rxtx )
 {
-    /*
-     * Turn on the DMA channel
-     */
+	/*
+	 * Turn on the DMA channel
+	 */
 	
 #ifdef CONFIG_SBMAC_COALESCE
-    if (rxtx == DMA_RX) {
-        SBMAC_WRITECSR(d->sbdma_config1,
+	SBMAC_WRITECSR(d->sbdma_config1,
 		       V_DMA_INT_TIMEOUT(d->sbdma_int_timeout) |
 		       0);
-        SBMAC_WRITECSR(d->sbdma_config0,
-                       M_DMA_EOP_INT_EN |
-                       V_DMA_RINGSZ(d->sbdma_maxdescr) |
-                       V_DMA_INT_PKTCNT(d->sbdma_int_pktcnt) |
-                       0);
-	}
-    else {
-	SBMAC_WRITECSR(d->sbdma_config1,0);
 	SBMAC_WRITECSR(d->sbdma_config0,
+		       M_DMA_EOP_INT_EN |
 		       V_DMA_RINGSZ(d->sbdma_maxdescr) |
+		       V_DMA_INT_PKTCNT(d->sbdma_int_pktcnt) |
 		       0);
-	}
 #else
-    SBMAC_WRITECSR(d->sbdma_config1,0);
-    SBMAC_WRITECSR(d->sbdma_config0,
-		   V_DMA_RINGSZ(d->sbdma_maxdescr) |
-		   0);
+	SBMAC_WRITECSR(d->sbdma_config1,0);
+	SBMAC_WRITECSR(d->sbdma_config0,
+		       V_DMA_RINGSZ(d->sbdma_maxdescr) |
+		       0);
 #endif
 
-	
-    SBMAC_WRITECSR(d->sbdma_dscrbase,d->sbdma_dscrtable_phys);
-	
-    /*
-     * Initialize ring pointers
-     */
-	
-    d->sbdma_addptr = d->sbdma_dscrtable;
-    d->sbdma_remptr = d->sbdma_dscrtable;
+	SBMAC_WRITECSR(d->sbdma_dscrbase,d->sbdma_dscrtable_phys);
+
+	/*
+	 * Initialize ring pointers
+	 */
+
+	d->sbdma_addptr = d->sbdma_dscrtable;
+	d->sbdma_remptr = d->sbdma_dscrtable;
 }
 
 /**********************************************************************
@@ -921,7 +901,7 @@
 	if (nextdsc == d->sbdma_remptr) {
 		return -ENOSPC;
 	}
-	
+
 	/* 
 	 * Allocate a sk_buff if we don't already have one.  
 	 * If we do have an sk_buff, reset it so that it's empty.
@@ -935,22 +915,22 @@
 	 *    3. The buffer can be aligned such that the IP addresses are 
 	 *       naturally aligned.
 	 *
-	 *  Remember, the SB1250's MAC writes whole cache lines at a time,
+	 *  Remember, the SOCs MAC writes whole cache lines at a time,
 	 *  without reading the old contents first.  So, if the sk_buff's
-	 *  data portion starts in the middle of a cache line, the SB1250
+	 *  data portion starts in the middle of a cache line, the SOC
 	 *  DMA will trash the beginning (and ending) portions.
 	 */
 	
 	if (sb == NULL) {
-		sb_new = dev_alloc_skb(ENET_PACKET_SIZE + CACHELINESIZE*2 + ETHER_ALIGN);
+		sb_new = dev_alloc_skb(ENET_PACKET_SIZE + SMP_CACHE_BYTES * 2 + ETHER_ALIGN);
 		if (sb_new == NULL) {
 			printk(KERN_INFO "%s: sk_buff allocation failed\n",
 			       d->sbdma_eth->sbm_dev->name);
 			return -ENOBUFS;
 		}
-		
-		sbdma_align_skb(sb_new,CACHELINESIZE,ETHER_ALIGN);
-		
+
+		sbdma_align_skb(sb_new, SMP_CACHE_BYTES, ETHER_ALIGN);
+
 		/* mark skbuff owned by our device */
 		sb_new->dev = d->sbdma_eth->sbm_dev;
 	}
@@ -958,7 +938,7 @@
 		sb_new = sb;
 		/* 
 		 * nothing special to reinit buffer, it's already aligned
-		 * and sb->tail already points to a good place.
+		 * and sb->data already points to a good place.
 		 */
 	}
 	
@@ -967,18 +947,18 @@
 	 */
 	
 #ifdef CONFIG_SBMAC_COALESCE
-        /*
-         * Do not interrupt per DMA transfer.
-         */
-        dsc->dscr_a = KVTOPHYS(sb_new->tail) |
-                V_DMA_DSCRA_A_SIZE(NUMCACHEBLKS(pktsize+ETHER_ALIGN)) |
-                0;
+	/*
+	 * Do not interrupt per DMA transfer.
+	 */
+	dsc->dscr_a = virt_to_phys(sb_new->tail) |
+		V_DMA_DSCRA_A_SIZE(NUMCACHEBLKS(pktsize+ETHER_ALIGN)) |
+		0;
 #else
-	dsc->dscr_a = KVTOPHYS(sb_new->tail) |
+	dsc->dscr_a = virt_to_phys(sb_new->tail) |
 		V_DMA_DSCRA_A_SIZE(NUMCACHEBLKS(pktsize+ETHER_ALIGN)) |
 		M_DMA_DSCRA_INTERRUPT;
 #endif
-	
+
 	/* receiving: no options */
 	dsc->dscr_b = 0;
 	
@@ -1057,12 +1037,14 @@
 	 * while doing the calculation.
 	 */
 	
-	phys = KVTOPHYS(sb->data);
-	ncb = NUMCACHEBLKS(length+(phys & (CACHELINESIZE-1)));
-	
+	phys = virt_to_phys(sb->data);
+	ncb = NUMCACHEBLKS(length+(phys & (SMP_CACHE_BYTES - 1)));
+
 	dsc->dscr_a = phys | 
 		V_DMA_DSCRA_A_SIZE(ncb) |
+#ifndef CONFIG_SBMAC_COALESCE
 		M_DMA_DSCRA_INTERRUPT |
+#endif
 		M_DMA_ETHTX_SOP;
 	
 	/* transmitting: set outbound options and length */
@@ -1139,7 +1121,8 @@
 	int idx;
 	
 	for (idx = 0; idx < SBMAC_MAX_RXDESCR-1; idx++) {
-		if (sbdma_add_rcvbuffer(d,NULL) != 0) break;
+		if (sbdma_add_rcvbuffer(d,NULL) != 0)
+			break;
 	}
 }
 
@@ -1190,7 +1173,8 @@
 		 * the hardware is working on right now.
 		 */
 		
-		if (curidx == hwidx) break;
+		if (curidx == hwidx)
+			break;
 		
 		/*
 		 * Otherwise, get the packet's sk_buff ptr back
@@ -1211,49 +1195,47 @@
 		if (!(dsc->dscr_a & M_DMA_ETHRX_BAD)) {
 			
 			/*
-			 * Set length into the packet
-			 */
-			skb_put(sb,len);
-			
-       			/*
 			 * Add a new buffer to replace the old one.  If we fail
 			 * to allocate a buffer, we're going to drop this
 			 * packet and put it right back on the receive ring.
 			 */
 			
 			if (sbdma_add_rcvbuffer(d,NULL) == -ENOBUFS) {
-			    sbdma_add_rcvbuffer(d,sb);	/* re-add old buffer */
-			    }
-			else {
-			    /*
-			     * Buffer has been replaced on the receive ring.
-			     * Pass the buffer to the kernel
-			     */
-			    sc->sbm_stats.rx_bytes += len;
-			    sc->sbm_stats.rx_packets++;
-			    sb->protocol = eth_type_trans(sb,d->sbdma_eth->sbm_dev);
-                            if (sc->rx_hw_checksum == ENABLE) {
-			    /* if the ip checksum is good indicate in skb.
-		                else set CHECKSUM_NONE as device failed to
-					checksum the packet */
-
-			       if (((dsc->dscr_b) |M_DMA_ETHRX_BADTCPCS) ||
-			     	  ((dsc->dscr_a)| M_DMA_ETHRX_BADIP4CS)){
-				  sb->ip_summed = CHECKSUM_NONE;
-			       } else {
-				 printk(KERN_DEBUG "hw checksum fail .\n");
-				 sb->ip_summed = CHECKSUM_UNNECESSARY;
-			       }
-			    } /*rx_hw_checksum */
-
-			    netif_rx(sb);
-			    }
-		}
-		else {
+				sc->sbm_stats.rx_dropped++;
+				sbdma_add_rcvbuffer(d,sb); /* re-add old buffer */
+			} else {
+				/*
+				 * Set length into the packet
+				 */
+				skb_put(sb,len);
+				
+				/*
+				 * Buffer has been replaced on the
+				 * receive ring.  Pass the buffer to
+				 * the kernel
+				 */
+				sc->sbm_stats.rx_bytes += len;
+				sc->sbm_stats.rx_packets++;
+				sb->protocol = eth_type_trans(sb,d->sbdma_eth->sbm_dev);
+				/* Check hw IPv4/TCP checksum if supported */
+				if (sc->rx_hw_checksum == ENABLE) {
+					if (!((dsc->dscr_a) & M_DMA_ETHRX_BADIP4CS) &&
+					    !((dsc->dscr_a) & M_DMA_ETHRX_BADTCPCS)) {
+						sb->ip_summed = CHECKSUM_UNNECESSARY;
+						/* don't need to set sb->csum */
+					} else {
+						sb->ip_summed = CHECKSUM_NONE;
+					}
+				}
+				
+				netif_rx(sb);
+			}
+		} else {
 			/*
 			 * Packet was mangled somehow.  Just drop it and
 			 * put it back on the receive ring.
 			 */
+			sc->sbm_stats.rx_errors++;
 			sbdma_add_rcvbuffer(d,sb);
 		}
 		
@@ -1309,36 +1291,17 @@
 		 */
 		
 		curidx = d->sbdma_remptr - d->sbdma_dscrtable;
-		{
-			/* XXX This is gross, ugly, and only here because justin hacked it
-			   in to fix a problem without really understanding it. 
-			   
-			   It seems that, for whatever reason, this routine is invoked immediately upon the enabling of interrupts.
-			   So then the Read below returns zero, making hwidx a negative number, and anti-hilarity
-			   ensues.
-			   
-			   I'm guessing there's a proper fix involving clearing out interrupt state from old packets
-			   before enabling interrupts, but I'm not sure.  
-
-			   Anyways, this hack seems to work, and is Good Enough for 11 PM.  :)
-			   
-			   -Justin
-			*/
-			  
-			uint64_t tmp = SBMAC_READCSR(d->sbdma_curdscr);
-			if (!tmp) {
-				break;
-			}
-			hwidx = (int) (((tmp & M_DMA_CURDSCR_ADDR) -
-					d->sbdma_dscrtable_phys) / sizeof(sbdmadscr_t));
-		}
+		hwidx = (int) (((SBMAC_READCSR(d->sbdma_curdscr) & M_DMA_CURDSCR_ADDR) -
+				d->sbdma_dscrtable_phys) / sizeof(sbdmadscr_t));
+
 		/*
 		 * If they're the same, that means we've processed all
 		 * of the descriptors up to (but not including) the one that
 		 * the hardware is working on right now.
 		 */
 		
-		if (curidx == hwidx) break;
+		if (curidx == hwidx)
+			break;
 		
 		/*
 		 * Otherwise, get the packet's sk_buff ptr back
@@ -1405,14 +1368,14 @@
 	 * figure out the addresses of some ports 
 	 */
 	
-	s->sbm_macenable = PKSEG1(s->sbm_base + R_MAC_ENABLE);
-	s->sbm_maccfg    = PKSEG1(s->sbm_base + R_MAC_CFG);
-	s->sbm_fifocfg   = PKSEG1(s->sbm_base + R_MAC_THRSH_CFG);
-	s->sbm_framecfg  = PKSEG1(s->sbm_base + R_MAC_FRAMECFG);
-	s->sbm_rxfilter  = PKSEG1(s->sbm_base + R_MAC_ADFILTER_CFG);
-	s->sbm_isr       = PKSEG1(s->sbm_base + R_MAC_STATUS);
-	s->sbm_imr       = PKSEG1(s->sbm_base + R_MAC_INT_MASK);
-	s->sbm_mdio      = PKSEG1(s->sbm_base + R_MAC_MDIO);
+	s->sbm_macenable = s->sbm_base + R_MAC_ENABLE;
+	s->sbm_maccfg    = s->sbm_base + R_MAC_CFG;
+	s->sbm_fifocfg   = s->sbm_base + R_MAC_THRSH_CFG;
+	s->sbm_framecfg  = s->sbm_base + R_MAC_FRAMECFG;
+	s->sbm_rxfilter  = s->sbm_base + R_MAC_ADFILTER_CFG;
+	s->sbm_isr       = s->sbm_base + R_MAC_STATUS;
+	s->sbm_imr       = s->sbm_base + R_MAC_INT_MASK;
+	s->sbm_mdio      = s->sbm_base + R_MAC_MDIO;
 
 	s->sbm_phys[0]   = 1;
 	s->sbm_phys[1]   = 0;
@@ -1451,12 +1414,12 @@
 static void sbdma_uninitctx(struct sbmacdma_s *d)
 {
 	if (d->sbdma_dscrtable) {
-		KFREE(d->sbdma_dscrtable);
+		kfree(d->sbdma_dscrtable);
 		d->sbdma_dscrtable = NULL;
 	}
 	
 	if (d->sbdma_ctxtable) {
-		KFREE(d->sbdma_ctxtable);
+		kfree(d->sbdma_ctxtable);
 		d->sbdma_ctxtable = NULL;
 	}
 }
@@ -1486,13 +1449,14 @@
 	uint64_t reg;
 	sbmac_port_t port;
 	uint64_t cfg,fifo,framecfg;
-	int idx;
+	int idx, th_value;
 	
 	/*
 	 * Don't do this if running
 	 */
 
-	if (s->sbm_state == sbmac_state_on) return;
+	if (s->sbm_state == sbmac_state_on)
+		return;
 	
 	/*
 	 * Bring the controller out of reset, but leave it off.
@@ -1519,31 +1483,35 @@
 		0;
 	
 	/* 
-	 * Be sure that RD_THRSH+WR_THRSH <= 32
+	 * Be sure that RD_THRSH+WR_THRSH <= 32 for pass1 pars
+	 * and make sure that RD_THRSH + WR_THRSH <=128 for pass2 and above
 	 * Use a larger RD_THRSH for gigabit
 	 */
+	if (periph_rev >= 2) 
+		th_value = 64;
+	else 
+		th_value = 28;
 
 	fifo = V_MAC_TX_WR_THRSH(4) |	/* Must be '4' or '8' */
 		((s->sbm_speed == sbmac_speed_1000)
-		 ? V_MAC_TX_RD_THRSH(28) : V_MAC_TX_RD_THRSH(4)) |
+		 ? V_MAC_TX_RD_THRSH(th_value) : V_MAC_TX_RD_THRSH(4)) |
 		V_MAC_TX_RL_THRSH(4) |
 		V_MAC_RX_PL_THRSH(4) |
 		V_MAC_RX_RD_THRSH(4) |	/* Must be '4' */
 		V_MAC_RX_PL_THRSH(4) |
 		V_MAC_RX_RL_THRSH(8) |
 		0;
-	
+
 	framecfg = V_MAC_MIN_FRAMESZ_DEFAULT |
 		V_MAC_MAX_FRAMESZ_DEFAULT |
 		V_MAC_BACKOFF_SEL(1);
-	
-	
+
 	/*
 	 * Clear out the hash address map 
 	 */
 	
-	port = PKSEG1(s->sbm_base + R_MAC_HASH_BASE);
-        for (idx = 0; idx < MAC_HASH_COUNT; idx++) {
+	port = s->sbm_base + R_MAC_HASH_BASE;
+	for (idx = 0; idx < MAC_HASH_COUNT; idx++) {
 		SBMAC_WRITECSR(port,0);
 		port += sizeof(uint64_t);
 	}
@@ -1552,7 +1520,7 @@
 	 * Clear out the exact-match table
 	 */
 	
-	port = PKSEG1(s->sbm_base + R_MAC_ADDR_BASE);
+	port = s->sbm_base + R_MAC_ADDR_BASE;
 	for (idx = 0; idx < MAC_ADDR_COUNT; idx++) {
 		SBMAC_WRITECSR(port,0);
 		port += sizeof(uint64_t);
@@ -1562,14 +1530,14 @@
 	 * Clear out the DMA Channel mapping table registers
 	 */
 	
-	port = PKSEG1(s->sbm_base + R_MAC_CHUP0_BASE);
+	port = s->sbm_base + R_MAC_CHUP0_BASE;
 	for (idx = 0; idx < MAC_CHMAP_COUNT; idx++) {
 		SBMAC_WRITECSR(port,0);
 		port += sizeof(uint64_t);
 	}
 
 
-	port = PKSEG1(s->sbm_base + R_MAC_CHLO0_BASE);
+	port = s->sbm_base + R_MAC_CHLO0_BASE;
 	for (idx = 0; idx < MAC_CHMAP_COUNT; idx++) {
 		SBMAC_WRITECSR(port,0);
 		port += sizeof(uint64_t);
@@ -1582,13 +1550,13 @@
 	
 	reg = sbmac_addr2reg(s->sbm_hwaddr);
 	
-	port = PKSEG1(s->sbm_base + R_MAC_ADDR_BASE);
+	port = s->sbm_base + R_MAC_ADDR_BASE;
 	SBMAC_WRITECSR(port,reg);
-	port = PKSEG1(s->sbm_base + R_MAC_ETHERNET_ADDR);
+	port = s->sbm_base + R_MAC_ETHERNET_ADDR;
 
 #ifdef CONFIG_SB1_PASS_1_WORKAROUNDS
 	/*
-	 * Pass1 SB1250s do not receive packets addressed to the
+	 * Pass1 SOCs do not receive packets addressed to the
 	 * destination address in the R_MAC_ETHERNET_ADDR register.
 	 * Set the value to zero.
 	 */
@@ -1646,7 +1614,7 @@
 	 * Accept any TX interrupt and EOP count/timer RX interrupts on ch 0
 	 */
 	SBMAC_WRITECSR(s->sbm_imr,
-		       (M_MAC_INT_CHANNEL << S_MAC_TX_CH0) |
+		       ((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_TX_CH0) |
 		       ((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_RX_CH0));
 #else
 	/*
@@ -1702,7 +1670,8 @@
 {
 	/* don't do this if already stopped */
 	
-	if (s->sbm_state == sbmac_state_off) return;
+	if (s->sbm_state == sbmac_state_off)
+		return;
 	
 	/* don't accept any packets, disable all interrupts */
 	
@@ -1795,7 +1764,8 @@
 {
 	uint64_t reg;
 	
-	if (sc->sbm_state != sbmac_state_on) return;
+	if (sc->sbm_state != sbmac_state_on)
+		return;
 	
 	if (onoff) {
 		reg = SBMAC_READCSR(sc->sbm_rxfilter);
@@ -1825,15 +1795,15 @@
 {
 	uint64_t reg;
 	
-	reg = SBMAC_READCSR(sc->sbm_rxfilter);
-	reg &= ~M_MAC_IPHDR_OFFSET;
 	/* Hard code the off set to 15 for now */
-	reg |= 15 << S_MAC_IPHDR_OFFSET;
+	reg = SBMAC_READCSR(sc->sbm_rxfilter);
+	reg &= ~M_MAC_IPHDR_OFFSET | V_MAC_IPHDR_OFFSET(15);
 	SBMAC_WRITECSR(sc->sbm_rxfilter,reg);
 	
 	/* read system identification to determine revision */
-	if (sb1250_pass >= K_SYS_REVISION_PASS2) {
-		printk(KERN_INFO "pass2 - enabling Rx rcv tcp checksum\n");
+	if (periph_rev >= 2) {
+		printk(KERN_INFO "%s: enabling TCP rcv checksum\n",
+		       sc->sbm_dev->name);
 		sc->rx_hw_checksum = ENABLE;
 	} else {
 		sc->rx_hw_checksum = DISABLE;
@@ -1841,31 +1811,6 @@
 }
 
 
-#if 0
-/**********************************************************************
- *  SBMAC_INIT_AND_START(sc)
- *  
- *  Stop the channel and restart it.  This is generally used
- *  when we have to do something to the channel that requires
- *  a swift kick.
- *  
- *  Input parameters: 
- *  	   sc - softc
- ********************************************************************* */
-
-static void sbmac_init_and_start(struct sbmac_softc *sc)
-{
-	unsigned long flags;
-	
-	spin_lock_irqsave(&(sc->sbm_lock),flags);
-	
-	sbmac_set_channel_state(sc,sbmac_state_on);
-	
-	spin_unlock_irqrestore(&(sc->sbm_lock),flags);
-}
-#endif
-
-
 /**********************************************************************
  *  SBMAC_ADDR2REG(ptr)
  *  
@@ -1927,7 +1872,8 @@
 	
 	s->sbm_speed = speed;
 	
-	if (s->sbm_state == sbmac_state_on) return 0;	/* save for next restart */
+	if (s->sbm_state == sbmac_state_on)
+		return 0;	/* save for next restart */
 
 	/*
 	 * Read current register values 
@@ -1987,7 +1933,6 @@
 	SBMAC_WRITECSR(s->sbm_maccfg,cfg);
 	
 	return 1;
-	
 }
 
 /**********************************************************************
@@ -2017,7 +1962,8 @@
 	s->sbm_duplex = duplex;
 	s->sbm_fc = fc;
 	
-	if (s->sbm_state == sbmac_state_on) return 0;	/* save for next restart */
+	if (s->sbm_state == sbmac_state_on)
+		return 0;	/* save for next restart */
 	
 	/*
 	 * Read current register values 
@@ -2116,7 +2062,8 @@
 		
 		isr = SBMAC_READCSR(sc->sbm_isr) & ~M_MAC_COUNTER_ADDR;
 		
-		if (isr == 0) break;
+		if (isr == 0)
+			break;
 		
 		/*
 		 * Transmits on channel 0
@@ -2151,7 +2098,6 @@
 			sbdma_rx_process(sc,&(sc->sbm_rxdma));
 		}
 	}
-	
 }
 
 
@@ -2224,12 +2170,12 @@
 	 */
 	
 	for (idx = 1; idx < MAC_ADDR_COUNT; idx++) {
-		port = PKSEG1(sc->sbm_base + R_MAC_ADDR_BASE+(idx*sizeof(uint64_t)));
+		port = sc->sbm_base + R_MAC_ADDR_BASE+(idx*sizeof(uint64_t));
 		SBMAC_WRITECSR(port,0);	
 	}
 	
 	for (idx = 0; idx < MAC_HASH_COUNT; idx++) {
-		port = PKSEG1(sc->sbm_base + R_MAC_HASH_BASE+(idx*sizeof(uint64_t)));
+		port = sc->sbm_base + R_MAC_HASH_BASE+(idx*sizeof(uint64_t));
 		SBMAC_WRITECSR(port,0);	
 	}
 	
@@ -2266,8 +2212,7 @@
 	mclist = dev->mc_list;
 	while (mclist && (idx < MAC_ADDR_COUNT)) {
 		reg = sbmac_addr2reg(mclist->dmi_addr);
-		port = PKSEG1(sc->sbm_base + 
-			      R_MAC_ADDR_BASE+(idx*sizeof(uint64_t)));
+		port = sc->sbm_base + R_MAC_ADDR_BASE+(idx * sizeof(uint64_t));
 		SBMAC_WRITECSR(port,reg);
 		idx++;
 		mclist = mclist->next;
@@ -2304,10 +2249,14 @@
 {
 	int digit;
 	
-	if ((str >= '0') && (str <= '9')) digit = str - '0';
-	else if ((str >= 'a') && (str <= 'f')) digit = str - 'a' + 10;
-	else if ((str >= 'A') && (str <= 'F')) digit = str - 'A' + 10;
-	else return -1;
+	if ((str >= '0') && (str <= '9'))
+		digit = str - '0';
+	else if ((str >= 'a') && (str <= 'f'))
+		digit = str - 'a' + 10;
+	else if ((str >= 'A') && (str <= 'F'))
+		digit = str - 'A' + 10;
+	else
+		return -1;
 	
 	return digit;
 }
@@ -2326,16 +2275,18 @@
  *  	   0 if ok, else -1
  ********************************************************************* */
 
-static int sbmac_parse_hwaddr(char *str,u_char *hwaddr)
+static int sbmac_parse_hwaddr(char *str, unsigned char *hwaddr)
 {
 	int digit1,digit2;
 	int idx = 6;
 	
 	while (*str && (idx > 0)) {
 		digit1 = sbmac_parse_xdigit(*str);
-		if (digit1 < 0) return -1;
+		if (digit1 < 0)
+			return -1;
 		str++;
-		if (!*str) return -1;
+		if (!*str)
+			return -1;
 		
 		if ((*str == ':') || (*str == '-')) {
 			digit2 = digit1;
@@ -2343,15 +2294,18 @@
 		}
 		else {
 			digit2 = sbmac_parse_xdigit(*str);
-			if (digit2 < 0) return -1;
+			if (digit2 < 0)
+				return -1;
 			str++;
 		}
 		
 		*hwaddr++ = (digit1 << 4) | digit2;
 		idx--;
 		
-		if (*str == '-') str++;
-		if (*str == ':') str++;
+		if (*str == '-')
+			str++;
+		if (*str == ':')
+			str++;
 	}
 	return 0;
 }
@@ -2359,11 +2313,11 @@
 
 static int sb1250_change_mtu(struct net_device *_dev, int new_mtu)
 {
-        if (new_mtu >  ENET_PACKET_SIZE)
-                return -EINVAL;
-        _dev->mtu = new_mtu;
+	if (new_mtu >  ENET_PACKET_SIZE)
+		return -EINVAL;
+	_dev->mtu = new_mtu;
 	printk(KERN_INFO "changing the mtu to %d\n", new_mtu);
-        return 0;
+	return 0;
 }
 
 /**********************************************************************
@@ -2378,19 +2332,20 @@
  *  	   status
  ********************************************************************* */
 
-static int sbmac_init(struct net_device *dev)
+static int sbmac_init(struct net_device *dev, int idx)
 {
 	struct sbmac_softc *sc;
-	u_char *eaddr;
+	unsigned char *eaddr;
 	uint64_t ea_reg;
-	int idx;
+	int i;
 	
 	sc = (struct sbmac_softc *)dev->priv;
 	
 	/* Determine controller base address */
 	
-	sc->sbm_base = (sbmac_port_t) dev->base_addr;
+	sc->sbm_base = KSEG1ADDR(dev->base_addr);
 	sc->sbm_dev = dev;
+	sc->sbe_idx = idx;
 	
 	eaddr = sc->sbm_hwaddr;
 	
@@ -2399,16 +2354,15 @@
 	 * for us in the ethernet address register for each mac.
 	 */
 	
-	ea_reg = SBMAC_READCSR(PKSEG1(sc->sbm_base + R_MAC_ETHERNET_ADDR));
-	SBMAC_WRITECSR(PKSEG1(sc->sbm_base + R_MAC_ETHERNET_ADDR), 0);
-	for (idx = 0; idx < 6; idx++) {
-		eaddr[idx] = (uint8_t) (ea_reg & 0xFF);
+	ea_reg = SBMAC_READCSR(sc->sbm_base + R_MAC_ETHERNET_ADDR);
+	SBMAC_WRITECSR(sc->sbm_base + R_MAC_ETHERNET_ADDR, 0);
+	for (i = 0; i < 6; i++) {
+		eaddr[i] = (uint8_t) (ea_reg & 0xFF);
 		ea_reg >>= 8;
 	}
 	
-	
-	for (idx = 0; idx < 6; idx++) {
-		dev->dev_addr[idx] = eaddr[idx];
+	for (i = 0; i < 6; i++) {
+		dev->dev_addr[i] = eaddr[i];
 	}
 	
 	
@@ -2416,8 +2370,8 @@
 	 * Init packet size 
 	 */
 	
-	sc->sbm_buffersize = ENET_PACKET_SIZE + CACHELINESIZE*2 + ETHER_ALIGN;
-	
+	sc->sbm_buffersize = ENET_PACKET_SIZE + SMP_CACHE_BYTES * 2 + ETHER_ALIGN;
+
 	/* 
 	 * Initialize context (get pointers to registers and stuff), then
 	 * allocate the memory for the descriptor tables.
@@ -2427,13 +2381,13 @@
 	
 	
 	/*
-	 * Display Ethernet address (this is called during the config process
-	 * so we need to finish off the config message that was being displayed)
+	 * Display Ethernet address (this is called during the config
+	 * process so we need to finish off the config message that
+	 * was being displayed)
 	 */
 	printk(KERN_INFO
-	       "%s: SB1250 Ethernet at 0x%08lX, address: %02X-%02X-%02X-%02X-%02X-%02X\n", 
-	       dev->name,
-	       (unsigned long) sc->sbm_base,
+	       "%s: SiByte Ethernet at 0x%08lX, address: %02X-%02X-%02X-%02X-%02X-%02X\n", 
+	       dev->name, dev->base_addr,
 	       eaddr[0],eaddr[1],eaddr[2],eaddr[3],eaddr[4],eaddr[5]);
 	
 	/*
@@ -2454,16 +2408,10 @@
 
 	dev->change_mtu         = sb1250_change_mtu;
 
-	if (sb1250_pass >= K_SYS_REVISION_PASS3) {
-		/* In pass3 we do dumb checksum in TX */
-		dev->features |= NETIF_F_IP_CSUM;
-	}
-
-        /* This is needed for PASS2 for Rx H/W checksum feature */
-	sbmac_set_iphdr_offset( sc);
+	/* This is needed for PASS2 for Rx H/W checksum feature */
+	sbmac_set_iphdr_offset(sc);
 	
 	return 0;
-	
 }
 
 
@@ -2478,9 +2426,12 @@
 	}
 	
 	/* 
-	 * map/route interrupt 
+	 * map/route interrupt (clear status first, in case something
+	 * weird is pending; we haven't initialized the mac registers
+	 * yet)
 	 */
-	
+
+	SBMAC_READCSR(sc->sbm_isr);
 	if (request_irq(dev->irq, &sbmac_intr, SA_SHIRQ, dev->name, dev)) {
 		MOD_DEC_USE_COUNT;
 		return -EBUSY;
@@ -2490,7 +2441,7 @@
 	 * Configure default speed 
 	 */
 
-	sbmac_mii_poll(sc,1);
+	sbmac_mii_poll(sc,noisy_mii);
 	
 	/*
 	 * Turn on the channel
@@ -2572,7 +2523,8 @@
 	chg = 1;
 	}
 
-    if (chg == 0) return 0;
+    if (chg == 0)
+	    return 0;
 
     p += sprintf(p,"Link speed: ");
 
@@ -2616,9 +2568,6 @@
 	p += sprintf(p,"Unknown");
 	}
 
-#ifdef CONFIG_NET_SB1250_MAC_QUIET
-    noisy = 0;
-#endif
     if (noisy) {
 	    printk(KERN_INFO "%s: %s\n",s->sbm_dev->name,buffer);
 	    }
@@ -2627,8 +2576,6 @@
 }
 
 
-
-
 static void sbmac_timer(unsigned long data)
 {
 	struct net_device *dev = (struct net_device *)data;
@@ -2655,19 +2602,19 @@
 	 * Poll the PHY to see what speed we should be running at
 	 */
 
-	if (sbmac_mii_poll(sc,1)) {
-	    if (sc->sbm_state != sbmac_state_off) {
-		/*
-		 * something changed, restart the channel
-		 */
-		if (debug > 1) {
-		    printk("%s: restarting channel because speed changed\n",
-			   sc->sbm_dev->name);
-		    }
-		sbmac_channel_stop(sc);
-		sbmac_channel_start(sc);
+	if (sbmac_mii_poll(sc,noisy_mii)) {
+		if (sc->sbm_state != sbmac_state_off) {
+			/*
+			 * something changed, restart the channel
+			 */
+			if (debug > 1) {
+				printk("%s: restarting channel because speed changed\n",
+				       sc->sbm_dev->name);
+			}
+			sbmac_channel_stop(sc);
+			sbmac_channel_start(sc);
 		}
-	    }
+	}
 	
 	spin_unlock_irq (&sc->sbm_lock);
 	
@@ -2735,7 +2682,8 @@
 	spin_unlock_irqrestore(&sc->sbm_lock, flags);
 	
 	if (msg_flag) {
-		printk(KERN_NOTICE "%s: Promiscuous mode %sabled.\n", dev->name,(msg_flag==1)?"en":"dis");
+		printk(KERN_NOTICE "%s: Promiscuous mode %sabled.\n",
+		       dev->name,(msg_flag==1)?"en":"dis");
 	}
 	
 	/*
@@ -2786,31 +2734,29 @@
 {
 	struct sbmac_softc *sc = (struct sbmac_softc *)dev->priv;
 	unsigned long flags;
-	
+
 	sbmac_set_channel_state(sc,sbmac_state_off);
-	
+
 	del_timer_sync(&sc->sbm_timer);
-	
+
 	spin_lock_irqsave(&sc->sbm_lock, flags);
-	
+
 	netif_stop_queue(dev);
-	
+
 	if (debug > 1) {
 		printk(KERN_DEBUG "%s: Shutting down ethercard\n",dev->name);
 	}
-	
+
 	spin_unlock_irqrestore(&sc->sbm_lock, flags);
-	
-	/* Make sure there is no irq-handler running on a different CPU. */
+
 	synchronize_irq();
-	
 	free_irq(dev->irq, dev);
-	
+
 	sbdma_emptyring(&(sc->sbm_txdma));
 	sbdma_emptyring(&(sc->sbm_rxdma));
 	
 	MOD_DEC_USE_COUNT;
-	
+
 	return 0;
 }
 
@@ -2827,8 +2773,8 @@
 	port = A_MAC_CHANNEL_BASE(chan);
 	sbmac_parse_hwaddr(addr,eaddr);
 	val = sbmac_addr2reg(eaddr);
-	SBMAC_WRITECSR(PKSEG1(port+R_MAC_ETHERNET_ADDR),val);
-	val = SBMAC_READCSR(PKSEG1(port+R_MAC_ETHERNET_ADDR));
+	SBMAC_WRITECSR(KSEG1ADDR(port+R_MAC_ETHERNET_ADDR),val);
+	val = SBMAC_READCSR(KSEG1ADDR(port+R_MAC_ETHERNET_ADDR));
 }
 #endif
 
@@ -2862,15 +2808,15 @@
 	 * Walk through the Ethernet controllers and find
 	 * those who have their MAC addresses set.
 	 */
-	chip_revision = SBMAC_READCSR(PKSEG1(A_SCD_SYSTEM_REVISION));
-	switch ((int)G_SYS_PART(chip_revision)) {
-	case 0x1150:
-	case 0x1250:
+	switch (soc_type) {
+	case K_SYS_SOC_TYPE_BCM1250:
+	case K_SYS_SOC_TYPE_BCM1250_ALT:
 		chip_max_units = 3;
 		break;
-	case 0x1120:
-	case 0x1125:
-	case 0x1126:
+	case K_SYS_SOC_TYPE_BCM1120:
+	case K_SYS_SOC_TYPE_BCM1125:
+	case K_SYS_SOC_TYPE_BCM1125H:
+	case K_SYS_SOC_TYPE_BCM1250_ALT2: /* Hybrid */
 		chip_max_units = 2;
 		break;
 	default:
@@ -2894,9 +2840,10 @@
 		 * If we find a zero, skip this MAC.
 		 */
 
-		sbmac_orig_hwaddr[idx] = SBMAC_READCSR(PKSEG1(port+R_MAC_ETHERNET_ADDR));
+		sbmac_orig_hwaddr[idx] = SBMAC_READCSR(KSEG1ADDR(port+R_MAC_ETHERNET_ADDR));
 		if (sbmac_orig_hwaddr[idx] == 0) {
-		    printk( KERN_DEBUG "sbmac: not configuring MAC at %x\n",(uint32_t)port);
+			printk(KERN_DEBUG "sbmac: not configuring MAC at "
+			       "%lx\n", port);
 		    continue;
 		}
 
@@ -2908,15 +2855,16 @@
 		if (!dev) 
 		  return -ENOMEM;	/* return ENOMEM */
 
+		printk(KERN_DEBUG "sbmac: configuring MAC at %lx\n", port);
+
 		dev->irq = K_INT_MAC_0 + idx;
 		dev->base_addr = port;
 		dev->mem_end = 0;
 		/*dev->init = sbmac_init;*/
-		sbmac_init(dev);
+		sbmac_init(dev, macidx);
 
 		dev_sbmac[macidx] = dev;
 		macidx++;
-
 	}
 
 	/*
@@ -2935,7 +2883,8 @@
 	sbmac_port_t port;
 	for (idx = 0; idx < MAX_UNITS; idx++) {
 		dev = dev_sbmac[idx];
-		if (dev == NULL) continue;
+		if (dev == NULL)
+			continue;
 		if (dev->priv != NULL) {
 			struct sbmac_softc *sc = (struct sbmac_softc *) dev->priv;
 			
@@ -2946,8 +2895,8 @@
 		}
 
 	        port = A_MAC_CHANNEL_BASE(idx);
-		SBMAC_WRITECSR(PKSEG1(port+R_MAC_ETHERNET_ADDR), sbmac_orig_hwaddr[idx] );
-		KFREE(dev);
+		SBMAC_WRITECSR(KSEG1ADDR(port+R_MAC_ETHERNET_ADDR), sbmac_orig_hwaddr[idx] );
+		kfree(dev);
 		dev_sbmac[idx] = NULL;
 	}
 }
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/sgiseeq.c linux-2.4.22/drivers/net/sgiseeq.c
--- linux-2.4.22.clean/drivers/net/sgiseeq.c	2003-06-13 16:51:35.000000000 +0200
+++ linux-2.4.22/drivers/net/sgiseeq.c	2003-09-21 03:32:42.000000000 +0200
@@ -5,51 +5,45 @@
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/init.h>
 #include <linux/types.h>
 #include <linux/interrupt.h>
-#include <linux/ptrace.h>
 #include <linux/ioport.h>
+#include <linux/socket.h>
 #include <linux/in.h>
+#include <linux/route.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
 
+#include <asm/byteorder.h>
 #include <asm/io.h>
-#include <asm/segment.h>
 #include <asm/system.h>
 #include <asm/bitops.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
-#include <linux/errno.h>
-#include <asm/byteorder.h>
-
-#include <linux/socket.h>
-#include <linux/route.h>
-
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-
-#include <asm/sgi/sgihpc.h>
-#include <asm/sgi/sgint23.h>
+#include <asm/sgi/hpc3.h>
+#include <asm/sgi/ip22.h>
 #include <asm/sgialib.h>
 
 #include "sgiseeq.h"
 
-static char *version =
-	"sgiseeq.c: David S. Miller (dm@engr.sgi.com)\n";
+static char *version = "sgiseeq.c: David S. Miller (dm@engr.sgi.com)\n";
 
 static char *sgiseeqstr = "SGI Seeq8003";
 
-/* If you want speed, you do something silly, it always has worked
- * for me.  So, with that in mind, I've decided to make this driver
- * look completely like a stupid Lance from a driver architecture
- * perspective.  Only difference is that here our "ring buffer" looks
- * and acts like a real Lance one does but is layed out like how the
- * HPC DMA and the Seeq want it to.  You'd be surprised how a stupid
- * idea like this can pay off in performance, not to mention making
- * this driver 2,000 times easier to write. ;-)
+/*
+ * If you want speed, you do something silly, it always has worked for me.  So,
+ * with that in mind, I've decided to make this driver look completely like a
+ * stupid Lance from a driver architecture perspective.  Only difference is that
+ * here our "ring buffer" looks and acts like a real Lance one does but is
+ * layed out like how the HPC DMA and the Seeq want it to.  You'd be surprised
+ * how a stupid idea like this can pay off in performance, not to mention
+ * making this driver 2,000 times easier to write. ;-)
  */
 
 /* Tune these if we tend to run out often etc. */
@@ -79,9 +73,10 @@
 	signed int buf_vaddr;
 };
 
-/* Warning: This structure is layed out in a certain way because
- *          HPC dma descriptors must be 8-byte aligned.  So don't
- *          touch this without some care.
+/*
+ * Warning: This structure is layed out in a certain way because HPC dma
+ *          descriptors must be 8-byte aligned.  So don't touch this without
+ *          some care.
  */
 struct sgiseeq_init_block { /* Note the name ;-) */
 	/* Ptrs to the descriptors in KSEG1 uncached space. */
@@ -96,8 +91,8 @@
 struct sgiseeq_private {
 	volatile struct sgiseeq_init_block srings;
 	char *name;
-	volatile struct hpc3_ethregs *hregs;
-	volatile struct sgiseeq_regs *sregs;
+	struct hpc3_ethregs *hregs;
+	struct sgiseeq_regs *sregs;
 
 	/* Ring entry counters. */
 	unsigned int rx_new, tx_new;
@@ -108,17 +103,23 @@
 	unsigned char mode;
 
 	struct net_device_stats stats;
+
+	struct net_device *next_module;
+	spinlock_t tx_lock;
 };
 
-static inline void hpc3_eth_reset(volatile struct hpc3_ethregs *hregs)
+/* A list of all installed seeq devices, for removing the driver module. */
+static struct net_device *root_sgiseeq_dev;
+
+static inline void hpc3_eth_reset(struct hpc3_ethregs *hregs)
 {
 	hregs->rx_reset = (HPC3_ERXRST_CRESET | HPC3_ERXRST_CLRIRQ);
 	udelay(20);
 	hregs->rx_reset = 0;
 }
 
-static inline void reset_hpc3_and_seeq(volatile struct hpc3_ethregs *hregs,
-				       volatile struct sgiseeq_regs *sregs)
+static inline void reset_hpc3_and_seeq(struct hpc3_ethregs *hregs,
+				       struct sgiseeq_regs *sregs)
 {
 	hregs->rx_ctrl = hregs->tx_ctrl = 0;
 	hpc3_eth_reset(hregs);
@@ -128,15 +129,15 @@
 		       SEEQ_RCMD_IDRIB | SEEQ_RCMD_ICRC)
 
 static inline void seeq_go(struct sgiseeq_private *sp,
-			   volatile struct hpc3_ethregs *hregs,
-			   volatile struct sgiseeq_regs *sregs)
+			   struct hpc3_ethregs *hregs,
+			   struct sgiseeq_regs *sregs)
 {
 	sregs->rstat = sp->mode | RSTAT_GO_BITS;
 	hregs->rx_ctrl = HPC3_ERXCTRL_ACTIVE;
 }
 
 static inline void seeq_load_eaddr(struct net_device *dev,
-				   volatile struct sgiseeq_regs *sregs)
+				   struct sgiseeq_regs *sregs)
 {
 	int i;
 
@@ -161,15 +162,9 @@
 
 	seeq_load_eaddr(dev, sp->sregs);
 
-	/* XXX for now just accept packets directly to us
-	 * XXX and ether-broadcast.  Will do multicast and
-	 * XXX promiscuous mode later. -davem
-	 */
-	sp->mode = SEEQ_RCMD_RBCAST;
-
 	/* Setup tx ring. */
 	for(i = 0; i < SEEQ_TX_BUFFERS; i++) {
-		if(!ib->tx_desc[i].tdma.pbuf) {
+		if (!ib->tx_desc[i].tdma.pbuf) {
 			unsigned long buffer;
 
 			buffer = (unsigned long) kmalloc(PKT_BUF_SZ, GFP_KERNEL);
@@ -177,7 +172,6 @@
 				return -ENOMEM;
 			ib->tx_desc[i].buf_vaddr = KSEG1ADDR(buffer);
 			ib->tx_desc[i].tdma.pbuf = PHYSADDR(buffer);
-//			flush_cache_all();
 		}
 		ib->tx_desc[i].tdma.cntinfo = (TCNTINFO_INIT);
 	}
@@ -192,7 +186,6 @@
 				return -ENOMEM;
 			ib->rx_desc[i].buf_vaddr = KSEG1ADDR(buffer);
 			ib->rx_desc[i].rdma.pbuf = PHYSADDR(buffer);
-//			flush_cache_all();
 		}
 		ib->rx_desc[i].rdma.cntinfo = (RCNTINFO_INIT);
 	}
@@ -209,10 +202,10 @@
 	static int once;
 	struct sgiseeq_rx_desc *r = gpriv->srings.rx_desc;
 	struct sgiseeq_tx_desc *t = gpriv->srings.tx_desc;
-	volatile struct hpc3_ethregs *hregs = gpriv->hregs;
+	struct hpc3_ethregs *hregs = gpriv->hregs;
 	int i;
 
-	if(once)
+	if (once)
 		return;
 	once++;
 	printk("RING DUMP:\n");
@@ -248,9 +241,9 @@
 #define RDMACFG_INIT    (HPC3_ERXDCFG_FRXDC | HPC3_ERXDCFG_FEOP | HPC3_ERXDCFG_FIRQ)
 
 static int init_seeq(struct net_device *dev, struct sgiseeq_private *sp,
-		      volatile struct sgiseeq_regs *sregs)
+		     struct sgiseeq_regs *sregs)
 {
-	volatile struct hpc3_ethregs *hregs = sp->hregs;
+	struct hpc3_ethregs *hregs = sp->hregs;
 	int err;
 
 	reset_hpc3_and_seeq(hregs, sregs);
@@ -291,8 +284,8 @@
 }
 
 static inline void rx_maybe_restart(struct sgiseeq_private *sp,
-				    volatile struct hpc3_ethregs *hregs,
-				    volatile struct sgiseeq_regs *sregs)
+				    struct hpc3_ethregs *hregs,
+				    struct sgiseeq_regs *sregs)
 {
 	if (!(hregs->rx_ctrl & HPC3_ERXCTRL_ACTIVE)) {
 		hregs->rx_ndptr = PHYSADDR(&sp->srings.rx_desc[sp->rx_new]);
@@ -305,8 +298,8 @@
 				(rd) = &(sp)->srings.rx_desc[(sp)->rx_new])
 
 static inline void sgiseeq_rx(struct net_device *dev, struct sgiseeq_private *sp,
-			      volatile struct hpc3_ethregs *hregs,
-			      volatile struct sgiseeq_regs *sregs)
+			      struct hpc3_ethregs *hregs,
+			      struct sgiseeq_regs *sregs)
 {
 	struct sgiseeq_rx_desc *rd;
 	struct sk_buff *skb = 0;
@@ -333,12 +326,17 @@
 				/* Copy out of kseg1 to avoid silly cache flush. */
 				eth_copy_and_sum(skb, pkt_pointer + 2, len, 0);
 				skb->protocol = eth_type_trans(skb, dev);
-				netif_rx(skb);
-				dev->last_rx = jiffies;
-				sp->stats.rx_packets++;
-				sp->stats.rx_bytes += len;
+				if (memcmp(skb->mac.ethernet->h_source, dev->dev_addr, 6)) {
+					netif_rx(skb);
+					dev->last_rx = jiffies;
+					sp->stats.rx_packets++;
+					sp->stats.rx_bytes += len;
+				} else {
+					/* Silently drop my own packets */
+					dev_kfree_skb_irq(skb);
+				}
 			} else {
-				printk ("%s: Memory squeeze, deferring packet.\n",
+				printk (KERN_NOTICE "%s: Memory squeeze, deferring packet.\n",
 					dev->name);
 				sp->stats.rx_dropped++;
 			}
@@ -356,7 +354,7 @@
 }
 
 static inline void tx_maybe_reset_collisions(struct sgiseeq_private *sp,
-					     volatile struct sgiseeq_regs *sregs)
+					     struct sgiseeq_regs *sregs)
 {
 	if (sp->is_edlc) {
 		sregs->rw.wregs.control = sp->control & ~(SEEQ_CTRL_XCNT);
@@ -365,7 +363,7 @@
 }
 
 static inline void kick_tx(struct sgiseeq_tx_desc *td,
-			   volatile struct hpc3_ethregs *hregs)
+			   struct hpc3_ethregs *hregs)
 {
 	/* If the HPC aint doin nothin, and there are more packets
 	 * with ETXD cleared and XIU set we must make very certain
@@ -383,8 +381,8 @@
 }
 
 static inline void sgiseeq_tx(struct net_device *dev, struct sgiseeq_private *sp,
-			      volatile struct hpc3_ethregs *hregs,
-			      volatile struct sgiseeq_regs *sregs)
+			      struct hpc3_ethregs *hregs,
+			      struct sgiseeq_regs *sregs)
 {
 	struct sgiseeq_tx_desc *td;
 	unsigned long status = hregs->tx_ctrl;
@@ -409,7 +407,7 @@
 		if (!(td->tdma.cntinfo & (HPCDMA_XIU)))
 			break;
 		if (!(td->tdma.cntinfo & (HPCDMA_ETXD))) {
-			if(!(status & HPC3_ETXCTRL_ACTIVE)) {
+			if (!(status & HPC3_ETXCTRL_ACTIVE)) {
 				hregs->tx_ndptr = PHYSADDR(td);
 				hregs->tx_ctrl = HPC3_ETXCTRL_ACTIVE;
 			}
@@ -426,8 +424,10 @@
 {
 	struct net_device *dev = (struct net_device *) dev_id;
 	struct sgiseeq_private *sp = (struct sgiseeq_private *) dev->priv;
-	volatile struct hpc3_ethregs *hregs = sp->hregs;
-	volatile struct sgiseeq_regs *sregs = sp->sregs;
+	struct hpc3_ethregs *hregs = sp->hregs;
+	struct sgiseeq_regs *sregs = sp->sregs;
+
+	spin_lock(&sp->tx_lock);
 
 	/* Ack the IRQ and set software state. */
 	hregs->rx_reset = HPC3_ERXRST_CLRIRQ;
@@ -435,59 +435,47 @@
 	/* Always check for received packets. */
 	sgiseeq_rx(dev, sp, hregs, sregs);
 
-	/* Only check for tx acks iff we have something queued. */
+	/* Only check for tx acks if we have something queued. */
 	if (sp->tx_old != sp->tx_new)
 		sgiseeq_tx(dev, sp, hregs, sregs);
 
 	if ((TX_BUFFS_AVAIL(sp) > 0) && netif_queue_stopped(dev)) {
 		netif_wake_queue(dev);
 	}
+	spin_unlock(&sp->tx_lock);
 }
 
 static int sgiseeq_open(struct net_device *dev)
 {
 	struct sgiseeq_private *sp = (struct sgiseeq_private *)dev->priv;
-	volatile struct sgiseeq_regs *sregs = sp->sregs;
-	unsigned long flags;
-	int err;
-
-	__save_and_cli(flags);
+	struct sgiseeq_regs *sregs = sp->sregs;
 
-	err = -EAGAIN;
-	if (request_irq(dev->irq, sgiseeq_interrupt, 0, sgiseeqstr, dev)) {
-		printk("Seeq8003: Can't get irq %d\n", dev->irq);
-		goto out;
-	}
-	err = init_seeq(dev, sp, sregs);
+	int err = init_seeq(dev, sp, sregs);
 	if (err)
-		goto out;
+		return err;
 
 	netif_start_queue(dev);
 
-out:
-	__restore_flags(flags);
-	return err;
+	return 0;
 }
 
 static int sgiseeq_close(struct net_device *dev)
 {
 	struct sgiseeq_private *sp = (struct sgiseeq_private *) dev->priv;
-	volatile struct sgiseeq_regs *sregs = sp->sregs;
+	struct sgiseeq_regs *sregs = sp->sregs;
 
 	netif_stop_queue(dev);
 
 	/* Shutdown the Seeq. */
 	reset_hpc3_and_seeq(sp->hregs, sregs);
 
-	free_irq(dev->irq, dev);
-
 	return 0;
 }
 
 static inline int sgiseeq_reset(struct net_device *dev)
 {
 	struct sgiseeq_private *sp = (struct sgiseeq_private *) dev->priv;
-	volatile struct sgiseeq_regs *sregs = sp->sregs;
+	struct sgiseeq_regs *sregs = sp->sregs;
 	int err;
 
 	err = init_seeq(dev, sp, sregs);
@@ -509,12 +497,12 @@
 static int sgiseeq_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct sgiseeq_private *sp = (struct sgiseeq_private *) dev->priv;
-	volatile struct hpc3_ethregs *hregs = sp->hregs;
+	struct hpc3_ethregs *hregs = sp->hregs;
 	unsigned long flags;
 	struct sgiseeq_tx_desc *td;
 	int skblen, len, entry;
 
-	save_and_cli(flags);
+	spin_lock_irqsave(&sp->tx_lock, flags);
 
 	/* Setup... */
 	skblen = skb->len;
@@ -530,14 +518,14 @@
 	 * 2) Do no allow the HPC to look at a new descriptor until
 	 *    we have completely set up it's state.  This means, do
 	 *    not clear HPCDMA_EOX in the current last descritptor
-	 *    until the one we are adding looks consistant and could
+	 *    until the one we are adding looks consistent and could
 	 *    be processes right now.
 	 * 3) The tx interrupt code must notice when we've added a new
 	 *    entry and the HPC got to the end of the chain before we
 	 *    added this new entry and restarted it.
 	 */
 	memcpy((char *)(long)td->buf_vaddr, skb->data, skblen);
-	if(len != skblen)
+	if (len != skblen)
 		memset((char *)(long)td->buf_vaddr + skb->len, 0, len-skblen);
 	td->tdma.cntinfo = (len & HPCDMA_BCNT) |
 	                   (HPCDMA_XIU | HPCDMA_EOXP | HPCDMA_XIE | HPCDMA_EOX);
@@ -558,14 +546,14 @@
 
 	if (!TX_BUFFS_AVAIL(sp))
 		netif_stop_queue(dev);
-	restore_flags(flags);
+	spin_unlock_irqrestore(&sp->tx_lock, flags);
 
 	return 0;
 }
 
 static void timeout(struct net_device *dev)
 {
-	printk("%s: transmit timed out, resetting\n", dev->name);
+	printk(KERN_NOTICE "%s: transmit timed out, resetting\n", dev->name);
 	sgiseeq_reset(dev);
 
 	dev->trans_start = jiffies;
@@ -581,6 +569,22 @@
 
 static void sgiseeq_set_multicast(struct net_device *dev)
 {
+	struct sgiseeq_private *sp = (struct sgiseeq_private *) dev->priv;
+	unsigned char oldmode = sp->mode;
+
+	if(dev->flags & IFF_PROMISC)
+		sp->mode = SEEQ_RCMD_RANY;
+	else if ((dev->flags & IFF_ALLMULTI) || dev->mc_count)
+		sp->mode = SEEQ_RCMD_RBMCAST;
+	else
+		sp->mode = SEEQ_RCMD_RBCAST;
+
+	/* XXX I know this sucks, but is there a better way to reprogram
+	 * XXX the receiver? At least, this shouldn't happen too often.
+	 */
+
+	if (oldmode != sp->mode)
+		sgiseeq_reset(dev);
 }
 
 static inline void setup_tx_ring(struct sgiseeq_tx_desc *buf, int nbufs)
@@ -608,42 +612,50 @@
 	buf[i].rdma.pnext = PHYSADDR(&buf[0]);
 }
 
-static char onboard_eth_addr[6];
-
 #define ALIGNED(x)  ((((unsigned long)(x)) + 0xf) & ~(0xf))
 
-int sgiseeq_init(struct net_device *dev, struct sgiseeq_regs *sregs,
-		 struct hpc3_ethregs *hregs, int irq)
+int sgiseeq_init(struct hpc3_regs* regs, int irq)
 {
-	static unsigned version_printed;
-	int i;
+	struct net_device *dev;
 	struct sgiseeq_private *sp;
+	int err, i;
 
-	dev->priv = (struct sgiseeq_private *) get_free_page(GFP_KERNEL);
-	if (dev->priv == NULL)
-		return -ENOMEM;
+	dev = alloc_etherdev(0);
+	if (!dev) {
+		printk(KERN_ERR "Sgiseeq: Etherdev alloc failed, aborting.\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+	/* Make private data page aligned */
+	sp = (struct sgiseeq_private *) get_zeroed_page(GFP_KERNEL); 	 
+	if (!sp) {
+		printk(KERN_ERR "Sgiseeq: Page alloc failed, aborting.\n");
+		err = -ENOMEM;
+		goto err_out_free_dev;
+	}
+
+	if (request_irq(irq, sgiseeq_interrupt, 0, sgiseeqstr, dev)) {
+		printk(KERN_ERR "Seeq8003: Can't get irq %d\n", dev->irq);
+		err = -EAGAIN;
+		goto err_out_free_page;
+	}
+
+#define EADDR_NVOFS     250
+	for (i = 0; i < 3; i++) {
+		unsigned short tmp = ip22_nvram_read(EADDR_NVOFS / 2 + i);
 
-	if (!version_printed++)
-		printk(version);
-
-	printk("%s: SGI Seeq8003 ", dev->name);
-
-	for (i = 0; i < 6; i++)
-		printk("%2.2x%c",
-		       dev->dev_addr[i] = onboard_eth_addr[i],
-		       i == 5 ? ' ': ':');
-
-	printk("\n");
+		dev->dev_addr[2 * i]     = tmp >> 8;
+		dev->dev_addr[2 * i + 1] = tmp & 0xff;
+	}
 
-	sp = (struct sgiseeq_private *) dev->priv;
 #ifdef DEBUG
 	gpriv = sp;
 	gdev = dev;
 #endif
-	memset((char *)dev->priv, 0, sizeof(struct sgiseeq_private));
-	sp->sregs = sregs;
-	sp->hregs = hregs;
+	sp->sregs = (struct sgiseeq_regs *) &hpc3c0->eth_ext[0];
+	sp->hregs = &hpc3c0->ethregs;
 	sp->name = sgiseeqstr;
+	sp->mode = SEEQ_RCMD_RBCAST;
 
 	sp->srings.rx_desc = (struct sgiseeq_rx_desc *)
 	                     (KSEG1ADDR(ALIGNED(&sp->srings.rxvector[0])));
@@ -659,71 +671,78 @@
 	setup_tx_ring(sp->srings.tx_desc, SEEQ_TX_BUFFERS);
 
 	/* Reset the chip. */
-	hpc3_eth_reset((volatile struct hpc3_ethregs *) hregs);
+	hpc3_eth_reset(sp->hregs);
 
-	sp->is_edlc = !(sregs->rw.rregs.collision_tx[0] & 0xff);
-	if (sp->is_edlc) {
+	sp->is_edlc = !(sp->sregs->rw.rregs.collision_tx[0] & 0xff);
+	if (sp->is_edlc)
 		sp->control = (SEEQ_CTRL_XCNT | SEEQ_CTRL_ACCNT |
 			       SEEQ_CTRL_SFLAG | SEEQ_CTRL_ESHORT |
 			       SEEQ_CTRL_ENCARR);
+
+	dev->open		= sgiseeq_open;
+	dev->stop		= sgiseeq_close;
+	dev->hard_start_xmit	= sgiseeq_start_xmit;
+	dev->tx_timeout		= timeout;
+	dev->watchdog_timeo	= (200 * HZ) / 1000;
+	dev->get_stats		= sgiseeq_get_stats;
+	dev->set_multicast_list	= sgiseeq_set_multicast;
+	dev->irq		= irq;
+	dev->dma		= 0;
+	dev->priv		= sp;
+
+	if (register_netdev(dev)) {
+		printk(KERN_ERR "Sgiseeq: Cannot register net device, "
+		       "aborting.\n");
+		err = -ENODEV;
+		goto err_out_free_irq;
 	}
 
-	dev->open                 = sgiseeq_open;
-	dev->stop                 = sgiseeq_close;
-	dev->hard_start_xmit      = sgiseeq_start_xmit;
-	dev->tx_timeout           = timeout;
-	dev->watchdog_timeo       = (200 * HZ) / 1000;
-	dev->get_stats            = sgiseeq_get_stats;
-	dev->set_multicast_list   = sgiseeq_set_multicast;
-	dev->irq                  = irq;
-	dev->dma                  = 0;
-	ether_setup(dev);
+	printk(KERN_INFO "%s: SGI Seeq8003 ", dev->name);
+	for (i = 0; i < 6; i++)
+		printk("%2.2x%c", dev->dev_addr[i], i == 5 ? '\n' : ':');
+
+	sp->next_module = root_sgiseeq_dev;
+	root_sgiseeq_dev = dev;
 
 	return 0;
-}
 
-static inline unsigned char str2hexnum(unsigned char c)
-{
-	if (c >= '0' && c <= '9')
-		return c - '0';
-	if (c >= 'a' && c <= 'f')
-		return c - 'a' + 10;
-	return 0; /* foo */
+err_out_free_irq:
+	free_irq(irq, dev);
+err_out_free_page:
+	free_page((unsigned long) sp);
+err_out_free_dev:
+	kfree(dev);
+
+err_out:
+	return err;
 }
 
-static inline void str2eaddr(unsigned char *ea, unsigned char *str)
+static int __init sgiseeq_probe(void)
 {
-	int i;
+	printk(version);
 
-	for (i = 0; i < 6; i++) {
-		unsigned char num;
-
-		if(*str == ':')
-			str++;
-		num = str2hexnum(*str++) << 4;
-		num |= (str2hexnum(*str++));
-		ea[i] = num;
-	}
+	/* On board adapter on 1st HPC is always present */
+	return sgiseeq_init(hpc3c0, SGI_ENET_IRQ);
 }
 
-int sgiseeq_probe(struct net_device *dev)
+static void __exit sgiseeq_exit(void)
 {
-	static int initialized;
-	char *ep;
-
-	if (initialized)	/* Already initialized? */
-		return 1;
-	initialized++;
+	struct net_device *next, *dev;
+	struct sgiseeq_private *sp;
+	int irq;
 
-	/* First get the ethernet address of the onboard interface from ARCS.
-	 * This is fragile; PROM doesn't like running from cache.
-	 * On MIPS64 it crashes for some other, yet unknown reason ...
-	 */
-	ep = ArcGetEnvironmentVariable("eaddr");
-	str2eaddr(onboard_eth_addr, ep);
-	return sgiseeq_init(dev,
-			    (struct sgiseeq_regs *) (KSEG1ADDR(0x1fbd4000)),
-			    &hpc3c0->ethregs, SGI_ENET_IRQ);
+	for (dev = root_sgiseeq_dev; dev; dev = next) {
+		sp = (struct sgiseeq_private *) dev->priv;
+		next = sp->next_module;
+		irq = dev->irq;
+		unregister_netdev(dev);
+		free_irq(irq, dev);
+		free_page((unsigned long) dev->priv);
+		kfree(dev);
+	}
 }
 
+module_init(sgiseeq_probe);
+module_exit(sgiseeq_exit);
+
 MODULE_LICENSE("GPL");
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/net/Space.c linux-2.4.22/drivers/net/Space.c
--- linux-2.4.22.clean/drivers/net/Space.c	2002-08-03 02:39:44.000000000 +0200
+++ linux-2.4.22/drivers/net/Space.c	2003-05-17 03:55:31.000000000 +0200
@@ -83,7 +83,6 @@
 extern int SK_init(struct net_device *);
 extern int seeq8005_probe(struct net_device *);
 extern int smc_init( struct net_device * );
-extern int sgiseeq_probe(struct net_device *);
 extern int atarilance_probe(struct net_device *);
 extern int sun3lance_probe(struct net_device *);
 extern int sun3_82586_probe(struct net_device *);
@@ -366,14 +365,6 @@
 	{NULL, 0},
 };
 
-
-static struct devprobe sgi_probes[] __initdata = {
-#ifdef CONFIG_SGISEEQ
-	{sgiseeq_probe, 0},
-#endif
-	{NULL, 0},
-};
-
 static struct devprobe mips_probes[] __initdata = {
 #ifdef CONFIG_MIPS_JAZZ_SONIC
 	{sonic_probe, 0},
@@ -408,8 +399,6 @@
 		return 0;
 	if (probe_list(dev, mips_probes) == 0)
 		return 0;
-	if (probe_list(dev, sgi_probes) == 0)
-		return 0;
 	if (probe_list(dev, eisa_probes) == 0)
 		return 0;
 	if (probe_list(dev, mca_probes) == 0)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/parport/Config.in linux-2.4.22/drivers/parport/Config.in
--- linux-2.4.22.clean/drivers/parport/Config.in	2001-12-21 18:41:55.000000000 +0100
+++ linux-2.4.22/drivers/parport/Config.in	2003-03-25 00:45:07.000000000 +0100
@@ -61,6 +61,12 @@
       define_tristate CONFIG_PARPORT_SUNBPP n
    fi
 
+   if [ "$CONFIG_SGI_IP22" = "y" -a "$CONFIG_EXPERIMENTAL" = "y" ]; then
+      dep_tristate '  SGI Indy/Indigo2 hardware (EXPERIMENTAL)' CONFIG_PARPORT_IP22 $CONFIG_PARPORT
+   else
+      define_tristate CONFIG_PARPORT_IP22 n
+   fi
+
    # If exactly one hardware type is selected then parport will optimise away
    # support for loading any others.  Defeat this if the user is keen.
    bool '  Support foreign hardware' CONFIG_PARPORT_OTHER
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/parport/init.c linux-2.4.22/drivers/parport/init.c
--- linux-2.4.22.clean/drivers/parport/init.c	2002-11-29 00:53:14.000000000 +0100
+++ linux-2.4.22/drivers/parport/init.c	2003-03-25 00:45:07.000000000 +0100
@@ -164,6 +164,9 @@
 #ifdef CONFIG_PARPORT_SUNBPP
 	parport_sunbpp_init();
 #endif
+#ifdef CONFIG_PARPORT_IP22
+	parport_ip22_init();
+#endif
 	return 0;
 }
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/parport/Makefile linux-2.4.22/drivers/parport/Makefile
--- linux-2.4.22.clean/drivers/parport/Makefile	2001-09-14 01:04:43.000000000 +0200
+++ linux-2.4.22/drivers/parport/Makefile	2003-03-25 00:45:07.000000000 +0100
@@ -23,12 +23,13 @@
 obj-$(CONFIG_PARPORT)		+= parport.o
 obj-$(CONFIG_PARPORT_PC)	+= parport_pc.o
 obj-$(CONFIG_PARPORT_SERIAL)	+= parport_serial.o
-obj-$(CONFIG_PARPORT_PC_PCMCIA)+= parport_cs.o
+obj-$(CONFIG_PARPORT_PC_PCMCIA)	+= parport_cs.o
 obj-$(CONFIG_PARPORT_AMIGA)	+= parport_amiga.o
 obj-$(CONFIG_PARPORT_MFC3)	+= parport_mfc3.o
 obj-$(CONFIG_PARPORT_ATARI)	+= parport_atari.o
 obj-$(CONFIG_PARPORT_SUNBPP)	+= parport_sunbpp.o
 obj-$(CONFIG_PARPORT_GSC)	+= parport_gsc.o
+obj-$(CONFIG_PARPORT_IP22)	+= parport_ip22.o
 
 include $(TOPDIR)/Rules.make
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/parport/parport_ip22.c linux-2.4.22/drivers/parport/parport_ip22.c
--- linux-2.4.22.clean/drivers/parport/parport_ip22.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/parport/parport_ip22.c	2003-03-25 00:45:07.000000000 +0100
@@ -0,0 +1,315 @@
+/*
+ * Low-level parallel port routines for the SGI Indy/Indigo2 builtin port
+ *
+ * Copyright (c) 2002 Vincent Stehl <vincent.stehle@free.fr>
+ * (shamelessly based on other parport_xxx.c)
+ * See the "COPYING" license file at the top-level.
+ *
+ * PI1 registers have the same bits as the PC parallel port registers, but
+ * all PI1 bits are "direct"; i.e. no invertion: A 1 is TTL "high" (5 V),
+ * a 0 is TTL "low" (0 V). There are also some bits on the PI1, which have
+ * no equivalents on the PC. They are for non-SPP modes.
+ *
+ * Here follows a little summary of the signals and their meanings:
+ *
+ * A "/" in front of a signal means that the _bit_ is inverted: i.e. a "1"
+ * bit value means a TTL "low" (0 V) signal.
+ *
+ * A "-" in front of a signal means that it is low active: i.e. a TTL "low"
+ * (0 V) value means that the signal is active.
+ *
+ * Internal only signals are between ()'s.
+ *
+ * Control
+ * -------
+ *                   PC                     SGI
+ *
+ * 7 6 5 4 3 2 1 0
+ *  \ \ \ \ \ \ \ `- /-STROBE               -STROBE
+ *   \ \ \ \ \ \ `-- /-AUTO FEED            -AFD
+ *    \ \ \ \ \ `---  -INIT                 -INIT
+ *     \ \ \ \ `---- /-SELECT               -SLIN
+ *      \ \ \ `----- (IRQ 1=enabled)
+ *       \ \ `------ (DIRECTION 0=forward)
+ *        \ `-------                        (SEL ?)
+ *         `--------
+ *
+ * Status
+ * ------
+ *                   PC                     SGI
+ *
+ * 7 6 5 4 3 2 1 0
+ *  \ \ \ \ \ \ \ `-                         DEVID
+ *   \ \ \ \ \ \ `--                          " "
+ *    \ \ \ \ \ `---                         NOINK
+ *     \ \ \ \ `----  -ERROR                -ERROR
+ *      \ \ \ `-----   SELECT IN             ONLINE
+ *       \ \ `------   PAPER END             PE
+ *        \ `-------  -ACK                  -ACK
+ *         `-------- / BUSY                  BUSY
+ *
+ * Note that some of those information have been "guessed" with a multimeter
+ * and some spare nights :)
+ *
+ * Reminder: all functions await PC-style values, i.e. one should convert
+ *           status and control.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/parport.h>
+#include <asm/sgi/ioc.h>
+
+#define DEBUG
+
+#ifdef DEBUG
+#define DPRINTK printk
+#else
+#define DPRINTK(x...)	do { } while (0)
+#endif
+
+const unsigned char control_invert = PARPORT_CONTROL_STROBE
+	| PARPORT_CONTROL_AUTOFD | PARPORT_CONTROL_SELECT;
+const unsigned char status_invert = PARPORT_STATUS_BUSY;
+
+static struct parport *this_port = NULL;
+
+static inline void debug_dump_registers(void)
+{
+#ifdef DEBUG
+	printk(KERN_DEBUG
+		"PI1 registers:\n"
+		"             data= %02x\n"
+		"          control= %02x\n"
+		"           status= %02x\n"
+		"      dma control= %02x\n"
+		" interrupt status= %02x\n"
+		"   interrupt mask= %02x\n"
+		"          timer 1= %02x\n"
+		"          timer 2= %02x\n"
+		"          timer 3= %02x\n"
+		"          timer 4= %02x\n"
+		,
+		sgioc->pport.data,
+		sgioc->pport.ctrl,
+		sgioc->pport.status,
+		sgioc->pport.dmactrl,
+		sgioc->pport.intrstat,
+		sgioc->pport.intrmask,
+		sgioc->pport.timer1,
+		sgioc->pport.timer2,
+		sgioc->pport.timer3,
+		sgioc->pport.timer4
+	);
+#endif
+}
+
+static unsigned char parport_ip22_read_data(struct parport *p)
+{
+	unsigned char data = sgioc->pport.data;
+	DPRINTK("parport_ip22_read_data: %#x\n", data);
+	return data;
+}
+
+static void parport_ip22_write_data(struct parport *p, unsigned char data)
+{
+	DPRINTK("parport_ip22_write_data: %#x\n", data);
+	sgioc->pport.data = data;
+}
+
+static unsigned char parport_ip22_read_control(struct parport *p)
+{
+	const unsigned char mask = PARPORT_CONTROL_STROBE
+		| PARPORT_CONTROL_AUTOFD | PARPORT_CONTROL_INIT
+		| PARPORT_CONTROL_SELECT;
+	unsigned char pctrl = sgioc->pport.ctrl,
+		control = ((pctrl & mask) ^ control_invert);
+	DPRINTK("parport_ip22_read_control: %#x, %#x\n", pctrl, control);
+	return control;
+}
+
+static void parport_ip22_write_control(struct parport *p, unsigned char control)
+{
+	const unsigned char mask = PARPORT_CONTROL_STROBE
+		| PARPORT_CONTROL_AUTOFD | PARPORT_CONTROL_INIT
+		| PARPORT_CONTROL_SELECT,
+	/* we enforce some necessary bits */
+		force = 0x30;
+	unsigned char pctrl = ((control & mask) ^ control_invert) | force;
+	DPRINTK("parport_ip22_write_control: %#x, %#x\n", control, pctrl);
+	sgioc->pport.ctrl = pctrl;
+}
+
+static unsigned char parport_ip22_frob_control(struct parport *p,
+	unsigned char mask, unsigned char val)
+{
+	unsigned char old;
+	DPRINTK(KERN_DEBUG "parport_ip22_frob_control mask %02x, value %02x\n",mask,val);
+	old = parport_ip22_read_control(p);
+	parport_ip22_write_control(p, (old & ~mask) ^ val);
+	return old;
+}
+
+static unsigned char parport_ip22_read_status(struct parport *p)
+{
+	const unsigned mask = PARPORT_STATUS_ERROR | PARPORT_STATUS_SELECT
+		| PARPORT_STATUS_PAPEROUT | PARPORT_STATUS_ACK
+		| PARPORT_STATUS_BUSY;
+	unsigned char pstat = sgioc->pport.status,
+		status = ((pstat & mask) ^ status_invert);
+	DPRINTK("parport_ip22_read_status: %#x, %#x\n", pstat, status);
+	return status;
+}
+
+static void parport_ip22_init_state(struct pardevice *d, struct parport_state *s)
+{
+	DPRINTK("parport_ip22_init_state\n");
+}
+
+static void parport_ip22_save_state(struct parport *p, struct parport_state *s)
+{
+	DPRINTK("parport_ip22_save_state\n");
+}
+
+static void parport_ip22_restore_state(struct parport *p, struct parport_state *s)
+{
+	DPRINTK("parport_ip22_restore_state\n");
+}
+
+static void parport_ip22_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	DPRINTK("parport_ip22_interrupt\n");
+	parport_generic_irq(irq, (struct parport *) dev_id, regs);
+}
+
+static void parport_ip22_enable_irq(struct parport *p)
+{
+	DPRINTK("parport_ip22_enable_irq\n");
+}
+
+static void parport_ip22_disable_irq(struct parport *p)
+{
+	DPRINTK("parport_ip22_disable_irq\n");
+}
+
+static void parport_ip22_data_forward(struct parport *p)
+{
+	DPRINTK("parport_ip22_data_forward\n");
+	sgioc->pport.ctrl &= ~SGIOC_PCTRL_DIRECTION;
+}
+
+static void parport_ip22_data_reverse(struct parport *p)
+{
+	DPRINTK("parport_ip22_data_reverse\n");
+	sgioc->pport.ctrl |= SGIOC_PCTRL_DIRECTION;
+}
+
+static void parport_ip22_inc_use_count(void)
+{
+	DPRINTK("parport_ip22_inc_use_count\n");
+#	ifdef MODULE
+	MOD_INC_USE_COUNT;
+#	endif
+}
+
+static void parport_ip22_dec_use_count(void)
+{
+	DPRINTK("parport_ip22_dec_use_count\n");
+#	ifdef MODULE
+	MOD_DEC_USE_COUNT;
+#	endif
+}
+
+static struct parport_operations parport_ip22_ops = {
+	parport_ip22_write_data,
+	parport_ip22_read_data,
+	parport_ip22_write_control,
+	parport_ip22_read_control,
+	parport_ip22_frob_control,
+	parport_ip22_read_status,
+	parport_ip22_enable_irq,
+	parport_ip22_disable_irq,
+	parport_ip22_data_forward,
+	parport_ip22_data_reverse,
+	parport_ip22_init_state,
+	parport_ip22_save_state,
+	parport_ip22_restore_state,
+	parport_ip22_inc_use_count,
+	parport_ip22_dec_use_count,
+	parport_ieee1284_epp_write_data,
+	parport_ieee1284_epp_read_data,
+	parport_ieee1284_epp_write_addr,
+	parport_ieee1284_epp_read_addr,
+	parport_ieee1284_ecp_write_data,
+	parport_ieee1284_ecp_read_data,
+	parport_ieee1284_ecp_write_addr,
+	parport_ieee1284_write_compat,
+	parport_ieee1284_read_nibble,
+	parport_ieee1284_read_byte
+};
+
+static void init_hardware(void)
+{
+	sgioc->pport.intrmask = 0xfc;
+	sgioc->pport.dmactrl = 1;
+	sgioc->pport.ctrl = 0x3f;
+	sgioc->pport.timer1 = 0;
+	sgioc->pport.timer2 = 0;
+	sgioc->pport.timer3 = 0;
+	sgioc->pport.timer4 = 0;
+	sgioc->pport.data = 0;
+}
+
+int __init parport_ip22_init(void)
+{
+	struct parport *p;
+
+	DPRINTK("parport_ip22_init\n");
+	p = parport_register_port((unsigned long)&sgioc->pport.data, PARPORT_IRQ_NONE,
+		PARPORT_DMA_NONE, &parport_ip22_ops);
+	if (!p)
+		return -EBUSY;
+
+/* TODO
+	err = request_irq(IRQ_AMIGA_CIAA_FLG, amiga_interrupt, 0, p->name, p);
+	if (err)
+		goto out_irq;
+*/
+	
+	/* tell what we are capable of */
+	p->modes = PARPORT_MODE_PCSPP;
+
+/* TODO
+	 | PARPORT_MODE_TRISTATE;*/
+
+	/* remember for exit */
+	this_port = p;
+
+	/* put hardware into known initial state */
+	init_hardware();
+
+	printk(KERN_INFO "%s: SGI Indy/Indigo2 built-in port\n", p->name);
+	parport_proc_register(p);
+	parport_announce_port(p);
+
+	return 0;
+}
+
+void __exit parport_ip22_exit(void)
+{
+	DPRINTK("parport_ip22_exit\n");
+	if (this_port->irq != PARPORT_IRQ_NONE)
+		free_irq(this_port->irq, this_port);
+
+	parport_proc_unregister(this_port);
+	parport_unregister_port(this_port);
+}
+
+MODULE_AUTHOR("Vincent Stehl <vincent.stehle@free.fr>");
+MODULE_DESCRIPTION("Driver for SGI Indy/Indigo2 parallel port");
+MODULE_SUPPORTED_DEVICE("SGI PI1 parallel port");
+MODULE_LICENSE("GPL");
+
+module_init(parport_ip22_init);
+module_exit(parport_ip22_exit);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/pci/pci.c linux-2.4.22/drivers/pci/pci.c
--- linux-2.4.22.clean/drivers/pci/pci.c	2003-06-13 16:51:35.000000000 +0200
+++ linux-2.4.22/drivers/pci/pci.c	2003-02-25 23:03:08.000000000 +0100
@@ -1276,11 +1276,17 @@
 {
 	unsigned int buses;
 	unsigned short cr;
+	unsigned short bctl;
 	struct pci_bus *child;
 	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
 
 	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
 	DBG("Scanning behind PCI bridge %s, config %06x, pass %d\n", dev->slot_name, buses & 0xffffff, pass);
+	/* Disable MasterAbortMode during probing to avoid reporting
+           of bus errors (in some architectures) */
+	pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &bctl);
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, 
+			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
 	if ((buses & 0xffff00) && !pcibios_assign_all_busses()) {
 		/*
 		 * Bus already configured by firmware, process it in the first
@@ -1339,6 +1345,7 @@
 		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
 		pci_write_config_word(dev, PCI_COMMAND, cr);
 	}
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, bctl);
 	sprintf(child->name, (is_cardbus ? "PCI CardBus #%02x" : "PCI Bus #%02x"), child->number);
 	return max;
 }
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/pcmcia/Config.in linux-2.4.22/drivers/pcmcia/Config.in
--- linux-2.4.22.clean/drivers/pcmcia/Config.in	2002-08-03 02:39:44.000000000 +0200
+++ linux-2.4.22/drivers/pcmcia/Config.in	2003-07-14 18:14:06.000000000 +0200
@@ -29,5 +29,20 @@
    if [ "$CONFIG_8xx" = "y" ]; then
       dep_tristate '  M8xx support' CONFIG_PCMCIA_M8XX $CONFIG_PCMCIA
    fi
+   if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
+      dep_tristate '  Au1x00 PCMCIA support' CONFIG_PCMCIA_AU1X00 $CONFIG_PCMCIA 
+      if [ "$CONFIG_PCMCIA_AU1X00" != "n" ]; then
+        bool '  Pb1x00 board support' CONFIG_PCMCIA_PB1X00
+        bool '  Db1x00 board support' CONFIG_PCMCIA_DB1X00
+        bool '  XXS1500 board support' CONFIG_PCMCIA_XXS1500
+      fi
+   fi
+   if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
+      dep_bool '  SiByte PCMCIA support' CONFIG_PCMCIA_SIBYTE $CONFIG_PCMCIA $CONFIG_BLK_DEV_IDE_SIBYTE
+   fi
+   if [ "$CONFIG_VRC4173" != "n" ]; then
+      dep_tristate '  NEC VRC4173 CARDU support' CONFIG_PCMCIA_VRC4173 $CONFIG_PCMCIA
+   fi
 fi
+
 endmenu
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/pcmcia/Makefile linux-2.4.22/drivers/pcmcia/Makefile
--- linux-2.4.22.clean/drivers/pcmcia/Makefile	2002-08-03 02:39:44.000000000 +0200
+++ linux-2.4.22/drivers/pcmcia/Makefile	2003-07-14 18:14:06.000000000 +0200
@@ -59,8 +59,15 @@
   endif
 endif
 
+obj-$(CONFIG_PCMCIA_AU1X00)			+= au1x00_ss.o
+au1000_ss-objs-y				:= au1000_generic.o
+au1000_ss-objs-$(CONFIG_PCMCIA_PB1X00)		+= au1000_pb1x00.o
+au1000_ss-objs-$(CONFIG_PCMCIA_DB1X00)		+= au1000_db1x00.o
+au1000_ss-objs-$(CONFIG_PCMCIA_XXS1500) 	+= au1000_xxs1500.o
+
 obj-$(CONFIG_PCMCIA_SA1100)	+= sa1100_cs.o
 obj-$(CONFIG_PCMCIA_M8XX)	+= m8xx_pcmcia.o
+obj-$(CONFIG_PCMCIA_SIBYTE)	+= sibyte_generic.o
 
 sa1100_cs-objs-y				:= sa1100_generic.o
 sa1100_cs-objs-$(CONFIG_SA1100_ADSBITSY)	+= sa1100_adsbitsy.o sa1111_generic.o
@@ -82,6 +89,8 @@
 sa1100_cs-objs-$(CONFIG_SA1100_XP860)		+= sa1100_xp860.o sa1111_generic.o
 sa1100_cs-objs-$(CONFIG_SA1100_YOPY)		+= sa1100_yopy.o
 
+obj-$(CONFIG_PCMCIA_VRC4173)	+= vrc4173_cardu.o
+
 include $(TOPDIR)/Rules.make
 
 pcmcia_core.o:  $(pcmcia_core-objs)
@@ -90,5 +99,8 @@
 sa1100_cs.o: $(sa1100_cs-objs-y)
 	$(LD) -r -o $@ $(sa1100_cs-objs-y)
 
+au1x00_ss.o: $(au1000_ss-objs-y)
+	$(LD) -r -o $@ $(au1000_ss-objs-y)
+
 yenta_socket.o: $(yenta_socket-objs)
 	$(LD) $(LD_RFLAG) -r -o $@ $(yenta_socket-objs)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/pcmcia/sibyte_generic.c linux-2.4.22/drivers/pcmcia/sibyte_generic.c
--- linux-2.4.22.clean/drivers/pcmcia/sibyte_generic.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/pcmcia/sibyte_generic.c	2003-07-14 18:14:06.000000000 +0200
@@ -0,0 +1,688 @@
+/*
+ * Copyright (C) 2003 Broadcom Corporation
+ *    originally contributed to SiByte, Inc as
+ *    "sb1250pc.c 0.10 (Stanley Chen & James Liao)"
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * Notes / Apologies:
+ *   - only ATA cards tested so far
+ *   - requires hack in cs.c to avoid poking the CISCOR register
+ *   - ack_intr routine might be improved to avoid error msgs.
+ *   - remove and re-insert doesn't work (crash or fail to probe drive)
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/timer.h>
+#include <linux/ide.h>
+
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/bulkmem.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/cs.h>
+#include "cs_internal.h"
+
+#include <asm/io.h>
+
+#include <asm/sibyte/board.h>
+#include <asm/sibyte/sb1250_regs.h>
+#include <asm/sibyte/sb1250_scd.h>
+#include <asm/sibyte/sb1250_int.h>
+#include <asm/sibyte/sb1250_genbus.h>
+#include <asm/sibyte/64bit.h>
+
+#define PFX "sibyte-pcmcia: "
+
+MODULE_AUTHOR("Kip Walker, Stanley Chen & James Liao");
+MODULE_DESCRIPTION("SiByte PCMCIA socket driver");
+
+#undef PCMCIA_DEBUG
+#ifdef PCMCIA_DEBUG
+#define DPRINTK(args...) do { printk(KERN_DEBUG args); } while (0)
+#else
+#define DPRINTK(n, args...) do { } while (0)
+#endif
+
+static unsigned long sb_pcmcia_base = PCMCIA_PHYS;
+static unsigned long sb_pcmcia_size;
+#define SIBYTE_CS_REG(pcaddr)  (IO_SPACE_BASE + sb_pcmcia_base - mips_io_port_base + pcaddr)
+#define SB_PC_PORT 0xff00
+extern void sibyte_set_ideops(ide_hwif_t *hwif);
+
+/* The card status change interrupt */
+static int cs_irq = K_INT_PCMCIA;
+
+/* Memory map windows */
+static struct pccard_mem_map sibyte_memmap[MAX_WIN];
+static struct pccard_io_map  sibyte_iomap[MAX_IO_WIN];
+
+/*====================================================================*/
+/* Socket structures                                                  */
+/*====================================================================*/
+
+
+static void sb1250pc_interrupt(int irq, void *dev, struct pt_regs *regs);
+static struct pccard_operations sb1250pc_operations;
+
+typedef struct socket_handler_t {
+	void	(*handler)(void *info, u_int events);
+	void	*info;
+} socket_handler_t;
+
+static socket_handler_t socket_handler;
+
+/*
+ * cap features:
+ *   full 32-bit addressing for 16-bit PCcard memory windows
+ *   16-bit card memory and IO accesses need bus_ops
+ *   only 16-bit PCcards
+ *   align memory windows
+ *   statically mapped memory windows
+ */
+static socket_cap_t sb1250pc_cap = {
+	features: (SS_CAP_PAGE_REGS |
+//		   SS_CAP_VIRTUAL_BUS |
+		   SS_CAP_PCCARD |
+		   SS_CAP_MEM_ALIGN | SS_CAP_STATIC_MAP),
+	irq_mask:  0,		/* tell ide layer to take PCI irq */
+	map_size:  0x4000000,	/* 64MB minimum window size (What *should* this be?)*/
+	io_offset: SB_PC_PORT,	/* This is ide5 -- just a special token for ide-sibyte */
+	pci_irq:   K_INT_PC_READY, /* XXXKW This serves as IREQ# for CompactFlash */
+	cb_dev:    NULL,
+	bus:       NULL
+};
+
+/*====================================================================*/
+/* Useful macros                                                      */
+/*====================================================================*/
+
+#define READ_PHYSADDR(addr) (*(volatile u32 *)(KSEG1ADDR(addr)))
+#define WRITE_PHYSADDR(addr, data) (*(volatile u32 *)(KSEG1ADDR(addr))) = (data)
+
+#define READ_CSR32(reg)		csr_in32(IO_SPACE_BASE + (reg))
+#define WRITE_CSR32(data, reg)	csr_out32(data, IO_SPACE_BASE + (reg))
+
+#define sb1250pc_write_config(data)	WRITE_CSR32(data, A_IO_PCMCIA_CFG)
+#define sb1250pc_read_config()		READ_CSR32(A_IO_PCMCIA_CFG)
+#define sb1250pc_read_status()		READ_CSR32(A_IO_PCMCIA_STATUS)
+
+#define CARDPRESENT(s) (((s) & (M_PCMCIA_STATUS_CD1 | M_PCMCIA_STATUS_CD2)) == 0)
+
+int sb_pcmcia_ack_intr(struct hwif_s *hwif)
+{
+	/*
+	 * XXXKW verify interrupt and return appropriate value?
+	 * Simple check of the bit in A_GPIO_READ didn't DTRT
+	 */
+
+	/* Clear out the GPIO edge detector */
+	WRITE_CSR32(1 << K_GPIO_PC_READY, A_GPIO_CLR_EDGE);
+	return 1;
+}
+
+/*====================================================================*/
+/* Interrupt handling                                                 */
+/*====================================================================*/
+
+static unsigned int pending_events;
+static spinlock_t pending_event_lock = SPIN_LOCK_UNLOCKED;
+
+static void sb1250pc_bh(void *dummy)
+{
+	unsigned int events;
+
+	spin_lock_irq(&pending_event_lock);
+	events = pending_events;
+	pending_events = 0;
+	spin_unlock_irq(&pending_event_lock);
+
+	if (socket_handler.handler)
+		socket_handler.handler(socket_handler.info, events);
+}
+
+static struct tq_struct sb1250pc_task =
+{
+	routine:	sb1250pc_bh
+};
+
+static void sb1250pc_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	unsigned int events = 0;
+	uint32_t status;
+
+	status = sb1250pc_read_status();
+
+	if (status & M_PCMCIA_STATUS_CDCHG) {
+		events = SS_DETECT;
+		if (CARDPRESENT(status)) {
+			events |= SS_INSERTION;
+		} else {
+			events |= SS_EJECTION;
+		}
+	}
+#if 0
+	/* XXXKW ignore everything but CD? */
+	if (status & M_PCMCIA_STATUS_RDYCHG) {
+		if (status & M_PCMCIA_STATUS_RDY) {
+			/* XXXKW if ide, ack the interrupt? */
+			events |= SS_READY;
+		}
+	}
+#endif
+
+	if (events) {
+		DPRINTK(PFX " passing %x to bh\n", events);
+
+		/* Pass the events off to the bottom-half */
+		spin_lock(&pending_event_lock);
+		pending_events |= events;
+		spin_unlock(&pending_event_lock);
+		schedule_task(&sb1250pc_task);
+	}
+}
+
+/*====================================================================*/
+/* PC Card Operations                                                 */
+/*====================================================================*/
+
+static int sb1250pc_register_callback(unsigned int lsock,
+				      void (*handler)(void *, unsigned int),
+				      void * info)
+{
+	DPRINTK(PFX "sb1250pc_register_callback(%d)\n", lsock);
+
+	socket_handler.handler = handler;
+	socket_handler.info = info;
+	if (handler == NULL) {
+		MOD_DEC_USE_COUNT;
+	} else {
+		MOD_INC_USE_COUNT;
+	}
+	return 0;
+}
+
+/*====================================================================*/
+
+static int sb1250pc_get_status(unsigned int lsock, u_int *value)
+{
+	u_int val;
+	uint32_t status;
+#if PCMCIA_DEBUG
+	u32 config;
+#endif
+
+	status = sb1250pc_read_status();
+#if PCMCIA_DEBUG
+	config = sb1250pc_read_config();
+#endif
+
+	val = CARDPRESENT(status) ? SS_DETECT : 0;
+	val |= (status & M_PCMCIA_CFG_RESET) ? SS_RESET : 0;
+	val |= (status & (M_PCMCIA_STATUS_3VEN | M_PCMCIA_STATUS_5VEN)) ?
+		SS_POWERON : 0;
+	val |= (status & M_PCMCIA_STATUS_RDY) ? SS_READY : 0;
+	val |= (status & M_PCMCIA_STATUS_WP) ? SS_WRPROT : 0;
+	val |= ((status & M_PCMCIA_STATUS_VS2) &&
+		(~status & M_PCMCIA_STATUS_VS1)) ? SS_3VCARD : 0;
+	val |= (status & (M_PCMCIA_STATUS_CDCHG | M_PCMCIA_STATUS_WPCHG
+			  | M_PCMCIA_STATUS_RDYCHG)) ? SS_STSCHG : 0;
+	/* XXXKW SS_INSERTION on cdchange? */
+
+	DPRINTK(PFX "GetStatus(%d) = %x", lsock, val);
+#if PCMCIA_DEBUG
+	DPRINTK(" [config(0x%4.4x) status(0x%4.4x)]", config, status);
+#endif
+	DPRINTK("\n");
+
+	*value = val;
+	return 0;
+}
+
+/*====================================================================*/
+
+static int sb1250pc_inquire_socket(unsigned int lsock, socket_cap_t *cap)
+{
+	*cap = sb1250pc_cap;
+
+	DPRINTK(PFX "InquireSocket(%d) = features 0x%4.4x, irq_mask "
+	       "0x%4.4x, map_size 0x%4.4x\n", lsock, cap->features,
+	       cap->irq_mask, cap->map_size);
+
+	return 0;
+}
+
+/*====================================================================*/
+
+// This garbage function never seems to get called...
+static int sb1250pc_get_socket(unsigned int lsock, socket_state_t *state)
+{
+	DPRINTK(PFX "Does GetSocket(%d) ever get called???", lsock);
+	return -1;
+} /* sb1250pc_get_socket */
+
+/*====================================================================*/
+
+static uint32_t sibyte_set_power(uint32_t config, int vcc)
+{
+	config &= ~(M_PCMCIA_CFG_3VEN | M_PCMCIA_CFG_5VEN);
+	if (vcc == 33) {
+		config |= M_PCMCIA_CFG_3VEN;
+	} else if (vcc == 50) {
+		config |= M_PCMCIA_CFG_5VEN;
+	}
+
+	sb1250pc_write_config(config);
+	return config;
+}
+
+static int sb1250pc_set_socket(unsigned int lsock, socket_state_t *state)
+{
+	uint32_t config;
+
+	DPRINTK(PFX "SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, "
+	       "io_irq %d, csc_mask %#2.2x)\n", lsock, state->flags,
+	       state->Vcc, state->Vpp, state->io_irq, state->csc_mask);
+
+	config = sb1250pc_read_config();
+
+	config = sibyte_set_power(config, state->Vcc);
+
+	if (state->flags & SS_DEBOUNCED)
+		state->flags &= ~SS_DEBOUNCED; /* SS_DEBOUNCED is oneshot */
+	/* XXXKW SS_OUTPUT_ENA? */
+	/* XXXKW SS_PWR_AUTO? */
+	/* XXXKW SS_IOCARD? */
+
+	if (state->csc_mask & SS_DETECT)
+		config &= ~M_PCMCIA_CFG_CDMASK;
+	else
+		config |= M_PCMCIA_CFG_CDMASK;
+
+	config &= ~M_PCMCIA_CFG_RESET;
+	if (state->flags & SS_RESET) {
+		DPRINTK(PFX "  resetting PCMCIA\n");
+		config |= M_PCMCIA_CFG_RESET;
+	}
+	sb1250pc_write_config(config);
+
+	DPRINTK(PFX "  new config: %x\n", sb1250pc_read_config());
+
+	return 0;
+}
+
+/*====================================================================*/
+
+static int sb1250pc_get_io_map(unsigned int lsock, struct pccard_io_map *io)
+{
+	*io = sibyte_iomap[io->map];
+
+	DPRINTK(PFX "GetIOMap(%d, %d) = %#2.2x, %d ns, "
+	       "%#4.4x-%#4.4x\n", lsock, io->map, io->flags,
+	       io->speed, io->start, io->stop);
+	return 0;
+} /* sb1250pc_get_io_map */
+
+static int sb1250pc_set_io_map(unsigned int lsock, struct pccard_io_map *io)
+{
+   	unsigned int speed;
+	unsigned long start;
+	u32 config;
+
+	/* SB1250 uses direct mapping */
+	DPRINTK(PFX "SetIOMap(%d, %d, %#2.2x, %d ns, "
+	       "%#4.4x-%#4.4x) called\n", lsock, io->map, io->flags,
+	       io->speed, io->start, io->stop);
+
+	if (io->map >= MAX_IO_WIN) {
+		DPRINTK(KERN_ERR PFX "map (%d) out of range\n", io->map);
+		return -1;
+	}
+
+	if (io->flags & MAP_ACTIVE) {
+		speed = (io->speed > 0) ? io->speed : 255;
+	}
+
+	config = sb1250pc_read_config();
+
+	if (io->flags & MAP_ATTRIB) {
+		DPRINTK(PFX "  Setting pcmcia_cfg_reg to 1  (Attribute Mode)\n");
+		config |= M_PCMCIA_CFG_ATTRMEM;
+	} else {
+		DPRINTK(PFX "  Setting pcmcia_cfg_reg to 0  (Data Mode)\n");
+		config &= ~M_PCMCIA_CFG_ATTRMEM;
+	}
+	sb1250pc_write_config(config);
+
+	start = io->start;
+
+	if (io->stop == 1) {
+		io->stop = PAGE_SIZE - 1;
+	}
+
+	if (io->start == 0)
+		io->start = sb_pcmcia_base;
+
+	io->stop = io->start + (io->stop - start);
+
+	sibyte_iomap[io->map] = *io;
+
+	DPRINTK(PFX "SetIOMap(%d, %d, %#2.2x, %d ns, "
+	       "%#4.4x-%#4.4x) returns\n", lsock, io->map, io->flags,
+	       io->speed, io->start, io->stop);
+	return 0;
+} /* sb1250pc_set_io_map */
+
+/*====================================================================*/
+
+static int sb1250pc_get_mem_map(unsigned int lsock, struct pccard_mem_map *mem)
+{
+	if(mem->map >= MAX_WIN)
+		return -EINVAL;
+	
+	*mem = sibyte_memmap[mem->map];
+
+	DPRINTK(PFX "GetMemMap(%d, mem[%d, %#2.2x, %d ns, "
+	       "%#5.5lx-%#5.5lx, %#5.5x) called\n", lsock, mem->map, mem->flags,
+	       mem->speed, mem->sys_start, mem->sys_stop, mem->card_start);
+
+	return 0;
+}
+
+static int sb1250pc_set_mem_map(unsigned int lsock, struct pccard_mem_map *mem)
+{
+	u32 old_config, new_config;
+
+	if (mem->map >= MAX_WIN) {
+		DPRINTK(KERN_ERR PFX "map (%d) out of range\n", mem->map);
+		return -1;
+	}
+
+	if (mem->sys_start == 0)
+		mem->sys_start = mem->card_start + sb_pcmcia_base;
+
+	if (mem->sys_stop == 0)
+		mem->sys_stop = mem->sys_start + sb_pcmcia_size - 1;
+
+	old_config = sb1250pc_read_config();
+
+	DPRINTK(PFX "  Setting mem_map %p\n", mem);
+	if (mem->flags & MAP_ATTRIB) {
+		DPRINTK(PFX "  Setting pcmcia_cfg_reg to 1 (Attribute Mode)\n");
+		new_config = old_config | M_PCMCIA_CFG_ATTRMEM;
+	} else {
+		DPRINTK(PFX "  Setting pcmcia_cfg_reg to 0 (Data Mode)\n");
+		new_config = old_config & ~M_PCMCIA_CFG_ATTRMEM;
+	}
+	if (new_config != old_config)
+		sb1250pc_write_config(new_config);
+
+	sibyte_memmap[mem->map] = *mem;
+
+	DPRINTK(PFX "SetMemMap(%d, mem[%d, %#2.2x, %d ns], "
+	       "%#5.5lx-%#5.5lx, %#5.5x)\n", lsock, mem->map, mem->flags,
+	       mem->speed, mem->sys_start, mem->sys_stop, mem->card_start);
+
+	return 0;
+}
+
+/*====================================================================*/
+
+#ifdef CONFIG_PROC_FS
+/* sb1250pc_proc_status()
+ * Implements the /proc/bus/pccard/??/status file.
+ *
+ * Returns: the number of characters added to the buffer
+ *
+ * Be aware that reading status clears the "change" bits; this seems
+ * unlikely to bite us by making us miss interrupts.
+ */
+static int sb1250pc_proc_status(char *buf, char **start, off_t pos,
+				int count, int *eof, void *data)
+{
+	char *p = buf;
+	u32 addr, temp;
+	u32 status, config;
+	//unsigned int sock = (unsigned int) data;
+
+	config = sb1250pc_read_config();
+	status = sb1250pc_read_status();
+	p += sprintf(p, "config(0x%4.4x) status(0x%4.4x)\n", config, status);
+
+	for (addr = sb_pcmcia_base; addr < sb_pcmcia_base + 8; addr+=4) {
+		temp = READ_PHYSADDR(addr);
+		p += sprintf(p, " Looking up addr 0x%x: 0x%8.8x\n", addr, temp);
+	}
+
+	return p - buf;
+}
+
+static void sb1250pc_proc_setup(unsigned int sock, struct proc_dir_entry *base)
+{
+	struct proc_dir_entry *entry;
+	
+	if ((entry = create_proc_entry("sb1250pc", 0, base)) == NULL) {
+		printk(KERN_ERR PFX "Unable to install \"sb1250pc\" procfs entry\n");
+		return;
+	} else
+		printk(KERN_INFO PFX "Setting up \"sb1250pc\" procfs entry\n");
+	
+	entry->read_proc = sb1250pc_proc_status;
+	entry->data = (void *) sock;
+}
+
+#endif
+
+/*====================================================================*/
+
+static int sibyte_pcmcia_initted = 0;
+
+static int sb1250pc_init(unsigned int s)
+{
+	u32 config, status;
+	
+	DPRINTK(PFX "Initializing SB1250 PCMCIA:\n");
+
+	/* Read status to clear interrupt sources */
+	status = sb1250pc_read_status();
+
+	/*
+	 * Before getting setting up the IRQ, set the config:
+	 *   reset off, auto-power off
+	 *   interrupt mask: WP, CD, Ready off
+	 */
+	config = sb1250pc_read_config();
+	config = M_PCMCIA_CFG_CDMASK | M_PCMCIA_CFG_WPMASK | M_PCMCIA_CFG_RDYMASK;
+	sb1250pc_write_config(config);
+	   
+	if (!sibyte_pcmcia_initted) {
+		uint32_t gpio_ctrl;
+		/* Set up the GPIO for PC_READY for use in ide-cs */
+		gpio_ctrl = READ_CSR32(A_GPIO_INT_TYPE);
+		gpio_ctrl &= ~M_GPIO_INTR_TYPEX(K_GPIO_PC_READY);
+		gpio_ctrl |= V_GPIO_INTR_TYPEX(K_GPIO_PC_READY, K_GPIO_INTR_EDGE);
+		WRITE_CSR32(gpio_ctrl, A_GPIO_INT_TYPE);
+		WRITE_CSR32(1 << K_GPIO_PC_READY, A_GPIO_CLR_EDGE);
+
+		/* Invert to get busy->ready transition */
+		gpio_ctrl = READ_CSR32(A_GPIO_INPUT_INVERT);
+		gpio_ctrl |= 1 << K_GPIO_PC_READY;
+		WRITE_CSR32(gpio_ctrl, A_GPIO_INPUT_INVERT);
+
+		/* Should not be any pending since we masked all sources */
+		if (request_irq(cs_irq, sb1250pc_interrupt, 0, "pcmcia", NULL))
+			return -ENODEV;
+		DPRINTK(PFX "  IRQ %d registered\n", cs_irq);
+
+		sibyte_pcmcia_initted = 1;
+	}
+	
+	status = sb1250pc_read_status();
+	DPRINTK(PFX "  config(0x%4.4x) status(0x%4.4x)\n", config, status);
+
+	sb1250pc_set_socket(s, &dead_socket);
+
+	return 0;
+}
+
+static int sb1250pc_suspend(unsigned int sock)
+{
+	free_irq(cs_irq, NULL);
+	DPRINTK(KERN_INFO PFX "  IRQ %d freed\n", cs_irq);
+	return sb1250pc_set_socket(sock, &dead_socket);
+}
+
+static struct pccard_operations sb1250pc_operations = {
+	sb1250pc_init,
+	sb1250pc_suspend,
+	sb1250pc_register_callback,
+	sb1250pc_inquire_socket,
+	sb1250pc_get_status,
+	sb1250pc_get_socket,
+	sb1250pc_set_socket,
+	sb1250pc_get_io_map,
+	sb1250pc_set_io_map,
+	sb1250pc_get_mem_map,
+	sb1250pc_set_mem_map,
+#ifdef CONFIG_PROC_FS
+	sb1250pc_proc_setup
+#endif
+};
+
+/*
+ * XXXKW This is a hack.  The ide-cs stuff seems to leave us in
+ * Attribute mode.  Since I know that a SELECT_DRIVE will happen as
+ * the first I/O access, use this opportunity to enter data mode.
+ */
+static void sibyte_pcmcia_selectproc(ide_drive_t *drive)
+{
+	sb1250pc_write_config(sb1250pc_read_config() & ~M_PCMCIA_CFG_ATTRMEM);
+}
+
+static int sibyte_pc_prep_ide(void)
+{
+	int i;
+	ide_hwif_t *hwif = NULL;
+
+	/* Stake early claim on an ide_hwif */
+	for (i = 0; i < MAX_HWIFS; i++) {
+		if (!ide_hwifs[i].io_ports[IDE_DATA_OFFSET]) {
+			hwif = &ide_hwifs[i];
+			break;
+		}
+	}
+	if (hwif == NULL) {
+		printk("No space for SiByte onboard PCMCIA driver in ide_hwifs[].  Not enabled.\n");
+		return 1;
+	}
+
+	/*
+	 * Prime the hwif with port values, so when a card is
+	 * detected, the 'io_offset' from the capabilities will lead
+	 * it here
+	 */
+	hwif->hw.io_ports[IDE_DATA_OFFSET]    = SIBYTE_CS_REG(0);
+	hwif->hw.io_ports[IDE_ERROR_OFFSET]   = SIBYTE_CS_REG(1);
+	hwif->hw.io_ports[IDE_NSECTOR_OFFSET] = SIBYTE_CS_REG(2);
+	hwif->hw.io_ports[IDE_SECTOR_OFFSET]  = SIBYTE_CS_REG(3);
+	hwif->hw.io_ports[IDE_LCYL_OFFSET]    = SIBYTE_CS_REG(4);
+	hwif->hw.io_ports[IDE_HCYL_OFFSET]    = SIBYTE_CS_REG(5);
+	hwif->hw.io_ports[IDE_SELECT_OFFSET]  = SIBYTE_CS_REG(6);
+	hwif->hw.io_ports[IDE_STATUS_OFFSET]  = SIBYTE_CS_REG(7);
+	hwif->hw.io_ports[IDE_CONTROL_OFFSET] = SIBYTE_CS_REG(6); /* XXXKW ? */
+	hwif->hw.ack_intr                     = sb_pcmcia_ack_intr;
+	hwif->selectproc                      = sibyte_pcmcia_selectproc;
+	hwif->hold                            = 1;
+	hwif->mmio                            = 2;
+	sibyte_set_ideops(&ide_hwifs[i]);
+
+	printk("SiByte onboard PCMCIA-IDE configured as device %i\n", i);
+
+	return 0;
+}
+
+static int __init sibyte_pcmcia_init(void)
+{
+	servinfo_t info;
+	u32 addr, temp;
+	u64 cfg;
+
+	CardServices(GetCardServicesInfo, &info);
+	if (info.Revision != CS_RELEASE_CODE) {
+		printk(KERN_ERR PFX "Card Services release does not match!\n");
+		return -1;
+	}
+
+        cfg = in64(IO_SPACE_BASE + A_SCD_SYSTEM_CFG);
+        if (!(cfg & M_SYS_PCMCIA_ENABLE)) {
+		printk(KERN_INFO PFX "chip not configured for PCMCIA\n");
+		return -1;
+	}
+
+	/* Find memory base address and size */
+	addr = A_IO_EXT_REG(R_IO_EXT_REG(R_IO_EXT_MULT_SIZE, PCMCIA_CS));
+	temp = G_IO_MULT_SIZE(csr_in32(IO_SPACE_BASE + addr));
+	printk(PFX "Looking up addr 0x%x: 0x%4.4x (IO size)\n", addr, temp);
+	sb_pcmcia_size = (temp+1) << S_IO_REGSIZE;
+
+	addr = A_IO_EXT_REG(R_IO_EXT_REG(R_IO_EXT_START_ADDR, PCMCIA_CS));
+	temp = G_IO_START_ADDR(csr_in32(KSEG1|addr));
+	printk(PFX "Looking up addr 0x%x: 0x%4.4x (IO Base Address)\n", addr, temp);
+	if (temp << S_IO_ADDRBASE != PCMCIA_PHYS)
+		panic(PFX "pcmcia base doesn't match gencs value\n");
+
+	/* check and request memory region */
+	if (check_mem_region(sb_pcmcia_base, sb_pcmcia_size)) {
+		printk(KERN_ERR PFX "Can't request memory region?\n");
+	} else {
+		request_mem_region(sb_pcmcia_base, sb_pcmcia_size, "sibyte-pcmcia");
+		printk(PFX "Memory region 0x%8.8lx of size 0x%8.8lx requested.\n",
+		       sb_pcmcia_base, sb_pcmcia_size);
+	}
+
+	/* register with socket services */
+	if (register_ss_entry(1, &sb1250pc_operations)) {
+		printk(KERN_ERR PFX "register_ss_entry() failed\n");
+		release_region(sb_pcmcia_base, sb_pcmcia_size);
+		return -ENODEV;
+	}
+
+	if (!sibyte_pc_prep_ide()) {
+		/* XXXKW hack for ide-cs warning squash */
+		request_region(sb1250pc_cap.io_offset, 16, "ide-cs");
+		request_mem_region(SIBYTE_CS_REG(0), 8, "sibyte-ide-cs");
+	}
+
+	return 0;
+}
+
+static void __exit sibyte_pcmcia_exit(void)
+{
+	/* XXXKW untested as module */
+	unregister_ss_entry(&sb1250pc_operations);
+	release_region(sb_pcmcia_base, sb_pcmcia_size);
+}
+
+module_init(sibyte_pcmcia_init);
+module_exit(sibyte_pcmcia_exit);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/pcmcia/vrc4173_cardu.c linux-2.4.22/drivers/pcmcia/vrc4173_cardu.c
--- linux-2.4.22.clean/drivers/pcmcia/vrc4173_cardu.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/pcmcia/vrc4173_cardu.c	2003-09-27 14:08:10.000000000 +0200
@@ -0,0 +1,628 @@
+/*
+ * FILE NAME
+ *	drivers/pcmcia/vrc4173_cardu.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ * 	NEC VRC4173 CARDU driver for Socket Services
+ *	(This device doesn't support CardBus. it is supporting only 16bit PC Card.)
+ *
+ * Copyright 2002,2003 Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#include <asm/io.h>
+
+#include <pcmcia/ss.h>
+
+#include "vrc4173_cardu.h"
+
+MODULE_DESCRIPTION("NEC VRC4173 CARDU driver for Socket Services");
+MODULE_AUTHOR("Yoichi Yuasa <yuasa@hh.iij4u.or.jp>");
+MODULE_LICENSE("GPL");
+
+static int vrc4173_cardu_slots;
+
+static vrc4173_socket_t cardu_sockets[CARDU_MAX_SOCKETS];
+
+extern struct socket_info_t *pcmcia_register_socket (int slot,
+                                                     struct pccard_operations *vtable,
+                                                     int use_bus_pm);
+extern void pcmcia_unregister_socket(struct socket_info_t *s);
+
+static inline uint8_t exca_readb(vrc4173_socket_t *socket, uint16_t offset)
+{
+	return readb(socket->base + EXCA_REGS_BASE + offset);
+}
+
+static inline uint16_t exca_readw(vrc4173_socket_t *socket, uint16_t offset)
+{
+	uint16_t val;
+
+	val = readb(socket->base + EXCA_REGS_BASE + offset);
+	val |= (u16)readb(socket->base + EXCA_REGS_BASE + offset + 1) << 8;
+
+	return val;
+}
+
+static inline void exca_writeb(vrc4173_socket_t *socket, uint16_t offset, uint8_t val)
+{
+	writeb(val, socket->base + EXCA_REGS_BASE + offset);
+}
+
+static inline void exca_writew(vrc4173_socket_t *socket, uint8_t offset, uint16_t val)
+{
+	writeb((u8)val, socket->base + EXCA_REGS_BASE + offset);
+	writeb((u8)(val >> 8), socket->base + EXCA_REGS_BASE + offset + 1);
+}
+
+static inline uint32_t cardbus_socket_readl(vrc4173_socket_t *socket, u16 offset)
+{
+	return readl(socket->base + CARDBUS_SOCKET_REGS_BASE + offset);
+}
+
+static inline void cardbus_socket_writel(vrc4173_socket_t *socket, u16 offset, uint32_t val)
+{
+	writel(val, socket->base + CARDBUS_SOCKET_REGS_BASE + offset);
+}
+
+static void cardu_pciregs_init(struct pci_dev *dev)
+{
+	u32 syscnt;
+	u16 brgcnt;
+	u8 devcnt;
+
+	pci_write_config_dword(dev, 0x1c, 0x10000000);
+	pci_write_config_dword(dev, 0x20, 0x17fff000);
+	pci_write_config_dword(dev, 0x2c, 0);
+	pci_write_config_dword(dev, 0x30, 0xfffc);
+
+	pci_read_config_word(dev, BRGCNT, &brgcnt);
+	brgcnt &= ~IREQ_INT;
+	pci_write_config_word(dev, BRGCNT, brgcnt);
+
+	pci_read_config_dword(dev, SYSCNT, &syscnt);
+	syscnt &= ~(BAD_VCC_REQ_DISB|PCPCI_EN|CH_ASSIGN_MASK|SUB_ID_WR_EN|PCI_CLK_RIN);
+	syscnt |= (CH_ASSIGN_NODMA|ASYN_INT_MODE);
+	pci_write_config_dword(dev, SYSCNT, syscnt);
+
+	pci_read_config_byte(dev, DEVCNT, &devcnt);
+	devcnt &= ~(ZOOM_VIDEO_EN|SR_PCI_INT_SEL_MASK|PCI_INT_MODE|IRQ_MODE);
+	devcnt |= (SR_PCI_INT_SEL_NONE|IFG);
+	pci_write_config_byte(dev, DEVCNT, devcnt);
+
+	pci_write_config_byte(dev, CHIPCNT, S_PREF_DISB);
+
+	pci_write_config_byte(dev, SERRDIS, 0);
+}
+
+static int cardu_init(unsigned int slot)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[slot];
+
+	cardu_pciregs_init(socket->dev);
+
+	/* CARD_SC bits are cleared by reading CARD_SC. */
+	exca_writeb(socket, GLO_CNT, 0);
+
+	socket->cap.features |= SS_CAP_PCCARD | SS_CAP_PAGE_REGS;
+	socket->cap.irq_mask = 0;
+	socket->cap.map_size = 0x1000;
+	socket->cap.pci_irq  = socket->dev->irq;
+	socket->events = 0;
+	spin_lock_init(socket->event_lock);
+
+	/* Enable PC Card status interrupts */
+	exca_writeb(socket, CARD_SCI, CARD_DT_EN|RDY_EN|BAT_WAR_EN|BAT_DEAD_EN);
+
+	return 0;
+}
+
+static int cardu_suspend(unsigned int slot)
+{
+	return -EINVAL;
+}
+
+static int cardu_register_callback(unsigned int sock,
+                                           void (*handler)(void *, unsigned int),
+                                           void * info)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+
+	socket->handler = handler;
+	socket->info = info;
+
+	if (handler)
+		MOD_INC_USE_COUNT;
+	else
+		MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+static int cardu_inquire_socket(unsigned int sock, socket_cap_t *cap)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+
+	*cap = socket->cap;
+
+	return 0;
+}
+
+static int cardu_get_status(unsigned int sock, u_int *value)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint32_t state;
+	uint8_t status;
+	u_int val = 0;
+
+	status = exca_readb(socket, IF_STATUS);
+	if (status & CARD_PWR) val |= SS_POWERON;
+	if (status & READY) val |= SS_READY;
+	if (status & CARD_WP) val |= SS_WRPROT;
+	if ((status & (CARD_DETECT1|CARD_DETECT2)) == (CARD_DETECT1|CARD_DETECT2))
+		val |= SS_DETECT;
+	if (exca_readb(socket, INT_GEN_CNT) & CARD_TYPE_IO) {
+		if (status & STSCHG) val |= SS_STSCHG;
+	} else {
+		status &= BV_DETECT_MASK;
+		if (status != BV_DETECT_GOOD) {
+			if (status == BV_DETECT_WARN) val |= SS_BATWARN;
+			else val |= SS_BATDEAD;
+		}
+	}
+
+	state = cardbus_socket_readl(socket, SKT_PRE_STATE);
+	if (state & VOL_3V_CARD_DT) val |= SS_3VCARD;
+	if (state & VOL_XV_CARD_DT) val |= SS_XVCARD;
+	if (state & CB_CARD_DT) val |= SS_CARDBUS;
+	if (!(state &
+	      (VOL_YV_CARD_DT|VOL_XV_CARD_DT|VOL_3V_CARD_DT|VOL_5V_CARD_DT|CCD20|CCD10)))
+		val |= SS_PENDING;
+
+	*value = val;
+
+	return 0;
+}
+
+static inline u_char get_Vcc_value(uint8_t val)
+{
+	switch (val & VCC_MASK) {
+	case VCC_3V:
+		return 33;
+	case VCC_5V:
+		return 50;
+	}
+
+	return 0;
+}
+
+static inline u_char get_Vpp_value(uint8_t val)
+{
+	switch (val & VPP_MASK) {
+	case VPP_12V:
+		return 120;
+	case VPP_VCC:
+		return get_Vcc_value(val);
+	}
+
+	return 0;
+}
+
+static int cardu_get_socket(unsigned int sock, socket_state_t *state)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint8_t val;
+
+	val = exca_readb(socket, PWR_CNT);
+	state->Vcc = get_Vcc_value(val);
+	state->Vpp = get_Vpp_value(val);
+	state->flags = 0;
+	if (val & CARD_OUT_EN) state->flags |= SS_OUTPUT_ENA;
+
+	val = exca_readb(socket, INT_GEN_CNT);
+	if (!(val & CARD_REST0)) state->flags |= SS_RESET;
+	if (val & CARD_TYPE_IO) state->flags |= SS_IOCARD;
+
+	return 0;
+}
+
+static inline uint8_t set_Vcc_value(u_char Vcc)
+{
+	switch (Vcc) {
+	case 33:
+		return VCC_3V;
+	case 50:
+		return VCC_5V;
+	}
+
+	return VCC_0V;
+}
+
+static inline uint8_t set_Vpp_value(u_char Vpp)
+{
+	switch (Vpp) {
+	case 33:
+	case 50:
+		return VPP_VCC;
+	case 120:
+		return VPP_12V;
+	}
+
+	return VPP_0V;
+}
+
+static int cardu_set_socket(unsigned int sock, socket_state_t *state)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint8_t val;
+
+	if (((state->Vpp == 33) || (state->Vpp == 50)) && (state->Vpp != state->Vcc))
+			return -EINVAL;
+
+	val = set_Vcc_value(state->Vcc);
+	val |= set_Vpp_value(state->Vpp);
+	if (state->flags & SS_OUTPUT_ENA) val |= CARD_OUT_EN;
+	exca_writeb(socket, PWR_CNT, val);
+
+	val = exca_readb(socket, INT_GEN_CNT) & CARD_REST0;
+	if (state->flags & SS_RESET) val &= ~CARD_REST0;
+	else val |= CARD_REST0;
+	if (state->flags & SS_IOCARD) val |= CARD_TYPE_IO;
+	exca_writeb(socket, INT_GEN_CNT, val);
+
+	return 0;
+}
+
+static int cardu_get_io_map(unsigned int sock, struct pccard_io_map *io)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint8_t ioctl, window;
+	u_char map;
+
+	map = io->map;
+	if (map > 1)
+		return -EINVAL; 
+
+	io->start = exca_readw(socket, IO_WIN_SA(map));
+	io->stop = exca_readw(socket, IO_WIN_EA(map));
+
+	ioctl = exca_readb(socket, IO_WIN_CNT);
+	window = exca_readb(socket, ADR_WIN_EN);
+	io->flags  = (window & IO_WIN_EN(map)) ? MAP_ACTIVE : 0;
+	if (ioctl & IO_WIN_DATA_AUTOSZ(map))
+		io->flags |= MAP_AUTOSZ;
+	else if (ioctl & IO_WIN_DATA_16BIT(map))
+		io->flags |= MAP_16BIT;
+
+	return 0;
+}
+
+static int cardu_set_io_map(unsigned int sock, struct pccard_io_map *io)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint16_t ioctl;
+	uint8_t window, enable;
+	u_char map;
+
+	map = io->map;
+	if (map > 1)
+		return -EINVAL;
+
+	window = exca_readb(socket, ADR_WIN_EN);
+	enable = IO_WIN_EN(map);
+
+	if (window & enable) {
+		window &= ~enable;
+		exca_writeb(socket, ADR_WIN_EN, window);
+	}
+
+	exca_writew(socket, IO_WIN_SA(map), io->start);
+	exca_writew(socket, IO_WIN_EA(map), io->stop);
+
+	ioctl = exca_readb(socket, IO_WIN_CNT) & ~IO_WIN_CNT_MASK(map);
+	if (io->flags & MAP_AUTOSZ) ioctl |= IO_WIN_DATA_AUTOSZ(map);
+	else if (io->flags & MAP_16BIT) ioctl |= IO_WIN_DATA_16BIT(map);
+	exca_writeb(socket, IO_WIN_CNT, ioctl);
+
+	if (io->flags & MAP_ACTIVE)
+		exca_writeb(socket, ADR_WIN_EN, window | enable);
+
+	return 0;
+}
+
+static int cardu_get_mem_map(unsigned int sock, struct pccard_mem_map *mem)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint32_t start, stop, offset, page;
+	uint8_t window;
+	u_char map;
+
+	map = mem->map;
+	if (map > 4)
+		return -EINVAL;
+
+	window = exca_readb(socket, ADR_WIN_EN);
+	mem->flags = (window & MEM_WIN_EN(map)) ? MAP_ACTIVE : 0;
+
+	start = exca_readw(socket, MEM_WIN_SA(map));
+	mem->flags |= (start & MEM_WIN_DSIZE) ? MAP_16BIT : 0;
+	start = (start & 0x0fff) << 12;
+
+	stop = exca_readw(socket, MEM_WIN_EA(map));
+	stop = ((stop & 0x0fff) << 12) + 0x0fff;
+
+	offset = exca_readw(socket, MEM_WIN_OA(map));
+	mem->flags |= (offset & MEM_WIN_WP) ? MAP_WRPROT : 0;
+	mem->flags |= (offset & MEM_WIN_REGSET) ? MAP_ATTRIB : 0;
+	offset = ((offset & 0x3fff) << 12) + start;
+	mem->card_start = offset & 0x03ffffff;
+
+	page = exca_readb(socket, MEM_WIN_SAU(map)) << 24;
+	mem->sys_start = start + page;
+	mem->sys_stop = start + page;
+
+	return 0;
+}
+
+static int cardu_set_mem_map(unsigned int sock, struct pccard_mem_map *mem)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint16_t value;
+	uint8_t window, enable;
+	u_long sys_start, sys_stop, card_start;
+	u_char map;
+
+	map = mem->map;
+	sys_start = mem->sys_start;
+	sys_stop = mem->sys_stop;
+	card_start = mem->card_start;
+
+	if (map > 4 || sys_start > sys_stop || ((sys_start ^ sys_stop) >> 24) ||
+	    (card_start >> 26))
+		return -EINVAL;
+
+	window = exca_readb(socket, ADR_WIN_EN);
+	enable = MEM_WIN_EN(map);
+	if (window & enable) {
+		window &= ~enable;
+		exca_writeb(socket, ADR_WIN_EN, window);
+	}
+
+	exca_writeb(socket, MEM_WIN_SAU(map), sys_start >> 24);
+
+	value = (sys_start >> 12) & 0x0fff;
+	if (mem->flags & MAP_16BIT) value |= MEM_WIN_DSIZE;
+	exca_writew(socket, MEM_WIN_SA(map), value);
+
+	value = (sys_stop >> 12) & 0x0fff;
+	exca_writew(socket, MEM_WIN_EA(map), value);
+
+	value = ((card_start - sys_start) >> 12) & 0x3fff;
+	if (mem->flags & MAP_WRPROT) value |= MEM_WIN_WP;
+	if (mem->flags & MAP_ATTRIB) value |= MEM_WIN_REGSET;
+	exca_writew(socket, MEM_WIN_OA(map), value);
+
+	if (mem->flags & MAP_ACTIVE)
+		exca_writeb(socket, ADR_WIN_EN, window | enable);
+
+	return 0;
+}
+
+static void cardu_proc_setup(unsigned int sock, struct proc_dir_entry *base)
+{
+}
+
+static struct pccard_operations cardu_operations = {
+	.init			= cardu_init,
+	.suspend		= cardu_suspend,
+	.register_callback	= cardu_register_callback,
+	.inquire_socket		= cardu_inquire_socket,
+	.get_status		= cardu_get_status,
+	.get_socket		= cardu_get_socket,
+	.set_socket		= cardu_set_socket,
+	.get_io_map		= cardu_get_io_map,
+	.set_io_map		= cardu_set_io_map,
+	.get_mem_map		= cardu_get_mem_map,
+	.set_mem_map		= cardu_set_mem_map,
+	.proc_setup		= cardu_proc_setup,
+};
+
+static void cardu_bh(void *data)
+{
+	vrc4173_socket_t *socket = (vrc4173_socket_t *)data;
+	uint16_t events;
+
+	spin_lock_irq(&socket->event_lock);
+	events = socket->events;
+	socket->events = 0;
+	spin_unlock_irq(&socket->event_lock);
+
+	if (socket->handler)
+		socket->handler(socket->info, events);
+}
+
+static uint16_t get_events(vrc4173_socket_t *socket)
+{
+	uint16_t events = 0;
+	uint8_t csc, status;
+
+	status = exca_readb(socket, IF_STATUS);
+	csc = exca_readb(socket, CARD_SC);
+	if ((csc & CARD_DT_CHG) && 
+	    ((status & (CARD_DETECT1|CARD_DETECT2)) == (CARD_DETECT1|CARD_DETECT2)))
+		events |= SS_DETECT;
+
+	if ((csc & RDY_CHG) && (status & READY))
+		events |= SS_READY;
+
+	if (exca_readb(socket, INT_GEN_CNT) & CARD_TYPE_IO) {
+		if ((csc & BAT_DEAD_ST_CHG) && (status & STSCHG))
+			events |= SS_STSCHG;
+	} else {
+		if (csc & (BAT_WAR_CHG|BAT_DEAD_ST_CHG)) {
+			if ((status & BV_DETECT_MASK) != BV_DETECT_GOOD) {
+				if (status == BV_DETECT_WARN) events |= SS_BATWARN;
+				else events |= SS_BATDEAD;
+			}
+		}
+	}
+
+	return events;
+}
+
+static void cardu_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	vrc4173_socket_t *socket = (vrc4173_socket_t *)dev_id;
+	uint16_t events;
+
+	socket->tq_task.routine = cardu_bh;
+	socket->tq_task.data = socket;
+
+	events = get_events(socket);
+	if (events) {
+		spin_lock(&socket->event_lock);
+		socket->events |= events;
+		spin_unlock(&socket->event_lock);
+		schedule_task(&socket->tq_task);
+	}
+}
+
+static int __devinit vrc4173_cardu_probe(struct pci_dev *dev,
+                                         const struct pci_device_id *ent)
+{
+	vrc4173_socket_t *socket;
+	unsigned long start, len, flags;
+	int slot, err;
+
+	slot = vrc4173_cardu_slots++;
+	socket = &cardu_sockets[slot];
+	if (socket->noprobe != 0)
+		return -EBUSY;
+
+	sprintf(socket->name, "NEC VRC4173 CARDU%1d", slot+1);
+
+	if ((err = pci_enable_device(dev)) < 0)
+		return err;
+
+	start = pci_resource_start(dev, 0);
+	if (start == 0)
+		return -ENODEV;
+
+	len = pci_resource_len(dev, 0);
+	if (len == 0)
+		return -ENODEV;
+
+	if (((flags = pci_resource_flags(dev, 0)) & IORESOURCE_MEM) == 0)
+		return -EBUSY;
+
+	if ((err = pci_request_regions(dev, socket->name)) < 0)
+		return err;
+
+	socket->base = ioremap(start, len);
+	if (socket->base == NULL)
+		return -ENODEV;
+
+	socket->dev = dev;
+
+	socket->pcmcia_socket = pcmcia_register_socket(slot, &cardu_operations, 1);
+	if (socket->pcmcia_socket == NULL) {
+		iounmap(socket->base);
+		socket->base = NULL;
+		return -ENOMEM;
+	}
+
+	if (request_irq(dev->irq, cardu_interrupt, SA_SHIRQ, socket->name, socket) < 0) {
+		pcmcia_unregister_socket(socket->pcmcia_socket);
+		socket->pcmcia_socket = NULL;
+		iounmap(socket->base);
+		socket->base = NULL;
+		return -EBUSY;
+	}
+
+	printk(KERN_INFO "%s at %#08lx, IRQ %d\n", socket->name, start, dev->irq);
+
+	return 0;
+}
+
+static int __devinit vrc4173_cardu_setup(char *options)
+{
+	if (options == NULL || *options == '\0')
+		return 0;
+
+	if (strncmp(options, "cardu1:", 7) == 0) {
+		options += 7;
+		if (*options != '\0') {
+			if (strncmp(options, "noprobe", 7) == 0) {
+				cardu_sockets[CARDU1].noprobe = 1;
+				options += 7;
+			}
+
+			if (*options != ',')
+				return 0;
+		} else
+			return 0;
+	}
+
+	if (strncmp(options, "cardu2:", 7) == 0) {
+		options += 7;
+		if ((*options != '\0') && (strncmp(options, "noprobe", 7) == 0))
+			cardu_sockets[CARDU2].noprobe = 1;
+	}
+
+	return 0;
+}
+
+__setup("vrc4173_cardu=", vrc4173_cardu_setup);
+
+static struct pci_device_id vrc4173_cardu_id_table[] __devinitdata = {
+	{	.vendor		= PCI_VENDOR_ID_NEC,
+		.device		= PCI_DEVICE_ID_NEC_NAPCCARD,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID, },
+        {0, }
+};
+
+static struct pci_driver vrc4173_cardu_driver = {
+	.name		= "NEC VRC4173 CARDU",
+	.probe		= vrc4173_cardu_probe,
+	.id_table	= vrc4173_cardu_id_table,
+};
+
+static int __devinit vrc4173_cardu_init(void)
+{
+	vrc4173_cardu_slots = 0;
+
+	return pci_module_init(&vrc4173_cardu_driver);
+}
+
+static void __devexit vrc4173_cardu_exit(void)
+{
+	pci_unregister_driver(&vrc4173_cardu_driver);
+}
+
+module_init(vrc4173_cardu_init);
+module_exit(vrc4173_cardu_exit);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/pcmcia/vrc4173_cardu.h linux-2.4.22/drivers/pcmcia/vrc4173_cardu.h
--- linux-2.4.22.clean/drivers/pcmcia/vrc4173_cardu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/pcmcia/vrc4173_cardu.h	2003-09-27 14:08:10.000000000 +0200
@@ -0,0 +1,247 @@
+/*
+ * FILE NAME
+ *	drivers/pcmcia/vrc4173_cardu.h
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Include file for NEC VRC4173 CARDU.
+ *
+ * Copyright 2002 Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef _VRC4173_CARDU_H
+#define _VRC4173_CARDU_H
+
+#include <linux/pci.h>
+
+#include <pcmcia/ss.h>
+
+#define CARDU_MAX_SOCKETS	2
+#define CARDU1			0
+#define CARDU2			1
+
+/*
+ * PCI Configuration Registers
+ */
+#define BRGCNT			0x3e
+ #define POST_WR_EN		0x0400
+ #define MEM1_PREF_EN		0x0200
+ #define MEM0_PREF_EN		0x0100
+ #define IREQ_INT		0x0080
+ #define CARD_RST		0x0040
+ #define MABORT_MODE		0x0020
+ #define VGA_EN			0x0008
+ #define ISA_EN			0x0004
+ #define SERR_EN		0x0002
+ #define PERR_EN		0x0001
+
+#define SYSCNT			0x80
+ #define BAD_VCC_REQ_DISB	0x00200000
+ #define PCPCI_EN		0x00080000
+ #define CH_ASSIGN_MASK		0x00070000
+ #define CH_ASSIGN_NODMA	0x00040000
+ #define SUB_ID_WR_EN		0x00000008
+ #define ASYN_INT_MODE		0x00000004
+ #define PCI_CLK_RIN		0x00000002
+
+#define DEVCNT			0x91
+ #define ZOOM_VIDEO_EN		0x40
+ #define SR_PCI_INT_SEL_MASK	0x18
+ #define SR_PCI_INT_SEL_NONE	0x00
+ #define PCI_INT_MODE		0x04
+ #define IRQ_MODE		0x02
+ #define IFG			0x01
+
+#define CHIPCNT			0x9c
+ #define S_PREF_DISB		0x10
+
+#define SERRDIS			0x9f
+ #define SERR_DIS_MAB		0x10
+ #define SERR_DIS_TAB		0x08
+ #define SERR_DIS_DT_PERR	0x04
+
+/*
+ * ExCA Registers
+ */
+#define EXCA_REGS_BASE		0x800
+#define EXCA_REGS_SIZE		0x800
+
+#define ID_REV			0x000
+ #define IF_TYPE_16BIT		0x80
+
+#define IF_STATUS		0x001
+ #define CARD_PWR		0x40
+ #define READY			0x20
+ #define CARD_WP		0x10
+ #define CARD_DETECT2		0x08
+ #define CARD_DETECT1		0x04
+ #define BV_DETECT_MASK		0x03
+ #define BV_DETECT_GOOD		0x03	/* Memory card */
+ #define BV_DETECT_WARN		0x02
+ #define BV_DETECT_BAD1		0x01
+ #define BV_DETECT_BAD0		0x00
+ #define STSCHG			0x02	/* I/O card */
+ #define SPKR			0x01
+
+#define PWR_CNT			0x002
+ #define CARD_OUT_EN		0x80
+ #define VCC_MASK		0x18
+ #define VCC_3V			0x18
+ #define VCC_5V			0x10
+ #define VCC_0V			0x00
+ #define VPP_MASK		0x03
+ #define VPP_12V		0x02
+ #define VPP_VCC		0x01
+ #define VPP_0V			0x00
+
+#define INT_GEN_CNT		0x003
+ #define CARD_REST0		0x40
+ #define CARD_TYPE_MASK		0x20
+ #define CARD_TYPE_IO		0x20
+ #define CARD_TYPE_MEM		0x00
+
+#define CARD_SC			0x004
+ #define CARD_DT_CHG		0x08
+ #define RDY_CHG		0x04
+ #define BAT_WAR_CHG		0x02
+ #define BAT_DEAD_ST_CHG	0x01
+
+#define CARD_SCI		0x005
+ #define CARD_DT_EN		0x08
+ #define RDY_EN			0x04
+ #define BAT_WAR_EN		0x02
+ #define BAT_DEAD_EN		0x01
+
+#define ADR_WIN_EN		0x006
+ #define IO_WIN_EN(x)		(0x40 << (x))
+ #define MEM_WIN_EN(x)		(0x01 << (x))
+
+#define IO_WIN_CNT		0x007
+ #define IO_WIN_CNT_MASK(x)	(0x03 << ((x) << 2))
+ #define IO_WIN_DATA_AUTOSZ(x)	(0x02 << ((x) << 2))	
+ #define IO_WIN_DATA_16BIT(x)	(0x01 << ((x) << 2))	
+
+#define IO_WIN_SA(x)		(0x008 + ((x) << 2))
+#define IO_WIN_EA(x)		(0x00a + ((x) << 2))
+
+#define MEM_WIN_SA(x)		(0x010 + ((x) << 3))
+ #define MEM_WIN_DSIZE		0x8000
+
+#define MEM_WIN_EA(x)		(0x012 + ((x) << 3))
+
+#define MEM_WIN_OA(x)		(0x014 + ((x) << 3))
+ #define MEM_WIN_WP		0x8000
+ #define MEM_WIN_REGSET		0x4000
+
+#define GEN_CNT			0x016
+ #define VS2_STATUS		0x80
+ #define VS1_STATUS		0x40
+ #define EXCA_REG_RST_EN	0x02
+
+#define GLO_CNT			0x01e
+ #define FUN_INT_LEV		0x08
+ #define INT_WB_CLR		0x04
+ #define CSC_INT_LEV		0x02
+
+#define IO_WIN_OAL(x)		(0x036 + ((x) << 1))
+#define IO_WIN_OAH(x)		(0x037 + ((x) << 1))
+
+#define MEM_WIN_SAU(x)		(0x040 + (x))
+
+#define IO_SETUP_TIM		0x080
+#define IO_CMD_TIM		0x081
+#define IO_HOLD_TIM		0x082
+#define MEM_SETUP_TIM(x)	(0x084 + ((x) << 2))
+#define MEM_CMD_TIM(x)		(0x085 + ((x) << 2))
+#define MEM_HOLD_TIM(x)		(0x086 + ((x) << 2))
+ #define TIM_CLOCKS(x)		((x) - 1)
+
+#define MEM_TIM_SEL1		0x08c
+#define MEM_TIM_SEL2		0x08d
+ #define MEM_WIN_TIMSEL1(x)	(0x03 << (((x) & 3) << 1))
+
+#define MEM_WIN_PWEN		0x091
+ #define POSTWEN		0x01
+
+/*
+ * CardBus Socket Registers
+ */
+#define CARDBUS_SOCKET_REGS_BASE	0x000
+#define CARDBUS_SOCKET_REGS_SIZE	0x800
+
+#define SKT_EV			0x000
+ #define POW_CYC_EV		0x00000008
+ #define CCD2_EV		0x00000004
+ #define CCD1_EV		0x00000002
+ #define CSTSCHG_EV		0x00000001
+
+#define SKT_MASK		0x004
+ #define POW_CYC_MASK		0x00000008
+ #define CCD_MASK		0x00000006
+ #define CSC_MASK		0x00000001
+
+#define SKT_PRE_STATE		0x008
+#define SKT_FORCE_EV		0x00c
+ #define VOL_3V_SKT		0x20000000
+ #define VOL_5V_SKT		0x10000000
+ #define CVS_TEST		0x00004000
+ #define VOL_YV_CARD_DT		0x00002000
+ #define VOL_XV_CARD_DT		0x00001000
+ #define VOL_3V_CARD_DT		0x00000800
+ #define VOL_5V_CARD_DT		0x00000400
+ #define BAD_VCC_REQ		0x00000200
+ #define DATA_LOST		0x00000100
+ #define NOT_A_CARD		0x00000080
+ #define CREADY			0x00000040
+ #define CB_CARD_DT		0x00000020
+ #define R2_CARD_DT		0x00000010
+ #define POW_UP			0x00000008
+ #define CCD20			0x00000004
+ #define CCD10			0x00000002
+ #define CSTSCHG		0x00000001
+
+#define SKT_CNT			0x010
+ #define STP_CLK_EN		0x00000080
+ #define VCC_CNT_MASK		0x00000070
+ #define VCC_CNT_3V		0x00000030
+ #define VCC_CNT_5V		0x00000020
+ #define VCC_CNT_0V		0x00000000
+ #define VPP_CNT_MASK		0x00000007
+ #define VPP_CNT_3V		0x00000003
+ #define VPP_CNT_5V		0x00000002
+ #define VPP_CNT_12V		0x00000001
+ #define VPP_CNT_0V		0x00000000
+
+typedef struct vrc4173_socket {
+	int noprobe;
+	struct pci_dev *dev;
+	void *base;
+	void (*handler)(void *, unsigned int);
+	void *info;
+	socket_cap_t cap;
+	spinlock_t event_lock;
+	uint16_t events;
+	struct socket_info_t *pcmcia_socket;
+	struct tq_struct tq_task;
+	char name[20];
+} vrc4173_socket_t;
+
+#endif /* _VRC4173_CARDU_H */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/scsi/NCR53C9x.c linux-2.4.22/drivers/scsi/NCR53C9x.c
--- linux-2.4.22.clean/drivers/scsi/NCR53C9x.c	2002-11-29 00:53:14.000000000 +0100
+++ linux-2.4.22/drivers/scsi/NCR53C9x.c	2002-11-25 13:18:58.000000000 +0100
@@ -917,7 +917,7 @@
 		if (esp->dma_mmu_get_scsi_one)
 			esp->dma_mmu_get_scsi_one(esp, sp);
 		else
-			sp->SCp.have_data_in = (int) sp->SCp.ptr =
+			sp->SCp.ptr =
 				(char *) virt_to_phys(sp->request_buffer);
 	} else {
 		sp->SCp.buffer = (struct scatterlist *) sp->buffer;
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/scsi/NCR53C9x.h linux-2.4.22/drivers/scsi/NCR53C9x.h
--- linux-2.4.22.clean/drivers/scsi/NCR53C9x.h	2001-09-14 23:40:00.000000000 +0200
+++ linux-2.4.22/drivers/scsi/NCR53C9x.h	2002-07-24 19:55:47.000000000 +0200
@@ -144,12 +144,7 @@
 
 #ifndef MULTIPLE_PAD_SIZES
 
-#ifdef CONFIG_CPU_HAS_WB
-#include <asm/wbflush.h>
-#define esp_write(__reg, __val) do{(__reg) = (__val); wbflush();} while(0)
-#else
-#define esp_write(__reg, __val) ((__reg) = (__val))
-#endif
+#define esp_write(__reg, __val) do{(__reg) = (__val); iob();} while(0)
 #define esp_read(__reg) (__reg)
 
 struct ESP_regs {
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/scsi/sgiwd93.c linux-2.4.22/drivers/scsi/sgiwd93.c
--- linux-2.4.22.clean/drivers/scsi/sgiwd93.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/scsi/sgiwd93.c	2003-09-27 17:15:25.000000000 +0200
@@ -13,6 +13,7 @@
  *
  */
 #include <linux/init.h>
+#include <linux/interrupt.h>
 #include <linux/types.h>
 #include <linux/mm.h>
 #include <linux/blk.h>
@@ -37,13 +38,19 @@
 
 #include <linux/stat.h>
 
+#if 0
+#define DPRINTK(args...)	printk(args)
+#else
+#define DPRINTK(args...)
+#endif
+
 struct hpc_chunk {
 	struct hpc_dma_desc desc;
 	u32 _padding;	/* align to quadword boundary */
 };
 
-struct Scsi_Host *sgiwd93_host = NULL;
-struct Scsi_Host *sgiwd93_host1 = NULL;
+struct Scsi_Host *sgiwd93_host;
+struct Scsi_Host *sgiwd93_host1;
 
 /* Wuff wuff, wuff, wd33c93.c, wuff wuff, object oriented, bow wow. */
 static inline void write_wd33c93_count(const wd33c93_regs regs,
@@ -79,10 +86,8 @@
 	spin_unlock_irqrestore(&io_request_lock, flags);
 }
 
-#undef DEBUG_DMA
-
 static inline
-void fill_hpc_entries (struct hpc_chunk **hcp, char *addr, unsigned long len)
+void fill_hpc_entries(struct hpc_chunk **hcp, char *addr, unsigned long len)
 {
 	unsigned long physaddr;
 	unsigned long count;
@@ -104,48 +109,47 @@
 
 static int dma_setup(Scsi_Cmnd *cmd, int datainp)
 {
-	struct WD33C93_hostdata *hdata = (struct WD33C93_hostdata *)cmd->host->hostdata;
-	struct hpc3_scsiregs *hregs = (struct hpc3_scsiregs *) cmd->host->base;
+	struct WD33C93_hostdata *hdata =
+		(struct WD33C93_hostdata *) cmd->host->hostdata;
+	struct hpc3_scsiregs *hregs =
+		(struct hpc3_scsiregs *) cmd->host->base;
 	struct hpc_chunk *hcp = (struct hpc_chunk *) hdata->dma_bounce_buffer;
 
-#ifdef DEBUG_DMA
-	printk("dma_setup: datainp<%d> hcp<%p> ",
-	       datainp, hcp);
-#endif
+	DPRINTK("dma_setup: datainp<%d> hcp<%p> ", datainp, hcp);
 
 	hdata->dma_dir = datainp;
 
 	/*
-	 * wd33c93 shouldn't pass us bogus dma_setups, but
-	 * it does:-( The other wd33c93 drivers deal with
-	 * it the same way (which isn't that obvious).
-	 * IMHO a better fix would be, not to do these
-	 * dma setups in the first place
+	 * wd33c93 shouldn't pass us bogus dma_setups, but it does:-(  The
+	 * other wd33c93 drivers deal with it the same way (which isn't that
+	 * obvious).  IMHO a better fix would be, not to do these dma setups
+	 * in the first place.
 	 */
 	if (cmd->SCp.ptr == NULL || cmd->SCp.this_residual == 0)
 		return 1;
 
-	fill_hpc_entries (&hcp, cmd->SCp.ptr, cmd->SCp.this_residual);
+	fill_hpc_entries(&hcp, cmd->SCp.ptr, cmd->SCp.this_residual);
 
-	/* To make sure, if we trip an HPC bug, that we transfer
-	 * every single byte, we tag on an extra zero length dma
-	 * descriptor at the end of the chain.
+	/*
+	 * To make sure, if we trip an HPC bug, that we transfer every single
+	 * byte, we tag on an extra zero length dma descriptor at the end of
+	 * the chain.
 	 */
 	hcp->desc.pbuf = 0;
-	hcp->desc.cntinfo = (HPCDMA_EOX);
+	hcp->desc.cntinfo = HPCDMA_EOX;
 
-#ifdef DEBUG_DMA
-	printk(" HPCGO\n");
-#endif
+	DPRINTK(" HPCGO\n");
 
 	/* Start up the HPC. */
 	hregs->ndptr = PHYSADDR(hdata->dma_bounce_buffer);
-	if(datainp) {
-		dma_cache_inv((unsigned long) cmd->SCp.ptr, cmd->SCp.this_residual);
-		hregs->ctrl = (HPC3_SCTRL_ACTIVE);
+	if (datainp) {
+		dma_cache_inv((unsigned long) cmd->SCp.ptr,
+		              cmd->SCp.this_residual);
+		hregs->ctrl = HPC3_SCTRL_ACTIVE;
 	} else {
-		dma_cache_wback_inv((unsigned long) cmd->SCp.ptr, cmd->SCp.this_residual);
-		hregs->ctrl = (HPC3_SCTRL_ACTIVE | HPC3_SCTRL_DIR);
+		dma_cache_wback_inv((unsigned long) cmd->SCp.ptr,
+		                    cmd->SCp.this_residual);
+		hregs->ctrl = HPC3_SCTRL_ACTIVE | HPC3_SCTRL_DIR;
 	}
 
 	return 0;
@@ -154,7 +158,8 @@
 static void dma_stop(struct Scsi_Host *instance, Scsi_Cmnd *SCpnt,
 		     int status)
 {
-	struct WD33C93_hostdata *hdata = (struct WD33C93_hostdata *)instance->hostdata;
+	struct WD33C93_hostdata *hdata =
+		(struct WD33C93_hostdata *) instance->hostdata;
 	struct hpc3_scsiregs *hregs;
 
 	if (!SCpnt)
@@ -162,21 +167,17 @@
 
 	hregs = (struct hpc3_scsiregs *) SCpnt->host->base;
 
-#ifdef DEBUG_DMA
-	printk("dma_stop: status<%d> ", status);
-#endif
+	DPRINTK("dma_stop: status<%d> ", status);
 
 	/* First stop the HPC and flush it's FIFO. */
-	if(hdata->dma_dir) {
+	if (hdata->dma_dir) {
 		hregs->ctrl |= HPC3_SCTRL_FLUSH;
-		while(hregs->ctrl & HPC3_SCTRL_ACTIVE)
+		while (hregs->ctrl & HPC3_SCTRL_ACTIVE)
 			barrier();
 	}
 	hregs->ctrl = 0;
 
-#ifdef DEBUG_DMA
-	printk("\n");
-#endif
+	DPRINTK("\n");
 }
 
 void sgiwd93_reset(unsigned long base)
@@ -184,7 +185,7 @@
 	struct hpc3_scsiregs *hregs = (struct hpc3_scsiregs *) base;
 
 	hregs->ctrl = HPC3_SCTRL_CRESET;
-	udelay (50);
+	udelay(50);
 	hregs->ctrl = 0;
 }
 
@@ -195,8 +196,8 @@
 
 	start = (unsigned long) buf;
 	end = start + PAGE_SIZE;
-	while(start < end) {
-		hcp->desc.pnext = PHYSADDR((hcp + 1));
+	while (start < end) {
+		hcp->desc.pnext = PHYSADDR(hcp + 1);
 		hcp->desc.cntinfo = HPCDMA_EOX;
 		hcp++;
 		start += sizeof(struct hpc_chunk);
@@ -208,95 +209,77 @@
 	dma_cache_wback_inv((unsigned long) buf, PAGE_SIZE);
 }
 
-int __init sgiwd93_detect(Scsi_Host_Template *SGIblows)
+static struct Scsi_Host * __init sgiwd93_setup_scsi(
+	Scsi_Host_Template *SGIblows, int unit, int irq,
+	struct hpc3_scsiregs *hregs, unsigned char *wdregs)
 {
-	static unsigned char called = 0;
-	struct hpc3_scsiregs *hregs = &hpc3c0->scsi_chan0;
-	struct hpc3_scsiregs *hregs1 = &hpc3c0->scsi_chan1;
 	struct WD33C93_hostdata *hdata;
-	struct WD33C93_hostdata *hdata1;
+	struct Scsi_Host *host;
 	wd33c93_regs regs;
 	uchar *buf;
-	
-	if(called)
-		return 0; /* Should bitch on the console about this... */
 
-	SGIblows->proc_name = "SGIWD93";
+	host = scsi_register(SGIblows, sizeof(struct WD33C93_hostdata));
+	if (!host)
+		return NULL;
 
-	sgiwd93_host = scsi_register(SGIblows, sizeof(struct WD33C93_hostdata));
-	if(sgiwd93_host == NULL)
-		return 0;
-	sgiwd93_host->base = (unsigned long) hregs;
-	sgiwd93_host->irq = SGI_WD93_0_IRQ;
+	host->base = (unsigned long) hregs;
+	host->irq = irq;
 
 	buf = (uchar *) get_zeroed_page(GFP_KERNEL);
 	if (!buf) {
-		printk(KERN_WARNING "sgiwd93: Could not allocate memory for host0 buffer.\n");
-		scsi_unregister(sgiwd93_host);
-		return 0;
+		printk(KERN_WARNING "sgiwd93: Could not allocate memory for "
+		       "host %d buffer.\n", unit);
+		goto out_unregister;
 	}
 	init_hpc_chain(buf);
-	
-	/* HPC_SCSI_REG0 | 0x03 | KSEG1 */
-	regs.SASR = (unsigned char*) KSEG1ADDR (0x1fbc0003);
-	regs.SCMD = (unsigned char*) KSEG1ADDR (0x1fbc0007);
-	wd33c93_init(sgiwd93_host, regs, dma_setup, dma_stop, WD33C93_FS_16_20);
 
-	hdata = (struct WD33C93_hostdata *)sgiwd93_host->hostdata;
+	regs.SASR = wdregs + 3;
+	regs.SCMD = wdregs + 7;
+
+	wd33c93_init(host, regs, dma_setup, dma_stop, WD33C93_FS_16_20);
+
+	hdata = (struct WD33C93_hostdata *) host->hostdata;
 	hdata->no_sync = 0;
-	hdata->dma_bounce_buffer = (uchar *) (KSEG1ADDR(buf));
+	hdata->dma_bounce_buffer = (uchar *) KSEG1ADDR(buf);
 
-	if (request_irq(SGI_WD93_0_IRQ, sgiwd93_intr, 0, "SGI WD93", (void *) sgiwd93_host)) {
-		printk(KERN_WARNING "sgiwd93: Could not register IRQ %d (for host 0).\n", SGI_WD93_0_IRQ);
-#ifdef MODULE
-		wd33c93_release();
-#endif
-		free_page((unsigned long)buf);
-		scsi_unregister(sgiwd93_host);
-		return 0;
+	if (request_irq(irq, sgiwd93_intr, 0, "SGI WD93", (void *) host)) {
+		printk(KERN_WARNING "sgiwd93: Could not register irq %d "
+		       "for host %d.\n", irq, unit);
+		goto out_free;
 	}
-        /* set up second controller on the Indigo2 */
-	if(ip22_is_fullhouse()) {
-		sgiwd93_host1 = scsi_register(SGIblows, sizeof(struct WD33C93_hostdata));
-		if(sgiwd93_host1 != NULL)
-		{
-			sgiwd93_host1->base = (unsigned long) hregs1;
-			sgiwd93_host1->irq = SGI_WD93_1_IRQ;
-	
-			buf = (uchar *) get_zeroed_page(GFP_KERNEL);
-			if (!buf) {
-				printk(KERN_WARNING "sgiwd93: Could not allocate memory for host1 buffer.\n");
-				scsi_unregister(sgiwd93_host1);
-				called = 1;
-				return 1; /* We registered host0 so return success*/
-			}
-			init_hpc_chain(buf);
-
-			/* HPC_SCSI_REG1 | 0x03 | KSEG1 */
-			regs.SASR = (unsigned char*) KSEG1ADDR(0x1fbc8003);
-			regs.SCMD = (unsigned char*) KSEG1ADDR(0x1fbc8007);
-			wd33c93_init(sgiwd93_host1, regs, dma_setup, dma_stop,
-			             WD33C93_FS_16_20);
-	
-			hdata1 = (struct WD33C93_hostdata *)sgiwd93_host1->hostdata;
-			hdata1->no_sync = 0;
-			hdata1->dma_bounce_buffer = (uchar *) (KSEG1ADDR(buf));
-	
-			if (request_irq(SGI_WD93_1_IRQ, sgiwd93_intr, 0, "SGI WD93", (void *) sgiwd93_host1)) {
-				printk(KERN_WARNING "sgiwd93: Could not allocate irq %d (for host1).\n", SGI_WD93_1_IRQ);
-#ifdef MODULE
-				wd33c93_release();
-#endif
-				free_page((unsigned long)buf);
-				scsi_unregister(sgiwd93_host1);
-				/* Fall through since host0 registered OK */
-			}
-		}
+	return host;
+
+out_free:
+	free_page((unsigned long)buf);
+	wd33c93_release();
+
+out_unregister:
+	scsi_unregister(host);
+
+	return NULL;
+}
+
+int __init sgiwd93_detect(Scsi_Host_Template *SGIblows)
+{
+	int found = 0;
+
+	SGIblows->proc_name = "SGIWD93";
+	sgiwd93_host = sgiwd93_setup_scsi(SGIblows, 0, SGI_WD93_0_IRQ,
+	                                  &hpc3c0->scsi_chan0,
+	                                  (unsigned char *)hpc3c0->scsi0_ext);
+	if (sgiwd93_host)
+		found++;
+
+	/* Set up second controller on the Indigo2 */
+	if (ip22_is_fullhouse()) {
+		sgiwd93_host1 = sgiwd93_setup_scsi(SGIblows, 1, SGI_WD93_1_IRQ,
+		                          &hpc3c0->scsi_chan1,
+		                          (unsigned char *)hpc3c0->scsi1_ext);
+		if (sgiwd93_host1)
+			found++;
 	}
-	
-	called = 1;
 
-	return 1; /* Found one. */
+	return found;
 }
 
 #define HOSTS_C
@@ -313,7 +296,7 @@
 	free_irq(SGI_WD93_0_IRQ, sgiwd93_intr);
 	free_page(KSEG0ADDR(hdata->dma_bounce_buffer));
 	wd33c93_release();
-	if(ip22_is_fullhouse()) {
+	if (ip22_is_fullhouse()) {
 		free_irq(SGI_WD93_1_IRQ, sgiwd93_intr);
 		free_page(KSEG0ADDR(hdata1->dma_bounce_buffer));
 		wd33c93_release();
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/sound/au1000.c linux-2.4.22/drivers/sound/au1000.c
--- linux-2.4.22.clean/drivers/sound/au1000.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/sound/au1000.c	2003-09-27 14:08:57.000000000 +0200
@@ -2027,7 +2027,7 @@
 	s->codec = ac97_alloc_codec();
 	if(s->codec == NULL)
 	{
-		error("Out of memory");
+		err("Out of memory");
 		return -1;
 	}
 	s->codec->private_data = s;
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/sound/nec_vrc5477.c linux-2.4.22/drivers/sound/nec_vrc5477.c
--- linux-2.4.22.clean/drivers/sound/nec_vrc5477.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/sound/nec_vrc5477.c	2003-09-27 14:09:06.000000000 +0200
@@ -1965,7 +1965,7 @@
 	return -1;
 }
 
-static void __devinit vrc5477_ac97_remove(struct pci_dev *dev)
+static void __devexit vrc5477_ac97_remove(struct pci_dev *dev)
 {
 	struct vrc5477_ac97_state *s = pci_get_drvdata(dev);
 
@@ -2001,7 +2001,7 @@
 	name: VRC5477_AC97_MODULE_NAME,
 	id_table: id_table,
 	probe: vrc5477_ac97_probe,
-	remove: vrc5477_ac97_remove
+	remove: __devexit_p(vrc5477_ac97_remove)
 };
 
 static int __init init_vrc5477_ac97(void)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/sound/trident.c linux-2.4.22/drivers/sound/trident.c
--- linux-2.4.22.clean/drivers/sound/trident.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/sound/trident.c	2003-09-27 14:09:07.000000000 +0200
@@ -66,7 +66,7 @@
  *      with nothing in between. 
  *  v0.14.10a
  *      June 21 2002 Muli Ben-Yehuda <mulix@actcom.co.il> 
- *      use a debug macro instead of #ifdef CONFIG_DEBUG, trim to 80 columns 
+ *      use a debug macro instead of #ifdef CONFIG_RUNTIME_DEBUG, trim to 80 columns 
  *      per line, use 'do {} while (0)' in statement macros. 
  *  v0.14.10
  *      June 6 2002 Lei Hu <Lei_hu@ali.com.tw>
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/video/bt431.h linux-2.4.22/drivers/video/bt431.h
--- linux-2.4.22.clean/drivers/video/bt431.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/video/bt431.h	2003-09-23 14:10:50.000000000 +0200
@@ -0,0 +1,236 @@
+/*
+ *	linux/drivers/video/bt431.h
+ *
+ *	Copyright 2003  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+ *
+ *	This file is subject to the terms and conditions of the GNU General
+ *	Public License. See the file COPYING in the main directory of this
+ *	archive for more details.
+ */
+#include <linux/types.h>
+#include <asm/system.h>
+
+/*
+ * Bt431 cursor generator registers, 32-bit aligned.
+ * Two twin Bt431 are used on the DECstation's PMAG-AA.
+ */
+struct bt431_regs {
+	volatile u16 addr_lo;
+	u16 pad0;
+	volatile u16 addr_hi;
+	u16 pad1;
+	volatile u16 addr_cmap;
+	u16 pad2;
+	volatile u16 addr_reg;
+	u16 pad3;
+};
+
+static inline u16 bt431_set_value(u8 val)
+{
+	return ((val << 8) | (val & 0xff)) & 0xffff;
+}
+
+static inline u8 bt431_get_value(u16 val)
+{
+	return val & 0xff;
+}
+
+/*
+ * Additional registers addressed indirectly.
+ */
+#define BT431_REG_CMD		0x0000
+#define BT431_REG_CXLO		0x0001
+#define BT431_REG_CXHI		0x0002
+#define BT431_REG_CYLO		0x0003
+#define BT431_REG_CYHI		0x0004
+#define BT431_REG_WXLO		0x0005
+#define BT431_REG_WXHI		0x0006
+#define BT431_REG_WYLO		0x0007
+#define BT431_REG_WYHI		0x0008
+#define BT431_REG_WWLO		0x0009
+#define BT431_REG_WWHI		0x000a
+#define BT431_REG_WHLO		0x000b
+#define BT431_REG_WHHI		0x000c
+
+#define BT431_REG_CRAM_BASE	0x0000
+#define BT431_REG_CRAM_END	0x01ff
+
+/*
+ * Command register.
+ */
+#define BT431_CMD_CURS_ENABLE	0x40
+#define BT431_CMD_XHAIR_ENABLE	0x20
+#define BT431_CMD_OR_CURSORS	0x10
+#define BT431_CMD_AND_CURSORS	0x00
+#define BT431_CMD_1_1_MUX	0x00
+#define BT431_CMD_4_1_MUX	0x04
+#define BT431_CMD_5_1_MUX	0x08
+#define BT431_CMD_xxx_MUX	0x0c
+#define BT431_CMD_THICK_1	0x00
+#define BT431_CMD_THICK_3	0x01
+#define BT431_CMD_THICK_5	0x02
+#define BT431_CMD_THICK_7	0x03
+
+static inline void bt431_select_reg(struct bt431_regs *regs, int ir)
+{
+	/*
+	 * The compiler splits the write in two bytes without these
+	 * helper variables.
+	 */
+	volatile u16 *lo = &(regs->addr_lo);
+	volatile u16 *hi = &(regs->addr_hi);
+
+	mb();
+	*lo = bt431_set_value(ir & 0xff);
+	wmb();
+	*hi = bt431_set_value((ir >> 8) & 0xff);
+}
+
+/* Autoincrement read/write. */
+static inline u8 bt431_read_reg_inc(struct bt431_regs *regs)
+{
+	/*
+	 * The compiler splits the write in two bytes without the
+	 * helper variable.
+	 */
+	volatile u16 *r = &(regs->addr_reg);
+
+	mb();
+	return bt431_get_value(*r);
+}
+
+static inline void bt431_write_reg_inc(struct bt431_regs *regs, u8 value)
+{
+	/*
+	 * The compiler splits the write in two bytes without the
+	 * helper variable.
+	 */
+	volatile u16 *r = &(regs->addr_reg);
+
+	mb();
+	*r = bt431_set_value(value);
+}
+
+static inline u8 bt431_read_reg(struct bt431_regs *regs, int ir)
+{
+	bt431_select_reg(regs, ir);
+	return bt431_read_reg_inc(regs);
+}
+
+static inline void bt431_write_reg(struct bt431_regs *regs, int ir, u8 value)
+{
+	bt431_select_reg(regs, ir);
+	bt431_write_reg_inc(regs, value);
+}
+
+/* Autoincremented read/write for the cursor map. */
+static inline u16 bt431_read_cmap_inc(struct bt431_regs *regs)
+{
+	/*
+	 * The compiler splits the write in two bytes without the
+	 * helper variable.
+	 */
+	volatile u16 *r = &(regs->addr_cmap);
+
+	mb();
+	return *r;
+}
+
+static inline void bt431_write_cmap_inc(struct bt431_regs *regs, u16 value)
+{
+	/*
+	 * The compiler splits the write in two bytes without the
+	 * helper variable.
+	 */
+	volatile u16 *r = &(regs->addr_cmap);
+
+	mb();
+	*r = value;
+}
+
+static inline u16 bt431_read_cmap(struct bt431_regs *regs, int cr)
+{
+	bt431_select_reg(regs, cr);
+	return bt431_read_cmap_inc(regs);
+}
+
+static inline void bt431_write_cmap(struct bt431_regs *regs, int cr, u16 value)
+{
+	bt431_select_reg(regs, cr);
+	bt431_write_cmap_inc(regs, value);
+}
+
+static inline void bt431_enable_cursor(struct bt431_regs *regs)
+{
+	bt431_write_reg(regs, BT431_REG_CMD,
+			BT431_CMD_CURS_ENABLE | BT431_CMD_OR_CURSORS
+			| BT431_CMD_4_1_MUX | BT431_CMD_THICK_1);
+}
+
+static inline void bt431_erase_cursor(struct bt431_regs *regs)
+{
+	bt431_write_reg(regs, BT431_REG_CMD, BT431_CMD_4_1_MUX);
+}
+
+static inline void bt431_position_cursor(struct bt431_regs *regs, u16 x, u16 y)
+{
+	/*
+	 * Magic from the MACH sources.
+	 * 
+	 * Cx = x + D + H - P
+	 *  P = 37 if 1:1, 52 if 4:1, 57 if 5:1
+	 *  D = pixel skew between outdata and external data
+	 *  H = pixels between HSYNCH falling and active video
+	 *
+	 * Cy = y + V - 32
+	 *  V = scanlines between HSYNCH falling, two or more
+	 *      clocks after VSYNCH falling, and active video
+	 */
+	x += 412 - 52;
+	y += 68 - 32;
+
+	/* Use autoincrement. */
+	bt431_select_reg(regs, BT431_REG_CXLO);
+	bt431_write_reg_inc(regs, x & 0xff); /* BT431_REG_CXLO */
+	bt431_write_reg_inc(regs, (x >> 8) & 0x0f); /* BT431_REG_CXHI */
+	bt431_write_reg_inc(regs, y & 0xff); /* BT431_REG_CYLO */
+	bt431_write_reg_inc(regs, (y >> 8) & 0x0f); /* BT431_REG_CYHI */
+}
+
+static inline void bt431_set_font(struct bt431_regs *regs, u8 fgc,
+				  u16 width, u16 height)
+{
+	int i;
+	u16 fgp = fgc ? 0xffff : 0x0000;
+	u16 bgp = fgc ? 0x0000 : 0xffff;
+
+	bt431_select_reg(regs, BT431_REG_CRAM_BASE);
+	for (i = BT431_REG_CRAM_BASE; i <= BT431_REG_CRAM_END; i++) {
+		u16 value;
+
+		if (height << 6 <= i << 3)
+			value = bgp;
+		else if (width <= i % 8 << 3)
+			value = bgp;
+		else if (((width >> 3) & 0xffff) > i % 8)
+			value = fgp;
+		else
+			value = fgp & ~(bgp << (width % 8 << 1));
+
+		bt431_write_cmap_inc(regs, value);
+	}
+}
+
+static inline void bt431_init_cursor(struct bt431_regs *regs)
+{
+	/* no crosshair window */
+	bt431_select_reg(regs, BT431_REG_WXLO);
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WXLO */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WXHI */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WYLO */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WYHI */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WWLO */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WWHI */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WHLO */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WHHI */
+}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/video/bt455.h linux-2.4.22/drivers/video/bt455.h
--- linux-2.4.22.clean/drivers/video/bt455.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/video/bt455.h	2003-09-23 14:10:50.000000000 +0200
@@ -0,0 +1,95 @@
+/*
+ *	linux/drivers/video/bt455.h
+ *
+ *	Copyright 2003  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+ *
+ *	This file is subject to the terms and conditions of the GNU General
+ *	Public License. See the file COPYING in the main directory of this
+ *	archive for more details.
+ */
+#include <linux/types.h>
+#include <asm/system.h>
+
+/*
+ * Bt455 byte-wide registers, 32-bit aligned.
+ */
+struct bt455_regs {
+	volatile u8 addr_cmap;
+	u8 pad0[3];
+	volatile u8 addr_cmap_data;
+	u8 pad1[3];
+	volatile u8 addr_clr;
+	u8 pad2[3];
+	volatile u8 addr_ovly;
+	u8 pad3[3];
+};
+
+static inline void bt455_select_reg(struct bt455_regs *regs, int ir)
+{
+	mb();
+	regs->addr_cmap = ir & 0x0f;
+}
+
+/*
+ * Read/write to a Bt455 color map register.
+ */
+static inline void bt455_read_cmap_entry(struct bt455_regs *regs, int cr,
+					 u8* red, u8* green, u8* blue)
+{
+	bt455_select_reg(regs, cr);
+	mb();
+	*red = regs->addr_cmap_data & 0x0f;
+	rmb();
+	*green = regs->addr_cmap_data & 0x0f;
+	rmb();
+	*blue = regs->addr_cmap_data & 0x0f;
+}
+
+static inline void bt455_write_cmap_entry(struct bt455_regs *regs, int cr,
+					  u8 red, u8 green, u8 blue)
+{
+	bt455_select_reg(regs, cr);
+	wmb();
+	regs->addr_cmap_data = red & 0x0f;
+	wmb();
+	regs->addr_cmap_data = green & 0x0f;
+	wmb();
+	regs->addr_cmap_data = blue & 0x0f;
+}
+
+static inline void bt455_write_ovly_entry(struct bt455_regs *regs, int cr,
+					  u8 red, u8 green, u8 blue)
+{
+	bt455_select_reg(regs, cr);
+	wmb();
+	regs->addr_ovly = red & 0x0f;
+	wmb();
+	regs->addr_ovly = green & 0x0f;
+	wmb();
+	regs->addr_ovly = blue & 0x0f;
+}
+
+static inline void bt455_set_cursor(struct bt455_regs *regs)
+{
+	mb();
+	regs->addr_ovly = 0x0f;
+	wmb();
+	regs->addr_ovly = 0x0f;
+	wmb();
+	regs->addr_ovly = 0x0f;
+}
+
+static inline void bt455_erase_cursor(struct bt455_regs *regs)
+{
+	/* bt455_write_cmap_entry(regs, 8, 0x00, 0x00, 0x00); */
+	/* bt455_write_cmap_entry(regs, 9, 0x00, 0x00, 0x00); */
+	bt455_write_ovly_entry(regs, 8, 0x03, 0x03, 0x03);
+	bt455_write_ovly_entry(regs, 9, 0x07, 0x07, 0x07);
+
+	wmb();
+	regs->addr_ovly = 0x09;
+	wmb();
+	regs->addr_ovly = 0x09;
+	wmb();
+	regs->addr_ovly = 0x09;
+}
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/video/Config.in linux-2.4.22/drivers/video/Config.in
--- linux-2.4.22.clean/drivers/video/Config.in	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/video/Config.in	2003-09-27 14:09:26.000000000 +0200
@@ -218,6 +218,7 @@
       tristate '  HD64461 Frame Buffer support' CONFIG_FB_HIT
    fi
    if [ "$CONFIG_DECSTATION" = "y" ]; then
+      dep_bool '  PMAG-AA TURBOchannel framebuffer support' CONFIG_FB_PMAG_AA $CONFIG_TC
       dep_bool '  PMAG-BA TURBOchannel framebuffer support' CONFIG_FB_PMAG_BA $CONFIG_TC
       dep_bool '  PMAGB-B TURBOchannel framebuffer support' CONFIG_FB_PMAGB_B $CONFIG_TC
       dep_bool '  Maxine (Personal DECstation) onboard framebuffer support' CONFIG_FB_MAXINE $CONFIG_TC
@@ -296,8 +297,9 @@
 	   "$CONFIG_FB_RIVA" = "y" -o "$CONFIG_FB_RADEON" = "y" -o \
 	   "$CONFIG_FB_SGIVW" = "y" -o "$CONFIG_FB_CYBER2000" = "y" -o \
 	   "$CONFIG_FB_SA1100" = "y" -o "$CONFIG_FB_3DFX" = "y" -o \
-	   "$CONFIG_FB_PMAG_BA" = "y" -o "$CONFIG_FB_PMAGB_B" = "y" -o \
-	   "$CONFIG_FB_MAXINE" = "y" -o "$CONFIG_FB_TX3912" = "y" -o \
+	   "$CONFIG_FB_PMAG_AA" = "y" -o "$CONFIG_FB_PMAG_BA" = "y" -o \
+	   "$CONFIG_FB_PMAGB_B" = "y" -o "$CONFIG_FB_MAXINE" = "y" -o \
+	   "$CONFIG_FB_TX3912" = "y" -o \
 	   "$CONFIG_FB_SIS" = "y" -o "$CONFIG_FB_NEOMAGIC" = "y" -o \
 	   "$CONFIG_FB_STI" = "y" -o "$CONFIG_FB_HP300" = "y" -o \
 	   "$CONFIG_FB_INTEL" = "y" ]; then
@@ -318,8 +320,9 @@
 	      "$CONFIG_FB_P9100" = "m" -o "$CONFIG_FB_ATY128" = "m" -o \
 	      "$CONFIG_FB_RIVA" = "m" -o "$CONFIG_FB_3DFX" = "m" -o \
 	      "$CONFIG_FB_SGIVW" = "m" -o "$CONFIG_FB_CYBER2000" = "m" -o \
-	      "$CONFIG_FB_PMAG_BA" = "m" -o "$CONFIG_FB_PMAGB_B" = "m" -o \
-	      "$CONFIG_FB_MAXINE" = "m" -o "$CONFIG_FB_RADEON" = "m" -o \
+	      "$CONFIG_FB_PMAG_AA" = "m" -o "$CONFIG_FB_PMAG_BA" = "m" -o \
+	      "$CONFIG_FB_PMAGB_B" = "m" -o "$CONFIG_FB_MAXINE" = "m" -o \
+	      "$CONFIG_FB_RADEON" = "m" -o \
 	      "$CONFIG_FB_SA1100" = "m" -o "$CONFIG_FB_SIS" = "m" -o \
 	      "$CONFIG_FB_TX3912" = "m" -o "$CONFIG_FB_NEOMAGIC" = "m" -o \
 	      "$CONFIG_FB_STI" = "m" -o "$CONFIG_FB_INTEL" = "m" ]; then
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/video/fbmem.c linux-2.4.22/drivers/video/fbmem.c
--- linux-2.4.22.clean/drivers/video/fbmem.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/video/fbmem.c	2003-09-27 14:09:27.000000000 +0200
@@ -124,9 +124,10 @@
 extern int sisfb_setup(char*);
 extern int stifb_init(void);
 extern int stifb_setup(char*);
+extern int pmagaafb_init(void);
 extern int pmagbafb_init(void);
 extern int pmagbbfb_init(void);
-extern void maxinefb_init(void);
+extern int maxinefb_init(void);
 extern int tx3912fb_init(void);
 extern int radeonfb_init(void);
 extern int radeonfb_setup(char*);
@@ -313,6 +314,9 @@
 #ifdef CONFIG_FB_PVR2
 	{ "pvr2", pvr2fb_init, pvr2fb_setup },
 #endif
+#ifdef CONFIG_FB_PMAG_AA
+	{ "pmagaafb", pmagaafb_init, NULL },
+#endif
 #ifdef CONFIG_FB_PMAG_BA
 	{ "pmagbafb", pmagbafb_init, NULL },
 #endif
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/video/Makefile linux-2.4.22/drivers/video/Makefile
--- linux-2.4.22.clean/drivers/video/Makefile	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/video/Makefile	2003-09-27 14:09:26.000000000 +0200
@@ -81,6 +81,7 @@
 obj-$(CONFIG_FB_CGFOURTEEN)       += cgfourteenfb.o sbusfb.o
 obj-$(CONFIG_FB_P9100)            += p9100fb.o sbusfb.o
 obj-$(CONFIG_FB_LEO)              += leofb.o sbusfb.o
+obj-$(CONFIG_FB_PMAG_AA)          += pmag-aa-fb.o
 obj-$(CONFIG_FB_PMAG_BA)          += pmag-ba-fb.o
 obj-$(CONFIG_FB_PMAGB_B)          += pmagb-b-fb.o
 obj-$(CONFIG_FB_MAXINE)           += maxinefb.o
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/drivers/video/pmag-aa-fb.c linux-2.4.22/drivers/video/pmag-aa-fb.c
--- linux-2.4.22.clean/drivers/video/pmag-aa-fb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/drivers/video/pmag-aa-fb.c	2003-09-23 14:10:50.000000000 +0200
@@ -0,0 +1,514 @@
+/*
+ *	linux/drivers/video/pmag-aa-fb.c
+ *	Copyright 2002 Karsten Merker <merker@debian.org>
+ *
+ *	PMAG-AA TurboChannel framebuffer card support ... derived from
+ *	pmag-ba-fb.c, which is Copyright (C) 1999, 2000, 2001 by
+ *	Michael Engel <engel@unix-ag.org>, Karsten Merker <merker@debian.org>
+ *	and Harald Koerfgen <hkoerfg@web.de>, which itself is derived from
+ *	"HP300 Topcat framebuffer support (derived from macfb of all things)
+ *	Phil Blundell <philb@gnu.org> 1998"
+ *
+ *	This file is subject to the terms and conditions of the GNU General
+ *	Public License.  See the file COPYING in the main directory of this
+ *	archive for more details.
+ *
+ *	2002-09-28  Karsten Merker <merker@linuxtag.org>
+ *		Version 0.01: First try to get a PMAG-AA running.
+ * 
+ *	2003-02-24  Thiemo Seufer  <seufer@csv.ica.uni-stuttgart.de>
+ *		Version 0.02: Major code cleanup.
+ *
+ *	2003-09-21  Thiemo Seufer  <seufer@csv.ica.uni-stuttgart.de>
+ *		Hardware cursor support.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+
+#include <asm/bootinfo.h>
+#include <asm/dec/machtype.h>
+#include <asm/dec/tc.h>
+
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+
+#include "bt455.h"
+#include "bt431.h"
+
+/* Version information */
+#define DRIVER_VERSION "0.02"
+#define DRIVER_AUTHOR "Karsten Merker <merker@linuxtag.org>"
+#define DRIVER_DESCRIPTION "PMAG-AA Framebuffer Driver"
+
+/* Prototypes */
+static int aafb_set_var(struct fb_var_screeninfo *var, int con,
+			struct fb_info *info);
+
+/*
+ * Bt455 RAM DAC register base offset (rel. to TC slot base address).
+ */
+#define PMAG_AA_BT455_OFFSET		0x100000
+
+/*
+ * Bt431 cursor generator offset (rel. to TC slot base address).
+ */
+#define PMAG_AA_BT431_OFFSET		0x180000
+
+/*
+ * Begin of PMAG-AA framebuffer memory relative to TC slot address,
+ * resolution is 1280x1024x1 (8 bits deep, but only LSB is used).
+ */
+#define PMAG_AA_ONBOARD_FBMEM_OFFSET	0x200000
+
+struct aafb_cursor {
+	struct timer_list timer;
+	int enable;
+	int on;
+	int vbl_cnt;
+	int blink_rate;
+	u16 x, y, width, height;
+};
+
+#define CURSOR_TIMER_FREQ	(HZ / 50)
+#define CURSOR_BLINK_RATE	(20)
+#define CURSOR_DRAW_DELAY	(2)
+
+struct aafb_info {
+	struct fb_info info;
+	struct display disp;
+	struct aafb_cursor cursor;
+	struct bt455_regs *bt455;
+	struct bt431_regs *bt431;
+	unsigned long fb_start;
+	unsigned long fb_size;
+	unsigned long fb_line_length;
+};
+
+/*
+ * Max 3 TURBOchannel slots -> max 3 PMAG-AA.
+ */
+static struct aafb_info my_fb_info[3];
+
+static struct aafb_par {
+} current_par;
+
+static int currcon = -1;
+
+static void aafb_set_cursor(struct aafb_info *info, int on)
+{
+	struct aafb_cursor *c = &info->cursor;
+
+	if (on) {
+		bt431_position_cursor(info->bt431, c->x, c->y);
+		bt431_enable_cursor(info->bt431);
+	} else
+		bt431_erase_cursor(info->bt431);
+}
+
+static void aafbcon_cursor(struct display *disp, int mode, int x, int y)
+{
+	struct aafb_info *info = (struct aafb_info *)disp->fb_info;
+	struct aafb_cursor *c = &info->cursor;
+
+	x *= fontwidth(disp);
+	y *= fontheight(disp);
+
+	if (c->x == x && c->y == y && (mode == CM_ERASE) == !c->enable)
+		return;
+
+	c->enable = 0;
+	if (c->on)
+		aafb_set_cursor(info, 0);
+	c->x = x - disp->var.xoffset;
+	c->y = y - disp->var.yoffset;
+
+	switch (mode) {
+		case CM_ERASE:
+			c->on = 0;
+			break;
+		case CM_DRAW:
+		case CM_MOVE:
+			if (c->on)
+				aafb_set_cursor(info, c->on);
+			else
+				c->vbl_cnt = CURSOR_DRAW_DELAY;
+			c->enable = 1;
+			break;
+	}
+}
+
+static int aafbcon_set_font(struct display *disp, int width, int height)
+{
+	struct aafb_info *info = (struct aafb_info *)disp->fb_info;
+	struct aafb_cursor *c = &info->cursor;
+	u8 fgc = ~attr_bgcol_ec(disp, disp->conp);
+
+	if (width > 64 || height > 64 || width < 0 || height < 0)
+		return -EINVAL;
+
+	c->height = height;
+	c->width = width;
+
+	bt431_set_font(info->bt431, fgc, width, height);
+
+	return 1;
+}
+
+static void aafb_cursor_timer_handler(unsigned long data)
+{
+	struct aafb_info *info = (struct aafb_info *)data;
+	struct aafb_cursor *c = &info->cursor;
+
+	if (!c->enable)
+		goto out;
+
+	if (c->vbl_cnt && --c->vbl_cnt == 0) {
+		c->on ^= 1;
+		aafb_set_cursor(info, c->on);
+		c->vbl_cnt = c->blink_rate;
+	}
+
+out:
+	c->timer.expires = jiffies + CURSOR_TIMER_FREQ;
+	add_timer(&c->timer);
+}
+
+static void __init aafb_cursor_init(struct aafb_info *info)
+{
+	struct aafb_cursor *c = &info->cursor;
+
+	c->enable = 1;
+	c->on = 1;
+	c->x = c->y = 0;
+	c->width = c->height = 0;
+	c->vbl_cnt = CURSOR_DRAW_DELAY;
+	c->blink_rate = CURSOR_BLINK_RATE;
+
+	init_timer(&c->timer);
+	c->timer.data = (unsigned long)info;
+	c->timer.function = aafb_cursor_timer_handler;
+	mod_timer(&c->timer, jiffies + CURSOR_TIMER_FREQ);
+}
+
+static void __exit aafb_cursor_exit(struct aafb_info *info)
+{
+	struct aafb_cursor *c = &info->cursor;
+
+	del_timer_sync(&c->timer);
+}
+
+static struct display_switch aafb_switch8 = {
+	.setup = fbcon_cfb8_setup,
+	.bmove = fbcon_cfb8_bmove,
+	.clear = fbcon_cfb8_clear,
+	.putc = fbcon_cfb8_putc,
+	.putcs = fbcon_cfb8_putcs,
+	.revc = fbcon_cfb8_revc,
+	.cursor = aafbcon_cursor,
+	.set_font = aafbcon_set_font,
+	.clear_margins = fbcon_cfb8_clear_margins,
+	.fontwidthmask = FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)
+};
+
+static void aafb_get_par(struct aafb_par *par)
+{
+	*par = current_par;
+}
+
+static int aafb_get_fix(struct fb_fix_screeninfo *fix, int con,
+			struct fb_info *info)
+{
+	struct aafb_info *ip = (struct aafb_info *)info;
+
+	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
+	strcpy(fix->id, "PMAG-AA");
+	fix->smem_start = ip->fb_start;
+	fix->smem_len = ip->fb_size;
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->ypanstep = 1;
+	fix->ywrapstep = 1;
+	fix->visual = FB_VISUAL_MONO10;
+	fix->line_length = 1280;
+	fix->accel = FB_ACCEL_NONE;
+
+	return 0;
+}
+
+static void aafb_set_disp(struct display *disp, int con,
+			  struct aafb_info *info)
+{
+	struct fb_fix_screeninfo fix;
+
+	disp->fb_info = &info->info;
+	aafb_set_var(&disp->var, con, &info->info);
+	if (disp->conp && disp->conp->vc_sw && disp->conp->vc_sw->con_cursor)
+		disp->conp->vc_sw->con_cursor(disp->conp, CM_ERASE);
+	disp->dispsw = &aafb_switch8;
+	disp->dispsw_data = 0;
+
+	aafb_get_fix(&fix, con, &info->info);
+	disp->screen_base = (u8 *) fix.smem_start;
+	disp->visual = fix.visual;
+	disp->type = fix.type;
+	disp->type_aux = fix.type_aux;
+	disp->ypanstep = fix.ypanstep;
+	disp->ywrapstep = fix.ywrapstep;
+	disp->line_length = fix.line_length;
+	disp->next_line = 2048;
+	disp->can_soft_blank = 1;
+	disp->inverse = 0;
+	disp->scrollmode = SCROLL_YREDRAW;
+
+	aafbcon_set_font(disp, fontwidth(disp), fontheight(disp));
+}
+
+static int aafb_get_cmap(struct fb_cmap *cmap, int kspc, int con,
+			 struct fb_info *info)
+{
+	static u16 color[2] = {0x0000, 0x000f};
+	static struct fb_cmap aafb_cmap = {0, 2, color, color, color, NULL};
+
+	fb_copy_cmap(&aafb_cmap, cmap, kspc ? 0 : 2);
+	return 0;
+}
+
+static int aafb_set_cmap(struct fb_cmap *cmap, int kspc, int con,
+			 struct fb_info *info)
+{
+	u16 color[2] = {0x0000, 0x000f};
+
+	if (cmap->start == 0
+	    && cmap->len == 2
+	    && memcmp(cmap->red, color, sizeof(color)) == 0
+	    && memcmp(cmap->green, color, sizeof(color)) == 0
+	    && memcmp(cmap->blue, color, sizeof(color)) == 0
+	    && cmap->transp == NULL)
+		return 0;
+	else
+	return -EINVAL;
+}
+
+static int aafb_ioctl(struct inode *inode, struct file *file, u32 cmd,
+		      unsigned long arg, int con, struct fb_info *info)
+{
+	/* TODO: Not yet implemented */
+	return -ENOIOCTLCMD;
+}
+
+static int aafb_switch(int con, struct fb_info *info)
+{
+	struct aafb_info *ip = (struct aafb_info *)info;
+	struct display *old = (currcon < 0) ? &ip->disp : (fb_display + currcon);
+	struct display *new = (con < 0) ? &ip->disp : (fb_display + con);
+
+	if (old->conp && old->conp->vc_sw && old->conp->vc_sw->con_cursor)
+		old->conp->vc_sw->con_cursor(old->conp, CM_ERASE);
+
+	/* Set the current console. */
+	currcon = con;
+	aafb_set_disp(new, con, ip);
+
+	return 0;
+}
+
+static void aafb_encode_var(struct fb_var_screeninfo *var,
+			    struct aafb_par *par)
+{
+	var->xres = 1280;
+	var->yres = 1024;
+	var->xres_virtual = 2048;
+	var->yres_virtual = 1024;
+	var->xoffset = 0;
+	var->yoffset = 0;
+	var->bits_per_pixel = 8;
+	var->grayscale = 1;
+	var->red.offset = 0;
+	var->red.length = 0;
+	var->red.msb_right = 0;
+	var->green.offset = 0;
+	var->green.length = 1;
+	var->green.msb_right = 0;
+	var->blue.offset = 0;
+	var->blue.length = 0;
+	var->blue.msb_right = 0;
+	var->transp.offset = 0;
+	var->transp.length = 0;
+	var->transp.msb_right = 0;
+	var->nonstd = 0;
+	var->activate &= ~FB_ACTIVATE_MASK & FB_ACTIVATE_NOW;
+	var->accel_flags = 0;
+	var->sync = FB_SYNC_ON_GREEN;
+	var->vmode &= ~FB_VMODE_MASK & FB_VMODE_NONINTERLACED;
+}
+
+static int aafb_get_var(struct fb_var_screeninfo *var, int con,
+			struct fb_info *info)
+{
+	if (con < 0) {
+		struct aafb_par par;
+
+		memset(var, 0, sizeof(struct fb_var_screeninfo));
+		aafb_get_par(&par);
+		aafb_encode_var(var, &par);
+	} else
+		*var = info->var;
+
+	return 0;
+}
+
+static int aafb_set_var(struct fb_var_screeninfo *var, int con,
+			struct fb_info *info)
+{
+	struct aafb_par par;
+
+	aafb_get_par(&par);
+	aafb_encode_var(var, &par);
+	info->var = *var;
+
+	return 0;
+}
+
+static int aafb_update_var(int con, struct fb_info *info)
+{
+	struct aafb_info *ip = (struct aafb_info *)info;
+	struct display *disp = (con < 0) ? &ip->disp : (fb_display + con);
+
+	if (con == currcon)
+		aafbcon_cursor(disp, CM_ERASE, ip->cursor.x, ip->cursor.y);
+
+	return 0;
+}
+
+/* 0 unblanks, any other blanks. */
+
+static void aafb_blank(int blank, struct fb_info *info)
+{
+	struct aafb_info *ip = (struct aafb_info *)info;
+	u8 val = blank ? 0x00 : 0x0f;
+
+	bt455_write_cmap_entry(ip->bt455, 1, val, val, val);
+	aafbcon_cursor(&ip->disp, CM_ERASE, ip->cursor.x, ip->cursor.y);
+}
+
+static struct fb_ops aafb_ops = {
+	.owner = THIS_MODULE,
+	.fb_get_fix = aafb_get_fix,
+	.fb_get_var = aafb_get_var,
+	.fb_set_var = aafb_set_var,
+	.fb_get_cmap = aafb_get_cmap,
+	.fb_set_cmap = aafb_set_cmap,
+	.fb_ioctl = aafb_ioctl
+};
+
+static int __init init_one(int slot)
+{
+	unsigned long base_addr = get_tc_base_addr(slot);
+	struct aafb_info *ip = &my_fb_info[slot];
+
+	memset(ip, 0, sizeof(struct aafb_info));
+
+	/*
+	 * Framebuffer display memory base address and friends.
+	 */
+	ip->bt455 = (struct bt455_regs *) (base_addr + PMAG_AA_BT455_OFFSET);
+	ip->bt431 = (struct bt431_regs *) (base_addr + PMAG_AA_BT431_OFFSET);
+	ip->fb_start = base_addr + PMAG_AA_ONBOARD_FBMEM_OFFSET;
+	ip->fb_size = 2048 * 1024; /* fb_fix_screeninfo.smem_length
+				      seems to be physical */
+	ip->fb_line_length = 2048;
+
+	/*
+	 * Let there be consoles..
+	 */
+	strcpy(ip->info.modename, "PMAG-AA");
+	ip->info.node = -1;
+	ip->info.flags = FBINFO_FLAG_DEFAULT;
+	ip->info.fbops = &aafb_ops;
+	ip->info.disp = &ip->disp;
+	ip->info.changevar = NULL;
+	ip->info.switch_con = &aafb_switch;
+	ip->info.updatevar = &aafb_update_var;
+	ip->info.blank = &aafb_blank;
+
+	aafb_set_disp(&ip->disp, currcon, ip);
+
+	/*
+	 * Configure the RAM DACs.
+	 */
+	bt455_erase_cursor(ip->bt455);
+
+	/* Init colormap. */
+	bt455_write_cmap_entry(ip->bt455, 0, 0x00, 0x00, 0x00);
+	bt455_write_cmap_entry(ip->bt455, 1, 0x0f, 0x0f, 0x0f);
+
+	/* Init hardware cursor. */
+	bt431_init_cursor(ip->bt431);
+	aafb_cursor_init(ip);
+
+	/* Clear the screen. */
+	memset ((void *)ip->fb_start, 0, ip->fb_size);
+
+	if (register_framebuffer(&ip->info) < 0)
+		return -EINVAL;
+
+	printk(KERN_INFO "fb%d: %s frame buffer in TC slot %d\n",
+	       GET_FB_IDX(ip->info.node), ip->info.modename, slot);
+
+	return 0;
+}
+
+static int __exit exit_one(int slot)
+{
+	struct aafb_info *ip = &my_fb_info[slot];
+
+	if (unregister_framebuffer(&ip->info) < 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* 
+ * Initialise the framebuffer.
+ */
+int __init pmagaafb_init(void)
+{
+	int sid;
+	int found = 0;
+
+	while ((sid = search_tc_card("PMAG-AA")) >= 0) {
+		found = 1;
+		claim_tc_card(sid);
+		init_one(sid);
+	}
+
+	return found ? 0 : -ENODEV;
+}
+
+static void __exit pmagaafb_exit(void)
+{
+	int sid;
+
+	while ((sid = search_tc_card("PMAG-AA")) >= 0) {
+		exit_one(sid);
+		release_tc_card(sid);
+	}
+}
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
+MODULE_LICENSE("GPL");
+#ifdef MODULE
+module_init(pmagaafb_init);
+module_exit(pmagaafb_exit);
+#endif
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/fs/binfmt_elf.c linux-2.4.22/fs/binfmt_elf.c
--- linux-2.4.22.clean/fs/binfmt_elf.c	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.22/fs/binfmt_elf.c	2003-09-27 14:09:31.000000000 +0200
@@ -598,6 +598,9 @@
 		    bprm->argc++;
 		  }
 		}
+	} else {
+		/* Executables without an interpreter also need a personality  */
+		SET_PERSONALITY(elf_ex, ibcs2_interpreter);
 	}
 
 	/* Flush all traces of the currently running executable */
@@ -1110,7 +1113,11 @@
 	elf.e_entry = 0;
 	elf.e_phoff = sizeof(elf);
 	elf.e_shoff = 0;
+#ifdef ELF_CORE_EFLAGS
+	elf.e_flags = ELF_CORE_EFLAGS;
+#else
 	elf.e_flags = 0;
+#endif
 	elf.e_ehsize = sizeof(elf);
 	elf.e_phentsize = sizeof(struct elf_phdr);
 	elf.e_phnum = segs+1;		/* Include notes */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/fs/partitions/check.c linux-2.4.22/fs/partitions/check.c
--- linux-2.4.22.clean/fs/partitions/check.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/fs/partitions/check.c	2002-09-11 14:45:26.000000000 +0200
@@ -43,6 +43,9 @@
 #ifdef CONFIG_ACORN_PARTITION
 	acorn_partition,
 #endif
+#ifdef CONFIG_SGI_PARTITION
+	sgi_partition,
+#endif
 #ifdef CONFIG_EFI_PARTITION
 	efi_partition,		/* this must come before msdos */
 #endif
@@ -67,9 +70,6 @@
 #ifdef CONFIG_MAC_PARTITION
 	mac_partition,
 #endif
-#ifdef CONFIG_SGI_PARTITION
-	sgi_partition,
-#endif
 #ifdef CONFIG_ULTRIX_PARTITION
 	ultrix_partition,
 #endif
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/fs/proc/array.c linux-2.4.22/fs/proc/array.c
--- linux-2.4.22.clean/fs/proc/array.c	2003-06-13 16:51:37.000000000 +0200
+++ linux-2.4.22/fs/proc/array.c	2003-07-05 05:23:45.000000000 +0200
@@ -361,15 +361,15 @@
 		task->cmin_flt,
 		task->maj_flt,
 		task->cmaj_flt,
-		task->times.tms_utime,
-		task->times.tms_stime,
-		task->times.tms_cutime,
-		task->times.tms_cstime,
+		hz_to_std(task->times.tms_utime),
+		hz_to_std(task->times.tms_stime),
+		hz_to_std(task->times.tms_cutime),
+		hz_to_std(task->times.tms_cstime),
 		priority,
 		nice,
 		0UL /* removed */,
 		task->it_real_value,
-		task->start_time,
+		hz_to_std(task->start_time),
 		vsize,
 		mm ? mm->rss : 0, /* you might want to shift this left 3 */
 		task->rlim[RLIMIT_RSS].rlim_cur,
@@ -691,14 +691,14 @@
 
 	len = sprintf(buffer,
 		"cpu  %lu %lu\n",
-		task->times.tms_utime,
-		task->times.tms_stime);
+		hz_to_std(task->times.tms_utime),
+		hz_to_std(task->times.tms_stime));
 		
 	for (i = 0 ; i < smp_num_cpus; i++)
 		len += sprintf(buffer + len, "cpu%d %lu %lu\n",
 			i,
-			task->per_cpu_utime[cpu_logical_map(i)],
-			task->per_cpu_stime[cpu_logical_map(i)]);
+			hz_to_std(task->per_cpu_utime[cpu_logical_map(i)]),
+			hz_to_std(task->per_cpu_stime[cpu_logical_map(i)]));
 
 	return len;
 }
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/fs/proc/proc_misc.c linux-2.4.22/fs/proc/proc_misc.c
--- linux-2.4.22.clean/fs/proc/proc_misc.c	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.22/fs/proc/proc_misc.c	2003-09-27 14:09:33.000000000 +0200
@@ -306,16 +306,16 @@
 {
 	int i, len = 0;
 	extern unsigned long total_forks;
-	unsigned long jif = jiffies;
+	unsigned long jif = hz_to_std(jiffies);
 	unsigned int sum = 0, user = 0, nice = 0, system = 0;
 	int major, disk;
 
 	for (i = 0 ; i < smp_num_cpus; i++) {
 		int cpu = cpu_logical_map(i), j;
 
-		user += kstat.per_cpu_user[cpu];
-		nice += kstat.per_cpu_nice[cpu];
-		system += kstat.per_cpu_system[cpu];
+		user += hz_to_std(kstat.per_cpu_user[cpu]);
+		nice += hz_to_std(kstat.per_cpu_nice[cpu]);
+		system += hz_to_std(kstat.per_cpu_system[cpu]);
 #if !defined(CONFIG_ARCH_S390)
 		for (j = 0 ; j < NR_IRQS ; j++)
 			sum += kstat.irqs[cpu][j];
@@ -329,10 +329,10 @@
 		proc_sprintf(page, &off, &len,
 			"cpu%d %u %u %u %lu\n",
 			i,
-			kstat.per_cpu_user[cpu_logical_map(i)],
-			kstat.per_cpu_nice[cpu_logical_map(i)],
-			kstat.per_cpu_system[cpu_logical_map(i)],
-			jif - (  kstat.per_cpu_user[cpu_logical_map(i)] \
+			hz_to_std(kstat.per_cpu_user[cpu_logical_map(i)]),
+			hz_to_std(kstat.per_cpu_nice[cpu_logical_map(i)]),
+			hz_to_std(kstat.per_cpu_system[cpu_logical_map(i)]),
+			jif - hz_to_std(  kstat.per_cpu_user[cpu_logical_map(i)] \
 				   + kstat.per_cpu_nice[cpu_logical_map(i)] \
 				   + kstat.per_cpu_system[cpu_logical_map(i)]));
 	proc_sprintf(page, &off, &len,
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/fs/stat.c linux-2.4.22/fs/stat.c
--- linux-2.4.22.clean/fs/stat.c	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.22/fs/stat.c	2003-09-27 14:09:31.000000000 +0200
@@ -26,7 +26,7 @@
 }
 
 
-#if !defined(__alpha__) && !defined(__sparc__) && !defined(__ia64__) && !defined(CONFIG_ARCH_S390) && !defined(__hppa__) && !defined(__x86_64__)
+#if defined(__i386__) || defined(__m68k__) || defined(__ppc__) || defined(__sh__)
 
 /*
  * For backward compatibility?  Maybe this should be moved
@@ -129,7 +129,7 @@
 }
 
 
-#if !defined(__alpha__) && !defined(__sparc__) && !defined(__ia64__) && !defined(CONFIG_ARCH_S390) && !defined(__hppa__) && !defined(__x86_64__)
+#if defined(__i386__) || defined(__m68k__) || defined(__ppc__) || defined(__sh__)
 /*
  * For backward compatibility?  Maybe this should be moved
  * into arch/i386 instead?
@@ -165,7 +165,7 @@
 	return error;
 }
 
-#if !defined(__alpha__) && !defined(__sparc__) && !defined(__ia64__) && !defined(CONFIG_ARCH_S390) && !defined(__hppa__) && !defined(__x86_64__)
+#if defined(__i386__) || defined(__m68k__) || defined(__ppc__) || defined(__sh__)
 
 /*
  * For backward compatibility?  Maybe this should be moved
@@ -203,7 +203,7 @@
 	return error;
 }
 
-#if !defined(__alpha__) && !defined(__sparc__) && !defined(__ia64__) && !defined(CONFIG_ARCH_S390) && !defined(__hppa__) && !defined(__x86_64__)
+#if defined(__i386__) || defined(__m68k__) || defined(__ppc__) || defined(__sh__)
 
 /*
  * For backward compatibility?  Maybe this should be moved
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-alpha/param.h linux-2.4.22/include/asm-alpha/param.h
--- linux-2.4.22.clean/include/asm-alpha/param.h	2000-11-08 08:37:31.000000000 +0100
+++ linux-2.4.22/include/asm-alpha/param.h	2000-11-28 04:59:03.000000000 +0100
@@ -13,6 +13,9 @@
 # else
 #  define HZ	1200
 # endif
+#ifdef __KERNEL__
+# define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-i386/param.h linux-2.4.22/include/asm-i386/param.h
--- linux-2.4.22.clean/include/asm-i386/param.h	2000-10-27 20:04:43.000000000 +0200
+++ linux-2.4.22/include/asm-i386/param.h	2000-11-23 03:00:55.000000000 +0100
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-ia64/param.h linux-2.4.22/include/asm-ia64/param.h
--- linux-2.4.22.clean/include/asm-ia64/param.h	2001-04-05 21:51:47.000000000 +0200
+++ linux-2.4.22/include/asm-ia64/param.h	2001-06-13 19:28:11.000000000 +0200
@@ -20,6 +20,10 @@
 # define HZ	1024
 #endif
 
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
+
 #define EXEC_PAGESIZE	65536
 
 #ifndef NGROUPS
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-m68k/param.h linux-2.4.22/include/asm-m68k/param.h
--- linux-2.4.22.clean/include/asm-m68k/param.h	2001-01-04 22:00:55.000000000 +0100
+++ linux-2.4.22/include/asm-m68k/param.h	2001-01-11 05:02:45.000000000 +0100
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips/bootinfo.h linux-2.4.22/include/asm-mips/bootinfo.h
--- linux-2.4.22.clean/include/asm-mips/bootinfo.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.22/include/asm-mips/bootinfo.h	2003-09-27 14:09:45.000000000 +0200
@@ -176,6 +176,7 @@
 #define MACH_DB1500		5       /* Au1500-based eval board */
 #define MACH_XXS1500		6       /* Au1500-based eval board */
 #define MACH_MTX1		7	/* 4G MTX-1 Au1500-based board */
+#define MACH_CSB250		8	/* Cogent Au1500 */
 
 /*
  * Valid machtype for group NEC_VR41XX
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips/csb250.h linux-2.4.22/include/asm-mips/csb250.h
--- linux-2.4.22.clean/include/asm-mips/csb250.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/include/asm-mips/csb250.h	2003-09-08 02:05:46.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ * Cogent Computer Systems CSB250 Alchemy Au1500
+ *
+ * Copyright 2002 Cogent Computer Systems, Inc.
+ * 	dan@embeddededge.com
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * 
+ */
+#ifndef __ASM_CSB250_H
+#define __ASM_CSB250_H
+
+/* I don't know how to define all of these, yet.
+ *
+ * 0x0 0000 0000	32/64 MByte SDRAM
+ * 0x0 1C00 0000	AM29LLV642 Flash
+ * 0x0 1E00 0000	AM29LLV642 Flash
+ * 0xD 1000 0000	HT6542B PS/2 controller
+ * 0xE 1800 0000	S1D13506 LCD Controller
+ */
+
+#define RTC_I2C		0x58	/* I2C address of DS1307 RTC */
+
+#endif /* __ASM_CSB250_H */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips/msgbuf.h linux-2.4.22/include/asm-mips/msgbuf.h
--- linux-2.4.22.clean/include/asm-mips/msgbuf.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/include/asm-mips/msgbuf.h	2003-10-13 10:46:52.000000000 +0200
@@ -1,23 +1,41 @@
 #ifndef _ASM_MSGBUF_H
 #define _ASM_MSGBUF_H
 
+#include <linux/config.h>
+
 /*
- * The msqid64_ds structure for alpha architecture.
+ * The msqid64_ds structure for the MIPS architecture.
  * Note extra padding because this structure is passed back and forth
  * between kernel and user space.
  *
  * Pad space is left for:
- * - 2 miscellaneous 64-bit values
+ * - extension of time_t to 64-bit on 32-bitsystem to solve the y2038 problem
+ * - 2 miscellaneous unsigned long values
  */
 
 struct msqid64_ds {
 	struct ipc64_perm msg_perm;
+#if defined(CONFIG_MIPS32) && !defined(CONFIG_CPU_LITTLE_ENDIAN)
+	unsigned long	__unused1;
+#endif
 	__kernel_time_t msg_stime;	/* last msgsnd time */
+#if defined(CONFIG_MIPS32) && defined(CONFIG_CPU_LITTLE_ENDIAN)
 	unsigned long	__unused1;
+#endif
+#if defined(CONFIG_MIPS32) && !defined(CONFIG_CPU_LITTLE_ENDIAN)
+	unsigned long	__unused2;
+#endif
 	__kernel_time_t msg_rtime;	/* last msgrcv time */
+#if defined(CONFIG_MIPS32) && defined(CONFIG_CPU_LITTLE_ENDIAN)
 	unsigned long	__unused2;
+#endif
+#if defined(CONFIG_MIPS32) && !defined(CONFIG_CPU_LITTLE_ENDIAN)
+	unsigned long	__unused3;
+#endif
 	__kernel_time_t msg_ctime;	/* last change time */
+#if defined(CONFIG_MIPS32) && defined(CONFIG_CPU_LITTLE_ENDIAN)
 	unsigned long	__unused3;
+#endif
 	unsigned long  msg_cbytes;	/* current number of bytes on queue */
 	unsigned long  msg_qnum;	/* number of messages in queue */
 	unsigned long  msg_qbytes;	/* max number of bytes on queue */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips/pgtable-32.h linux-2.4.22/include/asm-mips/pgtable-32.h
--- linux-2.4.22.clean/include/asm-mips/pgtable-32.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-mips/pgtable-32.h	2003-09-27 14:09:45.000000000 +0200
@@ -5,15 +5,28 @@
  * traditional mips two-level paging structure:
  */
 
+#ifdef CONFIG_64BIT_PHYS_ADDR
+#define PMD_SHIFT	21
+#define PTRS_PER_PTE	512
+#define PTRS_PER_PMD	1
+#define PTRS_PER_PGD	2048
+#define PGD_ORDER	1
+#else
 #define PMD_SHIFT	22
 #define PTRS_PER_PTE	1024
 #define PTRS_PER_PMD	1
 #define PTRS_PER_PGD	1024
 #define PGD_ORDER	0
+#endif
 
 #if !defined (_LANGUAGE_ASSEMBLY)
+#ifdef CONFIG_64BIT_PHYS_ADDR
+#define pte_ERROR(e) \
+	printk("%s:%d: bad pte %016Lx.\n", __FILE__, __LINE__, pte_val(e))
+#else
 #define pte_ERROR(e) \
 	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, (e).pte_low)
+#endif
 #define pmd_ERROR(e) \
 	printk("%s:%d: bad pmd %08lx.\n", __FILE__, __LINE__, pmd_val(e))
 #define pgd_ERROR(e) \
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips/siginfo.h linux-2.4.22/include/asm-mips/siginfo.h
--- linux-2.4.22.clean/include/asm-mips/siginfo.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/include/asm-mips/siginfo.h	2003-09-27 14:09:45.000000000 +0200
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1998, 1999 by Ralf Baechle
+ * Copyright (C) 1998, 1999, 2003 by Ralf Baechle
  */
 #ifndef _ASM_SIGINFO_H
 #define _ASM_SIGINFO_H
@@ -209,19 +209,18 @@
  * thread manager then catches and does the appropriate nonsense.
  * However, everything is written out here so as to not get lost.
  */
-#define SIGEV_NONE	128	/* other notification: meaningless */
-#define SIGEV_SIGNAL	129	/* notify via signal */
-#define SIGEV_CALLBACK	130	/* ??? */
-#define SIGEV_THREAD	131	/* deliver via thread creation */
+#define SIGEV_SIGNAL	0	/* notify via signal */
+#define SIGEV_NONE	1	/* other notification: meaningless */
+#define SIGEV_THREAD	2	/* deliver via thread creation */
 
 #define SIGEV_MAX_SIZE	64
-#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 4)
+#define SIGEV_HEAD_SIZE	(sizeof(long) + 2*sizeof(int))
+#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE-SIGEV_HEAD_SIZE) / sizeof(int))
 
-/* XXX This one isn't yet IRIX / ABI compatible.  */
 typedef struct sigevent {
-	int sigev_notify;
 	sigval_t sigev_value;
 	int sigev_signo;
+	int sigev_notify;
 	union {
 		int _pad[SIGEV_PAD_SIZE];
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips/time.h linux-2.4.22/include/asm-mips/time.h
--- linux-2.4.22.clean/include/asm-mips/time.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-mips/time.h	2003-09-27 14:09:45.000000000 +0200
@@ -36,9 +36,11 @@
 extern int (*rtc_set_mmss)(unsigned long);
 
 /*
- * Timer interrupt ack function.
- * May be NULL if the interrupt is self-recoverable.
+ * Timer interrupt functions.
+ * mips_timer_state is needed for high precision timer calibration.
+ * mips_timer_ack may be NULL if the interrupt is self-recoverable.
  */
+extern int (*mips_timer_state)(void);
 extern void (*mips_timer_ack)(void);
 
 /*
@@ -88,9 +90,10 @@
 extern void (*board_timer_setup)(struct irqaction *irq);
 
 /*
- * mips_counter_frequency - must be set if you intend to use
- * counter as timer interrupt source or use fixed_rate_gettimeoffset.
+ * mips_hpt_frequency - must be set if you intend to use an R4k-compatible
+ * counter as a timer interrupt source; otherwise it can be set up
+ * automagically with an aid of mips_timer_state.
  */
-extern unsigned int mips_counter_frequency;
+extern unsigned int mips_hpt_frequency;
 
 #endif /* _ASM_TIME_H */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips/uaccess.h linux-2.4.22/include/asm-mips/uaccess.h
--- linux-2.4.22.clean/include/asm-mips/uaccess.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-mips/uaccess.h	2003-09-27 14:09:45.000000000 +0200
@@ -3,12 +3,13 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1996, 1997, 1998, 1999, 2000 by Ralf Baechle
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 03 by Ralf Baechle
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  */
 #ifndef _ASM_UACCESS_H
 #define _ASM_UACCESS_H
 
+#include <linux/compiler.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
 
@@ -73,7 +74,7 @@
  * this function, memory access functions may still return -EFAULT.
  */
 #define access_ok(type, addr, size)					\
-	__access_ok((unsigned long)(addr), (size), __access_mask)
+	likely(__access_ok((unsigned long)(addr), (size), __access_mask))
 
 /*
  * verify_area: - Obsolete, use access_ok()
@@ -194,84 +195,84 @@
 #define __GET_USER_DW __get_user_asm_ll32
 #endif
 
-#define __get_user_nocheck(x,ptr,size)				\
-({								\
-	long __gu_err;						\
-	__typeof(*(ptr)) __gu_val;				\
-	long __gu_addr;						\
-	__asm__("":"=r" (__gu_val));				\
-	__gu_addr = (long) (ptr);				\
-	__asm__("":"=r" (__gu_err));				\
-	switch (size) {						\
-		case 1: __get_user_asm("lb"); break;		\
-		case 2: __get_user_asm("lh"); break;		\
-		case 4: __get_user_asm("lw"); break;		\
-		case 8: __GET_USER_DW; break;			\
-		default: __get_user_unknown(); break;		\
-	} x = (__typeof__(*(ptr))) __gu_val;			\
-	__gu_err;						\
-})
-
-#define __get_user_check(x,ptr,size)				\
-({								\
-	long __gu_err;						\
-	__typeof__(*(ptr)) __gu_val;				\
-	long __gu_addr;						\
-	__asm__("":"=r" (__gu_val));				\
-	__gu_addr = (long) (ptr);				\
-	__asm__("":"=r" (__gu_err));				\
-	if (__access_ok(__gu_addr,size,__access_mask)) {	\
-		switch (size) {					\
-		case 1: __get_user_asm("lb"); break;		\
-		case 2: __get_user_asm("lh"); break;		\
-		case 4: __get_user_asm("lw"); break;		\
-		case 8: __GET_USER_DW; break;			\
-		default: __get_user_unknown(); break;		\
-		}						\
-	} x = (__typeof__(*(ptr))) __gu_val;			\
-	__gu_err;						\
-})
-
-#define __get_user_asm(insn)					\
-({								\
-	__asm__ __volatile__(					\
-	"1:\t" insn "\t%1,%2\n\t"				\
-	"move\t%0,$0\n"						\
-	"2:\n\t"						\
-	".section\t.fixup,\"ax\"\n"				\
-	"3:\tli\t%0,%3\n\t"					\
-	"move\t%1,$0\n\t"					\
-	"j\t2b\n\t"						\
-	".previous\n\t"						\
-	".section\t__ex_table,\"a\"\n\t"			\
-	".word\t1b,3b\n\t"					\
-	".previous"						\
-	:"=r" (__gu_err), "=r" (__gu_val)			\
-	:"o" (__m(__gu_addr)), "i" (-EFAULT));			\
+#define __get_user_nocheck(x,ptr,size)					\
+({									\
+	long __gu_err;							\
+	__typeof(*(ptr)) __gu_val;					\
+	long __gu_addr;							\
+	__asm__("":"=r" (__gu_val));					\
+	__gu_addr = (long) (ptr);					\
+	__asm__("":"=r" (__gu_err));					\
+	switch (size) {							\
+		case 1: __get_user_asm("lb"); break;			\
+		case 2: __get_user_asm("lh"); break;			\
+		case 4: __get_user_asm("lw"); break;			\
+		case 8: __GET_USER_DW; break;				\
+		default: __get_user_unknown(); break;			\
+	} x = (__typeof__(*(ptr))) __gu_val;				\
+	__gu_err;							\
+})
+
+#define __get_user_check(x,ptr,size)					\
+({									\
+	long __gu_err;							\
+	__typeof__(*(ptr)) __gu_val;					\
+	long __gu_addr;							\
+	__asm__("":"=r" (__gu_val));					\
+	__gu_addr = (long) (ptr);					\
+	__asm__("":"=r" (__gu_err));					\
+	if (access_ok(VERIFY_READ, __gu_addr, size)) {			\
+		switch (size) {						\
+		case 1: __get_user_asm("lb"); break;			\
+		case 2: __get_user_asm("lh"); break;			\
+		case 4: __get_user_asm("lw"); break;			\
+		case 8: __GET_USER_DW; break;				\
+		default: __get_user_unknown(); break;			\
+		}							\
+	} x = (__typeof__(*(ptr))) __gu_val;				\
+	__gu_err;							\
+})
+
+#define __get_user_asm(insn)						\
+({									\
+	__asm__ __volatile__(						\
+	"1:\t" insn "\t%1,%2\n\t"					\
+	"move\t%0,$0\n"							\
+	"2:\n\t"							\
+	".section\t.fixup,\"ax\"\n"					\
+	"3:\tli\t%0,%3\n\t"						\
+	"move\t%1,$0\n\t"						\
+	"j\t2b\n\t"							\
+	".previous\n\t"							\
+	".section\t__ex_table,\"a\"\n\t"				\
+	".word\t1b,3b\n\t"						\
+	".previous"							\
+	:"=r" (__gu_err), "=r" (__gu_val)				\
+	:"o" (__m(__gu_addr)), "i" (-EFAULT));				\
 })
 
 /*
  * Get a long long 64 using 32 bit registers.
  */
-#define __get_user_asm_ll32					\
-({								\
-__asm__ __volatile__(						\
-	"1:\tlw\t%1,%2\n"					\
-	"2:\tlw\t%D1,%3\n\t"					\
-	"move\t%0,$0\n"						\
-	"3:\t.section\t.fixup,\"ax\"\n"				\
-	"4:\tli\t%0,%4\n\t"					\
-	"move\t%1,$0\n\t"					\
-	"move\t%D1,$0\n\t"					\
-	"j\t3b\n\t"						\
-	".previous\n\t"						\
-	".section\t__ex_table,\"a\"\n\t"			\
-	".word\t1b,4b\n\t"					\
-	".word\t2b,4b\n\t"					\
-	".previous"						\
-	:"=r" (__gu_err), "=&r" (__gu_val)			\
-	:"o" (__m(__gu_addr)), "o" (__m(__gu_addr + 4)),	\
-	 "i" (-EFAULT));					\
+#define __get_user_asm_ll32						\
+({									\
+__asm__ __volatile__(							\
+	"1:\tlw\t%1,%2\n"						\
+	"2:\tlw\t%D1,%3\n\t"						\
+	"move\t%0,$0\n"							\
+	"3:\t.section\t.fixup,\"ax\"\n"					\
+	"4:\tli\t%0,%4\n\t"						\
+	"move\t%1,$0\n\t"						\
+	"move\t%D1,$0\n\t"						\
+	"j\t3b\n\t"							\
+	".previous\n\t"							\
+	".section\t__ex_table,\"a\"\n\t"				\
+	".word\t1b,4b\n\t"						\
+	".word\t2b,4b\n\t"						\
+	".previous"							\
+	:"=r" (__gu_err), "=&r" (__gu_val)				\
+	:"o" (__m(__gu_addr)), "o" (__m(__gu_addr + 4)),		\
+	 "i" (-EFAULT));						\
 })
 
 extern void __get_user_unknown(void);
@@ -286,79 +287,79 @@
 #define __PUT_USER_DW __put_user_asm_ll32
 #endif
 
-#define __put_user_nocheck(x,ptr,size)				\
-({								\
-	long __pu_err;						\
-	__typeof__(*(ptr)) __pu_val;				\
-	long __pu_addr;						\
-	__pu_val = (x);						\
-	__pu_addr = (long) (ptr);				\
-	__asm__("":"=r" (__pu_err));				\
-	switch (size) {						\
-		case 1: __put_user_asm("sb"); break;		\
-		case 2: __put_user_asm("sh"); break;		\
-		case 4: __put_user_asm("sw"); break;		\
-		case 8: __PUT_USER_DW; break;			\
-		default: __put_user_unknown(); break;		\
-	}							\
-	__pu_err;						\
-})
-
-#define __put_user_check(x,ptr,size)				\
-({								\
-	long __pu_err;						\
-	__typeof__(*(ptr)) __pu_val;				\
-	long __pu_addr;						\
-	__pu_val = (x);						\
-	__pu_addr = (long) (ptr);				\
-	__asm__("":"=r" (__pu_err));				\
-	if (__access_ok(__pu_addr,size,__access_mask)) {	\
-		switch (size) {					\
-		case 1: __put_user_asm("sb"); break;		\
-		case 2: __put_user_asm("sh"); break;		\
-		case 4: __put_user_asm("sw"); break;		\
-		case 8: __PUT_USER_DW; break;			\
-		default: __put_user_unknown(); break;		\
-		}						\
-	}							\
-	__pu_err;						\
-})
-
-#define __put_user_asm(insn)					\
-({								\
-	__asm__ __volatile__(					\
-	"1:\t" insn "\t%z1, %2\t\t\t# __put_user_asm\n\t"	\
-	"move\t%0, $0\n"					\
-	"2:\n\t"						\
-	".section\t.fixup,\"ax\"\n"				\
-	"3:\tli\t%0, %3\n\t"					\
-	"j\t2b\n\t"						\
-	".previous\n\t"						\
-	".section\t__ex_table,\"a\"\n\t"			\
-	".word\t1b, 3b\n\t"					\
-	".previous"						\
-	:"=r" (__pu_err)					\
-	:"Jr" (__pu_val), "o" (__m(__pu_addr)), "i" (-EFAULT));	\
-})
-
-#define __put_user_asm_ll32					\
-({								\
-__asm__ __volatile__(						\
-	"1:\tsw\t%1, %2\t\t\t# __put_user_asm_ll32\n\t"		\
-	"2:\tsw\t%D1, %3\n"					\
-	"move\t%0, $0\n"					\
-	"3:\n\t"						\
-	".section\t.fixup,\"ax\"\n"				\
-	"4:\tli\t%0, %4\n\t"					\
-	"j\t3b\n\t"						\
-	".previous\n\t"						\
-	".section\t__ex_table,\"a\"\n\t"			\
-	".word\t1b,4b\n\t"					\
-	".word\t2b,4b\n\t"					\
-	".previous"						\
-	:"=r" (__pu_err)					\
-	:"r" (__pu_val), "o" (__m(__pu_addr)), "o" (__m(__pu_addr + 4)), \
-	 "i" (-EFAULT));					\
+#define __put_user_nocheck(x,ptr,size)					\
+({									\
+	long __pu_err;							\
+	__typeof__(*(ptr)) __pu_val;					\
+	long __pu_addr;							\
+	__pu_val = (x);							\
+	__pu_addr = (long) (ptr);					\
+	__asm__("":"=r" (__pu_err));					\
+	switch (size) {							\
+		case 1: __put_user_asm("sb"); break;			\
+		case 2: __put_user_asm("sh"); break;			\
+		case 4: __put_user_asm("sw"); break;			\
+		case 8: __PUT_USER_DW; break;				\
+		default: __put_user_unknown(); break;			\
+	}								\
+	__pu_err;							\
+})
+
+#define __put_user_check(x,ptr,size)					\
+({									\
+	long __pu_err;							\
+	__typeof__(*(ptr)) __pu_val;					\
+	long __pu_addr;							\
+	__pu_val = (x);							\
+	__pu_addr = (long) (ptr);					\
+	__asm__("":"=r" (__pu_err));					\
+	if (access_ok(VERIFY_WRITE, __pu_addr, size)) {			\
+		switch (size) {						\
+		case 1: __put_user_asm("sb"); break;			\
+		case 2: __put_user_asm("sh"); break;			\
+		case 4: __put_user_asm("sw"); break;			\
+		case 8: __PUT_USER_DW; break;				\
+		default: __put_user_unknown(); break;			\
+		}							\
+	}								\
+	__pu_err;							\
+})
+
+#define __put_user_asm(insn)						\
+({									\
+	__asm__ __volatile__(						\
+	"1:\t" insn "\t%z1, %2\t\t\t# __put_user_asm\n\t"		\
+	"move\t%0, $0\n"						\
+	"2:\n\t"							\
+	".section\t.fixup,\"ax\"\n"					\
+	"3:\tli\t%0, %3\n\t"						\
+	"j\t2b\n\t"							\
+	".previous\n\t"							\
+	".section\t__ex_table,\"a\"\n\t"				\
+	".word\t1b, 3b\n\t"						\
+	".previous"							\
+	:"=r" (__pu_err)						\
+	:"Jr" (__pu_val), "o" (__m(__pu_addr)), "i" (-EFAULT));		\
+})
+
+#define __put_user_asm_ll32						\
+({									\
+__asm__ __volatile__(							\
+	"1:\tsw\t%1, %2\t\t\t# __put_user_asm_ll32\n\t"			\
+	"2:\tsw\t%D1, %3\n"						\
+	"move\t%0, $0\n"						\
+	"3:\n\t"							\
+	".section\t.fixup,\"ax\"\n"					\
+	"4:\tli\t%0, %4\n\t"						\
+	"j\t3b\n\t"							\
+	".previous\n\t"							\
+	".section\t__ex_table,\"a\"\n\t"				\
+	".word\t1b,4b\n\t"						\
+	".word\t2b,4b\n\t"						\
+	".previous"							\
+	:"=r" (__pu_err)						\
+	:"r" (__pu_val), "o" (__m(__pu_addr)), "o" (__m(__pu_addr + 4)),\
+	 "i" (-EFAULT));						\
 })
 
 extern void __put_user_unknown(void);
@@ -368,13 +369,13 @@
  * jump instructions
  */
 #ifdef MODULE
-#define __MODULE_JAL(destination)	\
-	".set\tnoat\n\t"		\
-	"la\t$1, " #destination "\n\t"	\
-	"jalr\t$1\n\t"			\
+#define __MODULE_JAL(destination)					\
+	".set\tnoat\n\t"						\
+	"la\t$1, " #destination "\n\t"					\
+	"jalr\t$1\n\t"							\
 	".set\tat\n\t"
 #else
-#define __MODULE_JAL(destination)	\
+#define __MODULE_JAL(destination)					\
 	"jal\t" #destination "\n\t"
 #endif
 
@@ -566,14 +567,14 @@
 	return res;
 }
 
-#define clear_user(addr,n)					\
-({								\
-	void * __cl_addr = (addr);				\
-	unsigned long __cl_size = (n);				\
-	if (__cl_size && access_ok(VERIFY_WRITE,		\
-		((unsigned long)(__cl_addr)), __cl_size))	\
-		__cl_size = __clear_user(__cl_addr, __cl_size);	\
-	__cl_size;						\
+#define clear_user(addr,n)						\
+({									\
+	void * __cl_addr = (addr);					\
+	unsigned long __cl_size = (n);					\
+	if (__cl_size && access_ok(VERIFY_WRITE,			\
+		((unsigned long)(__cl_addr)), __cl_size))		\
+		__cl_size = __clear_user(__cl_addr, __cl_size);		\
+	__cl_size;							\
 })
 
 /*
@@ -732,9 +733,9 @@
 extern unsigned long search_exception_table(unsigned long addr);
 
 /* Returns the new pc */
-#define fixup_exception(map_reg, fixup_unit, pc)                \
-({                                                              \
-	fixup_unit;                                             \
+#define fixup_exception(map_reg, fixup_unit, pc)			\
+({									\
+	fixup_unit;							\
 })
 
 #endif /* _ASM_UACCESS_H */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips64/kmap_types.h linux-2.4.22/include/asm-mips64/kmap_types.h
--- linux-2.4.22.clean/include/asm-mips64/kmap_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/include/asm-mips64/kmap_types.h	2003-09-29 18:38:01.000000000 +0200
@@ -0,0 +1,16 @@
+#ifndef _ASM_KMAP_TYPES_H
+#define _ASM_KMAP_TYPES_H
+
+enum km_type {
+	KM_BOUNCE_READ,
+	KM_SKB_SUNRPC_DATA,
+	KM_SKB_DATA_SOFTIRQ,
+	KM_USER0,
+	KM_USER1,
+	KM_BH_IRQ,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
+	KM_TYPE_NR
+};
+
+#endif
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips64/sigcontext.h linux-2.4.22/include/asm-mips64/sigcontext.h
--- linux-2.4.22.clean/include/asm-mips64/sigcontext.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-mips64/sigcontext.h	2003-09-27 14:09:46.000000000 +0200
@@ -27,6 +27,7 @@
 	unsigned int       sc_badvaddr;
 };
 
+#ifdef __KERNEL__
 struct sigcontext32 {
 	u32 sc_regmask;		/* Unused */
 	u32 sc_status;
@@ -46,5 +47,6 @@
 
 	u32 sc_sigset[4];	/* kernel's sigset_t */
 };
+#endif /* __KERNEL__ */
 
 #endif /* _ASM_SIGCONTEXT_H */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips64/siginfo.h linux-2.4.22/include/asm-mips64/siginfo.h
--- linux-2.4.22.clean/include/asm-mips64/siginfo.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/include/asm-mips64/siginfo.h	2003-09-27 14:17:45.000000000 +0200
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1998, 1999, 2001 Ralf Baechle
+ * Copyright (C) 1998, 1999, 2001, 2003 Ralf Baechle
  * Copyright (C) 2000, 2001 Silicon Graphics, Inc.
  */
 #ifndef _ASM_SIGINFO_H
@@ -282,19 +282,18 @@
  * thread manager then catches and does the appropriate nonsense.
  * However, everything is written out here so as to not get lost.
  */
-#define SIGEV_NONE	128	/* other notification: meaningless */
-#define SIGEV_SIGNAL	129	/* notify via signal */
-#define SIGEV_CALLBACK	130	/* ??? */
-#define SIGEV_THREAD	131	/* deliver via thread creation */
+#define SIGEV_SIGNAL	0	/* notify via signal */
+#define SIGEV_NONE	1	/* other notification: meaningless */
+#define SIGEV_THREAD	2	/* deliver via thread creation */
 
 #define SIGEV_MAX_SIZE	64
-#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 4)
+#define SIGEV_HEAD_SIZE	(sizeof(long) + 2*sizeof(int))
+#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE-SIGEV_HEAD_SIZE) / sizeof(int))
 
-/* XXX This one isn't yet IRIX / ABI compatible.  */
 typedef struct sigevent {
-	int sigev_notify;
 	sigval_t sigev_value;
 	int sigev_signo;
+	int sigev_notify;
 	union {
 		int _pad[SIGEV_PAD_SIZE];
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips64/sn/addrs.h linux-2.4.22/include/asm-mips64/sn/addrs.h
--- linux-2.4.22.clean/include/asm-mips64/sn/addrs.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-mips64/sn/addrs.h	2003-09-27 14:44:43.000000000 +0200
@@ -16,7 +16,6 @@
 #endif /* !__ASSEMBLY__ */
 
 #include <asm/addrspace.h>
-#include <asm/reg.h>
 #include <asm/sn/kldir.h>
 
 #if defined(CONFIG_SGI_IP27)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips64/stackframe.h linux-2.4.22/include/asm-mips64/stackframe.h
--- linux-2.4.22.clean/include/asm-mips64/stackframe.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-mips64/stackframe.h	2003-09-27 14:58:49.000000000 +0200
@@ -50,8 +50,6 @@
 
 		.macro	SAVE_TEMP
 		mfhi	v1
-		sd	$8, PT_R8(sp)
-		sd	$9, PT_R9(sp)
 		sd	v1, PT_HI(sp)
 		mflo	v1
 		sd	$10, PT_R10(sp)
@@ -135,6 +133,8 @@
 		sd	$6, PT_R6(sp)
 		dmfc0	v1, CP0_EPC
 		sd	$7, PT_R7(sp)
+		sd	$8, PT_R8(sp)
+		sd	$9, PT_R9(sp)
 		sd	v1, PT_EPC(sp)
 		sd	$25, PT_R25(sp)
 		sd	$28, PT_R28(sp)
@@ -164,8 +164,6 @@
 
 		.macro	RESTORE_TEMP
 		ld	$24, PT_LO(sp)
-		ld	$8, PT_R8(sp)
-		ld	$9, PT_R9(sp)
 		mtlo	$24
 		ld	$24, PT_HI(sp)
 		ld	$10, PT_R10(sp)
@@ -210,6 +208,8 @@
 		ld	$31, PT_R31(sp)
 		ld	$28, PT_R28(sp)
 		ld	$25, PT_R25(sp)
+		ld	$9,  PT_R9(sp)
+		ld	$8,  PT_R8(sp)
 		ld	$7,  PT_R7(sp)
 		ld	$6,  PT_R6(sp)
 		ld	$5,  PT_R5(sp)
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips64/time.h linux-2.4.22/include/asm-mips64/time.h
--- linux-2.4.22.clean/include/asm-mips64/time.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-mips64/time.h	2003-09-27 14:58:50.000000000 +0200
@@ -36,9 +36,11 @@
 extern int (*rtc_set_mmss)(unsigned long);
 
 /*
- * Timer interrupt ack function.
- * May be NULL if the interrupt is self-recoverable.
+ * Timer interrupt functions.
+ * mips_timer_state is needed for high precision timer calibration.
+ * mips_timer_ack may be NULL if the interrupt is self-recoverable.
  */
+extern int (*mips_timer_state)(void);
 extern void (*mips_timer_ack)(void);
 
 /*
@@ -88,9 +90,10 @@
 extern void (*board_timer_setup)(struct irqaction *irq);
 
 /*
- * mips_counter_frequency - must be set if you intend to use
- * counter as timer interrupt source or use fixed_rate_gettimeoffset.
+ * mips_hpt_frequency - must be set if you intend to use an R4k-compatible
+ * counter as a timer interrupt source; otherwise it can be set up
+ * automagically with an aid of mips_timer_state.
  */
-extern unsigned int mips_counter_frequency;
+extern unsigned int mips_hpt_frequency;
 
 #endif /* _ASM_TIME_H */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips64/uaccess.h linux-2.4.22/include/asm-mips64/uaccess.h
--- linux-2.4.22.clean/include/asm-mips64/uaccess.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-mips64/uaccess.h	2003-09-27 14:45:02.000000000 +0200
@@ -3,12 +3,13 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1996, 1997, 1998, 1999, 2000 by Ralf Baechle
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 03 by Ralf Baechle
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  */
 #ifndef _ASM_UACCESS_H
 #define _ASM_UACCESS_H
 
+#include <linux/compiler.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
 
@@ -73,7 +74,7 @@
  * this function, memory access functions may still return -EFAULT.
  */
 #define access_ok(type, addr, size)					\
-	__access_ok((unsigned long)(addr), (size), __access_mask)
+	likely(__access_ok((unsigned long)(addr), (size), __access_mask))
 
 /*
  * verify_area: - Obsolete, use access_ok()
@@ -184,117 +185,117 @@
 struct __large_struct { unsigned long buf[100]; };
 #define __m(x) (*(struct __large_struct *)(x))
 
-#define __get_user_nocheck(x,ptr,size)				\
-({								\
-	long __gu_err;						\
-	__typeof(*(ptr)) __gu_val;				\
-	long __gu_addr;						\
-	__asm__("":"=r" (__gu_val));				\
-	__gu_addr = (long) (ptr);				\
-	__asm__("":"=r" (__gu_err));				\
-	switch (size) {						\
-		case 1: __get_user_asm("lb"); break;		\
-		case 2: __get_user_asm("lh"); break;		\
-		case 4: __get_user_asm("lw"); break;		\
-		case 8: __get_user_asm("ld"); break;		\
-		default: __get_user_unknown(); break;		\
-	} x = (__typeof__(*(ptr))) __gu_val;			\
-	__gu_err;						\
-})
-
-#define __get_user_check(x,ptr,size)				\
-({								\
-	long __gu_err;						\
-	__typeof__(*(ptr)) __gu_val;				\
-	long __gu_addr;						\
-	__asm__("":"=r" (__gu_val));				\
-	__gu_addr = (long) (ptr);				\
-	__asm__("":"=r" (__gu_err));				\
-	if (__access_ok(__gu_addr,size,__access_mask)) {	\
-		switch (size) {					\
-		case 1: __get_user_asm("lb"); break;		\
-		case 2: __get_user_asm("lh"); break;		\
-		case 4: __get_user_asm("lw"); break;		\
-		case 8: __get_user_asm("ld"); break;		\
-		default: __get_user_unknown(); break;		\
-		}						\
-	} x = (__typeof__(*(ptr))) __gu_val;			\
-	__gu_err;						\
-})
-
-#define __get_user_asm(insn)					\
-({								\
-	__asm__ __volatile__(					\
-	"1:\t" insn "\t%1,%2\n\t"				\
-	"move\t%0,$0\n"						\
-	"2:\n\t"						\
-	".section\t.fixup,\"ax\"\n"				\
-	"3:\tli\t%0,%3\n\t"					\
-	"move\t%1,$0\n\t"					\
-	"j\t2b\n\t"						\
-	".previous\n\t"						\
-	".section\t__ex_table,\"a\"\n\t"			\
-	".dword\t1b,3b\n\t"					\
-	".previous"						\
-	:"=r" (__gu_err), "=r" (__gu_val)			\
-	:"o" (__m(__gu_addr)), "i" (-EFAULT));			\
+#define __get_user_nocheck(x,ptr,size)					\
+({									\
+	long __gu_err;							\
+	__typeof(*(ptr)) __gu_val;					\
+	long __gu_addr;							\
+	__asm__("":"=r" (__gu_val));					\
+	__gu_addr = (long) (ptr);					\
+	__asm__("":"=r" (__gu_err));					\
+	switch (size) {							\
+		case 1: __get_user_asm("lb"); break;			\
+		case 2: __get_user_asm("lh"); break;			\
+		case 4: __get_user_asm("lw"); break;			\
+		case 8: __get_user_asm("ld"); break;			\
+		default: __get_user_unknown(); break;			\
+	} x = (__typeof__(*(ptr))) __gu_val;				\
+	__gu_err;							\
+})
+
+#define __get_user_check(x,ptr,size)					\
+({									\
+	long __gu_err;							\
+	__typeof__(*(ptr)) __gu_val;					\
+	long __gu_addr;							\
+	__asm__("":"=r" (__gu_val));					\
+	__gu_addr = (long) (ptr);					\
+	__asm__("":"=r" (__gu_err));					\
+	if (access_ok(VERIFY_READ, __gu_addr, size)) {			\
+		switch (size) {						\
+		case 1: __get_user_asm("lb"); break;			\
+		case 2: __get_user_asm("lh"); break;			\
+		case 4: __get_user_asm("lw"); break;			\
+		case 8: __get_user_asm("ld"); break;			\
+		default: __get_user_unknown(); break;			\
+		}							\
+	} x = (__typeof__(*(ptr))) __gu_val;				\
+	__gu_err;							\
+})
+
+#define __get_user_asm(insn)						\
+({									\
+	__asm__ __volatile__(						\
+	"1:\t" insn "\t%1,%2\n\t"					\
+	"move\t%0,$0\n"							\
+	"2:\n\t"							\
+	".section\t.fixup,\"ax\"\n"					\
+	"3:\tli\t%0,%3\n\t"						\
+	"move\t%1,$0\n\t"						\
+	"j\t2b\n\t"							\
+	".previous\n\t"							\
+	".section\t__ex_table,\"a\"\n\t"				\
+	".dword\t1b,3b\n\t"						\
+	".previous"							\
+	:"=r" (__gu_err), "=r" (__gu_val)				\
+	:"o" (__m(__gu_addr)), "i" (-EFAULT));				\
 })
 
 extern void __get_user_unknown(void);
 
-#define __put_user_nocheck(x,ptr,size)				\
-({								\
-	long __pu_err;						\
-	__typeof__(*(ptr)) __pu_val;				\
-	long __pu_addr;						\
-	__pu_val = (x);						\
-	__pu_addr = (long) (ptr);				\
-	__asm__("":"=r" (__pu_err));				\
-	switch (size) {						\
-		case 1: __put_user_asm("sb"); break;		\
-		case 2: __put_user_asm("sh"); break;		\
-		case 4: __put_user_asm("sw"); break;		\
-		case 8: __put_user_asm("sd"); break;		\
-		default: __put_user_unknown(); break;		\
-	}							\
-	__pu_err;						\
-})
-
-#define __put_user_check(x,ptr,size)				\
-({								\
-	long __pu_err;						\
-	__typeof__(*(ptr)) __pu_val;				\
-	long __pu_addr;						\
-	__pu_val = (x);						\
-	__pu_addr = (long) (ptr);				\
-	__asm__("":"=r" (__pu_err));				\
-	if (__access_ok(__pu_addr,size,__access_mask)) {	\
-		switch (size) {					\
-		case 1: __put_user_asm("sb"); break;		\
-		case 2: __put_user_asm("sh"); break;		\
-		case 4: __put_user_asm("sw"); break;		\
-		case 8: __put_user_asm("sd"); break;		\
-		default: __put_user_unknown(); break;		\
-		}						\
-	}							\
-	__pu_err;						\
-})
-
-#define __put_user_asm(insn)					\
-({								\
-	__asm__ __volatile__(					\
-	"1:\t" insn "\t%z1, %2\t\t\t# __put_user_asm\n\t"	\
-	"move\t%0, $0\n"					\
-	"2:\n\t"						\
-	".section\t.fixup,\"ax\"\n"				\
-	"3:\tli\t%0, %3\n\t"					\
-	"j\t2b\n\t"						\
-	".previous\n\t"						\
-	".section\t__ex_table,\"a\"\n\t"			\
-	".dword\t1b, 3b\n\t"					\
-	".previous"						\
-	:"=r" (__pu_err)					\
-	:"Jr" (__pu_val), "o" (__m(__pu_addr)), "i" (-EFAULT));	\
+#define __put_user_nocheck(x,ptr,size)					\
+({									\
+	long __pu_err;							\
+	__typeof__(*(ptr)) __pu_val;					\
+	long __pu_addr;							\
+	__pu_val = (x);							\
+	__pu_addr = (long) (ptr);					\
+	__asm__("":"=r" (__pu_err));					\
+	switch (size) {							\
+		case 1: __put_user_asm("sb"); break;			\
+		case 2: __put_user_asm("sh"); break;			\
+		case 4: __put_user_asm("sw"); break;			\
+		case 8: __put_user_asm("sd"); break;			\
+		default: __put_user_unknown(); break;			\
+	}								\
+	__pu_err;							\
+})
+
+#define __put_user_check(x,ptr,size)					\
+({									\
+	long __pu_err;							\
+	__typeof__(*(ptr)) __pu_val;					\
+	long __pu_addr;							\
+	__pu_val = (x);							\
+	__pu_addr = (long) (ptr);					\
+	__asm__("":"=r" (__pu_err));					\
+	if (access_ok(VERIFY_WRITE, __pu_addr, size)) {			\
+		switch (size) {						\
+		case 1: __put_user_asm("sb"); break;			\
+		case 2: __put_user_asm("sh"); break;			\
+		case 4: __put_user_asm("sw"); break;			\
+		case 8: __put_user_asm("sd"); break;			\
+		default: __put_user_unknown(); break;			\
+		}							\
+	}								\
+	__pu_err;							\
+})
+
+#define __put_user_asm(insn)						\
+({									\
+	__asm__ __volatile__(						\
+	"1:\t" insn "\t%z1, %2\t\t\t# __put_user_asm\n\t"		\
+	"move\t%0, $0\n"						\
+	"2:\n\t"							\
+	".section\t.fixup,\"ax\"\n"					\
+	"3:\tli\t%0, %3\n\t"						\
+	"j\t2b\n\t"							\
+	".previous\n\t"							\
+	".section\t__ex_table,\"a\"\n\t"				\
+	".dword\t1b, 3b\n\t"						\
+	".previous"							\
+	:"=r" (__pu_err)						\
+	:"Jr" (__pu_val), "o" (__m(__pu_addr)), "i" (-EFAULT));		\
 })
 
 extern void __put_user_unknown(void);
@@ -304,13 +305,13 @@
  * jump instructions
  */
 #ifdef MODULE
-#define __MODULE_JAL(destination)	\
-	".set\tnoat\n\t"		\
-	"dla\t$1, " #destination "\n\t" \
-	"jalr\t$1\n\t"			\
+#define __MODULE_JAL(destination)					\
+	".set\tnoat\n\t"						\
+	"dla\t$1, " #destination "\n\t"					 \
+	"jalr\t$1\n\t"							\
 	".set\tat\n\t"
 #else
-#define __MODULE_JAL(destination)	\
+#define __MODULE_JAL(destination)					\
 	"jal\t" #destination "\n\t"
 #endif
 
@@ -503,14 +504,14 @@
 	return res;
 }
 
-#define clear_user(addr,n)					\
-({								\
-	void * __cl_addr = (addr);				\
-	unsigned long __cl_size = (n);				\
-	if (__cl_size && access_ok(VERIFY_WRITE,		\
-		((unsigned long)(__cl_addr)), __cl_size))	\
-		__cl_size = __clear_user(__cl_addr, __cl_size);	\
-	__cl_size;						\
+#define clear_user(addr,n)						\
+({									\
+	void * __cl_addr = (addr);					\
+	unsigned long __cl_size = (n);					\
+	if (__cl_size && access_ok(VERIFY_WRITE,			\
+		((unsigned long)(__cl_addr)), __cl_size))		\
+		__cl_size = __clear_user(__cl_addr, __cl_size);		\
+	__cl_size;							\
 })
 
 /*
@@ -669,9 +670,9 @@
 extern unsigned long search_exception_table(unsigned long addr);
 
 /* Returns the new pc */
-#define fixup_exception(map_reg, fixup_unit, pc)                \
-({                                                              \
-	fixup_unit;                                             \
+#define fixup_exception(map_reg, fixup_unit, pc)			\
+({									\
+	fixup_unit;							\
 })
 
 #endif /* _ASM_UACCESS_H */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-mips64/unistd.h linux-2.4.22/include/asm-mips64/unistd.h
--- linux-2.4.22.clean/include/asm-mips64/unistd.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-mips64/unistd.h	2003-09-27 14:09:46.000000000 +0200
@@ -480,11 +480,14 @@
 #define __NR_unused209			(__NR_Linux + 209)
 #define __NR_unused210			(__NR_Linux + 210)
 #define __NR_rt_sigreturn		(__NR_Linux + 211)
+#define __NR_unused212			(__NR_Linux + 212)
+#define __NR_unused213			(__NR_Linux + 213)
+#define __NR_semtimedop			(__NR_Linux + 214)
 
 /*
  * Offset of the last Linux flavoured syscall
  */
-#define __NR_Linux_syscalls		211
+#define __NR_Linux_syscalls		214
 
 /*
  * Linux N32 syscalls are in the range from 6000 to 6999.
@@ -705,7 +708,7 @@
 #define __NR_N32_fcntl64		(__NR_N32_Linux + 212)
 #define __NR_N32_unused213		(__NR_N32_Linux + 213)
 #define __NR_N32_unused214		(__NR_N32_Linux + 214)
-#define __NR_N32_unused215		(__NR_N32_Linux + 215)
+#define __NR_N32_semtimedop		(__NR_N32_Linux + 215)
 #define __NR_N32_unused216		(__NR_N32_Linux + 216)
 #define __NR_N32_unused217		(__NR_N32_Linux + 217)
 #define __NR_N32_unused218		(__NR_N32_Linux + 218)
@@ -883,7 +886,7 @@
 	\
 	__asm__ volatile ( \
 	".set\tnoreorder\n\t" \
-	"li\t$2, %5\t\t\t# " #name "\n\t" \
+	"li\t$2, %7\t\t\t# " #name "\n\t" \
 	"syscall\n\t" \
 	"move\t%0, $2\n\t" \
 	".set\treorder" \
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-ppc/param.h linux-2.4.22/include/asm-ppc/param.h
--- linux-2.4.22.clean/include/asm-ppc/param.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/asm-ppc/param.h	2003-07-05 05:23:46.000000000 +0200
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-s390/param.h linux-2.4.22/include/asm-s390/param.h
--- linux-2.4.22.clean/include/asm-s390/param.h	2001-02-13 23:13:44.000000000 +0100
+++ linux-2.4.22/include/asm-s390/param.h	2001-03-09 21:34:48.000000000 +0100
@@ -11,6 +11,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-sh/param.h linux-2.4.22/include/asm-sh/param.h
--- linux-2.4.22.clean/include/asm-sh/param.h	2001-01-04 22:19:13.000000000 +0100
+++ linux-2.4.22/include/asm-sh/param.h	2001-01-11 05:02:45.000000000 +0100
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-sparc/param.h linux-2.4.22/include/asm-sparc/param.h
--- linux-2.4.22.clean/include/asm-sparc/param.h	2000-10-30 23:34:12.000000000 +0100
+++ linux-2.4.22/include/asm-sparc/param.h	2000-11-23 03:00:56.000000000 +0100
@@ -4,6 +4,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192    /* Thanks for sun4's we carry baggage... */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/asm-sparc64/param.h linux-2.4.22/include/asm-sparc64/param.h
--- linux-2.4.22.clean/include/asm-sparc64/param.h	2000-10-30 23:34:12.000000000 +0100
+++ linux-2.4.22/include/asm-sparc64/param.h	2000-11-23 03:00:56.000000000 +0100
@@ -4,6 +4,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192    /* Thanks for sun4's we carry baggage... */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/byteorder/generic.h linux-2.4.22/include/linux/byteorder/generic.h
--- linux-2.4.22.clean/include/linux/byteorder/generic.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.22/include/linux/byteorder/generic.h	2003-09-27 14:09:53.000000000 +0200
@@ -122,7 +122,7 @@
 #define be16_to_cpus __be16_to_cpus
 #endif
 
-
+#if defined(__KERNEL__)
 /*
  * Handle ntohl and suches. These have various compatibility
  * issues - like we want to give the prototype even though we
@@ -146,35 +146,26 @@
  * Do the prototypes. Somebody might want to take the
  * address or some such sick thing..
  */
-#if defined(__KERNEL__) || (defined (__GLIBC__) && __GLIBC__ >= 2)
 extern __u32			ntohl(__u32);
 extern __u32			htonl(__u32);
-#else
-extern unsigned long int	ntohl(unsigned long int);
-extern unsigned long int	htonl(unsigned long int);
-#endif
 extern unsigned short int	ntohs(unsigned short int);
 extern unsigned short int	htons(unsigned short int);
 
-
-#if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__) && !defined(__STRICT_ANSI__)
+#if defined(__GNUC__) && defined(__OPTIMIZE__)
 
 #define ___htonl(x) __cpu_to_be32(x)
 #define ___htons(x) __cpu_to_be16(x)
 #define ___ntohl(x) __be32_to_cpu(x)
 #define ___ntohs(x) __be16_to_cpu(x)
 
-#if defined(__KERNEL__) || (defined (__GLIBC__) && __GLIBC__ >= 2)
 #define htonl(x) ___htonl(x)
 #define ntohl(x) ___ntohl(x)
-#else
-#define htonl(x) ((unsigned long)___htonl(x))
-#define ntohl(x) ((unsigned long)___ntohl(x))
-#endif
 #define htons(x) ___htons(x)
 #define ntohs(x) ___ntohs(x)
 
 #endif /* OPTIMIZE */
 
+#endif /* KERNEL */
+
 
 #endif /* _LINUX_BYTEORDER_GENERIC_H */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/elf.h linux-2.4.22/include/linux/elf.h
--- linux-2.4.22.clean/include/linux/elf.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/include/linux/elf.h	2003-09-27 14:52:03.000000000 +0200
@@ -32,11 +32,16 @@
 #define PT_LOPROC  0x70000000
 #define PT_HIPROC  0x7fffffff
 #define PT_MIPS_REGINFO		0x70000000
+#define PT_MIPS_OPTIONS		0x70000001
 
 /* Flags in the e_flags field of the header */
 #define EF_MIPS_NOREORDER 0x00000001
 #define EF_MIPS_PIC       0x00000002
 #define EF_MIPS_CPIC      0x00000004
+#define EF_MIPS_ABI2      0x00000020
+#define EF_MIPS_OPTIONS_FIRST 0x00000080
+#define EF_MIPS_32BITMODE 0x00000100
+#define EF_MIPS_ABI       0x0000f000
 #define EF_MIPS_ARCH      0xf0000000
 
 /* These constants define the different elf file types */
@@ -60,7 +65,7 @@
 
 #define EM_MIPS		8	/* MIPS R3000 (officially, big-endian only) */
 
-#define EM_MIPS_RS4_BE 10	/* MIPS R4000 big-endian */
+#define EM_MIPS_RS3_LE 10	/* MIPS R3000 little-endian */
 
 #define EM_PARISC      15	/* HPPA */
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/fb.h linux-2.4.22/include/linux/fb.h
--- linux-2.4.22.clean/include/linux/fb.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/linux/fb.h	2003-09-27 14:59:26.000000000 +0200
@@ -95,9 +95,11 @@
 #define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
 #define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
 #define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
-#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_EPSON_SED1356  39	/* Epson SED1356		*/
+#define FB_ACCEL_SIS_GLAMOUR_2	40	/* SiS 315, 650, 740		*/
 #define FB_ACCEL_SIS_XABRE	41	/* SiS 330 ("Xabre")		*/
 
+
 #define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
 #define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
 #define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/i2c-algo-sgi.h linux-2.4.22/include/linux/i2c-algo-sgi.h
--- linux-2.4.22.clean/include/linux/i2c-algo-sgi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/include/linux/i2c-algo-sgi.h	2003-09-11 17:36:48.000000000 +0200
@@ -0,0 +1,27 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License version 2 as published by the Free Software Foundation.
+ *
+ * Copyright (C) 2003 Ladislav Michl <ladis@linux-mips.org>
+ */
+
+#ifndef I2C_ALGO_SGI_H
+#define I2C_ALGO_SGI_H 1
+
+#include <linux/i2c.h>
+
+struct i2c_algo_sgi_data {
+	void *data;	/* private data for lowlevel routines */
+	unsigned (*getctrl)(void *data);
+	void (*setctrl)(void *data, unsigned val);
+	unsigned (*rdata)(void *data);
+	void (*wdata)(void *data, unsigned val);
+
+	int xfer_timeout;
+	int ack_timeout;
+};
+
+int i2c_sgi_add_bus(struct i2c_adapter *);
+int i2c_sgi_del_bus(struct i2c_adapter *);
+
+#endif /* I2C_ALGO_SGI_H */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/i2c-id.h linux-2.4.22/include/linux/i2c-id.h
--- linux-2.4.22.clean/include/linux/i2c-id.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/linux/i2c-id.h	2003-09-27 14:09:52.000000000 +0200
@@ -91,6 +91,9 @@
 #define I2C_DRIVERID_SP5055	44     /* Satellite tuner		*/
 #define I2C_DRIVERID_STV0030	45     /* Multipurpose switch		*/
 #define I2C_DRIVERID_ADV717X   48     /* video encoder                 */
+#define I2C_DRIVERID_MAX1617	56     /* temp sensor			*/
+#define I2C_DRIVERID_SAA7191	57     /* video decoder                 */
+#define I2C_DRIVERID_INDYCAM	58     /* SGI IndyCam			*/
 
 #define I2C_DRIVERID_EXP0	0xF0	/* experimental use id's	*/
 #define I2C_DRIVERID_EXP1	0xF1
@@ -149,6 +152,10 @@
 
 #define I2C_ALGO_MPC8XX 0x110000	/* MPC8xx PowerPC I2C algorithm */
 
+#define I2C_ALGO_SIBYTE 0x120000	/* Broadcom SiByte SOCs		*/
+
+#define I2C_ALGO_SGI	0x130000	/* SGI algorithm		*/
+
 #define I2C_ALGO_EXP	0x800000	/* experimental			*/
 
 #define I2C_ALGO_MASK	0xff0000	/* Mask for algorithms		*/
@@ -190,6 +197,13 @@
 /* --- MPC8xx PowerPC adapters						*/
 #define I2C_HW_MPC8XX_EPON 0x00	/* Eponymous MPC8xx I2C adapter 	*/
 
+/* --- Broadcom SiByte adapters						*/
+#define I2C_HW_SIBYTE	0x00
+
+/* --- SGI adapters							*/
+#define I2C_HW_SGI_VINO	0x00
+#define I2C_HW_SGI_MACE	0x01
+
 /* --- SMBus only adapters						*/
 #define I2C_HW_SMBUS_PIIX4	0x00
 #define I2C_HW_SMBUS_ALI15X3	0x01
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/mc146818rtc.h linux-2.4.22/include/linux/mc146818rtc.h
--- linux-2.4.22.clean/include/linux/mc146818rtc.h	2001-11-22 20:46:58.000000000 +0100
+++ linux-2.4.22/include/linux/mc146818rtc.h	2003-09-27 14:59:53.000000000 +0200
@@ -98,4 +98,12 @@
 #define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
 #endif
 
+#ifndef RTC_IO_EXTENT
+#define RTC_IO_EXTENT	0x10	/* Only really two ports, but...	*/
+#endif
+
+#ifndef RTC_IOMAPPED
+#define RTC_IOMAPPED	1	/* Default to I/O mapping. */
+#endif
+
 #endif /* _MC146818RTC_H */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/miscdevice.h linux-2.4.22/include/linux/miscdevice.h
--- linux-2.4.22.clean/include/linux/miscdevice.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/linux/miscdevice.h	2003-09-27 14:45:54.000000000 +0200
@@ -20,9 +20,11 @@
 #define RTC_MINOR		135
 #define EFI_RTC_MINOR		136	/* EFI Time services */
 #define SUN_OPENPROM_MINOR	139
+#define LCD_MINOR		140	/* Inofficial Linux/MIPS only alloc */
 #define NVRAM_MINOR		144
 #define I2O_MINOR		166
 #define MICROCODE_MINOR		184
+#define GPIO_MINOR		185
 #define MWAVE_MINOR		219	/* ACP/Mwave Modem */
 #define MPT_MINOR		220
 #define MISC_DYNAMIC_MINOR	255
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/pci_ids.h linux-2.4.22/include/linux/pci_ids.h
--- linux-2.4.22.clean/include/linux/pci_ids.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/linux/pci_ids.h	2003-09-27 14:09:53.000000000 +0200
@@ -508,9 +508,11 @@
 #define PCI_DEVICE_ID_MIRO_36050	0x5601
 
 #define PCI_VENDOR_ID_NEC		0x1033
+#define PCI_DEVICE_ID_NEC_NAPCCARD	0x003e
 #define PCI_DEVICE_ID_NEC_PCX2		0x0046
 #define PCI_DEVICE_ID_NEC_NILE4		0x005a
 #define PCI_DEVICE_ID_NEC_VRC5476       0x009b
+#define PCI_DEVICE_ID_NEC_VRC4173	0x00a5
 #define PCI_DEVICE_ID_NEC_VRC5477_AC97  0x00a6
 
 #define PCI_VENDOR_ID_FD		0x1036
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/sched.h linux-2.4.22/include/linux/sched.h
--- linux-2.4.22.clean/include/linux/sched.h	2003-06-13 16:51:39.000000000 +0200
+++ linux-2.4.22/include/linux/sched.h	2003-09-27 14:45:02.000000000 +0200
@@ -615,6 +615,10 @@
 extern int in_group_p(gid_t);
 extern int in_egroup_p(gid_t);
 
+extern ATTRIB_NORET void cpu_idle(void);
+
+extern void release_task(struct task_struct * p);
+
 extern void proc_caches_init(void);
 extern void flush_signals(struct task_struct *);
 extern void flush_signal_handlers(struct task_struct *);
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/spinlock.h linux-2.4.22/include/linux/spinlock.h
--- linux-2.4.22.clean/include/linux/spinlock.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/include/linux/spinlock.h	2003-09-27 14:45:02.000000000 +0200
@@ -3,6 +3,8 @@
 
 #include <linux/config.h>
 
+#include <asm/system.h>
+
 /*
  * These are the generic versions of the spinlocks and read-write
  * locks..
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/threads.h linux-2.4.22/include/linux/threads.h
--- linux-2.4.22.clean/include/linux/threads.h	2002-02-25 20:38:13.000000000 +0100
+++ linux-2.4.22/include/linux/threads.h	2002-02-26 07:00:31.000000000 +0100
@@ -9,7 +9,11 @@
  */
  
 #ifdef CONFIG_SMP
-#define NR_CPUS	32		/* Max processors that can be running in SMP */
+#ifdef __mips__
+#define NR_CPUS _MIPS_SZLONG
+#else
+#define NR_CPUS	64		/* Max processors that can be running in SMP */
+#endif
 #else
 #define NR_CPUS 1
 #endif
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/linux/videodev.h linux-2.4.22/include/linux/videodev.h
--- linux-2.4.22.clean/include/linux/videodev.h	2003-06-13 16:51:39.000000000 +0200
+++ linux-2.4.22/include/linux/videodev.h	2003-03-06 01:51:47.000000000 +0100
@@ -405,6 +405,7 @@
 #define VID_HARDWARE_CPIA2	33
 #define VID_HARDWARE_VICAM	34	/* ViCam, 3Com Homeconnect */
 #define VID_HARDWARE_SF16FMR2	35
+#define VID_HARDWARE_SAA7114H	36
 
 #endif /* __LINUX_VIDEODEV_H */
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/pcmcia/cs_types.h linux-2.4.22/include/pcmcia/cs_types.h
--- linux-2.4.22.clean/include/pcmcia/cs_types.h	2001-10-11 18:43:29.000000000 +0200
+++ linux-2.4.22/include/pcmcia/cs_types.h	2002-02-15 20:54:43.000000000 +0100
@@ -36,7 +36,7 @@
 #include <sys/types.h>
 #endif
 
-#ifdef __arm__
+#if defined(__arm__) || defined(__mips__)
 typedef u_int   ioaddr_t;
 #else
 typedef u_short	ioaddr_t;
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/include/video/e1356fb.h linux-2.4.22/include/video/e1356fb.h
--- linux-2.4.22.clean/include/video/e1356fb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22/include/video/e1356fb.h	2003-04-27 04:56:07.000000000 +0200
@@ -0,0 +1,73 @@
+/*
+ *	e1356fb.h  --  Epson SED1356 Framebuffer Driver IOCTL Interface
+ *
+ *	Copyright 2001, 2002, 2003 MontaVista Software Inc.
+ *	Author: MontaVista Software, Inc.
+ *		stevel@mvista.com or source@mvista.com
+ *
+ *	This program is free software; you can redistribute  it and/or modify it
+ *	under  the terms of  the GNU General  Public License as published by the
+ *	Free Software Foundation;  either version 2 of the  License, or (at your
+ *	option) any later version.
+ *
+ *	THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *	WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *	NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *	NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *	USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *	ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *	THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *	You should have received a copy of the  GNU General Public License along
+ *	with this program; if not, write  to the Free Software Foundation, Inc.,
+ *	675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * IOCTLs to SED1356 fb driver. 0x45 is 'E' for Epson.
+ */
+#define FBIO_SED1356_BITBLT 0x4500
+
+typedef struct {
+	int   operation;
+	int   rop;
+	int   src_y;
+	int   src_x;
+	int   src_width;
+	int   src_height;
+	int   dst_y;
+	int   dst_x;
+	int   dst_width;
+	int   dst_height;
+	int   pattern_x;
+	int   pattern_y;
+	int   attribute;
+	unsigned int bg_color;
+	unsigned int fg_color;
+	unsigned short* src;
+	int   srcsize;
+	int   srcstride;
+} blt_info_t;
+
+enum blt_attribute_t {
+	BLT_ATTR_TRANSPARENT = 1
+};
+
+enum blt_operation_t {
+	BLT_WRITE_ROP = 0,
+	BLT_READ,
+	BLT_MOVE_POS_ROP,
+	BLT_MOVE_NEG_ROP,
+	BLT_WRITE_TRANSP,
+	BLT_MOVE_POS_TRANSP,
+	BLT_PAT_FILL_ROP,
+	BLT_PAT_FILL_TRANSP,
+	BLT_COLOR_EXP,
+	BLT_COLOR_EXP_TRANSP,
+	BLT_MOVE_COLOR_EXP,
+	BLT_MOVE_COLOR_EXP_TRANSP,
+	BLT_SOLID_FILL
+};
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/init/main.c linux-2.4.22/init/main.c
--- linux-2.4.22.clean/init/main.c	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/init/main.c	2003-09-27 14:09:55.000000000 +0200
@@ -290,7 +290,6 @@
 
 
 extern void setup_arch(char **);
-extern void cpu_idle(void);
 
 unsigned long wait_init_idle;
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/kernel/exit.c linux-2.4.22/kernel/exit.c
--- linux-2.4.22.clean/kernel/exit.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/kernel/exit.c	2003-01-11 18:53:18.000000000 +0100
@@ -26,7 +26,7 @@
 
 int getrusage(struct task_struct *, int, struct rusage *);
 
-static void release_task(struct task_struct * p)
+void release_task(struct task_struct * p)
 {
 	if (p != current) {
 #ifdef CONFIG_SMP
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/kernel/printk.c linux-2.4.22/kernel/printk.c
--- linux-2.4.22.clean/kernel/printk.c	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/kernel/printk.c	2003-09-27 14:09:55.000000000 +0200
@@ -99,7 +99,7 @@
 /*
  *	Setup a list of consoles. Called from init/main.c
  */
-static int __init console_setup(char *str)
+int __init console_setup(char *str)
 {
 	struct console_cmdline *c;
 	char name[sizeof(c->name)];
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/kernel/signal.c linux-2.4.22/kernel/signal.c
--- linux-2.4.22.clean/kernel/signal.c	2003-06-13 16:51:39.000000000 +0200
+++ linux-2.4.22/kernel/signal.c	2003-02-25 23:03:13.000000000 +0100
@@ -14,6 +14,7 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 
+#include <asm/param.h>
 #include <asm/uaccess.h>
 
 /*
@@ -28,6 +29,14 @@
 #define SIG_SLAB_DEBUG	0
 #endif
 
+#define DEBUG_SIG 0
+
+#if DEBUG_SIG
+#define SIG_SLAB_DEBUG	(SLAB_DEBUG_FREE | SLAB_RED_ZONE /* | SLAB_POISON */)
+#else
+#define SIG_SLAB_DEBUG	0
+#endif
+
 static kmem_cache_t *sigqueue_cachep;
 
 atomic_t nr_queued_signals;
@@ -270,6 +279,11 @@
 	signal_pending(current));
 #endif
 
+#if DEBUG_SIG
+printk("SIG dequeue (%s:%d): %d ", current->comm, current->pid,
+	signal_pending(current));
+#endif
+
 	sig = next_signal(current, mask);
 	if (sig) {
 		if (current->notifier) {
@@ -293,6 +307,10 @@
 printk(" %d -> %d\n", signal_pending(current), sig);
 #endif
 
+#if DEBUG_SIG
+printk(" %d -> %d\n", signal_pending(current), sig);
+#endif
+
 	return sig;
 }
 
@@ -540,6 +558,11 @@
 printk("SIG queue (%s:%d): %d ", t->comm, t->pid, sig);
 #endif
 
+
+#if DEBUG_SIG
+printk("SIG queue (%s:%d): %d ", t->comm, t->pid, sig);
+#endif
+
 	ret = -EINVAL;
 	if (sig < 0 || sig > _NSIG)
 		goto out_nolock;
@@ -778,8 +801,8 @@
 	info.si_uid = tsk->uid;
 
 	/* FIXME: find out whether or not this is supposed to be c*time. */
-	info.si_utime = tsk->times.tms_utime;
-	info.si_stime = tsk->times.tms_stime;
+	info.si_utime = hz_to_std(tsk->times.tms_utime);
+	info.si_stime = hz_to_std(tsk->times.tms_stime);
 
 	status = tsk->exit_code & 0x7f;
 	why = SI_KERNEL;	/* shouldn't happen */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/kernel/sys.c linux-2.4.22/kernel/sys.c
--- linux-2.4.22.clean/kernel/sys.c	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/kernel/sys.c	2003-09-27 14:09:55.000000000 +0200
@@ -810,16 +810,23 @@
 
 asmlinkage long sys_times(struct tms * tbuf)
 {
+	struct tms temp;
+
 	/*
 	 *	In the SMP world we might just be unlucky and have one of
 	 *	the times increment as we use it. Since the value is an
 	 *	atomically safe type this is just fine. Conceptually its
 	 *	as if the syscall took an instant longer to occur.
 	 */
-	if (tbuf)
-		if (copy_to_user(tbuf, &current->times, sizeof(struct tms)))
+	if (tbuf) {
+		temp.tms_utime = hz_to_std(current->times.tms_utime);
+		temp.tms_stime = hz_to_std(current->times.tms_stime);
+		temp.tms_cutime = hz_to_std(current->times.tms_cutime);
+		temp.tms_cstime = hz_to_std(current->times.tms_cstime);
+		if (copy_to_user(tbuf, &temp, sizeof(struct tms)))
 			return -EFAULT;
-	return jiffies;
+	}
+	return hz_to_std(jiffies);
 }
 
 /*
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/lib/Makefile linux-2.4.22/lib/Makefile
--- linux-2.4.22.clean/lib/Makefile	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/lib/Makefile	2003-09-27 14:09:55.000000000 +0200
@@ -26,6 +26,7 @@
 subdir-$(CONFIG_ZLIB_INFLATE) += zlib_inflate
 subdir-$(CONFIG_ZLIB_DEFLATE) += zlib_deflate
 
+-include $(TOPDIR)/arch/$(ARCH)/Makefile.lib
 include $(TOPDIR)/drivers/net/Makefile.lib
 include $(TOPDIR)/drivers/usb/Makefile.lib
 include $(TOPDIR)/fs/Makefile.lib
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/lib/string.c linux-2.4.22/lib/string.c
--- linux-2.4.22.clean/lib/string.c	2002-08-03 02:39:46.000000000 +0200
+++ linux-2.4.22/lib/string.c	2002-06-27 00:36:48.000000000 +0200
@@ -356,7 +356,7 @@
  *
  * Do not use memset() to access IO space, use memset_io() instead.
  */
-void * memset(void * s,int c,size_t count)
+void * memset(void * s,int c, size_t count)
 {
 	char *xs = (char *) s;
 
@@ -474,14 +474,15 @@
 void * memscan(void * addr, int c, size_t size)
 {
 	unsigned char * p = (unsigned char *) addr;
+	unsigned char * e = p + size;
 
-	while (size) {
-		if (*p == c)
+	while (p != e) {
+		if (*p == (unsigned char)c)
 			return (void *) p;
 		p++;
-		size--;
 	}
-  	return (void *) p;
+
+	return (void *) p;
 }
 #endif
 
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/MAINTAINERS linux-2.4.22/MAINTAINERS
--- linux-2.4.22.clean/MAINTAINERS	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/MAINTAINERS	2003-09-27 14:06:41.000000000 +0200
@@ -940,7 +940,7 @@
 
 IOC3 DRIVER
 P:	Ralf Baechle
-M:	ralf@oss.sgi.com
+M:	ralf@linux-mips.org
 L:	linux-mips@linux-mips.org
 S:	Maintained
 
@@ -1130,6 +1130,13 @@
 M:	zab@zabbo.net
 S:	Odd Fixes
 
+MARVELL MV64340 ETHERNET DRIVER
+P:	Manish Lachwani
+M:	Manish_Lachwani@pmc-sierra.com
+L:	linux-mips@linux-mips.org
+L:	netdev@oss.sgi.com
+S:	Supported
+
 MATROX FRAMEBUFFER DRIVER
 P:	Petr Vandrovec
 M:	vandrove@vc.cvut.cz
@@ -1151,7 +1158,7 @@
 
 MIPS
 P:	Ralf Baechle
-M:	ralf@gnu.org
+M:	ralf@linux-mips.org
 W:	http://oss.sgi.com/mips/mips-howto.html
 L:	linux-mips@linux-mips.org
 S:	Maintained
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/Makefile linux-2.4.22/Makefile
--- linux-2.4.22.clean/Makefile	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/Makefile	2003-09-27 17:01:16.000000000 +0200
@@ -5,7 +5,7 @@
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
-ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+ARCH = mips
 KERNELPATH=kernel-$(shell echo $(KERNELRELEASE) | sed -e "s/-//g")
 
 CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
@@ -19,7 +19,7 @@
 HOSTCC  	= gcc
 HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 
-CROSS_COMPILE 	=
+CROSS_COMPILE 	= 
 
 #
 # Include the make variables (CC, etc...)
@@ -175,7 +175,6 @@
 DRIVERS-$(CONFIG_PPC32) += drivers/macintosh/macintosh.o
 DRIVERS-$(CONFIG_MAC) += drivers/macintosh/macintosh.o
 DRIVERS-$(CONFIG_ISAPNP) += drivers/pnp/pnp.o
-DRIVERS-$(CONFIG_SGI_IP22) += drivers/sgi/sgi.a
 DRIVERS-$(CONFIG_VT) += drivers/video/video.o
 DRIVERS-$(CONFIG_PARIDE) += drivers/block/paride/paride.a
 DRIVERS-$(CONFIG_HAMRADIO) += drivers/net/hamradio/hamradio.o
@@ -220,6 +219,7 @@
 	drivers/scsi/aic7xxx/aicasm/aicdb.h \
 	drivers/scsi/aic7xxx/aicasm/y.tab.h \
 	drivers/scsi/53c700_d.h \
+	drivers/tc/lk201-map.c \
 	net/khttpd/make_times_h \
 	net/khttpd/times.h \
 	submenu*
@@ -460,10 +460,11 @@
 	$(MAKE) -C Documentation/DocBook mrproper
 
 distclean: mrproper
-	rm -f core `find . \( -not -type d \) -and \
-		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
-		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
-		-o -name '.*.rej' -o -name '.SUMS' -o -size 0 \) -type f -print` TAGS tags
+	find . \( -not -type d \) -and \
+		\( -name core -o -name '*.orig' -o -name '*.rej' \
+		-o -name '*~' -o -name '*.bak' -o -name '#*#' \
+		-o -name '.*.rej' -o -name '.SUMS' -o -size 0 \
+		-o -name TAGS -o -name tags \) -print | env -i xargs rm -f
 
 backup: mrproper
 	cd .. && tar cf - linux/ | gzip -9 > backup.gz
@@ -490,7 +491,7 @@
 	$(MAKE) -C Documentation/DocBook man
 
 sums:
-	find . -type f -print | sort | xargs sum > .SUMS
+	find . -type f -print | sort | env -i xargs sum > .SUMS
 
 dep-files: scripts/mkdep archdep include/linux/version.h
 	rm -f .depend .hdepend
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/mm/mmap.c linux-2.4.22/mm/mmap.c
--- linux-2.4.22.clean/mm/mmap.c	2003-06-13 16:51:39.000000000 +0200
+++ linux-2.4.22/mm/mmap.c	2003-12-01 14:16:40.000000000 +0100
@@ -1041,6 +1041,9 @@
 	if (!len)
 		return addr;
 
+	if ((addr + len) > TASK_SIZE || (addr + len) < addr)
+		return -EINVAL;
+
 	/*
 	 * mlock MCL_FUTURE?
 	 */
diff -Naur --exclude='*.orig' --exclude=CVS --exclude=.cvsignore --exclude='.#*' --exclude=README.Debian linux-2.4.22.clean/Rules.make linux-2.4.22/Rules.make
--- linux-2.4.22.clean/Rules.make	2002-08-03 02:39:42.000000000 +0200
+++ linux-2.4.22/Rules.make	2003-08-13 17:39:03.000000000 +0200
@@ -96,12 +96,12 @@
 $(O_TARGET): $(obj-y)
 	rm -f $@
     ifneq "$(strip $(obj-y))" ""
-	$(LD) $(EXTRA_LDFLAGS) -r -o $@ $(filter $(obj-y), $^)
+	$(LD) $(LDFLAGS) $(EXTRA_LDFLAGS) -r -o $@ $(filter $(obj-y), $^)
     else
 	$(AR) rcs $@
     endif
 	@ ( \
-	    echo 'ifeq ($(strip $(subst $(comma),:,$(EXTRA_LDFLAGS) $(obj-y))),$$(strip $$(subst $$(comma),:,$$(EXTRA_LDFLAGS) $$(obj-y))))' ; \
+	    echo 'ifeq ($(strip $(subst $(comma),:,$(LDFLAGS) $(EXTRA_LDFLAGS) $(obj-y))),$$(strip $$(subst $$(comma),:,$$(LDFLAGS) $$(EXTRA_LDFLAGS) $$(obj-y))))' ; \
 	    echo 'FILES_FLAGS_UP_TO_DATE += $@' ; \
 	    echo 'endif' \
 	) > $(dir $@)/.$(notdir $@).flags
