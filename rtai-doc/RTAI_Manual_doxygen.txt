/* -*- C -*- */

/*
  Questions
=========

Dans rt_task_init_cpuid, à quoi correspond le paramètre cpuid.

Différence entre rt_task_make_periodic_relative_ns et
rt_task_make_periodic.

rt_preempt_always : c'est vraiment du chinois !



RTAI_SCHED module.. 7
Task functions. 8
rt_task_init 9
rt_task_init_cpuid 9
rt_task_delete 11
rt_task_make_periodic 12
rt_task_make_periodic_relative_ns 12
rt_task_wait_period 13
rt_task_yield 14
rt_task_suspend 15
rt_task_resume 16
rt_get_task_state 17
rt_whoami 18
rt_task_signal_handler 19
rt_set_runnable_on_cpus 20
rt_set_runnable_on_cpuid 20
rt_task_use_fpu 21
rt_linux_use_fpu 21
rt_preempt_always 22
rt_preempt_always_cpuid 22
rt_sched_lock 23
rt_sched_unlock 23
rt_change_prio 24
rt_get_prio 24
rt_get_inher_prio 24
Timer functions. 25
rt_set_oneshot_mode 26
rt_set_periodic_mode 26
start_rt_timer 27
stop_rt_timer 27
start_rt_apic_timer 28
stop_rt_apic_timer 28
count2nano 29
count2nano_cpuid 29
nano2count 29
nano2count_cpuid 29
rt_get_time 30
rt_get_time_cpuid 30
rt_get_time_ns 30
rt_get_cpu_time_ns 30
next_period 31
rt_busy_sleep 32
rt_sleep 32
rt_sleep_until 32
Semaphore functions. 33
rt_typed_sem_init 34
rt_sem_init 35
rt_sem_delete 36
rt_sem_signal 37
rt_sem_wait 38
rt_sem_wait_if 39
rt_sem_wait_until 40
rt_sem_wait_timed 40
Message handling functions. 41
rt_send 42
rt_send_if 43
rt_send_until 44
rt_send_timed 44
rt_receive 45
rt_receive_if 46
rt_receive_until 47
rt_receive_timed 47
RPC (Remote Procedure Call) functions. 48
rt_rpc 49
rt_rpc_if 50
rt_rpc_until 51
rt_rpc_timed 51
rt_isrpc 52
rt_return 53
Mailbox functions. 54
rt_mbx_init 55
rt_mbx_delete 56
rt_mbx_send 57
rt_mbx_send_wp 58
rt_mbx_send_if 59
rt_mbx_send_until 60
rt_mbx_send_timed 60
rt_mbx_receive 61
rt_mbx_receive_wp 62
rt_mbx_receive_if 63
rt_mbx_receive_until 64
rt_mbx_receive_timed 64
RTAI module.. 65
RTAI service functions. 66
rt_global_cli 67
rt_global_sti 67
rt_global_save_flags 68
rt_global_save_flags_and_cli 68
rt_global_restore_flags 68
rt_startup_irq 69
rt_shutdown_irq 69
rt_enable_irq 69
rt_disable_irq 69
rt_mask_and_ack_irq 69
rt_unmask_irq 69
rt_ack_irq 69
send_ipi_shorthand 71
send_ipi_logical 71
rt_assign_irq_to_cpu 72
rt_reset_irq_to_sym_mode 72
rt_request_global_irq 73
request_RTirq 73
rt_free_global_irq 73
rt_request_linux_irq 74
rt_free_linux_irq 74
rt_pend_linux_irq 75
rt_request_srq 76
rt_free_srq 76
rt_pend_linux_srq 77
rt_request_timer 78
rt_free_timer 78
rt_request_apic_timers 79
rt_free_apic_timers 79
rt_mount_rtai 80
rt_umount_rtai 80
RTAI_SHM module.. 81
RTAI_SHM service functions. 82
rtai_malloc_adr 83
rtai_malloc 83
rtai_kmalloc 83
rt_request_timer 83
rt_request_timer 83
rtai_free 84
rtai_kfree 84
rt_request_timer 84
nam2num 85
num2nam 85
LXRT module.. 86
LXRT service functions. 87
rt_task_init 88
rt_sem_init 89
rt_mbx_init 90
rt_register 91
rt_get_adr 91
rt_get_name 91
rt_drg_on_adr 91
rt_drg_on_name 91
rt_make_hard_real_time 92
rt_make_soft_real_time 92
rt_allow_nonroot_hrt 93
MINI_RTAI_LXRT module.. 94
MINI_RTAI_LXRT service functions. 95
rt_tasklet_init 96
rt_tasklet_delete 96
rt_insert_tasklet 97
rt_remove_tasklet 97
rt_find_tasklet_by_id 98
rt_tasklet_exec 98
rt_timer_init 99
rt_timer_delete 99
rt_insert_timer 100
rt_remove_timer 100
rt_set_timer_priority 101
rt_set_timer_firing_time 102
rt_set_timer_period 102
rt_set_timer_handler 103
rt_set_timer_data 104
rt_tasklets_use_fpu 105
RTAI_FIFOS module.. 106
RTAI FIFO communication functions. 107
rtf_create 108
rtf_open_sized 108
rtf_destroy 109
rtf_reset 110
rtf_resize 111
rtf_put 112
rtf_write_timed 113
rtf_get 114
rtf_read_timed 115
rtf_read_all_at_once 116
rtf_create_handler 117
rtf_suspend_timed 118
rtf_set_async_sig 119
RTAI FIFO semaphore functions. 120
rtf_sem_init 121
rtf_sem_destroy 122
rtf_sem_post 123
rtf_sem_wait 124
rtf_sem_trywait 125
rtf_sem_timed_wait 126
APPENDIX A.. 127
APPENDIX B0. 129
APPENDIX B1. 132
APPENDIX C.. 136
INDEX.. 138

****** Functions provided by rtai_sched modulesif
 for: ******
****** - UniProcessor (UP), ******
****** SymmetricMultiProcessors (SMP), ******
****** MultiUniPprocessors (MUP). ******
****  ****
**** See Appendix A for a quick overview of RTAI schedulers. ****

***** Task functions: *****

    * rt_task_init
    * rt_task_init_cpuid
    * rt_task_delete
    * rt_task_make_periodic
    * rt_task_make_periodic_relative_ns
    * rt_task_wait_period
    * rt_task_yield
    * rt_task_suspend
    * rt_task_resume
    * rt_get_task_state
    * rt_whoami
    * rt_task_signal_handler
    * rt_set_runneable_on_cpus
    * rt_set_runnable_on_cpuid
    * rt_task_use_fpu
    * rt_linux_use_fpu
    * rt_preempt_always
    * rt_preempt_always_cpuid
*/

============
rt_task_init
============

/**
 * @anchor rt_task_init
 * Creates a new real time task.
 *
 * The newly created real time task is initially in a suspend
 * state. It can be made active by calling: @ref
 * rt_task_make_periodic, @ref rt_task_make_periodic_relative_ns, @ref
 * rt_task_resume.
 *
 * When used with the MUP scheduler rt_task_init automatically selects
 * which CPU the task will run on, while with the SMP scheduler the
 * task defaults to using any of the available CPUs. This assignment
 * may be changed by calling @ref rt_set_runnable_on_cpus.
 *
 * @param task is a pointer to an RT_TASK type structure whose space
 *	  must be provided by the application. It must be kept during
 *	  the whole lifetime of the real time task. 
 *
 * @param rt_thread is the entry point of the task function.
 *
 * @param data The parent task can pass a single integer value data to
 *	  the new task being created. Recall that an appropriately
 *	  type casting allows data to be a pointer to whatever data
 *	  structure one would like to pass to the task, so you can
 *	  indirectly pass whatever you want to the task.
 * 
 * @param stack_size is the size of the stack to be used by the new
 *		     task. In sizing it, recall to make room for any
 *		     real time interrupt handler, as real time
 *		     interrupts run on the stack of the task they
 *		     interrupt. So try to avoid being too sparing.
 *
 * @param priority is the priority to be given to the task. The
 *	  highest priority is 0, while the lowest is
 *	  RT_LOWEST_PRIORITY. 
 *
 * @param uses_fpu is a flag. A nonzero value indicates that the task
 *		   will use the floating point unit.
 *
 * @param signal is a function that is called, within the task
 *	  environment and with interrupts disabled, when the task
 * 	  becomes the current running task after a context
 *	  switch. Note however that signal is not called at the very
 *	  first scheduling of the task. Such a function can be
 *	  assigned and/or changed dynamically whenever needed (see
 *	  function @ref rt_task_signal_handler.)
 *
 * @retval 0 on success.
 * @retval a negative value on failure as described below:
 * - @b EINVAL: task structure pointed by task is already in use;
 * - @b ENOMEM: stack_size bytes could not be allocated for the stack.
 *
 * See also: @ref rt_task_init_cpuid.
 */


==================
rt_task_init_cpuid
==================

/**
 * @anchor rt_task_init_cpuid
 * Creates a new real time task and assigns it to a single specific
 * CPU. 
 *
 * The newly created real time task is initially in a suspend
 * state. It can be made active by calling: @ref rt_task_make_periodic,
 * @ref rt_task_make_periodic_relative_ns, @ref rt_task_resume.
 *
 *
 * When used with the MUP scheduler @ref rt_task_init automatically
 * selects which CPU the task will run on, while with the SMP
 * scheduler the task defaults to using any of the available
 * CPUs. This assignment may be changed by calling @ref
 * rt_set_runnable_on_cpus or @ref rt_set_runnable_on_cpuid. If cpuid
 * is invalid rt_task_init_cpuid falls back to automatic CPU
 * selection.
 *
 * Whatever scheduler is used on multiprocessor systems
 * rt_task_init_cpuid allows to create a task and assign it to a
 * single specific CPU cpuid from its very beginning, without any need
 * to call @ref rt_set_runnable_on_cpuid later on.
 *
 * @param task is a pointer to an RT_TASK type structure whose space
 *	  must be provided by the application. It must be kept during
 *	  the whole lifetime of the real time task.  
 *
 * @param rt_thread is the entry point of the task function.
 *
 * @param data The parent task can pass a single integer value data to
 *	       the new task being created. Recall that an
 *	       appropriately type casting allows data to be a pointer
 *	       to whatever data structure one would like to pass to
 *	       the task, so you can indirectly pass whatever you want
 *	       to the task.
 *
 * @param stack_size is the size of the stack to be used by the new
 *	  task. In sizing it recall to make room for any real time
 *	  interrupt handler, as real time interrupts run on the stack
 *	  of the task they interrupt. So try to avoid being too
 *	  sparing.
 *
 * @param priority is the priority to be given to the task. The
 *	  highest priority is 0, while the lowest is
 *	  RT_LOWEST_PRIORITY.
 *
 * @param uses_fpu is a flag. A nonzero value indicates that the task
 *	  will use the floating point unit.
 *
 * @param signal is a function that is called, within the task
 *	  environment and with interrupts disabled, when the task
 *	  becomes the current running task after a context
 *	  switch. Note however that signal is not called at the very
 *	  first scheduling of the task. Such a function can be
 *	  assigned and/or changed dynamically whenever needed (see
 *	  function rt_task_signal_handler.)
 *
 * @param cpuid FIXME
 *
 * @retval 0 on success.
 * @retval a negative value on failure as described below:
 * - @b EINVAL: task structure pointed by task is already in use;
 * - @b ENOMEM: stack_size bytes could not be allocated for the stack.
 *
 * See also: @ref rt_task_init.
 */


==============
rt_task_delete
==============

/**
 * @anchor rt_task_delete
 * Delete a real time task.
 *
 * rt_task_delete deletes a real time task previously created by
 * @ref rt_task_init or @ref rt_task_init_cpuid.
 *
 * @param task is the pointer to the task structure. If task task was
 *	  waiting on a queue, i.e. semaphore, mailbox, etc, it is
 *	  removed from such a queue and messaging tasks pending on its
 *	  message queue are unblocked with an error return.
 * 
 * @retval 0 on success.
 * @retval a negative value on failure as described below:
 * - @b EINVAL: task does not refer to a valid task.
 */


=====================
rt_task_make_periodic
=====================

/**
 * @anchor rt_task_make_periodic
 * Make a task run periodically
 *
 * rt_task_make_periodic mark the task @e task, previously created
 * with @ref rt_task_init, as suitable for a periodic execution, with
 * period @e period, when @ref rt_task_wait_period is called.
 *
 * The time of first execution is given by @e start_time or @e
 * start_delay. @e start_time is an absolute value measured in clock
 * ticks.  @e start_delay is relative to the current time and measured
 * in nanoseconds.
 *
 * @param task is a pointer to the task you want to make periodic.
 *
 * @param start_time is the time to wait before the task start
 *	  running.
 *
 * @param period corresponds to the period of the task.
 *
 * @retval 0 on success.
 * @retval a negative value on failure as described below:
 * - @b EINVAL: task does not refer to a valid task.
 *
 * See also: @ref rt_task_make_periodic_relative_ns
 */


=================================
rt_task_make_periodic_relative_ns
=================================

/**
 * @anchor rt_task_make_periodic_relative_ns
 * Make a task run periodically.
 *
 * rt_task_make_periodic_relative_ns mark the task @e task, previously
 * created with @ref rt_task_init, as suitable for a periodic
 * execution, with period @e period, when @ref rt_task_wait_period is
 * called.
 *
 * The time of first execution is given by @e start_time or @e
 * start_delay. @e start_time is an absolute value measured in clock
 * ticks. @e start_delay is relative to the current time and measured
 * in nanoseconds.
 *
 * @param task is a pointer to the task you want to make periodic.
 *
 * @param start_delay is the time to wait before the task start
 *	  running.
 *
 * @param period corresponds to the period of the task.
 *
 * @retval 0 on success.
 * @retval a negative value on failure as described below:
 * - @b EINVAL: task does not refer to a valid task.
 */


===================
rt_task_wait_period
===================

/**
 * @anchor rt_task_wait_period
 * Wait till next period.
 *
 * rt_task_wait_period suspends the execution of the currently running
 * real time task until the next period is reached.
 * The task must have
 * been previously marked for a periodic execution by calling
 * @ref rt_task_make_periodic or @ref rt_task_make_periodic_relative_ns.
 *
 * @note The task is suspended only temporarily, i.e. it simply gives
 * up control until the next time period.
 */


=============
rt_task_yield
=============

/**
 * @anchor rt_task_yield
 * Yield the current task.
 *
 * @ref rt_task_yield stops the current task and takes it at the end
 * of the list of ready tasks having its same priority. The scheduler
 * makes the next ready task of the same priority active.
 *
 * Recall that RTAI schedulers allow only higher priority tasks to
 * preempt the execution of lower priority ones. So equal priority
 * tasks cannot preempt each other and @ref rt_task_yield should be
 * used if a user needs a cooperative time slicing among equal
 * priority tasks. The implementation of the related policy is wholly
 * in the hand of the user. It is believed that time slicing is too
 * much an overhead for the most demanding real time applications, so
 * it is left up to you.
 */


===============
rt_task_suspend
===============

/**
 * @anchor rt_task_suspend
 * rt_task_suspend suspends execution of the task task.
 *
 * It will not be executed until a call to @ref rt_task_resume or @ref
 * rt_task_make_periodic is made. No account is made for multiple
 * suspends, i.e. a multiply suspended task is made ready as soon as
 * it is rt_task_resumed, thus immediately resuming its execution if
 * it is the highest in priority.

 * @retval 0 on success.
 * @retval a negative value on failure as described below:
 * - @b EINVAL: task does not refer to a valid task.
 *
 * @note: the new RTAI 24.1.xx (FIXME) development releases take into
 * account multiple suspend and require as many @ref rt_task_resumes
 * as the rt_task_suspends placed on a task.
 */

==============
rt_task_resume
==============

/**
 * @anchor rt_task_resume
 * Resume a task.
 *
 * rt_task_resume resumes execution of the task @e task previously
 * suspended by @ref rt_task_suspend, or makes a newly created task
 * ready to run, if it makes the task ready. Since no account is made
 * for multiple suspend rt_task_resume unconditionally resumes any
 * task it makes ready.
 *
 * @retval 0 on success.
 * @retval a negative value on failure as described below:
 * - @b EINVAL: task does not refer to a valid task.
 *
 * @note: the new RTAI 24.1.xx (FIXME) development releases take into
 *        account multiple suspend and require as many rt_task_resumes
 *	  as the rt_task_suspends placed on a task.
 */
   


=================
rt_get_task_state
=================

/**
 * @anchor rt_get_task_state
 * Query task state
 *
 * rt_get_task_state returns the state of a real time task.
 *
 * @param task is a pointer to the task structure.
 *
 * Task state is formed by the bitwise OR of one or more of the
 * following flags:
 *
 * @retval READY Task @e task is ready to run (i.e. unblocked).
 * Note that on a UniProcessor machine the currently running task is
 * just in READY state, while on MultiProcessors can be (READY |
 * RUNNING), see below. 
 * @retval SUSPENDED Task @e task blocked waiting for a resume.
 * @retval DELAYED Task @e task blocked waiting for its next running
 * period or expiration of a timeout.
 * @retval SEMAPHORE Task @e task blocked on a semaphore, waiting for
 * the semaphore to be signaled.
 * @retval SEND Task @e task blocked on sending a message, receiver
 * was not in RECEIVE state.
 * @retval RECEIVE Task @e task blocked waiting for incoming messages,
 * sends or rpcs. 
 * @retval RPC Task @e task blocked on a Remote Procedure Call,
 * receiver was not in RECEIVE state.
 * @retval RETURN Task @e task blocked waiting for a return from a
 * Remote Procedure Call, receiver got the RPC but has not replied
 * yet. 
 * @retval RUNNING Task @e task is running, used only for SMP
 * schedulers. 
 *
 * The returned task state is just an approximate information. Timer
 * and other hardware interrupts may cause a change in the state of
 * the queried task before the caller could evaluate the returned
 * value. Caller should disable interrupts if it wants reliable info
 * about an other task.  rt_get_task_state does not perform any check
 * on pointer task.
 */


=========
rt_whoami
=========
/**
 * @anchor rt_whoami
 * @brief Get the task pointer of the current task.
 *
 * Calling rt_whoami from a task can get a pointer to its own task
 * structure.
 * 
 * @return The pointer to the current task.
 */


======================
rt_task_signal_handler
======================
   
/**
 * @anchor
 * @brief Set the signal handler of a task.
 *
 * rt_task_signal_handler installs, or changes, the signal function
 * of a real time task.
 *
 * @param task is a pointer to the real time task.
 *
 * @param handler is the entry point of the signal function.
 *
 * A signal handler function can be set also when the task is newly
 * created with @ref rt_task_init.  The signal handler is a function
 * called within the task environment and with interrupts disabled,
 * when the task becomes the current running task after a context
 * switch, except at its very first scheduling. It allows you to
 * implement whatever signal management policy you think useful, and
 * many other things as well (FIXME).
 *
 * @retval 0 on success.
 * @retval a negative value on failure as described below:
 * - @b EINVAL: task does not refer to a valid task.
 */

============================
void rt_set_runnable_on_cpus
============================

/**
 * @anchor rt_set_runnable_on_cpus
 * @brief Assign CPUs to a task.
 *
 * rt_set_runnable_on_cpus selects one or more CPUs which are allowed
 * to run task @e task. 
 * rt_set_runnable_on_cpus behaves differently for MUP and SMP
 * schedulers. Under the SMP scheduler bit<n> of cpu_mask enables the
 * task to run on CPU<n>. Under the MUP scheduler it selects the CPU
 * with less running tasks among those allowed by cpu_mask.
 * Recall that with MUP a task must be bounded to run on a single CPU.
 * If no CPU, as selected by cpu_mask or cpuid, is available, both
 * functions choose a possible CPU automatically, following the same
 * rule as above. 
 *
 * @note This call has no effect on UniProcessor (UP) systems.
 *
 * See also: @ref rt_set_runnable_on_cpuid.
 */

=============================
void rt_set_runnable_on_cpuid
=============================

/**
 * @anchor rt_set_runnable_on_cpuid
 * @brief Assign CPUs to a task.
 *
 * rt_set_runnable_on_cpuid select one or more CPUs which are allowed
 * to run task @e task. 
 *
 * rt_set_runnable_on_cpuid assigns a task to a single specific CPU.
 * If no CPU, as selected by cpu_mask or cpuid, is available, both
 * functions choose a possible CPU automatically, following the same
 * rule as above. 
 *
 * @note This call has no effect on UniProcessor (UP) systems.
 *
 * See also: @ref rt_set_runnable_on_cpus.
 */

====================
void rt_task_use_fpu
====================

/**
 * @anchor rt_task_use_fpu
 * @brief 
 *
 * rt_task_use_fpu informs the scheduler that floating point
 * arithmetic operations will be used by the real time task @e task.
 *
 * @param task is a pointer to the real time task.
 * 
 * @param use_fpu_flag If this parameter has a nonzero value, the
 * Floating Point Unit (FPU) context is also switched when @e task or
 * the kernel becomes active.
 * This makes task switching slower, negligibly, on all 32 bits CPUs
 * but 386s and the oldest 486s.
 * This flag can be set also by @ref rt_task_init when the real time
 * task is created. With UP and MUP schedulers care is taken to avoid
 * useless saves/restores of the FPU environment.
 * Under SMP tasks can be moved from CPU to CPU so saves/restores for
 * tasks using the FPU are always carried out. 
 *
 * @retval 0 on success.
 * @retval a negative value on failure as described below:
 * - @b EINVAL: task does not refer to a valid task.
 *
 * See also: @ref rt_linux_use_fpu.
 */


=====================
void rt_linux_use_fpu
=====================

/**
 * @anchor rt_linux_use_fpu
 * @brief Set indication of FPU usage.
 *
 * rt_linux_use_fpu informs the scheduler that floating point
 * arithmetic operations will be used also by foreground Linux
 * processes, i.e. the Linux kernel itself (unlikely) and any of its
 * processes. 
 *
 * @param task is a pointer to the real time task.
 * 
 * @param use_fpu_flag If this parameter has a nonzero value, the
 * Floating Point Unit (FPU) context is also switched when @e task or
 * the kernel becomes active.
 * This makes task switching slower, negligibly, on all 32 bits CPUs
 * but 386s and the oldest 486s. 
 * This flag can be set also by rt_task_init when the real time task
 * is created. With UP and MUP schedulers care is taken to avoid
 * useless saves/ restores of the FPU environment. 
 * Under SMP tasks can be moved from CPU to CPU so saves/restores for
 * tasks using the FPU are always carried out. 
 * Note that by default Linux has this flag cleared. Beside by using
 * rt_linux_use_fpu you can change the Linux FPU flag when you insmod
 * any RTAI scheduler module by setting the LinuxFpu command line
 * parameter of the rtai_sched module itself.
 *
 * @retval 0 on success.
 * @retval a negative value on failure as described below:
 * - @b EINVAL: task does not refer to a valid task.
 *
 * See also: @ref rt_linux_use_fpu.
 */


=================
rt_preempt_always
=================

/**
 * @anchor rt_preempt_always
 * @brief Enable hard preemption
 *
 * In the oneshot mode the next timer expiration is programmed after a
 * timer shot by choosing among the timed tasks the one with a
 * priority higher than the task chosen to run as current, with the
 * constraint of always assuring a correct Linux timing. In such a
 * view there is no need to fire the timer immediately. In fact it can
 * happen that the current task can be so fast to get suspended and
 * rerun before the one that was devised to time the next shot when it
 * was made running. In such a view @b RTAI schedulers try to shoot
 * only when strictly needed. This minimizes the number of slow setups
 * of the 8254 timer used with UP and 8254 based SMP
 * schedulers. While such a policy minimizes the number of actual
 * shots, greatly enhancing efficiency, it can be unsuitable when an
 * application has to be guarded against undesired program loops or
 * other unpredicted error causes.
 * Calling these functions with a nonzero value assures that a timed
 * high priority preempting task is always programmed to be fired
 * while another task is currently running. The default is no
 * immediate preemption in oneshot mode, i.e. firing of the next shot
 * programmed only when strictly needed to satisfy tasks timings.
 *
 * @note With UP and SMP schedulers there is always only a timing
 * source so that cpu_idinrt_preempt_always_cpuid is not used. With
 * the MUP scheduler you have an independent timer for each CPU, so
 * rt_preempt_always applies to all the CPUs while
 * rt_preempt_always_cpuid should be used when preemption is to be
 * forced only on a specific CPU. 
 */
   

=======================
rt_preempt_always_cpuid
=======================

/**
 * @anchor rt_preempt_always_cpuid
 * @brief Enable hard preemption
 *
 * In the oneshot mode the next timer expiration is programmed after a
 * timer shot by choosing among the timed tasks the one with a
 * priority higher than the task chosen to run as current, with the
 * constraint of always assuring a correct Linux timing. In such a
 * view there is no need to fire the timer immediately. In fact it can
 * happen that the current task can be so fast to get suspended and
 * rerun before the one that was devised to time the next shot when it
 * was made running. In such a view @b RTAI schedulers try to shoot
 * only when strictly needed. This minimizes the number of slow setups
 * of the 8254 timer used with UP and 8254 based SMP
 * schedulers. While such a policy minimizes the number of actual
 * shots, greatly enhancing efficiency, it can be unsuitable when an
 * application has to be guarded against undesired program loops or
 * other unpredicted error causes.
 * Calling these functions with a nonzero value assures that a timed
 * high priority preempting task is always programmed to be fired
 * while another task is currently running. The default is no
 * immediate preemption in oneshot mode, i.e. firing of the next shot
 * programmed only when strictly needed to satisfy tasks timings.
 *
 * @note With UP and SMP schedulers there is always only a timing
 * source so that cpu_idinrt_preempt_always_cpuid is not used. With
 * the MUP scheduler you have an independent timer for each CPU, so
 * rt_preempt_always applies to all the CPUs while
 * rt_preempt_always_cpuid should be used when preemption is to be
 * forced only on a specific CPU. 
 */


=============
rt_sched_lock
=============

/**
 * @anchor rt_sched_lock
 * @brief Lock the scheduling of tasks.
 *
 * rt_sched_lock, lock on the CPU on which they are called, any
 * scheduler activity, thus preventing a higher priority task to
 * preempt a lower priority one. They can be nested, provided unlocks
 * are paired to locks in reversed order. It can be used for
 * synchronization access to data among tasks. Note however that under
 * MP the lock is active only for the CPU on which it has been issued,
 * so it cannot be used to avoid races with tasks that can run on any
 * other available CPU. 
 * Interrupts are not affected by such calls. Any task that needs
 * rescheduling while a scheduler lock is in placewill be only at the
 * issuing of the last unlock 
 * 
 * @note To be used only with RTAI24.x.xx.
 *
 * See also: @ref rt_sched_unlock.
 */


===============
rt_sched_unlock
===============

/**
 * @anchor rt_sched_unlock
 * @brief Unlock the scheduling of tasks.
 *
 * rt_sched_unlock, unlock on the CPU on which they are called, any
 * scheduler activity, thus preventing a higher priority task to
 * preempt a lower priority one. They can be nested, provided unlocks
 * are paired to locks in reversed order. It can be used for
 * synchronization access to data among tasks. Note however that under
 * MP the lock is active only for the CPU on which it has been issued,
 * so it cannot be used to avoid races with tasks that can run on any
 * other available CPU. 
 * Interrupts are not affected by such calls. Any task that needs
 * rescheduling while a scheduler lock is in placewill be only at the
 * issuing of the last unlock 
 * 
 * @note To be used only with RTAI24.x.xx.
 *
 * See also: @ref rt_sched_unlock.
 */


==============
rt_change_prio
==============
/**
 * @anchor rt_change_prio
 * @brief Change a task priority.
 * 
 * rt_change_prio changes the base priority of task @e task to @e
 * prio. 
 *
 * Recall that a task has a base native priority, assigned at its
 * birth or by @ref rt_change_prio,and an actual, inherited,
 * priority. They can be different because of priority inheritance.
 *
 * @param task is the affected task.
 *
 * @param prio is the new priority, it can range within 0 < prio < 
 * RT_LOWEST_PRIORITY. 
 *
 * @return rt_change_prio returns the base priority task @e task had
 * before the change.
 *
 * @note To be used only with RTAI24.x.xx (FIXME).
 */


===========
rt_get_prio
===========
/**
 * @anchor rt_get_prio
 * @brief Check a task priority.
 * 
 * rt_get_prio returns the base priority of task @e task.
 *
 * Recall that a task has a base native priority, assigned at its
 * birth or by @ref rt_change_prio,and an actual, inherited,
 * priority. They can be different because of priority inheritance.
 *
 * @param task is the affected task.
 *
 * @return rt_get_prio returns the priority of task @e task.
 *
 * @note To be used only with RTAI24.x.xx.
 */


=================
rt_get_inher_prio
=================
/**
 * @anchor rt_get_inher_prio
 * @brief Check a task priority.
 * 
 * rt_get_prio returns the base priority task @e task has inherited
 * from other tasks, either blocked on resources owned by or waiting
 * to pass a message to task @e task.
 *
 * Recall that a task has a base native priority, assigned at its
 * birth or by @ref rt_change_prio,and an actual, inherited,
 * priority. They can be different because of priority inheritance.
 *
 * @param task is the affected task.
 *
 * @return rt_get_inher_prio returns the priority of task @e task.
 *
 * @note To be used only with RTAI24.x.xx.
 */


===================
rt_set_oneshot_mode
===================

/**
 * @anchor rt_set_oneshot_mode
 * @brief Set timer mode.
 *
 * rt_set_periodic_mode sets the periodic mode for the timer. It
 * consists of a fixed frequency timing of the tasks in multiple of
 * the period set with a call to @ref start_rt_timer. The resolution
 * is that of the 8254 (1193180 Hz) on a UP machine, or if the 8254
 * based SMP scheduler is being used. For the SMP scheduler timed by
 * the local APIC timer and for the MUP scheduler the timer resolution
 * is that of the local APIC timer frequency, generally the bus
 * frequency divided 16. Any timing request not being an integer
 * multiple of the set timer period is satisfied at the closest period
 * tick. It is the default mode when no call is made to set the
 * oneshot mode. 
 *
 * @note Stopping the timer by @ref stop_rt_timer sets the timer back
 * into its default (periodic) mode. Always call @ref
 * rt_set_oneshot_mode before each @ref start_rt_timer if you want to
 * be sure to have it oneshot on multiple insmod without rmmoding the
 * RTAI scheduler in use. 
 */


====================
rt_set_periodic_mode
====================

/**
 * @anchor rt_set_periodic_mode
 * @brief Set timer mode.
 *
 * rt_set_periodic_mode sets the periodic mode for the timer. It
 * consists of a fixed frequency timing of the tasks in multiple of
 * the period set with a call to @ref start_rt_timer. The resolution
 * is that of the 8254 (1193180 Hz) on a UP machine, or if the 8254
 * based SMP scheduler is being used. For the SMP scheduler timed by
 * the local APIC timer and for the MUP scheduler the timer resolution
 * is that of the local APIC timer frequency, generally the bus
 * frequency divided 16. Any timing request not being an integer
 * multiple of the set timer period is satisfied at the closest period
 * tick. It is the default mode when no call is made to set the
 * oneshot mode. 
 *
 * @note Stopping the timer by @ref stop_rt_timer sets the timer back
 * into its default (periodic) mode. Always call @ref
 * rt_set_oneshot_mode before each @ref start_rt_timer if you want to
 * be sure to have it oneshot on multiple insmod without rmmoding the
 * RTAI scheduler in use. 
 */


==============
start_rt_timer
==============

/**
 * @anchor start_rt_timer
 * @brief Start timer.
 *
 * start_rt_timer starts the timer with a period @e period. The
 * period is in internal count units and is required only for the
 * periodic mode. In the oneshot mode the period value is ignored.
 * This functions uses the 8254 with the UP and the 8254 based SMP
 * scheduler. 
 * Otherwise it uses a single local APIC with the APIC based SMP
 * schedulers and an APIC for each CPU with the MUP scheduler. In the
 * latter case all local APIC timers are paced in the same way,
 * according to the timer mode set.
 *
 * @return The period in internal count units.
 */



=============
stop_rt_timer
=============

/**
 * @anchor stop_rt_timer
 * @brief Stop timer.
 *
 * stop_rt_timer stops the timer. The timer mode is set to periodic.
 *
 * @return The period in internal count units.
 */


===================
start_rt_apic_timer
===================

/**
 * @anchor start_rt_apic_timer
 * @brief Start local apic timer.
 * 
 * start_rt_apic_timers starts local APIC timers according to what is
 * found in @e setup_data.
 *
 * @param setup_data is a pointer to an array of structures
 *  	  apic_timer_setup_data, see function @ref
 *  	  rt_setup_apic_timers in RTAI module functions described
 *  	  further on in this manual.
 * @param rcvr_jiffies_cpuid is the CPU number whose time log has to
 *  	  be used to keep Linux timing and pacing in tune.
 *	  This function is specific to the MUP scheduler. If it is
 *	  called with either the UP or SMP scheduler it will use:
 *	  - a periodic timer if all local APIC timers are periodic
 *	    with the same period;
 *	  - a oneshot timer if all the local APIC timers are oneshot, 
 *	    or have different timing modes, are periodic with
 *	    different periods. 
 */


==================
stop_rt_apic_timer
==================
/**
 * @anchor stop_rt_apic_timer
 * @brief Stop local apic timer.
 * 
 * This function stops all of the local APIC timers.
 *
 */  


==========
count2nano
==========
/**
 * @anchor count2nano
 * @brief Convert internal count units to nanoseconds.
 *
 * This function converts the time of timercounts internal count units
 * into nanoseconds.
 * Remember that the count units are related to the time base being 
 * used (see functions @ref rt_set_oneshot_mode and @ref
 * rt_set_periodic_mode for an explanation).
 *
 * @param timercounts internal count units.
 *
 * @return The given time in nanoseconds is returned.
 */


================
count2nano_cpuid
================
/**
 * @anchor count2nano_cpuid
 * @brief Convert internal count units to nanoseconds.
 *
 * This function converts the time of timercounts internal count units
 * into nanoseconds.
 * It is to be used with the MUP scheduler since with such a scheduler
 * it is possible to have independent timers, i.e. periodic of
 * different periods or a mixing of periodic and oneshot, so that it
 * is impossible to establish which conversion units should be used in
 * the case one asks for a conversion from any CPU for any other
 * CPU. All these functions have the same behavior with UP and SMP
 * schedulers.
 *
 * @param timercounts internal count units. 
 *
 * @param cpuid Identifier of the CPU (FIXME).
 *
 * @return The given time in nanoseconds is returned.
 */


==========
nano2count
==========
/**
 * @anchor nano2count
 * @brief Convert nanoseconds to internal count units.
 *
 * This function converts the time of nanosecs @e nanoseconds into
 * internal counts units.
 * Remember that the count units are related to the time base being
 * used (see functions @ref rt_set_oneshot_mode and @ref
 * rt_set_periodic_mode for an explanation).
 *
 * The versions ending with_cpuid are to be used with the MUP
 * scheduler since with such a scheduler it is possible to have
 * independent timers, i.e. periodic of different periods or a mixing
 * of periodic and oneshot, so that it is impossible to establish
 * which conversion units should be used in the case one asks for a
 * conversion from any CPU for any other CPU. All these functions have
 * the same behavior with UP and SMP schedulers. 
 *
 * @param nanosecs Number of nanoseconds.
 *
 * @return The given time in nanoseconds is returned.
 */


================
nano2count_cpuid
================
/**
 * @anchor nano2count_cpuid
 * @brief Convert nanoseconds to internal count units.
 *
 * This function converts the time of nanosecs @e nanoseconds into
 * internal counts units.
 * Remember that the count units are related to the time base being
 * used (see functions @ref rt_set_oneshot_mode and @ref
 * rt_set_periodic_mode for an explanation).
 *
 * This function is to be used with the MUP scheduler since with such
 * a scheduler it is possible to have independent timers,
 * i.e. periodic of different periods or a mixing  of periodic and
 * oneshot, so that it is impossible to establish which conversion
 * units should be used in the case one asks for a conversion from
 * any CPU for any other CPU. All these functions have the same
 * behavior with UP and SMP schedulers.
 *
 * @param nanosecs Number of nanoseconds.
 *
 * @param cpuid Identifier of the CPU (FIXME).
 *
 * @return The given time in nanoseconds is returned.
 */


===========
rt_get_time
===========
/**
 * @anchor rt_get_time
 * @brief Get the current time.
 *
 * rt_get_time returns the time, in internal count units, since
 * start_rt_timer was called. In periodic mode this number is in
 * multiples of the periodic tick. In oneshot mode it is directly the
 * TSC count for CPUs having a time stamp clock (TSC), while it is a
 * (FIXME) on 8254 units for those not having it (see functions @ref
 * rt_set_oneshot_mode and @ref rt_set_periodic_mode for an
 * explanation). 
 *
 * rt_get_time_ns is the same as rt_get_time but the returned time is
 * converted to nanoseconds.
 *
 * rt_get_cpu_time_ns always returns the CPU time in nanoseconds
 * whatever timer is in use.
 *
 * The version ending with _cpuid must be used with the MUP scheduler
 * when there is the need to declare from which cpuidthe time must be
 * got. In fact one can need to get the time of another CPU and timers
 * can differ from CPU to CPU. 
 * All these functions have the same behavior with UP and SMP
 * schedulers. 
 *
 * @return The current time in internal count units is returned.
 */



=================
rt_get_time_cpuid
=================
/**
 * @anchor rt_get_time
 * @brief Get the current time.
 *
 * rt_get_time returns the time, in internal count units, since
 * start_rt_timer was called. In periodic mode this number is in
 * multiples of the periodic tick. In oneshot mode it is directly the
 * TSC count for CPUs having a time stamp clock (TSC), while it is a
 * (FIXME) on 8254 units for those not having it (see functions @ref
 * rt_set_oneshot_mode and @ref rt_set_periodic_mode for an
 * explanation). 
 * This version ending with _cpuid must be used with the MUP
 * scheduler when there is the need to declare from which cpuid the 
 * time must be gotten (FIXME). In fact one can need to get the time
 * of another CPU and timers can differ from CPU to CPU. (FIXME)
 * All these functions have the same behavior with UP and SMP
 * schedulers.
 *
 * @param cpuid corresponds to the CPUI identifier.
 *
 * @return The current time in internal count units is returned.
 */


==============
rt_get_time_ns
==============
/**
 * @anchor rt_get_time_ns
 * @brief Get the current time.
 *
 * rt_get_time_ns is the same as @ref rt_get_time but the returned
 * time is converted to nanoseconds. 
 *
 * @return The current time in internal count units is returned.
 */


==================
rt_get_cpu_time_ns
==================
/**
 * @anchor rt_get_cpu_time_ns
 * @brief Get the current time.
 *
 * rt_get_cpu_time_ns always returns the CPU time in nanoseconds
 * whatever timer is in use.
 *
 * @return The current time in internal count units is returned.
 */



====================
rt_get_time_ns_cpuid
====================
/**
 * @anchor rt_get_time_ns_cpuid
 * @brief Get the current time.
 *
 * rt_get_time_ns is the same as rt_get_time but the returned time is
 * converted to nanoseconds.
 * The version ending with _cpuid must be used with the MUP scheduler
 * when there is the need to declare from which cpuidthe time must be
 * got. In fact one can need to get the time of another CPU and timers
 * can differ from CPU to CPU. 
 * All these functions have the same behavior with UP and SMP
 * schedulers. 
 *
 * @param cpuid corresponds to the CPUI identifier.
 *
 * @return The current time in internal count units is returned.
 */


===========
next_period
===========

/**
 * @anchor next_period
 * @brief Get the time a periodic task will be resumed after calling
 *  rt_task_wait_period.
 *
 * this function returns the time when the caller task will run
 * next. Combined with the appropriate @ref rt_get_time function it
 * can be used for checking the fraction of period used or any period
 * overrun.
 *
 * @return Next period time in internal count units.
 */



=============
rt_busy_sleep
=============

/**
 * @anchor rt_busy_sleep
 * @brief Delay/suspend execution for a while.
 *
 * rt_busy_sleep delays the execution of the caller task without
 * giving back the control to the scheduler. This function burns away
 * CPU cycles in a busy wait loop so it should be used only for very
 * short synchronization delays. On machine not having a TSC clock it
 * can lead to many microseconds uncertain busy sleeps because of the
 * need of reading the 8254 timer.
 *
 * @param nanosecs is the number of nanoseconds to wait.
 * 
 * See also: @ref rt_sleep, @ref rt_sleep_until.
 *
 * @note A higher priority task or interrupt handler can run before
 *	 the task goes to sleep, so the actual time spent in these
 *	 functions may be longer than that specified.
 */



========
rt_sleep
========

/**
 * @anchor rt_sleep
 * @brief Delay/suspend execution for a while.
 *
 * rt_sleep suspends execution of the caller task for a time of delay
 * internal count units. During this time the CPU is used by other
 * tasks.
 * 
 * @param Corresponds to the time the task is going to be suspended.
 *
 * See also: @ref rt_busy_sleep, @ref rt_sleep_until.
 *
 * @note A higher priority task or interrupt handler can run before
 *	 the task goes to sleep, so the actual time spent in these
 *	 functions may be longer than the the one specified.
 */


==============
rt_sleep_until
==============

/**
 * @anchor rt_sleep_until
 * @brief Delay/suspend execution for a while.
 *
 * rt_sleep_until is similar to @ref rt_sleep but the parameter time
 * is the absolute time till the task have to be suspended. If the
 * given time is already passed this call has no effect.
 * 
 * @param Absolute time till the task have to be suspended
 *
 * See also: @ref rt_busy_sleep, @ref rt_sleep_until.
 *
 * @note A higher priority task or interrupt handler can run before
 *	 the task goes to sleep, so the actual time spent in these
 *	 functions may be longer than the the one specified.
 */


=================
rt_typed_sem_init
=================

/**
 * @anchor rt_typed_sem_init
 * @brief Initialize a specifically typed (counting, binary, resource)
 *	  semaphore
 *
 * rt_typed_sem_init initializes a semaphore @e sem of type @e type. A
 * semaphore can be used for communication and synchronization among
 * real time tasks. Negative value of a semaphore shows how many tasks
 * are blocked on the semaphore queue, waiting to be awaken by calls
 * to rt_sem_signal.
 *
 * @param sem must point to an allocated SEM structure.
 *
 * @param value is the initial value of the semaphore, always set to 1
 *	  for a resource semaphore.
 *
 * @param type is the semaphore type and can be: CNT_SEM for counting
 *	  semaphores, BIN_SEM for binary semaphores, RES_SEM for
 *	  resource semaphores.
 * 
 * Counting semaphores can register up to 0xFFFE events. Binary
 * semaphores do not count signalled events, their count will never
 * exceed 1 whatever number of events is signaled to them. Resource
 * semaphores are special binary semaphores suitable for managing
 * resources. The task that acquires a resource semaphore becomes its
 * owner, also called resource owner, since it is the only one capable
 * of manipulating the resource the semaphore is protecting. The owner
 * has its priority increased to that of any task blocking on a wait
 * to the semaphore. Such a feature, called priority inheritance,
 * ensures that a high priority task is never slaved to a lower
 * priority one, thus allowing to avoid any deadlock due to priority
 * inversion. Resource semaphores can be recursed, i.e. their task
 * owner is not blocked by nested waits placed on an owned
 * resource. The owner must insure that it will signal the semaphore,
 * in reversed order, as many times as he waited on it. Note that that
 * full priority inheritance is supported both for resource semaphores
 * and inter task messages, for a singly owned resource. Instead it
 * becomes an adaptive priority ceiling when a task owns multiple
 * resources, including messages sent to him. In such a case in fact
 * its priority is returned to its base one only when all such
 * resources are released and no message is waiting for being
 * received. This is a compromise design choice aimed at avoiding
 * extensive searches for the new priority to be inherited across
 * multiply owned resources and blocked tasks sending messages to
 * him. Such a solution will be implemented only if it proves
 * necessary. Note also that, to avoid @e deadlocks, a task owning a
 * resource semaphore cannot be suspended. Any @ref rt_task_suspend
 * posed on it is just registered. An owner task will go into suspend
 * state only when it releases all the owned resources.
 *
 * @note RTAI counting semaphores assume that their counter will never
 *	 exceed 0xFFFF, such a number being used to signal returns in
 *	 error. Thus also the initial count value cannot be greater
 *	 than 0xFFFF. To be used only with RTAI24.x.xx (FIXME).
 */



===========
rt_sem_init
===========

/**
 * @anchor rt_sem_init
 * @brief Initialize a counting semaphore.
 *
 * rt_sem_init initializes a semaphore @e sem.
 *
 * A semaphore can be used for communication and synchronization among
 * real time tasks.
 *
 * @param sem must point to an allocated @e SEM structure.
 *
 * @param value is the initial value of the semaphore.
 * 
 * Positive values of the semaphore variable show how many tasks can
 * do a @ref rt_sem_wait call without blocking. Negative value of a
 * semaphore shows how many tasks are blocked on the semaphore queue,
 * waiting to be awaken by calls to @ref rt_sem_signal.
 *
 * @note RTAI counting semaphores assume that their counter will never
 *	 exceed 0xFFFF, such a number being used to signal returns in
 *	 error. Thus also the initial count value cannot be greater
 *	 than 0xFFFF.
 *	 RTAI 24.1.xx has also @ref rt_typed_sem_init, allowing to
 *	 choose among counting, binary and resource
 *	 semaphores. Resource semaphores have priority inherithance. 
 */


=============
rt_sem_delete
=============

/**
 * @anchor rt_sem_delete
 * @brief Delete a semaphore
 *
 * rt_sem_delete deletes a semaphore previously created with 
 * @ref rt_sem_init. 
 *
 * @param sem points to the structure used in the corresponding
 * call to rt_sem_init. 
 *
 * Any tasks blocked on this semaphore is returned in error and
 * allowed to run when semaphore is destroyed. 
 *
 * @retval 0 on success.
 * A negative is returned on failure as described below:
 * - @b 0xFFFF: @e sem does not refer to a valid semaphore.
 *
 * @note In principle 0xFFFF could theoretically be a usable
 *	 semaphores events count, so it could be returned also under
 *	 normal circumstances. It is unlikely you are going to count
 *	 up to such number of events, in any case avoid counting up 
 *	 to 0xFFFF. 
 */


=============
rt_sem_signal
=============

/**
 * @anchor rt_sem_signal
 * @brief Signaling a semaphore.
 *
 * rt_sem_signal signal an event to a semaphore. It is typically
 * called when the task leaves a critical region. The semaphore value
 * is incremented and tested. If the value is not positive, the first
 * task in semaphore's waiting queue is allowed to run.  rt_sem_signal
 * never blocks the caller task. @e sem points to the structure used
 * in the call to @ref rt_sem_create.
 *
 * @retval 0 on success.
 * @retval a negative value on failure as described below:
 * - @b 0xFFFF: @e sem does not refer to a valid semaphore.
 *
 * @note In principle 0xFFFF could theoretically be a usable
 *	 semaphores events count, so it could be returned also under
 *	 normal circumstances. It is unlikely you are going to count
 *	 up to such number of events, in any case avoid counting up to
 * 	 0xFFFF.
 *	 See @ref rt_sem_wait notes for some curiosities.
 */



===========
rt_sem_wait
===========

/**
 * @anchor rt_sem_wait
 * @brief Take a semaphore.
 *

 * rt_sem_wait waits for a event to be signaled to a semaphore. It is
 * typically called when a task enters a critical region. The
 * semaphore value is decremented and tested. If it is still
 * non-negative rt_sem_wait returns immediately. Otherwise the caller
 * task is blocked and queued up. Queuing may happen in priority order
 * or on FIFO base. This is determined by the compile time option @e
 * SEM_PRIORD. In this case rt_sem_wait returns if:
 *	       - The caller task is in the first place of the waiting
 *		 queue and another task issues a @ref rt_sem_signal
 *		 call;
 *	       - An error occurs (e.g. the semaphore is destroyed);
 *
 * @param sem points to the structure used in the call to @ref
 *	  rt_sem_create.
 *
 * @retval on success, the number of events already signaled.
 * @retval on failure, the special value 0xFFFF as described below:
 * - @b 0xFFFF: @e sem does not refer to a valid semaphore.
 *
 * @note In principle 0xFFFF could theoretically be a usable
 *	 semaphores events count, so it could be returned also under
 *	 normal circumstances. It is unlikely you are going to count
 *	 up to such number of events, in any case avoid counting up to
 *	 0xFFFF.
 *
 *	 Just for curiosity: the original Dijkstra notation for
 *	 rt_sem_wait was a "P" operation, and rt_sem_signal was a "V"
 *	 operation. The name for P comes from the Dutch "prolagen", a
 *	 combination of "proberen" (to probe) and "verlagen" (to
 *	 decrement). Also from the word "passeren" (to pass).
 *
 *	 The name for V comes from the Dutch "verhogen" (to increase)
 *	 or "vrygeven" (to release).  (Source: Daniel Tabak -
 *	 Multiprocessors, Prentice Hall, 1990).
 *
 *	 It should be also remarked that real time programming
 *	 practitioners were using semaphores a long time before
 *	 Dijkstra formalized P and V. "In Italian semaforo" means a
 *	 traffic light, so that semaphores have an intuitive appeal
 * 	 and their use and meaning is easily understood.
 */


==============
rt_sem_wait_if
==============

/**
 * @anchor rt_sem_wait_if
 * @brief Take a semaphore, only if the calling task is not blocked.
 *
 * rt_sem_wait_if is a version of the semaphore wait operation is
 * similar to @ref rt_sem_wait but it is never blocks the caller. If
 * the semaphore is not free, rt_sem_wait_if returns immediately and
 * the semaphore value remains unchanged.
 *
 * @retval on success, the number of events already signaled.
 * @retval on failure, the special value 0xFFFF as described below:
 * - @b 0xFFFF: @e sem does not refer to a valid semaphore.
 *
 * @note In principle 0xFFFF could theoretically be a usable
 *	 semaphores events count so it could be returned also under
 *	 normal circumstances. It is unlikely you are going to count
 *	 up to such number  of events, in any case avoid counting up
 *	 to 0xFFFF.
 */


=================
rt_sem_wait_until
=================

/**
 * @anchor rt_sem_wait_until
 * @brief Wait a semaphore with timeout.
 *
 * rt_sem_wait_until (like @ref rt_sem_wait_timed) is a timed version
 * of the standard semaphore wait call. The semaphore value is
 * decremented and tested. If it is still non-negative these functions
 * return immediately. Otherwise the caller task is blocked and queued
 * up. Queuing may happen in priority order or on FIFO base. This is
 * determined by the compile time option @e SEM_PRIORD. In this case
 * the function returns if:
 *	- The caller task is in the first place of the waiting queue
 *	  and an other task issues a @ref rt_sem_signal call;
 *	- a timeout occurs;
 *	- an error occurs (e.g. the semaphore is destroyed);
 *
 * In case of a timeout, the semaphore value is incremented before 
 * return.  
 *
 * @param time is an absolute value to the current time.
 *
 * @retval on success, the number of events already signaled.
 * @retval on failure, the special value 0xFFFF as described below:
 * - @b 0xFFFF: @e sem does not refer to a valid semaphore.
 * 
 * @note In principle 0xFFFF could theoretically be a usable
 *	 semaphores events count so it could be returned also under
 *	 normal circumstances. It is unlikely you are going to count
 *	 up to such number of events, in any case avoid counting up to
 *	 0xFFFF.
 */



=================
rt_sem_wait_timed
=================

/**
 * @anchor rt_sem_wait_timed
 * @brief Wait a semaphore with timeout.
 *
 * rt_sem_wait_timed (like @ref rt_sem_wait_until) is a timed version
 * of the standard semaphore wait call. The semaphore value is
 * decremented and tested. If it is still non-negative these functions
 * return immediately. Otherwise the caller task is blocked and queued
 * up. Queuing may happen in priority order or on FIFO base. This is
 * determined by the compile time option @e SEM_PRIORD. In this case
 * the function returns if:
 *	- The caller task is in the first place of the waiting queue
 *	  and an other task issues a @ref rt_sem_signal call;
 *	- a timeout occurs;
 *	- an error occurs (e.g. the semaphore is destroyed);
 *
 * In case of a timeout, the semaphore value is incremented before 
 * return.  
 *
 * @param time is an absolute value to the current time.
 *
 * @retval on success, the number of events already signaled.
 * @retval on failure, the special value 0xFFFF as described below:
 * - @b 0xFFFF: @e sem does not refer to a valid semaphore.
 * 
 * @note In principle 0xFFFF could theoretically be a usable
 *	 semaphores events count so it could be returned also under
 *	 normal circumstances. It is unlikely you are going to count
 *	 up to such number of events, in any case avoid counting up to
 *	 0xFFFF.
 */




=======
rt_send
=======

/**
 * @anchor rt_send
 * @brief Send a message.
 *
 * rt_send sends the message @e msg to the task @e task. If the
 * receiver task is ready to get the message rt_send does not block
 * the sending task, but its execution can be preempted if the
 * receiving task has a higher priority. Otherwise the caller task is
 * blocked and queued up (queuing may happen in priority order or on
 * FIFO base. This is determined by the compile time option
 * MSG_PRIORD.)
 *
 * @retval on success, @e task,the pointer to the task that received
 * the message, is returned.
 *
 * @retval if the caller is unblocked but the message has not been
 * sent, e.g. the task @e task was killed before receiving the
 * message, 0 is returned.
 *
 * @retval On other failure, a special value 0xFFFF is returned as
 * described below:
 * - @b 0xFFFF: @e task does not refer to a valid task.
 * 
 * @note Since all the messaging functions return a task address
 * 0xFFFF could seem an inappropriate return value. However on all the
 * CPUs RTAI runs on 0xFFFF is not an address that can be used by any
 * RTAI task, so it is should be always safe.
 */


==========
rt_send_if
==========

/**
 * @anchor rt_send_if
 * @brief Send a message, only if the calling task is not blocked.
 *
 * rt_send_if sends the message @e msg to the task @e task if the
 * latter is ready to receive, so that the caller task is never
 * blocked, but its execution can be preempted if the messaged task is
 * ready to receive and has a higher priority.
 *
 * @retval on success, @e task (the pointer to the task that received
 * the message) is returned.
 *
 * @retval if the message has not been sent, 0 is returned.
 *
 * @retval On other failure, a special value is returned. The errors
 * are described below: 
 * - @b 0: the task @e task was not ready to receive the message.
 * - @b 0xFFFF: @e task does not refer to a valid task.
 *
 * @note Since all the messaging functions return a task address,
 * 0xFFFF could seem an inappropriate return value. However on all the
 * CPUs RTAI runs on 0xFFFF is not an address that can be used by any
 * RTAI task, so it is should be always safe. (FIXME)
 */



=============
rt_send_until
=============

/**
 * @anchor rt_send_until
 * brief Send a message with timeout.
 *
 * rt_send_until sends the message @e msg to the task @e task. If the
 * receiver task is ready to get the message, this function does not
 * block the sending task, but its execution can be preempted if the
 * receiving task has a higher priority. Otherwise the caller task is
 * blocked and queued up (queuing may happen in priority order or on
 * FIFO base. This is determined by the compile time option
 * MSG_PRIORD). In this case the function returns if:
 * - the caller task is in the first place of the waiting queue and
 *   the receiver gets the message and has a lower priority;
 * - a timeout occurs;
 * - an error occurs (e.g. the receiver task is killed).
 *
 * @param time is an absolute value.
 *
 * @param delay is relative to the current time.
 *
 * @retval on success, i.e. message received before timeout expiration,
 * @e task (the pointer to the task that received the message) is
 * returned. 
 *
 * @retval if the message has not been sent, 0 is returned.
 *
 * @retval on other failure, a special value is returned. The errors
 * are described below:  
 * - @b 0: operation timed out, message was not delivered; 
 * - @b 0xFFFF: @e task does not refer to a valid task.
 *
 * See also: @ref rt_send_timed.
 *
 * @note Since all the messaging functions return a task address
 * 0xFFFF could seem an inappropriate return value.  However on all
 * the CPUs RTAI runs on 0xFFFF is not an address that can be used by
 * any RTAI task, so it is should be always safe.
 */



=============
rt_send_timed
=============
/**
 * @anchor rt_send_timed
 * brief Send a message with timeout.
 *
 * rt_send_timed sends the message @e msg to the task @e task. If the 
 * receiver task is ready to get the message, this function does not
 * block the sending task, but its execution can be preempted if the
 * receiving task has a higher priority. Otherwise the caller task is
 * blocked and queued up (queuing may happen in priority order or on
 * FIFO base. This is determined by the compile time option
 * MSG_PRIORD). In this case the function returns if:
 * - the caller task is in the first place of the waiting queue and
 *   the receiver gets the message and has a lower priority;
 * - a timeout occurs;
 * - an error occurs (e.g. the receiver task is killed).
 *
 * @param time is an absolute value.
 *
 * @param delay is relative to the current time.
 *
 * @retval on success, i.e. message received before timeout expiration,
 * @e task (the pointer to the task that received the message) is
 * returned. 
 *
 * @retval if the message has not been sent, 0 is returned.
 *
 * @retval on other failure, a special value is returned. The errors
 * are described below:  
 * - @b 0: operation timed out, message was not delivered;
 * - @b 0xFFFF: @e task does not refer to a valid task.
 *
 * See also: @ref rt_send_until.
 *
 * @note Since all the messaging functions return a task address
 * 0xFFFF could seem an inappropriate return value.  However on all
 * the CPUs RTAI runs on 0xFFFF is not an address that can be used by
 * any RTAI task, so it is should be always safe. (FIXME)
 */




==========
rt_receive
==========

/**
 * @anchor rt_receive
 * @brief Receive a message.
 *
 * rt_receive gets a message from the task specified by task.  If task
 * is equal to 0, the caller accepts messages from any task. If there
 * is a pending message, rt_receive does not block but can be
 * preempted if the task that sent the just received message has a
 * higher priority. Otherwise the caller task is blocked and queued up
 * (queuing may happen in priority order or on FIFO base.  This is
 * determined by the compile time option MSG_PRIORD.)
 *
 * @param task is a pointer to a @e RT_TASK structure.
 * 
 * @param msg points to any 4 bytes word buffer provided by the
 * caller. 
 *
 * @retval on success, a pointer to the sender task is returned.
 * If the caller is unblocked but no message has been received
 * (e.g. the task @e task was killed before sending the message) @e 0
 * is returned. 
 *
 * @retval on other failure, a special value is returned. The errors
 * are described below:  
 * - @b 0: the sender task was killed before sending the message;
 * - @b 0xFFFF: @e task does not refer to a valid task.
 * 
 * @note Since all the messaging functions return a task address
 * 0xFFFF could seem an inappropriate return value.  However on all
 * the CPUs RTAI runs on 0xFFFF is not an address that can be used by
 * any RTAI task, so it is should be always safe.
 */


=============
rt_receive_if
=============

/**
 * @anchor rt_receive_if
 * @brief Receive a message, only if the calling task is not blocked.
 * 
 * rt_receive_if tries to get a message from the task specified by
 * task. If task is equal to 0, the caller accepts messages from any
 * task. The caller task is never blocked but can be preempted if the
 * receiving task is ready to receive and has a higher priority.
 *
 * @param task is a pointer to the task structure.
 *
 * @param msg points to a buffer provided by the caller.
 *
 * @retval on success, a pointer to the sender task is returned.
 *
 * @retval on other failure, a special value is returned. The errors
 * are described below:  
 * - @b 0: there was no message to receive.
 * - @b 0xFFFF: @e task does not refer to a valid task.
 *
 * Since all the messaging functions return a task address 0xFFFF
 * could seem an inappropriate return value. However on all the CPUs
 * RTAI runs on 0xFFFF is not an address that can be used by any RTAI
 * task, so it is should be always safe.
 */


================
rt_receive_until
================

/**
 * @anchor rt_receive_until
 * @brief Receive a message with timeout.
 *
 * rt_receive_until receives a message from the task specified by
 * task. If task is equal to 0, the caller accepts messages from any
 * task. If there is a pending message, rt_receive does not block but
 * can be preempted if the task that sent the just received message
 * has a higher priority.
 * Otherwise the caller task is blocked and queued up (queuing may
 * happen in priority order or on FIFO base. This is determined by the
 * compile time option MSG_PRIORD.) In this case these functions
 * return if:
 * - the caller task is in the first place of the waiting queue and
 *   the sender sends a message and has a lower priority;
 * - timeout occurs;
 * - an error occurs (e.g. the sender task is killed.)
 *
 * @param task is a pointer to the task structure.
 *
 * @param msg points to a buffer provided by the caller.
 *
 * @param time is an absolute value, delay is relative to the current
 * time.
 *
 * @retval on success, a pointer to the sender task is returned.
 *
 * @retval on other failure, a special value is returned. The errors
 * are described below:  
 * - @b 0: there was no message to receive.
 * - @b 0xFFFF: @e task does not refer to a valid task.
 *
 * @note Since all the messaging functions return a task address
 * 0xFFFF could seem an inappropriate return value. However on all
 * the CPUs RTAI runs on 0xFFFF is not an address that can be used by
 * any RTAI task, so it is should be always safe.
 *
 * See also: @ref rt_receive_timed
 */


================
rt_receive_timed
================
/**
 * @anchor rt_receive_timed
 * @brief Receive a message with timeout.
 *
 * rt_receive_timed receives a message from the task specified by
 * task. If task is equal to 0, the caller accepts messages from any
 * task. If there is a pending message, rt_receive does not block but
 * can be preempted if the task that sent the just received message
 * has a higher priority.
 * Otherwise the caller task is blocked and queued up (queuing may
 * happen in priority order or on FIFO base. This is determined by the
 * compile time option MSG_PRIORD.) In this case these functions
 * return if:
 * - the caller task is in the first place of the waiting queue and
 *   the sender sends a message and has a lower priority;
 * - timeout occurs;
 * - an error occurs (e.g. the sender task is killed.)
 *
 * @param task is a pointer to the task structure.
 *
 * @param msg points to a buffer provided by the caller.
 *
 * @param time is an absolute value, delay is relative to the current
 * time.
 *
 * @retval on success, a pointer to the sender task is returned.
 *
 * @retval on other failure, a special value is returned. The errors
 * are described below:  
 * - @b 0: there was no message to receive.
 * - @b 0xFFFF: @e task does not refer to a valid task.
 *
 * @note Since all the messaging functions return a task address
 * 0xFFFF could seem an inappropriate return value. However on all
 * the CPUs RTAI runs on 0xFFFF is not an address that can be used by
 * any RTAI task, so it is should be always safe.
 *
 * See also: @ref rt_receive_until
 */


======
rt_rpc
======

/**
 * @anchor rt_rpc
 * @brief Make a remote procedure call
 *
 * rt_rpc makes a Remote Procedure Call (RPC). rt_rpc is used for
 * synchronous inter task messaging as it sends the message @e msg to the
 * task @e task then it always block waiting until a return is
 * received from the called task. So the caller task is always blocked
 * and queued up (queuing may happen in priority order or on FIFO
 * base. This is determined by the compile time option
 * MSG_PRIORD). The receiver task may get the message with any
 * rt_receive function. It can send an answer with @ref rt_return.
 *
 * @param task pointer to a RT_TASK structure.
 *
 * @param msg message to send.
 *
 * @param reply points to a buffer provided by the caller were the
 * returned result message, any 4 bytes integer, is to be place.
 *
 * @return On success, task (the pointer to the task that received the
 * message) is returned. If the message has not been sent (e.g. the
 * task @e task was killed before receiving the message) 0 is returned.
 * On other failure, a special value is returned as described below:
 * - @b 0: the receiver task was killed before receiving the message.
 * - @b 0xFFFF: @e task does not refer to a valid task.
 *
 * See also: @ref rt_receive_*, @ref rt_return, @ref rt_isrpc.
 *
 * @note Since all the messaging functions return a task address,
 *       0xFFFF could seem an inappropriate return value. However on
 *       all the CPUs RTAI runs on, 0xFFFF is not an address that can
 *       be used by any RTAI task, so it is should be always safe.<br>
 *	 The trio @ref rt_rpc, @ref rt_receive, @ref rt_return
 * 	 implement functions similar to its peers send-receive-replay
 * 	 found in QNX, except that in RTAI only four bytes messages
 * 	 contained in any integer can be exchanged. That's so because
 * 	 we never needed anything different. Note also that we prefer
 * 	 the idea of calling a function by using a message and then
 * 	 wait for a return value since it is believed to give a better
 *  	 idea of what is meant for synchronous message passing. For
 * 	 a truly QNX like way of inter task messaging use the support
 * 	 module found in directory lxrt-informed.
 */

=========
rt_rpc_if
=========

/**
 * @anchor rt_rpc_if
 * @brief Make a remote procedure call, only if the calling task is
 *  not blocked.
 *
 * rt_rpc_if tries to make a Remote Procedure Call (RPC). If the
 * receiver task is ready to accept a message rt_rpc_if sends the
 * message @e msg then it always block until a return is received. In
 * this case the caller task is blocked and queued up (queuing may
 * happen in priority order or on FIFO base. This is determined by the
 * compile time option MSG_PRIORD). If the receiver is not ready
 * rt_rpc_if returns immediately. The receiver task may get the
 * message with any rt_receive function. It can send the answer with
 * @ref rt_return.
 *
 * @param task pointer to a RT_TASK structure.
 *
 * @param msg message to send.
 *
 * @param reply points to a buffer provided by the caller.
 *
 * @return On success, task (the pointer to the task that received the
 * message) is returned. If message has not been sent, 0 is
 * returned. On other failure, a special value is returned as
 * described below:
 * - @b 0: The task @e task was not ready to receive the message or
 *   	   it was killed before sending the reply.
 * - @b 0xFFFF: @e task does not refer to a valid task.
 *
 * See also: notes under @ref rt_rpc.
 *
 * @note Since all the messaging functions return a task address,
 * 	 0xFFFF could seem an inappropriate return value. However on
 * 	 all the CPUs RTAI runs on, 0xFFFF is not an address that can
 *  	 be used by any RTAI task, so it is should be always safe.
 */
 

============
rt_rpc_until
============

/** 
 * @anchor rt_rpc_until
 * @brief Make a remote procedure call with timeout.
 *
 * rt_rpc_until makes a Remote Procedure Call. It sends the message @e
 * msg to the task @ref task then always waits until a return is
 * received or a timeout occurs. So the caller task is always blocked
 * and queued up (queuing may happen in priority order or on FIFO
 * base. This is determined by the compile time option
 * MSG_PRIORD). The receiver task may get the message with any @ref
 * rt_receive function. It can send the answer with @ref rt_return.
 *
 * @param task pointer to a RT_TASK structure.
 *
 * @param msg message to send.
 *
 * @param reply points to a buffer provided by the caller.
 *
 * @param time is an absolute value.
 *
 * @return On success, task (the pointer to the task that received the
 * message) is returned. If message has not been sent or no answer
 * arrived, 0 is returned.
 * On other failure, a special value is returned as described below:
 * - @b 0: The message could not be sent or the answer did not arrived
 *    	   in time.  
 * - @b 0xFFFF: @e task does not refer to a valid task.
 *
 * See also: @ref rt_receive, @ref rt_return, @ref rt_isrpc.
 *
 * @ref Since all the messaging functions return a task address, 0xFFFF
 * could seem an inappropriate return value. However on all the CPUs
 * RTAI runs on, 0xFFFF is not an address that can be used by any RTAI
 * task, so it is should be always safe.<br>
 * See also the notes under @ref rt_rpc.
 */


============
rt_rpc_timed
============

/** 
 * @anchor rt_rpc_timed
 * @brief Make a remote procedure call with timeout.
 *
 * rt_rpc_timed makes a Remote Procedure Call. It sends the message @e
 * msg to the task @e task then always waits until a return is
 * received or a timeout occurs. So the caller task is always blocked
 * and queued up (queuing may happen in priority order or on FIFO
 * base. This is determined by the compile time option
 * MSG_PRIORD). The receiver task may get the message with any @ref
 * rt_receive function. It can send the answer with @ref rt_return.
 *
 * @param task pointer to a RT_TASK structure.
 *
 * @param msg message to send.
 *
 * @param reply points to a buffer provided by the caller.
 *
 * @param delay is relative to the current time.
 *
 * @return On success, task (the pointer to the task that received the
 * message) is returned. If message has not been sent or no answer
 * arrived, 0 is returned.
 * On other failure, a special value is returned as described below:
 * - @b 0: The message could not be sent or the answer did not arrived
 *    	   in time.  
 * - @b 0xFFFF: @e task does not refer to a valid task.
 *
 * See also: @ref rt_receive, @ref rt_return, @ref rt_isrpc.
 *
 * @note Since all the messaging functions return a task address, 0xFFFF
 * could seem an inappropriate return value. However on all the CPUs
 * RTAI runs on, 0xFFFF is not an address that can be used by any RTAI
 * task, so it is should be always safe.<br>
 * See also the notes under @ref rt_rpc.
 */

========
rt_isrpc
========

/**
 * @anchor rt_isrpc
 * @brief Check if sender waits for reply or not.
 *
 * After receiving a message, by calling rt_isrpc a task can figure
 * out whether the sender task @e task is waiting for a reply or
 * not. That can be needed in the case one needs a server task that
 * must provide services both to sends (FIXME) and rt_rtcs.
 * No answer is required if the message sent by a @e rt_send function
 * or the sender called @ref rt_rpc_timed or @ref rt_rpc_until but it
 * is already timed out.
 *
 * @param task pointer to a task structure.
 *
 * @return If the task waits for a reply, a nonzero value is returned.
 * 	   Otherwise 0 is returned.
 *
 * @note rt_isrpc does not perform any check on pointer task. rt_isrpc
 *  cannot figure out what RPC result the sender is waiting for.<br>
 * @ref rt_return is intelligent enough to not send an answer to a
 * task which is not waiting for it. Therefore using rt_isrpc is not
 * necessary and discouraged. 
 */


=========
rt_return
=========

/**
 * @anchor rt_return
 * @brief Sends (returns) the result back to the task that made the 
 *  related remote procedure call.
 *
 * rt_return sends the result result to the task @e task. If the task
 * calling rt_rpc previously is not waiting the answer (i.e. killed or
 * timed out) this return message is silently discarded.
 *
 * @return On success, task (the pointer to the task that is got the
 * reply) is returned. If the reply message has not been sent, 0 is
 * returned. On other failure, a special value is returned as
 * described below:
 * - @b 0: The reply message was not delivered.
 * - @b 0xFFFF: @e task does not refer to a valid task.
 *
 * @note Since all the messaging functions return a task address,
 * 0xFFFF could seem an inappropriate return value. However on all the
 * CPUs RTAI runs on, 0xFFFF is not an address that can be used by any
 * RTAI task, so it is should be always safe.
 *
 * See also: notes under @ref rt_rpc.
 */



===========
rt_mbx_init
===========

/**
 * @brief Initializes a mailbox.
 *
 * rt_mbx_init initializes a mailbox of size @e size. @e mbx must
 * point to a user allocated MBX structure.
 * Using mailboxes is a flexible method for inter task
 * communications. Tasks are allowed to send arbitrarily sized
 * messages by using any mailbox buffer size. There is even no need to
 * use a buffer sized at least as the largest message you envisage,
 * even if efficiency is likely to suffer from such a
 * decision. However if you expect a message larger than the average
 * message size very rarely you can use a smaller buffer without much
 * loss of efficiency. In such a way you can set up your own mailbox
 * usage protocol, e.g. using fix sized messages with a buffer that is
 * an integer multiple of such a size guarantees maximum efficiency by
 * having each message sent/received atomically to/from the
 * mailbox. Multiple senders and receivers are allowed and each will
 * get the service it requires in turn, according to its priority. 
 * Thus mailboxes provide a flexible mechanism to allow you to freely
 * implement your own policy.
 *
 * @param mbx is a pointer to a user allocated mailbox structure.
 *
 * @param size corresponds to the size of the mailbox.
 *
 * @return On success 0 is returned. On failure, a special value is
 * returned as indicated below:
 * - @b EINVAL: Space could not be allocated for the mailbox buffer.
 */


=============
rt_mbx_delete
=============

/**
 *
 * @brief Deletes a mailbox.
 * 
 * rt_mbx_delete removes a mailbox previously created with @ref
 * rt_mbox_init().
 *
 * @param mbx Pointer to the structure used in the corresponding call
 * to rt_mbox_init.
 *
 * @return 0 is returned on success. On failure, a negative value is
 * returned as described below:
 * - @b EINVAL: @e mbx points to an invalid mailbox.
 * - @b EFAULT: mailbox data were found in an invalid state.
 */


===========
rt_mbx_send
===========

/**
 * @brief Sends a message unconditionally.
 *
 * rt_mbx_send sends a message @e msg of @e msg_size bytes to the
 * mailbox @e mbx. The caller will be blocked until the whole message
 * is copied into the mailbox or an error occurs. Even if the message
 * can be sent in a single shot, the sending task can be blocked if
 * there is a task of higher priority waiting to receive from the
 * mailbox.
 *
 * @param mbx is a pointer to a user allocated mailbox structure.
 *
 * @param msg corresponds to the message to be sent.
 *
 * @param msg_size is the size of the message.
 *
 * @return On success, the number of unsent bytes is returned. On
 * failure a negative value is returned as described below:
 * - @b EINVAL: @e mbx points to not a valid mailbox.
 */


==============
rt_mbx_send_wp
==============

/**
 * @brief Sends as many bytes as possible without blocking the calling task.
 *
 * rt_mbx_send_wp atomically sends as many bytes of message @e msg as
 * possible to the mailbox @e mbx then returns immediately.
 *
 * @param mbx is a pointer to a user allocated mailbox structure.
 *
 * @param msg corresponds to the message to be sent.
 * 
 * @param msg_size is the size of the message.
 *
 * @return On success, the number of unsent bytes is returned. On
 * failure a negative value is returned as described below:
 * - @b EINVAL: @e mbx points to an invalid mailbox.
 */

==============
rt_mbx_send_if
==============

/**
 * @brief Sends a message, only if the whole message can be passed
 * without blocking the calling task.
 *
 * rt_mbx_send_if tries to atomically send the message @e msg of @e
 * msg_size bytes to the mailbox @e mbx. It returns immediately and
 * the caller is never blocked.
 *
 * @return On success, the number of unsent bytes (0 or @e msg_size)
 * is returned. On failure a negative value is returned as described
 * below:
 * - @b EINVAL: @e mbx points to an invalid mailbox.
 */


=================
rt_mbx_send_until
=================

/**
 * @brief Sends a message with timeout.
 *
 * rt_mbx_send_until sends a message @e msg of @e msg_size bytes to
 * the mailbox @e mbx. The caller will be blocked until all bytes of
 * message is enqueued, timeout expires or an error occurs.
 *
 * @param mbx is a pointer to a user allocated mailbox structure.
 *
 * @param msg is the message to be sent.
 *
 * @param msg_size corresponds to the size of the message.
 *
 * @param time is an absolute value for the timeout.
 *
 * @return On success, the number of unsent bytes is returned. On
 * failure a negative value is returned as described below:
 * - @b EINVAL: mbx points to an invalid mailbox.
 *
 * See also: notes under @ref rt_mbx_send_timed().
 */

=================
rt_mbx_send_timed
=================

/**
 * @brief Sends a message with timeout.
 *
 * rt_mbx_send_timed send a message @e msg of @e msg_size bytes to the
 * mailbox @e mbx. The caller will be blocked until all bytes of message 
 * is enqueued, timeout expires or an error occurs.
 *
 * @param mbx is a pointer to a user allocated mailbox structure.
 *
 * @param msg is the message to be sent.
 *
 * @param msg_size corresponds to the size of the message.
 *
 * @parm delay is the timeout value relative to the current time.
 *
 * @return On success, the number of unsent bytes is returned. On
 * failure a negative value is returned as described below:
 * - @b EINVAL: mbx points to an invalid mailbox.
 *
 * See also: notes under @ref rt_mbx_send_until().
 */


==============
rt_mbx_receive
==============

/**
 * @brief Receives a message unconditionally.
 *
 * rt_mbx_receive receives a message of @e msg_size bytes from the
 * mailbox @e mbx. The caller will be blocked until all bytes of the
 * message arrive or an error occurs.
 *
 * @param mbx is a pointer to a user allocated mailbox structure.
 *
 * @param msg points to a buffer provided by the caller.
 *
 * @param msg_size corresponds to the size of the message received.
 *
 * @return On success, the number of received bytes is returned. On
 * failure a negative value is returned as described below:
 * - @b EINVAL: mbx points to an invalid mailbox.
 */

=================
rt_mbx_receive_wp
=================

/**
 * @brief Receives bytes as many as possible, without blocking the
 * calling task.
 *
 * rt_mbx_receive_wp receives at most @e msg_size of bytes of message
 * from mailbox mbx then returns immediately.
 *
 * @param mbx is a pointer to a user allocated mailbox structure.
 *
 * @param msg points to a buffer provided by the caller.
 *
 * @param msg_size corresponds to the size of the message received.
 *
 * @return On success, the number of received bytes is returned. On
 * failure a negative value is returned as described below:
 * - @b EINVAL: mbx points to not a valid mailbox.
 */

=================
rt_mbx_receive_if
=================

/**
 * @brief Receives a message only if the whole message can be passed
 * without blocking the calling task.
 *
 * rt_mbx_receive_if receives a message from the mailbox @e mbx if the
 * whole message of @e msg_size bytes is available immediately.
 *
 * @param mbx is a pointer to a user allocated mailbox structure.
 *
 * @param msg points to a buffer provided by the caller.
 *
 * @param msg_size corresponds to the size of the message received.
 *
 * @return On success, the number of received bytes (0 or @e msg_size)
 * is returned. On failure a negative value is returned as described
 * below:
 * - @b EINVAL: mbx points to an invalid mailbox.
 */

====================
rt_mbx_receive_until
====================

/**
 * @brief Receives a message with timeout.
 *
 * rt_mbx_receive_until receives a message of @e msg_size bytes from
 * the mailbox @e mbx. The caller will be blocked until all bytes of
 * the message arrive, timeout expires or an error occurs.
 *
 * @param mbx is a pointer to a user allocated mailbox structure.
 *
 * @param msg points to a buffer provided by the caller.
 *
 * @param msg_size corresponds to the size of the message received.
 *
 * @param time is an absolute value of the timeout.
 *
 * @return On success, the number of received bytes is returned. On
 * failure a negative value is returned as described below:
 * - @b EINVAL: mbx points to an invalid mailbox.
 *
 * See also: notes under @ref rt_mbx_received_timed().
 */


====================
rt_mbx_receive_timed
====================

int rt_mbx_receive_timed (MBX* mbx, void* msg, int msg_size, RTIME delay);

/**
 * @brief Receives a message with timeout.
 *
 * rt_mbx_receive_timed receives a message of @e msg_size bytes from
 * the mailbox @e mbx. The caller will be blocked until all bytes of 
 * the message arrive, timeout expires or an error occurs.
 *
 * @param mbx is a pointer to a user allocated mailbox structure.
 *
 * @param msg points to a buffer provided by the caller.
 *
 * @param msg_size corresponds to the size of the message received.
 *
 * @param delay is the timeout value relative to the current time.
 *
 * @return On success, the number of received bytes is returned. On
 * failure a negative value is returned as described below:
 * - @b EINVAL: mbx points to an invalid mailbox.
 *
 * See also: notes under @ref rt_mbx_received_until().
 */


****** Functions provided by rtai module
******

/**
 * @file
 *
 * RTAI services functions.
 *
 * This module defines some functions that can be used by RTAI tasks, for
 * managing interrupts and communication services with Linux processes.
 *
 */

=============
rt_global_cli
=============
/**
 * Disable interrupts across all CPUs
 *
 * rt_global_cli hard disables interrupts (cli) on the requesting CPU and
 * acquires the global spinlock to the calling CPU so that any other CPU
 * synchronized by this method is blocked. Nested calls to rt_global_cli within
 * the owner CPU will not cause a deadlock on the global spinlock, as it would
 * happen for a normal spinlock.
 *
 * rt_global_sti hard enables interrupts (sti) on the calling CPU and releases
 * the global lock.
 */
void rt_global_cli (void);

=============
rt_global_sti
=============
/**
 * Enable interrupts across all CPUs
 *
 * rt_global_sti hard enables interrupts (sti) on the calling CPU and releases
 * the global lock.
 */
void rt_global_sti (void);

====================
rt_global_save_flags
====================
/**
 * Save CPU flags
 *
 * rt_global_save_flags saves the CPU interrupt flag (IF) bit 9 of @a flags and
 * ORs the global lock flag in the first 8 bits of flags. From that you can
 * rightly infer that RTAI does not support more than 8 CPUs.
 */
void rt_global_save_flags (unsigned long *flags);

============================
rt_global_save_flags_and_cli
============================
/**
 * Save CPU flags
 *
 * rt_global_save_flags_and_cli combines rt_global_save_flags() and
 * rt_global_cli().
 */
int rt_global_save_flags_and_cli (void);

=======================
rt_global_restore_flags
=======================
/**
 * Restore CPU flags
 *
 * rt_global_restore_flags restores the CPU hard interrupt flag (IF) and the
 * global lock flag as given by flags, freeing or acquiring the global lock
 * according to the state of the global flag bit found in the bit corresponding
 * to the CPU it is called.
 */
void rt_global_restore_flags (unsigned long flags);


/**
 * Programmable Interrupt Controllers (PIC) management functions.
 */
==============
rt_startup_irq
==============
/**
 * start and initialize the PIC to accept interrupt request irq.
 *
 * The above function allow you to manipulate the PIC at hand, but you must
 * know what you are doing. Such a duty does not pertain to this manual and
 * you should refer to your PIC datasheet.
 *
 * Note that Linux has the same functions, but they must be used only for its
 * interrupts. Only the above ones can be safely used in real time handlers.
 *
 * It must also be remarked that when you install a real time interrupt handler,
 * RTAI already calls either rt_mask_and_ack_irq(), for level triggered
 * interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing
 * control to you interrupt handler. hus generally you should just call
 * rt_unmask_irq() at due time, for level triggered interrupts, while nothing
 * should be done for edge triggered ones. Recall that in the latter case you
 * allow also any new interrupts on the same request as soon as you enable
 * interrupts at the CPU level.
 * 
 * Often some of the above functions do equivalent things. Once more there is no
 * way of doing it right except by knowing the hardware you are manipulating.
 * Furthermore you must also remember that when you install a hard real time
 * handler the related interrupt is usually disabled, unless you are overtaking
 * one already owned by Linux which has been enabled by it.   Recall that if
 * have done it right, and interrupts do not show up, it is likely you have just
 * to rt_enable_irq() your irq.
 *
 * @note In 24.1.xx rt_startup_irq is not of type void, instead it returns an
 * unsigned long.
 */
void rt_startup_irq (unsigned int irq);

===============
rt_shutdown_irq
===============
/**
 * shut down the PIC
 *
 * No further interrupt request irq can be accepted.
 *
 * The above function allow you to manipulate the PIC at hand, but you must
 * know what you are doing. Such a duty does not pertain to this manual and
 * you should refer to your PIC datasheet.
 *
 * Note that Linux has the same functions, but they must be used only for its
 * interrupts. Only the above ones can be safely used in real time handlers.
 *
 * It must also be remarked that when you install a real time interrupt handler,
 * RTAI already calls either rt_mask_and_ack_irq(), for level triggered
 * interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing
 * control to you interrupt handler. hus generally you should just call
 * rt_unmask_irq() at due time, for level triggered interrupts, while nothing
 * should be done for edge triggered ones. Recall that in the latter case you
 * allow also any new interrupts on the same request as soon as you enable
 * interrupts at the CPU level.
 * 
 * Often some of the above functions do equivalent things. Once more there is no
 * way of doing it right except by knowing the hardware you are manipulating.
 * Furthermore you must also remember that when you install a hard real time
 * handler the related interrupt is usually disabled, unless you are overtaking
 * one already owned by Linux which has been enabled by it.   Recall that if
 * have done it right, and interrupts do not show up, it is likely you have just
 * to rt_enable_irq() your irq.
 */
void rt_shutdown_irq (unsigned int irq);

=============
rt_enable_irq
=============
/**
 * enable PIC interrupt request irq.
 *
 * The above function allow you to manipulate the PIC at hand, but you must
 * know what you are doing. Such a duty does not pertain to this manual and
 * you should refer to your PIC datasheet.
 *
 * Note that Linux has the same functions, but they must be used only for its
 * interrupts. Only the above ones can be safely used in real time handlers.
 *
 * It must also be remarked that when you install a real time interrupt handler,
 * RTAI already calls either rt_mask_and_ack_irq(), for level triggered
 * interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing
 * control to you interrupt handler. hus generally you should just call
 * rt_unmask_irq() at due time, for level triggered interrupts, while nothing
 * should be done for edge triggered ones. Recall that in the latter case you
 * allow also any new interrupts on the same request as soon as you enable
 * interrupts at the CPU level.
 * 
 * Often some of the above functions do equivalent things. Once more there is no
 * way of doing it right except by knowing the hardware you are manipulating.
 * Furthermore you must also remember that when you install a hard real time
 * handler the related interrupt is usually disabled, unless you are overtaking
 * one already owned by Linux which has been enabled by it.   Recall that if
 * have done it right, and interrupts do not show up, it is likely you have just
 * to rt_enable_irq() your irq.
 */
void rt_enable_irq (unsigned int irq);

==============
rt_disable_irq
==============
/**
 * disable PIC interrupt request irq.
 *
 * The above function allow you to manipulate the PIC at hand, but you must
 * know what you are doing. Such a duty does not pertain to this manual and
 * you should refer to your PIC datasheet.
 *
 * Note that Linux has the same functions, but they must be used only for its
 * interrupts. Only the above ones can be safely used in real time handlers.
 *
 * It must also be remarked that when you install a real time interrupt handler,
 * RTAI already calls either rt_mask_and_ack_irq(), for level triggered
 * interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing
 * control to you interrupt handler. hus generally you should just call
 * rt_unmask_irq() at due time, for level triggered interrupts, while nothing
 * should be done for edge triggered ones. Recall that in the latter case you
 * allow also any new interrupts on the same request as soon as you enable
 * interrupts at the CPU level.
 * 
 * Often some of the above functions do equivalent things. Once more there is no
 * way of doing it right except by knowing the hardware you are manipulating.
 * Furthermore you must also remember that when you install a hard real time
 * handler the related interrupt is usually disabled, unless you are overtaking
 * one already owned by Linux which has been enabled by it.   Recall that if
 * have done it right, and interrupts do not show up, it is likely you have just
 * to rt_enable_irq() your irq.
 */
void rt_disable_irq (unsigned int irq);

===================
rt_mask_and_ack_irq
===================
/**
 * mask PIC interrupt request irq and acknowledge it.
 *
 * No  * other interrupts can be accepted, once also the CPU will enable
 * interrupts, which ones depends on the PIC at hand and on how it is
 * programmed.
 *
 * The above function allow you to manipulate the PIC at hand, but you must
 * know what you are doing. Such a duty does not pertain to this manual and
 * you should refer to your PIC datasheet.
 *
 * Note that Linux has the same functions, but they must be used only for its
 * interrupts. Only the above ones can be safely used in real time handlers.
 *
 * It must also be remarked that when you install a real time interrupt handler,
 * RTAI already calls either rt_mask_and_ack_irq(), for level triggered
 * interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing
 * control to you interrupt handler. hus generally you should just call
 * rt_unmask_irq() at due time, for level triggered interrupts, while nothing
 * should be done for edge triggered ones. Recall that in the latter case you
 * allow also any new interrupts on the same request as soon as you enable
 * interrupts at the CPU level.
 * 
 * Often some of the above functions do equivalent things. Once more there is no
 * way of doing it right except by knowing the hardware you are manipulating.
 * Furthermore you must also remember that when you install a hard real time
 * handler the related interrupt is usually disabled, unless you are overtaking
 * one already owned by Linux which has been enabled by it.   Recall that if
 * have done it right, and interrupts do not show up, it is likely you have just
 * to rt_enable_irq() your irq.
 */
void rt_mask_and_ack_irq (unsigned int irq);

=============
rt_unmask_irq
=============
/**
 * unmask PIC interrupt request irq
 *
 * The related request can then interrupt the CPU again, provided it has also
 * been acknowledged.
 *
 * The above function allow you to manipulate the PIC at hand, but you must
 * know what you are doing. Such a duty does not pertain to this manual and
 * you should refer to your PIC datasheet.
 *
 * Note that Linux has the same functions, but they must be used only for its
 * interrupts. Only the above ones can be safely used in real time handlers.
 *
 * It must also be remarked that when you install a real time interrupt handler,
 * RTAI already calls either rt_mask_and_ack_irq(), for level triggered
 * interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing
 * control to you interrupt handler. hus generally you should just call
 * rt_unmask_irq() at due time, for level triggered interrupts, while nothing
 * should be done for edge triggered ones. Recall that in the latter case you
 * allow also any new interrupts on the same request as soon as you enable
 * interrupts at the CPU level.
 * 
 * Often some of the above functions do equivalent things. Once more there is no
 * way of doing it right except by knowing the hardware you are manipulating.
 * Furthermore you must also remember that when you install a hard real time
 * handler the related interrupt is usually disabled, unless you are overtaking
 * one already owned by Linux which has been enabled by it.   Recall that if
 * have done it right, and interrupts do not show up, it is likely you have just
 * to rt_enable_irq() your irq.
 */
void rt_unmask_irq (unsigned int irq);

==========
rt_ack_irq
==========
/**
 * rt_ack_irq acknowledge PIC interrupt request irq
 *
 * The related request can then interrupt the CPU again, provided it has not
 * been masked.
 *
 * The above function allow you to manipulate the PIC at hand, but you must
 * know what you are doing. Such a duty does not pertain to this manual and
 * you should refer to your PIC datasheet.
 *
 * Note that Linux has the same functions, but they must be used only for its
 * interrupts. Only the above ones can be safely used in real time handlers.
 *
 * It must also be remarked that when you install a real time interrupt handler,
 * RTAI already calls either rt_mask_and_ack_irq(), for level triggered
 * interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing
 * control to you interrupt handler. hus generally you should just call
 * rt_unmask_irq() at due time, for level triggered interrupts, while nothing
 * should be done for edge triggered ones. Recall that in the latter case you
 * allow also any new interrupts on the same request as soon as you enable
 * interrupts at the CPU level.
 * 
 * Often some of the above functions do equivalent things. Once more there is no
 * way of doing it right except by knowing the hardware you are manipulating.
 * Furthermore you must also remember that when you install a hard real time
 * handler the related interrupt is usually disabled, unless you are overtaking
 * one already owned by Linux which has been enabled by it.   Recall that if
 * have done it right, and interrupts do not show up, it is likely you have just
 * to rt_enable_irq() your irq.
 */
void rt_ack_irq (unsigned int irq);



==================
send_ipi_shorthand
==================
/**
 * Send an inter processors message
 *
 * send_ipi_shorthand sends an inter processors message corresponding to @a irq
 * on:
 * - all CPUs if shorthand is equal to @c APIC_DEST_ALLINC;
 * - all but itself if shorthand is equal to @c APIC_DEST_ALLBUT;
 * - itself if shorthand is equal to @c APIC_DEST_SELF.
 *
 * @note Inter processor messages are not identified by an irq number but by the
 * corresponding vector. Such a correspondence is wired internally in RTAI
 * internal tables.
 */
void send_ipi_shorthand (unsigned int shorthand, int irq);

================
send_ipi_logical
================
/**
 * Send an inter processors message
 *
 * send_ipi_logical sends an inter processor message to irq on all CPUs defined
 * by @a dest.
 * @param dest is given by an unsigned long corresponding to a bits mask of the
 * CPUs to be sent. It is used for local APICs programmed in flat logical mode,
 * so the max number of allowed CPUs is 8, a constraint that is valid for all
 * functions and data of RTAI. The flat logical mode is set when RTAI is
 * installed by calling rt_mount_rtai(). Linux 2.4.xx needs no more to be
 * reprogrammed has it has adopted the same idea.
 *
 * @note Inter processor messages are not identified by an irq number but by the
 * corresponding vector. Such a correspondence is wired internally in RTAI
 * internal tables.
 */
void send_ipi_logical (unsigned long dest, int irq);

====================
rt_assign_irq_to_cpu
====================
/**
 * Set IRQ->CPU assignment
 *
 * rt_assign_irq_to_cpu forces the assignment of the external interrupt @a irq
 * to the CPU @a cpu.
 *
 * @retval 1 if there is one CPU in the system.
 * @retval 0 on success if there are at least 2 CPUs.
 * @return the number of CPUs if @a cpu refers to a non-existent CPU.
 * @retval EINVAL if @a irq is not a valid IRQ number or some internal data
 * inconsistency is found.
 *
 * @note This functions has effect only on multiprocessors systems.
 * @note With Linux 2.4.xx such a service has finally been made available
 * natively within the raw kernel. With such Linux releases
 * rt_reset_irq_to_sym_mode() resets the original Linux delivery mode, or
 * deliver affinity as they call it. So be warned that such a name is kept
 * mainly for compatibility reasons, as for such a kernel the reset operation
 * does not necessarily implies a symmetric external interrupt delivery.
 */
int rt_assign_irq_to_cpu (int irq, int cpu);

========================
rt_reset_irq_to_sym_mode
========================
/**
 * reset IRQ->CPU assignment
 *
 * rt_reset_irq_to_sym_mode resets the interrupt irq to the symmetric interrupts
 * management. The symmetric mode distributes the IRQs over all the CPUs.
 *
 * @retval 1 if there is one CPU in the system.
 * @retval 0 on success if there are at least 2 CPUs.
 * @return the number of CPUs if @a cpu refers to a non-existent CPU.
 * @retval EINVAL if @a irq is not a valid IRQ number or some internal data
 * inconsistency is found.
 *
 * @note This function has effect only on multiprocessors systems.
 * @note With Linux 2.4.xx such a service has finally been made available
 * natively within the raw kernel. With such Linux releases
 * rt_reset_irq_to_sym_mode() resets the original Linux delivery mode, or
 * deliver affinity as they call it. So be warned that such a name is kept
 * mainly for compatibility reasons, as for such a kernel the reset operation
 * does not necessarily implies a symmetric external interrupt delivery.
 */
int rt_reset_irq_to_sym_mode (int irq);


=====================
rt_request_global_irq
=====================
/**
 * Install IT service routine.
 *
 * rt_request_global_irq installs function handler as a real time interrupt
 * service routine for IRQ level @a irq, eventually stealing it to Linux.
 * 
 * @param handler is then invoked whenever interrupt number irq occurs.   The
 * installed handler must take care of properly activating any Linux handler
 * using the same irq number it stole, by calling rt_pend_linux_irqr().
 *
 * @retval 0 on success.
 * @retval EINVAL if @a irq is not a valid IRQ number or handler is NULL.
 * @retval EBUSY  if there is already a handler of interrupt @a irq.
 */
int rt_request_global_irq (unsigned int irq, void (*handler)(void));

=============
request_RTirq
=============
/**
 * @note request_RTirq() are macros defined in rtai.h and is supported
 * only for backwards compatibility with our variant of RT_linux for 2.0.35.
 * It is fully equivalent of the function above.
 */
int request_RTirq (unsigned int irq, void (*handler)(void));

==================
rt_free_global_irq
==================
/**
 * Uninstall IT service routine.
 *
 * rt_free_global_irq uninstalls the interrupt service routine, resetting it for
 * Linux if it was previously owned by the kernel.
 *
 * @retval 0 on success.
 * @retval EINVAL if @a irq is not a valid IRQ number.
 */
int rt_free_global_irq (unsigned int irq);

==========
free_RTirq
==========
/**
 * @note free_RTirq is a macro defined in rtai.h and is supported only for
 * backwards compatibility with our variant of RT_linux for 2.0.35.
 * It is fully equivalent of the function above.
 *
 */
int free_RTirq (unsigned int irq);

====================
rt_request_linux_irq
====================
/**
 * Install shared Linux interrupt handler.
 *
 * rt_request_linux_irq installs function @a handler as a standard Linux
 * interrupt service routine for IRQ level @a irq forcing Linux to share the IRQ
 * with other interrupt handlers, even if it does not want. The handler is
 * appended to any already existing Linux handler for the same irq and is run by
 * Linux irq as any of its handler. In this way a real time application can
 * monitor Linux interrupts handling at its will. The handler appears in
 * /proc/interrupts.
 *
 * @param linux_handler_id is a name for /proc/interrupts.
 * @param dev_id is to pass to the interrupt handler, in the same way as the
 * standard Linux irq request call.
 *
 * The interrupt service routine can be uninstalled with rt_free_linux_irq().
 *
 * @retval 0 on success.
 * @retval EINVAL if @a irq is not a valid IRQ number or handler is @c NULL.
 * @retval EBUSY if there is already a handler of interrupt @a irq.
 */
int rt_request_linux_irq (unsigned int irq, void (*handler)(int irq, void
*dev_id, struct pt_regs *regs), char *linux_handler_id, void *dev_id);

=================
rt_free_linux_irq
=================
/**
 * Uninstall shared Linux interrupt handler.
 *
 * @param linux_handler_id is a name for /proc/interrupts.
 * @param dev_id is to pass to the interrupt handler, in the same way as the
 * standard Linux irq request call.
 *
 * @retval 0 on success.
 * @retval EINVAL if @a irq is not a valid IRQ number.
 */
int rt_free_linux_irq (unsigned int irq, void *dev_id);

=================
rt_pend_linux_irq
=================
/**
 * Make Linux service an interrupt
 *
 * rt_pend_linux_irq appends a Linux interrupt irq for processing in Linux IRQ
 * mode, i.e. with hardware interrupts fully enabled.
 *
 * @note rt_pend_linux_irq does not perform any check on @a irq.
 */
void rt_pend_linux_irq (unsigned int irq);
 

==============
rt_request_srq
==============
/**
 * Install a system request handler
 *
 * rt_request_srq installs a two way RTAI system request (srq) by assigning
 * @a user_handler, a function to be used when a user calls srq from user space,
 * and @a rtai_handler, the function to be called in kernel space following its
 * activation by a call to rt_pend_linux_srq. @a rtai_handler  is in practice
 * used to request a service from the kernel.   In fact Linux system requests
 * cannot be used safely from RTAI so you can setup a handler that receives real
 * time requests and safely executes them when Linux is running.
 *
 * @param user_handler can be used to effectively enter kernel space without the
 * overhead and clumsiness of standard Unix/Linux protocols.   This is very
 * flexible service that allows you to personalize your use of  RTAI.
 *
 * @return the number of the assigned system request on success.
 * @retval EINVAL if @a rtai_handler is @c NULL or @a srq is invalid.
 * @retval EBUSY if no free srq slot is available.
 */
int rt_request_srq (unsigned int label, void (*rtai_handler)(void), long long
(*user_handler)(unsigned int whatever));

===========
rt_free_srq
===========
/**
 * Uninstall a system request handler
 *
 * rt_free_srq uninstalls the specified system call @a srq, returned by
 * installing the related handler with a previous call to rt_request_srq().
 *
 * @retval EINVAL if @a srq is invalid.
 */
int rt_free_srq (unsigned int srq);

=================
rt_pend_linux_srq
=================
/**
 * Append a Linux IRQ.
 *
 * rt_pend_linux_srq appends a system call request srq to be used as a service
 * request to the Linux kernel.
 *
 * @param srq is the value returned by rt_request_srq.
 *
 * @note rt_pend_linux_srq does not perform any check on irq.
 */
void rt_pend_linux_srq (unsigned int srq);

================
rt_request_timer
================
/**
 * Install a timer interrupt handler.
 *
 * rt_request_timer requests a timer of period tick ticks, and installs the
 * routine @a handler as a real time interrupt service routine for the timer.
 *
 * Set @a tick to 0 for oneshot mode (in oneshot mode it is not used).
 * If @a apic has a nonzero value the local APIC timer is used.   Otherwise
 * timing is based on the 8254.
 *
 */
void rt_request_timer (void (*handler)(void), int tick, int apic);

=============
rt_free_timer
=============
/**
 * Uninstall a timer interrupt handler.
 *
 * rt_free_timer uninstalls a timer previously set by rt_request_timer().
 */
void rt_free_timer (void);

======================
rt_request_apic_timers
======================
/**
 * Install a local APICs timer interrupt handler
 *
 * rt_request_apic_timers requests local APICs timers and defines the mode and
 * count to be used for each local APIC timer. Modes and counts can be chosen
 * arbitrarily for each local APIC timer.
 *
 * @param apic_timer_data is a pointer to a vector of structures
 * @code struct apic_timer_setup_data { int mode, count; }
 * @endcode sized with the number of CPUs available.
 *
 * Such a structure defines:
 * - mode: 0 for a oneshot timing, 1 for a periodic timing.
 * - count: is the period in nanoseconds you want to use on the corresponding
 * timer, not used for oneshot timers.  It is in nanoseconds to ease its
 * programming when different values are used by each timer, so that you do not
 * have to care converting it from the CPU on which you are calling this
 * function.
 *
 * The start of the timing should be reasonably synchronized.   You should call
 * this function with due care and only when you want to manage the related
 * interrupts in your own handler.   For using local APIC timers in pacing real
 * time tasks use the usual rt_start_timer(), which under the MUP scheduler sets
 * the same timer policy on all the local APIC timers, or start_rt_apic_timers()
 * that allows you to use @c struct @c apic_timer_setup_data directly.
 */
void rt_request_apic_timers (void (*handler)(void), struct
apic_timer_setup_data *apic_timer_data);

===================
rt_free_apic_timers
===================
/**
 * Uninstall a local APICs timer interrupt handler
 */
void rt_free_apic_timers (void);

=============
rt_mount_rtai
=============
/**
 * Initialize real time application interface
 *
 * rt_mount_rtai initializes the real time application interface, i.e. grabs
 * anything related to the hardware, data or service, pointed by at by the Real
 * Time Hardware Abstraction Layer RTHAL(struct rt_hal rthal;).
 *
 * @note When you do insmod rtai RTAI is not active yet, it needs to be
 * specifically switched on by calling rt_mount_rtai.
 */
void rt_mount_rtai (void);

==============
rt_umount_rtai
==============
/**
 * Uninitialize real time application interface
 *
 * rt_umount_rtai unmounts the real time application interface resetting Linux
 * to its normal state.
 */
void rt_umount_rtai (void);

***** RTAI_SHM service functions: *****

/**
 * @file
 *
 * Shared memory services.
 *
 * This header contains some functions that allow sharing memory inter-intra
 * real-time tasks and Linux processes. In fact it can be an alternative to
 * SYSTEM V shared memory, the services are symmetrical, i.e. similar calls can
 * be used both in real time tasks, i.e. within the kernel, and Linux processes.
 * The function calls for Linux processes are inlined in this file. This
 * approach has been preferred to a library since: is simpler, more effective,
 * the calls are short, simple and just a few per process.
 *
 * @author Paolo Mantegazza
 *
 * @note Copyright &copy; 1999  Paolo Mantegazza <mantegazza@aero.polimi.it>
 * \n Copyright &copy; 2001  Lineo Inc. (Author: <bkuhn@lineo.com>)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

===============
rtai_malloc_adr
===============
/**
 * Allocate a chunk of memory to be shared inter-intra kernel modules and Linux
 * processes.
 *
 * rtai_malloc_adr is used to allocate in user space.
 *
 * @param adr is a user desired address where the allocated memory should be
 * mapped in user space;
 *
 * @param name is an unsigned long identifier;
 *
 * @param size is the amount of required shared memory.
 *
 * Since @c name can be a clumsy identifier, services are provided to
 * convert 6 characters identifiers to unsigned long, and vice versa.
 *
 * @see the functions nam2num() and num2nam().
 *
 * It must be remarked that the first allocation does a real allocation, any
 * subsequent call to allocate with the same name from Linux processes just maps
 * the area to the user space, or return the related pointer to the already
 * allocated space in kernel space.  The functions return a pointer to the
 * allocated memory, appropriately mapped to the memory space in use.
 *
 * @return a valid address on succes, 0 on failure.
 *
 * @note If the same process calls rtai_malloc_adr and rtai_malloc() twice in
 * the same process it get a zero return value on the second call.
 *
 */

===========
rtai_malloc
===========
/**
 * Allocate a chunk of memory to be shared inter-intra kernel modules and Linux
 * processes.
 *
 * rtai_malloc is used to allocate in user space.
 *
 * @param name is an unsigned long identifier;
 *
 * @param size is the amount of required shared memory.
 *
 * Since @c name can be a clumsy identifier, services are provided to
 * convert 6 characters identifiers to unsigned long, and vice versa.
 *
 * @see the functions nam2num() and num2nam().
 *
 * It must be remarked that the first allocation does a real allocation, any
 * subsequent call to allocate with the same name from Linux processes just maps
 * the area to the user space, or return the related pointer to the already
 * allocated space in kernel space.  The functions return a pointer to the
 * allocated memory, appropriately mapped to the memory space in use.
 *
 * @return a valid address on succes, 0 on failure.
 *
 * @note If the same process calls rtai_malloc_adr() and rtai_malloc twice in
 * the same process it get a zero return value on the second call.
 *
 */

============
rtai_kmalloc
============
/**
 * Allocate a chunk of memory to be shared inter-intra kernel modules and Linux
 * processes.
 *
 * rtai_kmalloc is a helper macro. rtai_kmalloc_f() does the real job.
 */

============
rtai_kmalloc_f
============
/**
 * Allocate a chunk of memory to be shared inter-intra kernel modules and Linux
 * processes.
 *
 * @internal
 *
 * rtai_kmalloc_f is used (through #rtai_kmalloc) to allocate in kernel space.
 *
 * @param name is an unsigned long identifier;
 *
 * @param size is the amount of required shared memory;
 *
 * @param pid is provided by the rtai_kmalloc() macro.
 *
 * Since @a name can be a clumsy identifier, services are provided to
 * convert 6 characters identifiers to unsigned long, and vice versa.
 *
 * @see nam2num() and num2nam().
 *
 * It must be remarked that the first allocation does a real allocation, any
 * subsequent call to allocate with the same name from Linux processes just maps
 * the area to the user space, or return the related pointer to the already
 * allocated space in kernel space.  The functions return a pointer to the
 * allocated memory, appropriately mapped to the memory space in use.
  *
 * @return a valid address on succes, 0 on failure.
 */

============
rtai_free
============
/**
 * Free a chunk of shared memory being shared inter-intra kernel modules and
 * Linux processes.
 *
 * rtai_free is used to free from the user space a previously allocated shared
 * memory.
 *
 * @param name is the unsigned long identifier used when the memory was
 * allocated;
 *
 * @param adr is the related address.
 *
 * Analogously to what done by the allocation functions the freeing calls have
 * just the effect of unmapping any shared memory being freed till the last is
 * done, as that is the one the really frees any allocated memory.
 */

============
rtai_kfree
============
/**
 * Free a chunk of shared memory being shared inter-intra kernel modules and
 * Linux processes.
 *
 * rtai_kfree is a helper macro. rtai_kfree_f() does the real job.
 */

============
rtai_kfree_f
============
/**
 * Free a chunk of shared memory being shared inter-intra kernel modules and
 * Linux processes.
 *
 * @internal
 *
 * rtai_kfree is used (through #rtai_kfree) to free from the kernel space a
 * previously allocated shared memory.
 *
 * @param name is the unsigned long identifier used when the memory was
 * allocated;
 *
 * @param adr is the related address.
 *
 * Analogously to what done by the allocation functions the freeing calls have
 * just the effect of unmapping any shared memory being freed till the last is
 * done, as that is the one the really frees any allocated memory.
 */

/**
 * @file
 *
 * Conversion between characters strings and unsigned long identifiers.
 *
 * Convert a 6 characters string to un unsigned long, and vice versa, to be used
 * as an identifier for RTAI services symmetrically available in user and kernel
 * space, e.g. shared memory and LXRT and LXRT-INFORMED.
 *
 * @author Paolo Mantegazza
 *
 * @note Copyright &copy; 1999-2003 Paolo Mantegazza <mantegazza@aero.polimi.it>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

============
nam2num
============
/**
 * Convert a 6 characters string to an unsigned long.
 *
 * converts a 6 characters string name containing the alpha numeric
 * identifier to its corresponding unsigned long identifier.
 *
 * @param name is the name to be converted.
 *
 * Allowed characters are:
 * -  english letters (no difference between upper and lower case);
 * -  decimal digits;
 * -  underscore (_) and another character of your choice. The latter will be
 * always converted back to a $ by num2nam().
 *
 * @return the unsigned long associated with @a name.
 */

============
num2nam
============
/**
 * Convert an unsigned long to a 6 characters string.
 *
 * @param num is the unsigned long identifier whose alphanumeric name string has
 * to be evaluated;
 *
 * @param name is a pointer to a 6 characters buffer where the identifier will
 * be returned.
 */


****** LXRT services (soft-hard real time in user space)
 ******
/**
 * @file
 *
 * LXRT services (soft-hard real time in user space)
 *
 * LXRT is a module that allows you to use all the services made available by
 * RTAI and its schedulers in user space, both for soft and hard real time. At
 * the moment it is a feature youll find nowhere but with RTAI. For an
 * explanation of how it works see the Appendix B0, containing Pierre Cloutiers
 * LXRT-INFORMED FAQs, and Appendix B1 for an explanation of the implementation
 * of hard real time in user space (contributed by: Pierre Cloutier, Paolo
 * Mantegazza, Steve Papacharalambous).
 *
 * LXRT-INFORMED should be the production version of LXRT, the latter being the
 * development version. So it can happen that LXRT-INFORMED could be lagging
 * slightly behind LXRT.  If you need to hurry to the services not yet ported to
 * LXRT-INFORMED do it without pain. Even if you are likely to miss some useful
 * services found only in LXRT-INFORMED, we release only when a feature is
 * relatively stable.
 *
 * From what said above there should be no need for anything specific as all the
 * functions you can use in user space have been already documented in this
 * manual.   There are however a few exceptions that need to be explained.
 *
 * Note also that, as already done for the shared memory services in user space,
 * the function calls for Linux processes are inlined in the file
 * "rtai_lxrt.h". This approach has been preferred to a library since it is
 * simpler, more effective, the calls are short and simple so that, even if it
 * is likely that there can be more than just a few per process, they could
 * never be charged of making codes too bigger.   Also common to shared memory
 * is the use of unsigned int to identify LXRT objects.   If you want to use
 * string identifiers the same support functions, i.e. nam2numand num2nam, can
 * be used.
 *
 * @author Paolo Mantegazza
 *
 * @note Copyright &copy; 1999-2003 Paolo Mantegazza <mantegazza@aero.polimi.it>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.
 *
 * ACKNOWLEDGMENTS:
 * Pierre Cloutier (pcloutier@poseidoncontrols.com) has suggested the 6
 * characters names and fixed many inconsistencies within this file.
 */

============
rt_task_init
============
/**
 * Create a new real time task in user space.
 * 
 * rt_task_init provides a real time buddy, also called proxy, task to the Linux
 * process that wants to access RTAI scheduler services.   It needs no task
 * function as none is used, but it does need to setup a task structure and
 * initialize it appropriately as the provided services are carried out as if
 * the Linux process has become an RTAI task.   Because of that it requires less
 * arguments and returns the pointer to the task that is to be used in related
 * calls.
 *
 * @param name is a unique identifier that is possibly used by easing
 * referencing the buddy RTAItask, and thus its peer Linux process.
 *
 * @param priority is the priority of the buddys priority.
 *
 * @param stack_size is just what is implied by such a name and refers to the
 * stack size used by the buddy.
 *
 * @param max_msg_size is a hint for the size of the most lengthy message than
 * is likely to be exchanged.
 *
 * @a stack_size and @a max_msg can be zero, in which case the default internal
 * values are used.  The assignment of a different value should be required only
 * if you want to use task signal functions.   In such a case note that these
 * signal functions are intended to catch asyncrounous events in kernel  space
 * and, as such, must be programmed into a companion module and interfaced to
 * their parent Linux process through the available services. Keep an eye on the
 * default stack (512) and message (256) sizes as they seem to be acceptable,
 * but this API has not been used extensively with complex interrupt service
 * routines.   Since the latter are served on the stack of any task being
 * interrupted, and more than one can pile up on the same stack, it can be
 * possible that a larger stack is required.   In such a case either recompile
 * lxrt.c with macros STACK_SIZE and MSG_SIZE set appropriately, or explicitly
 * assign larger values at your buddy tasks  inits.   Note that while the stack
 * size can be critical the message size will not. In fact the module reassigns
 * it, appropriately sized, whenever it is needed.   The cost is a kmalloc with
 * GFP_KERNEL that can block, but within the Linux environment.   Note also that
 * @a max_msg_size is for a buffer to be used to copy whatever message, either
 * mailbox or inter task, from user to kernel space, as messages are not
 * necessarily copied immediately, and has nothing to do directly with what you
 * are doing. It is important to remark that the returned task pointers cannot
 * be used directly, they are for kernel space data, but just passed as
 * arguments when needed.
 *
 * @return On success a pointer to the task structure initialized in kernel
 * space.
 * @return a 0 value if it was not possible to setup the buddy task or something
 * using the same name was found.
 */

============
rt_sem_init
============
/**
 * Initialize a counting semaphore.
 *
 * Allocates and initializes a semaphore to be referred by @a name.
 *
 * @param initial_count is the initial value of the semaphore
 *
 * It is important to remark that the returned task pointer cannot be used
 * directly, they are for kernel space data, but just passed as arguments when
 * needed.
 *
 * @return a pointer to the semaphore to be used in related calls or 0 if an
 * error has occured.
 */ 


============
rt_mbx_init
============
/**
 * Initialize mailbox.
 * 
 * Initializes a mailbox referred to by @a name of size @a size.
 * 
 * It is important to remark that the returned task pointer cannot be used
 * directly, they are for kernel space data, but just passed as arguments when
 * needed.
 *
 * @return On success a pointer to the mail box to be used in related calls.
 * @return A 0 value is returned if it was not possible to setup the semaphore
 * or something using the same name was found.
 */

    /** The above functions can be used also for synchronizing on the existence
     *  or not of any implied object. */
============
rt_register
============
/**
 * Register an object.
 *
 * rt_register registers the object to be identified with @a name, which is
 * pointed by @a adr.
 *
 * @return a positive number on success, 0 on failure.
 */

============
rt_get_adr
============
/**
 * Get an object address by its name.
 *
 * rt_get_adr returns the address associated to @a name.
 *
 * @return the address associated to @a name on success, 0 on failure
 */

============
rt_get_name
============
/**
 * Get an object name by its address.
 *
 * rt_get_name returns the name pointed by the address @a adr.
 *
 * @return the identifier pointed by the address @a adr on success, 0 on
 * failure.
 */

============
rt_drg_on_adr
============
/**
 * Deregister an object by its address.
 *
 * rt_drg_on_adr deregisters the object identified by its @a adr.
 *
 * @return a positive number on success, 0 on failure.
 */

============
rt_drg_on_name
============
/**
 * Deregister an object by its name.
 *
 * rt_drg_on_name deregisters the object identified by its @a name.
 *
 * @return a positive number on success, 0 on failure.
 */



============
rt_make_hard_real_time
============
/**
 * Give a Linux process, or pthread, hard real time execution capabilities 
 * allowing full kernel preemption.
 *
 * rt_make_hard_real_time makes the soft Linux POSIX real time process, from
 * which it is called, a hard real time LXRT process.   It is important to
 * remark that this function must be used only with soft Linux POSIX processes
 * having their memory locked in memory.   See Linux man pages.
 *
 * Only the process itself can use this functions, it is not possible to impose
 * the related transition from another process.
 *
 * Note that processes made hard real time should avoid making any Linux System
 * call that can lead to a task switch as Linux cannot run anymore processes
 * that are made hard real time.   To interact with Linux you should couple the
 * process that was made hard real time with a Linux buddy server, either
 * standard or POSIX soft real time.   To communicate and synchronize with the
 * buddy you can use the wealth of available RTAI, and its schedulers, services.
 * 
 * After all it is pure nonsense to use a non hard real time Operating System,
 * i.e. Linux, from within hard real time processes.
 */

============
rt_make_soft_real_time
============
/**
 * Return a hard real time Linux process, or pthread to the standard Linux
 * behavior.
 *
 * rt_make_soft_real_time returns to soft Linux POSIX real time a process, from
 * which it is called, that was made hard real time by a call to
 * rt_make_hard_real_time.
 *
 * Only the process itself can use this functions, it is not possible to impose
 * the related transition from another process.
 *
 */
    
============
rt_allow_nonroot_hrt
============
/**
 * Allows a non root user to use the Linux POSIX soft real time process 
 * management and memory lock functions, and allows it to do any input-output
 * operation from user space.
 *
 * Only the process itself can use this functions, it is not possible to impose
 * the related transition from another process.
 */


****** MINI_RTAI_LXRT module  ******
/**
 * @file
 *
 * The MINI_RTAI_LXRT tasklets module adds an interesting new feature along the
 * line, pioneered by RTAI, of a symmetric usage of all its services inter-intra
 * kernel and user space, both for soft and hard real time applications.   In
 * such a way you have opened a whole spectrum of development and implementation
 * lanes, allowing maximum flexibility with uncompromized performances.
 *
 * The new services provided can be useful when you have many tasks, both in
 * kernel and user space, that must execute in soft/hard real time but do not
 * need any RTAI scheduler service that could lead to a task block. Such tasks
 * are here called tasklets and can be of two kinds: normal tasklets and timed
 * tasklets (timers).
 *
 * It must be noted that only timers should need to be made available both in
 * user and kernel space.   In fact normal tasklets in kernel space are nothing
 * but standard functions that can be directly executed by calling them, so
 * there would be no need for any special treatment.   However to maintain full
 * usage symmetry, and to ease any possible porting from one address space to
 * the other, also normal tasklet functions can be used in whatever address
 * space.
 *
 * Note that if, at this point, you are reminded to similar Linux kernel
 * services you are not totally wrong.  They are not exactly the same, because
 * of their symmetric availability in kernel and user space, but the basic idea
 * behind them  is clearly fairly similar.
 *
 * Tasklets should be used whenever the standard hard real time tasks available
 * with RTAI and LXRT schedulers can be a waist of resources and the execution
 * of simple, possibly timed, functions could often be more than
 * enough. Instances of such applications are timed polling and simple
 * Programmable Logic Controllers (PLC) like sequences of services.   Obviously
 * there are many others instances that can make it sufficient the use of
 * tasklets, either normal or timers.   In general such an approach can be a
 * very useful complement to fully featured tasks in controlling complex
 * machines and systems, both for basic and support services.
 *
 * It is remarked that the implementation found here for timed tasklets rely on
 * a server support task that executes the related timer functions, either in
 * oneshot or periodic mode, on the base of their time deadline and according to
 * their, user assigned, priority. Instead, as told above, plain tasklets are
 * just functions executed from kernel space; their execution needs no server
 * and is simply triggered by calling a given service function at due time,
 * either from a kernel task or interrupt handler requiring, or in charge of,
 * their execution when they are needed. Once more it is important to recall
 * that all non blocking RTAI scheduler services can be used in any tasklet
 * function.   Blocking services must absolutely be avoided.   They will
 * deadlock the timers server task, executing task or interrupt handler,
 * whichever applies, so that no more tasklet functions will be executed.
 *
 * User and kernel space MINI_RTAI_LXRT applications can cooperate and
 * synchronize by using shared memory. It has been called MINI_RTAI_LXRT because
 * it is a kind of light soft/hard real time server that can partially
 * substitute RTAI and LXRT in simple applications, i.e. if the constraints
 * hinted above are wholly satisfied. So MINI_RTAI_LXRT can be used in kernel
 * and user space, with any RTAI scheduler. Its implementations has been very
 * easy, as it is nothing but what its name implies.   LXRT made all the needed
 * tools already available.   In fact it duplicates a lot of LXRT so that its
 * final production version will be fully integrated with it, ASAP.   However,
 * at the moment, it cannot work with LXRT yet.
 *
 * Note that in user space you run within the memory of the process owning the
 * tasklet function so you MUST lock all of your processes memory in core, by
 * using mlockall, to prevent it being swapped out.   Also abundantly pre grow
 * your stack to the largest size needed during the execution of your
 * application, see mlockall usage in Linux manuals.
 *
 * The RTAI distribution contains many useful examples that demonstrate the use
 * of most services, both in kernel and user space. 
 */

/*
***** MINI_RTAI_LXRT service functions: *****

    * rt_tasklet_init
    * rt_tasklet_delete
    * rt_insert_tasklet
    * rt_remove_tasklet
    * rt_find_tasklet_by_id
    * rt_tasklet_exec
    * rt_timer_init
    * rt_timer_delete
    * rt_insert_timer
    * rt_remove_timer
    * rt_set_timer_priority
    * rt_set_timer_firing_time
    * rt_set_timer_period
    * rt_set_timer_handler
    * rt_set_timer_data
    * rt_tasklets_use_fpu
    */
============
rt_init_tasklet
============
/**
 * Init, in kernel space, a tasklet structure to be used in user space.
 *
 * rt_tasklet_init allocate a tasklet structure (struct rt_tasklet_struct) in
 * kernel space to be used for the management of a user space tasklet.
 *
 * This function is to be used only for user space tasklets. In kernel space
 * it is just an empty macro, as the user can, and must  allocate the related
 * structure directly, either statically or dynamically.
 *
 * @return the pointer to the tasklet structure the user space application must
 * use to access all its related services.
 */

============
rt_delete_tasklet
============
/**
 * Delete, in kernel space, a tasklet structure to be used in user space.
 *
 * rt_tasklet_delete free a tasklet structure (struct rt_tasklet_struct) in
 * kernel space that was allocated by rt_tasklet_init.
 *
 * @param tasklet is the pointer to the tasklet structure (struct
 * rt_tasklet_struct) returned by rt_tasklet_init.
 *
 * This function is to be used only for user space tasklets. In kernel space
 * it is just an empty macro, as the user can, and must  allocate the related
 * structure directly, either statically or dynamically.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_insert_tasklet
============
/**
 * Insert a tasklet in the list of tasklets to be processed.
 *
 * rt_insert_tasklet insert a tasklet in the list of tasklets to be processed.
 *
 * @param tasklet is the pointer to the tasklet structure to be used to manage
 * the tasklet at hand.
 *
 * @param handler is the tasklet function to be executed.
 *
 * @param data is an unsigned long to be passed to the handler.   Clearly by an
 * appropriate type casting one can pass a pointer to whatever data structure
 * and type is needed.
 *
 * @param id is a unique unsigned number to be used to identify the tasklet
 * tasklet. It is typically required by the kernel space service, interrupt
 * handler ot task, in charge of executing a user space tasklet.   The support
 * functions nam2num() and num2nam() can be used for setting up id from a six
 * character string.
 *
 * @param pid is an integer that marks a tasklet either as being a kernel or
 * user space one. Despite its name you need not to know the pid of the tasklet
 * parent process in user space.   Simple use 0 for kernel space and 1 for user
 * space.
 *
 * @return 0 on success, otherwise a negative number is returned to indicate
 * that an invalid handler address has been passed.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_remove_tasklet
============
/**
 * Remove a tasklet in the list of tasklets to be processed.
 *
 * rt_remove_tasklet remove a tasklet from the list of tasklets to be processed.
 *
 * @param tasklet is the pointer to the tasklet structure to be used to manage
 * the tasklet at hand.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_find_tasklet_by_id
============
/**
 * Find a tasklet identified by its id.
 *
 * @param id is the unique unsigned long to be used to identify the tasklet.
 * The support functions nam2num() and num2nam() can be used for setting up id
 * from a six character string.
 *
 * @return On success, the pointer to @atasklet handler, or 0 to indicate that
 * @a id is not a valid identifier so that the related tasklet was not found.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_exec_tasklet
============
/**
 * Exec a tasklet.
 *
 * rt_exec_tasklet execute a tasklet from the list of tasklets to be processed.
 *
 * @param tasklet is the pointer to the tasklet structure to be used to manage
 * the tasklet @a tasklet.
 *
 * Kernel space tasklets addresses are usually available directly and can be
 * easily be used in calling rt_tasklet_exec.   In fact one can call the related
 * handler directly without using such a support  function, which is mainly
 * supplied for symmetry and to ease the porting of applications from one space
 * to the other.
 *
 * User space tasklets instead must be first found within the tasklet list by
 * calling rt_find_tasklet_by_id() to get the tasklet address to be used
 * in rt_tasklet_exec().
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_init_timer
============
/**
 * Init, in kernel space, a timed tasklet, simply called timer, structure
 * to be used in user space.
 *
 * rt_timer_init allocate a timer tasklet structure (struct rt_tasklet_struct)
 * in kernel space to be used for the management of a user space timer.
 *
 * This function is to be used only for user space timers. In kernel space
 * it is just an empty macro, as the user can, and must allocate the related
 * structure directly, either statically or dynamically.
 *
 * @return the pointer to the timer structure the user space application must
 * use to access all its related services.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_delete_timer
============
/**
 * Delete, in kernel space, a timed tasklet, simply called timer, structure
 * to be used in user space.
 *
 * rt_timer_delete free a timer tasklet structure (struct rt_tasklet_struct) in
 * kernel space that was allocated by rt_timer_init.
 *
 * @param timer is a pointer to a timer tasklet structure (struct
 * rt_tasklet_struct).
 *
 * This function is to be used only for user space timers. In kernel space
 * it is just an empty macro, as the user can, and must allocate the related
 * structure directly, either statically or dynamically.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_insert_timer
============
/**
 * Insert a timer in the list of timers to be processed.
 *
 * rt_insert_timer insert a timer in the list of timers to be processed.  Timers
 * can be either periodic or oneshot.   A periodic timer is reloaded at each
 * expiration so that it executes with the assigned periodicity.   A oneshot
 * timer is fired just once and then removed from the timers list. Timers can be
 * reinserted or modified within their handlers functions.
 *
 * @param timer is the pointer to the timer structure to be used to manage the
 * timer at hand.
 *
 * @param priority is the priority to be used to execute timers handlers when
 * more than one timer has to be fired at the same time.It can be assigned any
 * value such that: 0 < priority < RT_LOWEST_PRIORITY.
 *
 * @param firing_time is the time of the first timer expiration.
 *
 * @param period is the period of a periodic timer. A periodic timer keeps
 * calling its handler at  firing_time + k*period k = 0, 1.  To define a oneshot
 * timer simply use a null period.
 * 
 * @param handler is the timer function to be executed at each timer expiration.
 *
 * @param data is an unsigned long to be passed to the handler.   Clearly by a 
 * appropriate type casting one can pass a pointer to whatever data structure
 * and type is needed.
 *
 * @param pid is an integer that marks a timer either as being a kernel or user
 * space one. Despite its name you need not to know the pid of the timer parent
 * process in user space. Simple use 0 for kernel space and 1 for user space.
 *
 * @retval 0 on success
 * @retval EINVAL if @a handler is an invalid handler address
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_remove_timer
============
/**
 * Remove a timer in the list of timers to be processed.
 *
 * rt_remove_timer remove a timer from the list of the timers to be processed.
 *
 * @param timer is the pointer to the timer structure to be used to manage the
 * timer at hand.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_set_timer_priority
============
/**
 * Change the priority of an existing timer.
 *
 * rt_set_timer_priority change the priority of an existing timer.
 *
 * @param timer is the pointer to the timer structure to be used to manage the
 * timer at hand.
 *
 * @param priority is the priority to be used to execute timers handlers when
 * more than one timer has to be fired at the same time. It can be assigned any
 * value such that: 0 < priority < RT_LOWEST_PRIORITY.
 *
 * This function can be used within the timer handler.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_set_timer_firing_time
============
/**
 * Change the firing time of a timer.
 * 
 * rt_set_timer_firing_time changes the firing time of a periodic timer
 * overloading any existing value, so that the timer next shoot will take place
 * at the new firing time. Note that if a oneshot timer has its firing time
 * changed after it has already expired this function has no effect. You
 * should reinsert it in the timer list with the new firing time.
 *
 * @param timer is the pointer to the timer structure to be used to manage the
 * timer at hand.
 *
 * @param firing_time is the new time of the first timer expiration.
 *
 * This function can be used within the timer handler.
 *
 * @retval 0 on success.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_set_timer_period
============
/**
 * Change the period of a timer.
 * 
 * rt_set_timer_period changes the period of a periodic timer. Note that the new
 * period will be used to pace the timer only after the expiration of the firing
 * time already in place. Using this function with a period different from zero
 * for a oneshot timer, that has not expired yet, will transform it into a
 * periodic timer.
 *
 * @param timer is the pointer to the timer structure to be used to manage the
 * timer at hand.
 *
 * @param period is the new period of a periodic timer.
 *
 * The macro #rt_fast_set_timer_period  can substitute the corresponding
 * function in kernel space if both the existing timer period and the new one
 * fit into an 32 bits integer.
 *
 * This function an be used within the timer handler.
 *
 * @retval 0 on success.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_set_timer_handler
============
/**
 * Change the timer handler.
 *
 * rt_set_timer_handler changes the timer handler function overloading any
 * existing value, so that at the next timer firing the new handler will be
 * used.   Note that if a oneshot timer has its handler changed after it has
 * already expired this function has no effect. You should reinsert it in the
 * timer list with the new handler.
 *
 * @param timer is the pointer to the timer structure to be used to manage the
 * timer at hand.
 *
 * @param handler is the new handler.
 *
 * The macro rt_fast_set_timer_handler can safely be used to substitute the
 * corresponding function in kernel space.
 *
 * This function and macro can be used within the timer handler.
 *
 * @retval 0 on success.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_set_timer_data
============
/**
 * Change the data passed to a timer.
 *
 * rt_set_timer_data changes the timer data, overloading any existing value, so
 * that at the next timer firing the new data will be used.   Note that if a
 * oneshot timer has its data changed after it is already expired this function
 * has no effect.   You should reinsert it in the timer list with the new data.
 *
 * @param timer is the pointer to the timer structure to be used to manage the
 * timer at hand.
 *
 * @param data is the new data.
 *
 * The macro rt_fast_set_timer_data can safely be used substitute the
 * corresponding function in kernel space.
 *
 *  This function and macro can be used within the timer handler.
 *
 * @retval 0 on success.
 *
 * @note To be used only with RTAI24.x.xx.
 */

============
rt_tasklet_use_fpu
============
/**
 * Notify the use of floating point operations within any tasklet/timer.
 *
 * rt_tasklets_use_fpu notifies that there is at least one tasklet/timer using
 * floating point calculations within its handler function.
 *
 * @param use_fpu_flag set/resets the use of floating point calculations:
 * - a value different from 0 sets the use of floating point calculations ;
 * - a 0 value resets the no floating calculations state.
 *
 * Note that the use of floating calculations is assigned once for all and is
 * valid for all tasklets/timers. If just one handler needs it all of them
 * will have floating point support. An optimized floating point support,
 * i.e. on a per tasklet/timer base will add an unnoticeable performance
 * improvement on most CPUs. However such an optimization is not rule out a
 * priori, if anybody can prove it is really important.
 *
 * This function and macro can be used within the timer handler.
 *
 *
 * @note To be used only with RTAI24.x.xx.
 */

/**
 * @file
 * 
 * RTAI FIFO communication functions.
 *
 * RTAI fifos maintain full compatibility with those available in NMT_RTLinux
 * while adding many other useful services that avoid the clumsiness of
 * Unix/Linux calls. So if you need portability you should bent yourself to the
 * use of select for timing out IO operations, while if you have not to satisfy
 * such constraints use the available simpler, and more direct, RTAI fifos
 * specific services.
 *
 * In the table below the standard Unix/Linux services in user space are
 * enclosed in []. See standard Linux man pages if you want to use them, they
 * need not be explained here.
 *
 * <CENTER><TABLE>
 * <TR><TD> Called from RT task </TD><TD> Called from Linux process </TD></TR>
 * <TR><TD> #rtf_create         </TD><TD> #rtf_open_sized           <BR>
 *                                        [open]                    </TD></TR>
 * <TR><TD> #rtf_destroy        </TD><TD> [close]                   </TD></TR>
 * <TR><TD> #rtf_reset          </TD><TD> #rtf_reset                </TD></TR>
 * <TR><TD> #rtf_resize         </TD><TD> #rtf_resize               </TD></TR>
 * <TR><TD> #rtf_get            </TD><TD> [read]                    <BR>
 *                                        #rtf_read_timed           <BR>
 *                                        #rtf_read_all_at_once     </TD></TR>
 * <TR><TD> #rtf_put            </TD><TD> [write]                   <BR>
 *                                        #rtf_write_timed          </TD></TR>
 * <TR><TD> #rtf_create_handler </TD><TD>                           </TD></TR>
 * <TR><TD>                     </TD><TD> #rtf_suspend_timed        </TD></TR>
 * <TR><TD>                     </TD><TD> #rtf_set_async_sig        </TD></TR>
 * </TABLE></CENTER>
 *
 * In Linux fifos have to be created by :
 * @verbatim $ mknod /dev/rtf<x> c 150 <x> @endverbatim
 * where \<x\> is the minor device number, from 0 to 63; thus on the Linux side
 * RTL fifos can be used as standard character devices. As it was said above to
 * use standard IO operations on such devices there is no need to explain
 * anything, go directly to Linux man pages. RTAI fifos specific services
 * available in kernel and user space are instead explained here.
 *
 * What is important to remember is that in the user space side you address
 * fifos through the file descriptor you get at fifo device opening while in
 * kernel space you directly address them by their minor number. So you will
 * mate the @a fd you get in user space by using
 * @verbatim open(/dev/rtfxx,...) @endverbatim
 * to the integer @p xx you will use in kernel space.
 *
 * @note RTAI fifos should be used just with applications that use only real
 * time interrupt handlers, so that no RTAI scheduler is installed, or if you
 * need compatibility with NMT RTL.  If you are working with any RTAI scheduler
 * already installed you are strongly invited to think about avoiding them, use
 * LXRT instead.
 *
 * It is far better and flexible, and if you really like it the fifos way
 * mailboxes are a one to one, more effective, substitute.   After all RTAI
 * fifos are implemented on top of them.
 *
 * @author Paolo Mantegazza
 *
 * @note Copyright &copy; 1999-2003 Paolo Mantegazza <mantegazza@aero.polimi.it>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

============
rtf_create
============
/**
 * Create a real-time FIFO
 *
 * rtf_create creates a real-time fifo (RT-FIFO) of initial size @a size and
 * assigns it the identifier @a fifo.  It must be used only in kernel space.
 *
 * @param fifo is a positive integer that identifies the fifo on further
 * operations.   It has to be less than RTF_NO.
 *
 * @param size is the requested size for the fifo. 
 * 
 * @a fifo may refer to an existing RT-FIFO. In this case the size is adjusted
 * if necessary.
 *
 * The RT-FIFO is a character based mechanism to communicate among real-time
 * tasks and ordinary Linux processes. The rtf_* functions are used by the
 * real-time tasks; Linux processes use standard character device access
 * functions such as read, write, and select.
 *
 * If this function finds an existing fifo of lower size it resizes it to the
 * larger new size. Note that the same condition apply to the standard Linux
 * device open, except that when it does not find any already existing fifo it
 * creates it with a default size of 1K bytes.
 *
 * It must be remarked that practically any fifo size can be asked for. In
 * fact if @a size is within the constraint allowed by kmalloc such a function
 * is used, otherwise vmalloc is called, thus allowing any size that can fit
 * into the available core memory.
 *
 * Multiple calls of this function are allowed, a counter is kept internally to
 * track their number, and avoid destroying/closing a fifo that is still used.
 *
 * @retval @a size on success
 * @retval ENODEV if fifo is greater than or equal to RTF_NO
 * @retval ENOMEM if the necessary size could not be allocated for the RT-FIFO.
 *
 */
int rtf_create (unsigned int fifo, int size);
 
============
rtf_open_sized
============
/**
 * Create a real-time FIFO
 *
 * rtf_open_sized is the equivalent of rtf_create() in user space; it creates a
 * real-time fifo (RT-FIFO) of initial size @a size.
 *
 * @param size is the requested size for the fifo. 
 * 
 * The RT-FIFO is a character based mechanism to communicate among real-time
 * tasks and ordinary Linux processes. The rtf_* functions are used by the
 * real-time tasks; Linux processes use standard character device access
 * functions such as read, write, and select.
 *
 * If this function finds an existing fifo of lower size it resizes it to the
 * larger new size. Note that the same condition apply to the standard Linux
 * device open, except that when it does not find any already existing fifo it
 * creates it with a default size of 1K bytes.
 *
 * It must be remarked that practically any fifo size can be asked for. In
 * fact if @a size is within the constraint allowed by kmalloc such a function
 * is used, otherwise vmalloc is called, thus allowing any size that can fit
 * into the available core memory.
 *
 * Multiple calls of this function are allowed, a counter is kept internally to
 * track their number, and avoid destroying/closing a fifo that is still used.
 *
 * @return the usual Unix file descriptor on succes, to be used in standard reads
 * and writes. 
 * @retval ENOMEM if the necessary size could not be allocated for the RT-FIFO.
 *
 * @note In user space, the standard UNIX open acts like rtf_open_sized with a
 * default 1K size.
 */
int rtf_open_sized(const char *device, int permission, int size);


============
rtf_destroy
============
/**
 * Close a real-time FIFO
 *
 * rtf_destroy closes, in kernel space, a real-time fifo previously
 * created or reopened with rtf_create() or rtf_open_sized(). An internal
 * mechanism counts how many times a fifo was opened. Opens and closes must be
 * in pair. rtf_destroy should be called as many times as rtf_create was.
 * After the last close the fifo is really destroyed.
 *
 * No need for any particular function for the same service in user space,
 * simply use the standard Unix close.
 *
 * @return a non-negative value on success. Actually it is the open counter, that
 * means how many times rtf_destroy should be called yet to destroy the fifo.
 *
 * @return a a negative value is returned as described below.
 * @retval ENODEV if @a fifo is greater than or equal to RTF_NO.
 * @retval EINVAL if @a fifo refers to a not opened fifo.
 *
 * @note The equivalent of rtf_destroy in user space is the standard UNIX
 * close.
 */
int rtf_destroy (unsigned int fifo);


============
rtf_reset
============
/**
 * Reset a real-time FIFO
 *
 * rtf_reset resets RT-FIFO @a fd_fifo by setting its buffer pointers to zero,
 * so that any existing data is discarded and the fifo started anew like at its
 * creations.   It can be used both in kernel and user space.
 *
 * @param fd_fifo is a file descriptor returned by standard UNIX open in user
 * space while it is directly the chosen fifo number in kernel space.
 *
 * @retval 0 on succes.
 * @retval ENODEV if @a fd_fifo is greater than or equal to RTF_NO.
 * @retval EINVAL if @a fd_fifo refers to a not opened fifo.
 * @retval EFAULT if the operation was unsuccessful.
 */
int rtf_reset (unsigned int fd_fifo);

============
rtf_resize
============
/**
 * Resize a real-time FIFO
 *
 * rtf_resize modifies the real-time fifo fifo, previously created with,
 * rtf_create(), to have a new size of @a size. Any data in the fifo is
 * discarded.
 *
 * @param fifo is a file descriptor returned by standard UNIX open in user
 * space while it is directly the chosen fifo number in kernel space.
 *
 * @param size is the requested new size.
 *
 * @retval size on success.
 * @retval ENODEV if @a fifo is greater than or equal to RTF_NO.
 * @retval EINVAL if @a fifo refers to a not opened fifo.
 * @retval ENOMEM if @a size bytes could not be allocated for the RT-FIFO. Fifo
 * size is unchanged.
 */
int rtf_resize (unsigned int fifo, int size);

============
rtf_put
============
/**
 * Write data to FIFO
 *
 * rtf_put tries to write a block of data to a real-time fifo previously created
 * with rtf_create().
 *
 * @param fifo is the ID with which the RT-FIFO was created.
 * @param buf points the block of data to be written.
 * @param count is the size of the block in bytes.
 *
 * This mechanism is available only in kernel space, i.e. either in real-time
 * tasks or handlers; Linux processes use a write to the corresponding
 * /dev/fifo\<n\> device to enqueue data to a fifo. Similarly, Linux processes
 * use read or similar functions to read the data previously written via rtf_put
 * by a real-time task.
 *
 * @return the number of bytes written on succes. Note that this value may
 * be less than @a count if @a count bytes of free space is not available in the
 * fifo.
 * @retval ENODEV if @a fifo is greater than or equal to RTF_NO.
 * @retval EINVAL if @a fifo refers to a not opened fifo.
 *
 * @note The equivalent of rtf_put in user space is the standard UNIX write,
 * which can be either blocking or nonblocking according to how you opened the
 * related device.
 */
int rtf_put (unsigned int fifo, void *buf, int count);

============
rtf_write_timed
============
/**
 * Write data to FIFO in user space, with timeout.
 *
 * rtf_write_timed writes a block of data to a real-time fifo identified by the
 * file descriptor @a fd waiting at most @æ delay milliseconds to complete the
 * operation.
 *
 * @param fd is the file descriptor returned at fifo open.
 * @param buf points the block of data to be written.
 * @param count is the size of the block in bytes.
 * @param delay is the timeout time in milliseconds.
 *
 * @return the number of bytes written on succes. Note that this value may
 * be less than @a count if @a count bytes of free space is not available in the
 * fifo.
 * @retval EINVAL if @a fd refers to a not opened fifo.
 *
 * @note The standard, clumsy, Unix way to achieve the same result is to use
 * select.
 */
int rtf_write_timed (int fd, char *buf, int count,intdelay);

============
rtf_get
============
/**
 * Read data from FIFO
 *
 * rtf_get tries to read a block of data from a real-time fifo previously
 * created with a call to rtf_create().
 *
 * @param fifo is the ID with which the RT-FIFO was created.
 * @param buf points a buffer of @a count bytes size provided by the caller.
 *
 * This mechanism is available only to real-time tasks; Linux processes use a
 * read from the corresponding fifo device to dequeue data from a fifo.
 * Similarly, Linux processes use write or similar functions to write the data
 * to be read via rtf_put() by a real-time task.
 *
 * rtf_get is often used in conjunction with rtf_create_handler() to process
 * data received asynchronously from a Linux process. A handler is installed
 * via rtf_create_handler(); this handler calls rtf_get to receive any data
 * present in the RT-FIFO as it becomes available. In this way, polling is not
 * necessary; the handler is called only when data is present in the fifo.
 *
 * @return the size of the received data block on success. Note that this
 * value may be less than count if count bytes of data is not available in the
 * fifo.
 * @retval ENODEV if @a fifo is greater than or equal to RTF_NO.
 * @retval EINVAL if @a fifo refers to a not opened fifo.
 *
 * @note The equivalent of rtf_get in user space is the standard UNIX read,
 * which can be either blocking or nonblocking according to how you opened the
 * related device.
 */
int rtf_get (unsigned int fifo, void *buf, int count);

============
rtf_read_timed
============
/**
 * Read data from FIFO in user space, with timeout.
 *
 * rtf_read_timed reads a block of data from a real-time fifo identified by the
 * file descriptor @a fd waiting at most @a delay milliseconds to complete the
 * operation.
 *
 * @param fd is the file descriptor returned at fifo open.
 * @param buf points the block of data to be written.
 * @param count is the size of the block in bytes.
 * @param delay is the timeout time in milliseconds.
 *
 * @return the number of bytes read is returned on success or timeout. Note that
 * this value may be less than @a count if @a count bytes of free space is not
 * available in the fifo or a timeout occured.
 * @retval EINVAL if @a fd refers to a not opened fifo.
 *
 * @note The standard, clumsy, Unix way to achieve the same result is to use
 * select.
 */
int rtf_read_timed (int fd, char *buf, int count,intdelay);

============
rtf_read_all_at_once
============
/**
 * Read data from FIFO in user space, waiting for all of them
 *
 * rtf_read_all_at_once reads a block of data from a real-time fifo identified
 * by the file descriptor @a fd blocking till all waiting at most @a dcount
 * bytes are available, whichever option was used at the related device
 * opening.
 *
 * @param fd is the file descriptor returned at fifo open.
 * @param buf points the block of data to be written.
 *
 * @return the number of bytes read on success.
 * @retval EINVAL if @a fd refers to a not opened fifo.
 */
int rtf_read_all_at_once (int fd, char *buf, int count);

============
rtf_create_handler
============
/**
 * Install a FIFO handler function.
 *
 * rtf_create_handler installs a handler which is executed when data is written
 * to or read from a real-time fifo.
 *
 * @param fifo is an RT-FIFO that must have previously been created with a call
 * to rtf_create().
 *
 * The function pointed by @a handler is called whenever a Linux process
 * accesses that fifo.
 *
 * rtf_create_handler is often used in conjunction with rtf_get() to process
 * data acquired asynchronously from a Linux process. The installed handler
 * calls rtf_get() when data is present. Because the handler is only executed
 * when there is activity on the fifo, polling is not necessary.
 *
 * The form with X_FIFO_HANDLER(handler) allows to install an extended handler,
 * i.e. one prototyped as:
 * @code
 * int (*handler)(unsigned int fifo, int rw);
 * @endcode
 * to allow the user to easily understand if the handler was called at fifo
 * read (@a rw is \'r\') or write (rw is \'w\').
 *
 * @retval 0 on success.
 * @retval EINVAL if @a fifo is greater than or equal to RTF_NO, or handler is
 * @c NULL.
 *
 * @note rtf_create_handler does not check if FIFO referred by @a fifo is open
 * or not. The next call of rtf_create will uninstall the handler just
 * "installed".
 */
int rtf_create_handler (unsigned int fifo, int (*handler)(unsigned int fifo));
int rtf_create_handler (unsigned int fifo, X_FIFO_HANDLER(handler));

============
rtf_suspend_timed
============
/**
 * Suspend a process for some time
 *
 * rtf_suspend_timed suspends a Linux process according to @a delay.
 *
 * @param fd is the file descriptor returned at fifo open, rtf_suspend_timed
 * needs a fifo support.
 * @param delay is the timeout time in milliseconds.
 *
 * @note The standard, clumsy, way to achieve the same result is to use select
 * with null file arguments, for long sleeps, with seconds resolution, sleep is
 * also available.
 */
void rtf_suspend_timed (int fd, int delay);

============
rtf_set_async_sig
============
/**
 * Activate asynchronous notification of data availability
 *
 * rtf_set_async_sig activate an asynchronous signals to notify data
 * availability by catching a user set signal signum.
 *
 * @param signum is a user chosen signal number to be used, default is SIGIO.
 *
 * @retval EINVAL if fd refers to a not opened fifo.
 */
void rtf_set_async_sig(int fd, int signum);

/**
 * @file
 *
 * FIFO semaphore functions.
 *
 * Fifos have an embedded synchronization capability, however using them only
 * for such a purpose can be clumsy. So RTAI fifos have binary semaphores for
 * that purpose. Note that, as for put and get fifos functions, only nonblocking
 * functions are available in kernel space.
 * 
 * <CENTER><TABLE>
 * <TR><TD> Called from RT task </TD><TD> Called from Linux process </TD></TR>
 * <TR><TD> #rtf_sem_init       </TD><TD> #rtf_sem_init             </TD></TR>
 * <TR><TD> #rtf_sem_post       </TD><TD> #rtf_sem_post             </TD></TR>
 * <TR><TD> #rtf_sem_trywait    </TD><TD> #rtf_sem_wait             <BR>
 *                                        #rtf_sem_trywait          <BR>
 *                                        #rtf_sem_timed_wait       </TD></TR>
 * <TR><TD> #rtf_sem_destroy    </TD><TD> #rtf_sem_destroy          </TD></TR>
 * </TABLE></CENTER>
 *
 * To add a bit of confusion (J), with respect to RTAI schedulers semaphore
 * functions, fifos semaphore functions names follow the POSIX mnemonics.
 *
 * It should be noted that semaphores are associated to a fifo for
 * identification purposes. So it is once more important to remember is that
 * in the user space side you address fifos through the file descriptor you get
 * at fifo device opening while in kernel space you directly address them by
 * their minor number.   So you will mate the fd  you get in user space by
 * @verbatim open(/dev/rtfxx,) @endverbatim to the integer @p xx youll use in
 * kernel space.
 */

============
rtf_sem_init
============
/**
 * Initialize a binary semaphore
 *
 * rtf_sem_init initializes a semaphore identified by the file descriptor or
 * fifo number @a fd_fifo.
 *
 * A fifo semaphore can be used for communication and synchronization between
 * kernel and user space.
 *
 * @param fd_fifo is a file descriptor returned by standard UNIX open in user
 * space while it is directly the chosen fifo number in kernel space. In fact
 * fifos semaphores must be associated to a fifo for identification purposes.
 * @param value is the initial value of the semaphore, it must be either 0 or
 * 1.
 *
 * rt_sem_init can be used both in kernel and user space.
 *
 * @retval 0 on success.
 * @retval EINVAL if @a fd_fifo refers to an invalid file descriptor or fifo.
 */
int rtf_sem_init (int fd_fifo, int value);

============
rtf_sem_destroy
============
/**
 * Delete a semaphore
 *
 * rtf_sem_destroy deletes a semaphore previously created with rtf_sem_init().
 *
 * @param fd_fifo is a file descriptor returned by standard UNIX open in user
 * space while it is directly the chosen fifo number in kernel space. In fact
 * fifos semaphores must be associated to a fifo for identification purposes.
 *
 * Any tasks blocked on this semaphore is returned in error and allowed to run
 * when semaphore is destroyed.
 *
 * rtf_sem_destroy can be used both in kernel and user space.
 *
 * @retval 0 on sucess.
 * @retval EINVAL if @a fd_fifo refers to an invalid file descriptor or fifo.
 */
int rtf_sem_destroy (int fd_fifo);

============
rtf_sem_post
============
/**
 * Posting (signaling) a semaphore.
 *
 * rtf_sem_post signal an event to a semaphore. The semaphore value is set to
 * one and the first process, if any, in semaphore's waiting queue is allowed to
 * run.
 *
 * @param fd_fifo is a file descriptor returned by standard UNIX open in user
 * space while it is directly the chosen fifo number in kernel space. In fact
 * fifos semaphores must be associated to a fifo for identification purposes.
 *
 * Since it is not blocking rtf_sem_post can be used both in kernel and user
 * space.
 *
 * @retval 0 on success.
 * @retval EINVAL if @a fd_fifo refers to an invalid file descriptor or fifo.
 */
int rtf_sem_signal (int fd_fifo);

============
rtf_sem_wait
============
/**
 * Take a semaphore.
 *
 * rtf_sem_wait waits for a event to be posted (signaled) to a semaphore. The
 * semaphore value is set to tested and set to zero.   If it was one
 * rtf_sem_wait returns immediately. Otherwise the caller process is blocked and
 * queued up in a priority order based on is POSIX real time priority.
 *
 * A process blocked on a semaphore returns when:
 * - the caller task is in the first place of the waiting queue and somebody
 *   issues a rtf_sem_post; 
 * - an error occurs (e.g. the semaphore is destroyed).
 *
 * @param fd is the file descriptor returned by standard UNIX open in user space
 * 
 * Since it is blocking rtf_sem_waitcannot be used both in kernel and user
 * space.
 *
 * @retval 0 on success.
 * @retval EINVAL if @a fd_fifo  refers to an invalid file descriptor or fifo.
 */
int rtf_sem_wait (int fd);


============
rtf_sem_trywait
============
/**
 * Take a semaphore, only if the calling task is not blocked.
 *
 * rtf_sem_trywait is a version of the semaphore wait operation is similar to
 * rtf_sem_wait() but it is never blocks the caller.   If the semaphore is not
 * free, rtf_sem_trywait returns immediately and the semaphore value remains
 * unchanged.
 *
 * @param fd_fifo is a file descriptor returned by standard UNIX open in user
 * space while it is directly the chosen fifo number in kernel space. In fact
 * fifos semaphores must be associated to a fifo for identification purposes.
 *
 * Since it is not blocking rtf_sem_trywait can be used both in kernel and user
 * space.
 *
 * @retval 0 on success.
 * @retval EINVAL if @a fd_fifo  refers to an invalid file descriptor or fifo.
 */
int rtf_sem_trywait (int fd_fifo);

============
rtf_sem_timed_wait
============
/**
 * Wait a semaphore with timeout
 *
 * rtf_sem_timed_wait is a timed version of the standard semaphore wait
 * call. The semaphore value is tested and set to zero. If it was one
 * rtf_sem_timed_wait returns immediately. Otherwise the caller process is
 * blocked and queued up in a priority order based on is POSIX real time
 * priority.
 *
 * A process blocked on a semaphore returns when:
 * - the caller task is in the first place of the waiting queue and somebody
 *   issues a rtf_sem_post;
 * - timeout occurs;
 * - an error occurs (e.g. the semaphore is destroyed).
 *
 * @param fd is the file descriptor returned by standard UNIX open in user
 * space. In case of timeout the semaphore value is set to one before return.
 * @param delay is in milliseconds and is relative to the Linux current time.
 *
 * Since it is blocking rtf_sem_timed_wait cannot be used both in kernel and
 * user space.
 *
 * @retval 0 on success.
 * @retval EINVAL if fd_fifo refers to an invalid file descriptor or fifo.
 */
int rtf_sem_timed_wait (int fd, int delay);


APPENDIX A

An overview of RTAI schedulers.

RTAI has a UniProcessor (UP) specific scheduler and two for MultiProcessors
(MP).   In the latter case you can chose between a  symmetricMultiProcessor
(SMP) and a MultiUniProcessor (MUP) scheduler.

The UP scheduler can be timed only by the 8254 timer and cannot be used with
MPs.

The SMP scheduler can be timed either by the 8254 or by a local APIC timer.
In SMP/8254 tasks are defaulted to work on any CPU but you can assign them to
any subset, or to a single CPU, by using the function
"rt_set_runnable_on_cpus".
It is also possible to assign any real time interrupt service to a specific cpu
by using "rt_assign_irq_to_cpu" and "rt_reset_irq_to_sym_mode".
Thus a user can statically optimize his/her application if he/she believes that
it can be better done than using a symmetric load distribution.
The possibility of forcing any interrupts to a specific CPU is clearly not
related to the SMP scheduler and can be used also with interrupt handlers
alone.
Note that only the real time interrupt handling is forced to a specific CPU.
That means that if you check this feature by using "cat /proc/interrupts" for a
real time interrupt that is chained to Linux, e.g. the timer when rtai_sched is
installed, you can still see some interrupts distributed to all the CPUs, even
if they are mostly on the assigned one.   That is because Linux interrupts are
kept symmetric by the RTAI dispatcher of Linux irqs.
For the SMP/APIC based scheduler if you want to statically optimize the load
distribution by binding tasks to specific CPUs it can be useful to use
"rt_get_timer_cpu()" just after having installed the timer, to know which CPU
is using its local APIC timer to pace the scheduler.   Note that for the
oneshot  case that will be the main timing CPU but not the only one.   In fact
which local APIC is shot depends on the task scheduling out, as that will
determine the next shooting.

SMP schedulers allow to chose between a periodic and a oneshot timer, not  to
be used together.    The periodic ticking is less flexible but, with the usual
PC hardware much more efficient. So it is up to you which one to choose in
relation to the applications at hand.
It should be noted that in the oneshot mode the time is measured on the base of
the CPU time stamp clock (TSC) and neither on the 8254 chip nor on the local
APIC timer, which are used only to generate oneshot interrupts.   The periodic
mode is instead timed by either the 8254 or the local APIC timers.
If the 8254 is used slow I/Os to the ISA bus are limited as much as possible
with a sizable gain in efficiency. The oneshot mode has just about 15-20% more
overhead than the periodic one.   The use of the local APIC timers leads to a
further improvement and substantially less jitter.
Remember that local APICs are hard disabled on UPs, unless you are using just
one CPU on an MP motherboard.   Experience with local APIC timers shows that
there is no performance improvement for a periodic scheduling, except for a
marginal reduced jitter, while the oneshot case gain is the sizable 10-15%
mentioned above.
In fact by using the TSC just two outb are required to reprogram the 8254, i.e.
approximately 3 us, against almost nothing for the APIC timer.
However you have to broadcast a message to all the CPUs in any case, and that
is at least about more than 3 us, the APIC bus is an open drain 2 wires one and
is not lightning like.
Note that the performance loss of the 8254 is just a fraction of the overall
task switching procedure, which is always substantially heavier in the oneshot
case than in periodic mode.
No doubt however that if you have an SMP motherboard, or a local APIC enabled
anyhow, you should use the APIC SMP scheduler.   Note however that in this case
we have chosen not to bound the timer to a specific CPU.   Nonetheless, as
recalled above, you can still optimise the static binding of your task by using
the function "rt_get_timer_cpu()" which allows you to know which local APIC is
timing your application so that you can "rt_set_runnable_on_cpus" any task
accordingly.
See README in "smpscheduler".

Since the TSC is not available on 486 machines for them we use a form of
emulation of the "read time stamp clock" (rdtsc) assembler instruction based on
counter2 of the 8254. So you can use RTAI also on such machines.   Be warned
that the oneshot timer on 486 is a performance overkill because of the need of
reading the tsc, i.e. 8254 counter2 in this case, 2/3 times.   That can take 6-
8 us, i.e. more than it takes for a full switch among many tasks while using a
periodic timer.   Thus only a few khz period is viable, at most, for real time
tasks if you want to keep Linux alive.
No similar problems exist for the periodic timer that needs not to use any TSC
at all. So, compared to the 20% cited above, the real time performance ratio of
the oneshot/periodic timer efficiency ratio can be very low on 486 machines.
Moreover it will produce far worse jitters than those caused on Pentiums and
upward machines.   If you really need a oneshot timer buy at least a Pentium.
Instead, for a periodic timing 486s can still be more than adequate for many
applications.

The MUP scheduler instead derives its name by the fact that real time tasks
MUST be bound to a single CPU at the very task initialization.   They can be
afterward moved by using functions rt_set_runnable_on_cpus and
rt_set_runnable_on_cpuid.   The MUP scheduler can however use inter CPUs
services related to semaphores, messages and mailboxes.   The advantage of
using the MUP scheduler  comes mainly from the possibility of using mixed
timers simultaneously, i.e. periodic and oneshot, where periodic timers can be
based on different periods, and of possibly forcing critical task on the CPU
cache.
With dual SMP machines we cannot say that there is a noticeable difference in
efficiency.
MUP has been developed primarily for our, not so fast, a few khz, PWM
actuators, BANG-BANG air jet thrusters, coupled to a periodic scheduler.
All the functions of UP and SMP schedulers are available in the MUP scheduler.

APPENDIX B0

Pierre Cloutiers: How does LXRT works?

This one pager is an attempt to explain conceptually how LXRT works.   It does
not try to get into the nifty gritty details of the implementation but it tries
to explain how the context of execution switches between Linux and RTAI.

But first, what are we trying to do?

LXRT provides a family of real time scheduler services that can be used by both
real time RTAI tasks and Linux tasks.   To keep things simple for the
programmer the implementation is fully symmetric.   In other words, the same
function calls are used in both the kernel and user space.

What are those real time scheduler services?

RTAI provides the standard services like resume, yield, suspend, make periodic,
wait until etc.   You will also find semaphores, mail boxes, remote procedure
calls, send and receive primitives integrated into the state machine of the
real time scheduler.   Typically, the IPC function calls support:

            . Blocking until the transaction occurs.
            . Returning immediately if the other end is not ready.
            . Blocking for the transaction until a timeout occurs.

How do I setup my Linux program for LXRT?

You call rt_task_init( name, ...).   The call differs from the real time
counterpart (there are a few exceptions to the symmetry rule) in that, among
other things, you provide a name for your program.   The name must be unique
and is registered by LXRT.   Thus, other programs, real time or not, can find
the task pointer of your program and communicate with it.

LXRT creates a real time task who becomes the "angel" of your program.   The
angel's job is to execute the real time services for you.   For example, if you
call rt_sleep(...), LXRT will get your angel to execute the real rt_sleep()
function in the real time scheduler.   Control will return to your program when
the angel returns from rt_sleep().

With LXRT, can a Linux task send a message to a real time task?

Yes. You simply use the rt_send(...) primitive that you would normally use in
the code of a kernel program. LXRT gets your angel to execute rt_send(...).
Control returns to your program when the target task  completes the
corresponding rt_receive(...) call.

What happens when I send a message to another user space program?

Well, pretty much the same thing except that you now have two angels talking to
each other...

Can a real time task also register a name with LXRT?

Yes. The call rt_register( name, ...) does that.   Thus, other programs, real
time or not, can find the task pointer of your program and communicate with it.

Where do I put the code for the "angels"?

There is not any code required for the real time component of your Linux
task.   LXRT uses the standard RTAI scheduler functions for that.   In the QNX
world, the "angel" is called a virtual circuit.

How does it work from the point of view of a user space program?

The inline functions declared in rtai_lxrt.h all do a software interrupt (int
0xFC).   Linux system calls use the software int 0x80.   Hence the approach is
similar to a system call. LXRT sets the interrupt vector to call
rtai_lxrt_handler(void), a function that saves everything on the stack, changes
ds and es to __KERNEL_DS and then calls lxrt_handler, the function that does
the work.

lxrt_handler(...) extracts the first argument from user space and decides what
to do from the service request number srq.   For real time services,
lxrt_resume(...) is called with the scheduler function address pointer fun,
the number of remaining arguments, a pointer to the next argument, a service
type argument, and the real time task pointer.   lxrt_resume(...) will do what
is necessary to change the context of execution to RTAI and transfer execution
to the specified function address in the real time scheduler.

lxrt_resume(...) first copies the other arguments on the stack of the real time
task.   Any required data is also extracted from user space and copied into
rt_task->msg_buf.   At this point, the addresses of three functions are stored
above stack_top (LXRT made sure this wizardry would be possible when it first
created the real time task):

            top-1 lxrt_suspend(...)
            top-2 fun(...)
            top-3 lxrt_global_sti(...)

The stack is changed to point to top-3, global interrupts are disabled and and
the context of execution is switched to RTAI with the call to LXRT_RESUME
(rt_task).   RTAI executes lxrt_global_sti(...), fun(...), and eventually
lxrt_suspend(...).   Remember that fun(...) is a RTAI scheduler function like,
for example, rt_rpc(...).   At this point, fun(...) may or may not complete.

The easy way back to user space - fun(...) completes immediately:

RTAI enters function lxrt_suspend(...) that sets the real time task status to 0
and calls rt_schedule().   The context of execution is eventually switched back
to Linux and the system call resumes after LXRT_RESUME(rt_task).   Data for
mail boxes is copied to user space and a jump to ret_from_intr() is made to
complete the system call.

The long way back to user space - fun(...) cannot completed immediately:

RTAI schedules Linux to run again and the state of the real time task is non
zero, indicating it is held. Therefore, the system call cannot return to user
space and must wait.   So it sets itself TASK_INTERRUPTIBLE and calls the Linux
scheduler.

Eventually fun(...) completes and RTAI enters function lxrt_suspend(...) that
notices the system call is held. So RTAI pends a system call request to
instruct Linux to execute another system call whose handler is function
lxrt_srq_handler(void).   When Linux calls lxrt_srq_handler(), the original
system call is re-scheduled for execution and returns to user space as
explained above.

What happens to the registered resources if the Linux task crashes?

The "informed" version of LXRT has setup a pointer to a callback function in
the do_exit() code of the Linux kernel.   The callback is used to free the
resources that where registered by the real time task.   It also deletes the
real time task and unblocks any other task that may have been SEND, RPC, RETURN
or SEM blocked on the real time task.

What about mail boxes?

The mail box IPC approach is connection less.   In other words, it is not
possible for a zombie real time task to detect that another task is MBX blocked
specifically for a message from him.   The solution here is to use the
rt_mbx_receive_timed() with a timeout value and verify the return value to
detect the error.

What about performance?

Intertask communications with LXRT are about 36% faster than with old FIFO's.
Testing Linux ó Linux communications with int size msg and rep's on a P233 I
got these numbers:

LXRT         12,000 cycles RTAI-0.9x :-)
LXRT         13,000 cycles RTAI-0.8
Fifo            19,000 cycles RTAI-0.8
Fifo new     22,300 cycles RTAI-0.8 10% more cycles, a lot more utilities (that
cause some overhead)
SRR           14,200 cycles QNX 4 Send/Receive/Reply implemented with a Linux
module without a real time executive.


APPENDIX B1

LXRT and hard real time in user space.

We provide hard real time services in user space, also for normal, i.e. non
root, users.   We think that it will not be as good a performer as kernel space
hard real time task modules, but a few microseconds more latency can be
acceptable for many applications, especially on most recent almost Ghz CPUs.
Many users will be glad with it for itself.   At the very least, it will be
useful in easing development and many other things: training, teaching and so
on.   It is wholly along the basic LXRT concept so we have seen it as an
extension to LXRT.

To get hard real time in user space you need a fully preemptable kernel.   The
question, within RTAI "philosophy", is how to get full preemption with minimum
changes, possibly none, to the kernel source.

The solution calls for a compromise.   We propose to accept that a hard real
time process does no Linux context kernel operations leading to a task
switch.   In that sense, it is better to speak of a "user space kernel module",
and we will use the two terms interchangeably.

The approach is similar to what one of us did when he was using QNX: he always
mated a hard real time tasks with a buddy for any I/O operation that could lead
to excessive delays.   In fact, even within such a good and fully preemptable
kernel, I/Os could lead to deadlines misses under heavy hard real time I/O load
from many hard real time tasks.   Many examples in this distribution, i.e.:
clocks, latency calibration and sound, show you a clear picture of how easy it
is to use kernel services by mating to a buddy server process, without any
problem.
So, at least on the base of our modest experience, that is not an unbearable
constraint.   Since RTAI has many good intertask services, we do not see any
problem in using the same approach again, especially in view of with what
Pierre has done, is doing and will do, to make it the "informed" way.

It is nonetheless possible that such a constraint will be somewhat lifted as
development proceed.   Moreover the user space approach does not forbid you to
do it in kernel space, if it is eventually needed.   In fact it is not seen as
a complete alternative to doing it in the kernel, but simply as a way of giving
you  more opportunities, at least during the development phase.   However the
more we use it the more we tend to avoid kernel space, as far as possible.

Taking into account that the present solution is somewhat still at the
beginning of its development, we see a lot of space for making it better.   For
sure it is simpler than the exhausting search of safe scattered kernel pre-
emption points many experts are looking at.

How is that possible?

We think that what you'll in RTAI-LXRT shows that it can work, even if it can
be improved.   The idea is to keep soft interrupts disabled for hard real time
user space modules.   This way, kernel module hard real time tasks and hard
real time interrupts can preempt user space modules, but user space modules
cannot be preempted neither by Linux hard interrupt nor by Linux processes.
Linux hardware interrupt are pended as usual for service when RTAI's real time
tasks (both in the kernel and user space) are idle.

How does it work?

Hard real time user space modules are just normal Linux processes that mate to
a special buddy hard real time kernel task module, as done under LXRT
already.   They must be POSIX real time Linux processes locked into memory
using SCHED_FIFO.   Thus their memory must be pre grown to its maximum
extension and completely locked in memory.   See Linux man pages for mlockall/
munlockall.
To distinguish them from usual LXRT firm real time processes the user simply
calls rt_make_hard_real_time(), whereas by using rt_make_soft_real_time() he/
she can return to standard Linux task switching.
Note that some of the required features, e.g POSIX real time under Linux,
require root permission.   However by using the function rt_allow_nonroot_hrt()
you are allowed to: make a process POSIX real time, lock the memory and do IO
operations, as a normal non root user.   It is nonetheless necessary that the
superuser "insmod"s the required modules (rtai, rtai_sched and lxrt).

The call to rt_make_hard_real_time allows to take a normal process out from the
Linux running queue by calling schedule() after having queued the task to a
bottom handler.   When the bottom handler runs, the task is scheduled as a hard
real time module by lxrt_schedule(), and Linux will not know of it, while
having it still in its process list.

Lxrt_schedule() is also set as the signal function to be called when returning
to the Linux context from a hard real time kernel space schedule, thus ensuring
preemption in any case.

Lxrt_schedule() clear the soft interrupt flags and mimics the Linux schedule()
function, with scheduling policy SCHED_FIFO, even from within interrupts.

To return to soft real time, rt_make_soft_real_time() does the opposite.

What it currently does:

There are some (not so) simple test processes that runs periodically and on
which scheduling latency is measured.   No doubt that it does something
different as by running the same tasks under the same load with plain LXRT the
latency goes as high as Linux 10 ms tick, compared to a 10/20 microseconds
under user space modules (preliminary rough measures) and load.   Note that
within this new context it is likely that you can use also Linux pthreads both
for soft and hard real time.
In fact pthreads are normal user processes in disguise, Xavier made a choice,
i.e. pthreads as cloned processes, that is good also for LXRT.
Other examples show interacting tasks at work, while the sound task gives an
idea of IOs from user space.

The experience gathered so far indicates that, despite the availability of more
processing power, under SMP the latency for the same background load can be
double/tripled with respect to UP.   That is likely due to cache trashing
caused by process switches and seems not to depend on the RTAI MP scheduler you
are using.   So it makes a larger jitter difference, with respect to working in
kernel space, using hard real time processes under SMP than under UP.
In fact under UP the jitter is roughly the same weather you are using user or
kernel space modules.

What it currently does not very quickly:

Lxrt_schedule() can schedule in and out plain Linux processes, but to do it
safely that must happen within Linux idle tasks.   Clearly when one tests under
heavy load the starting and ending of hard real time mode can be somewhat
sluggish.   In any case problems are just in starting  and ending, once user
space modules are in place they are fine.
The matter has been somewhat improved by forcing the scheduling weight of the
idle task, just four lines added/modified within the kernel.
We know that there can be other ways of doing it, but all what we could
conceive is likely to require heavy kernel modifications.   Once more we recall
that all our "philosophy" is to deplete the kernel with the slightest changes
possible to it, better if none.

Note that within lxrt.c we trapped the kernel sys call and interrupt enabling
to be sure that they are not called within hard real time user space modules.
Pierre has conceived the same thing as possible to be done directly in rtai.c,
as it can already trap all the reserved Linux traps, but no alternative handler
has been implemented yet.

The new additions to lxrt:

-  changed rtai_lxrt_handler to avoid ret_from_intr if returning from within a
hard real time process;

-  added macros my_switch_to(prev,next,last), loaddebug and function switch_to,
all copied from Linux;

-  added lxrt_schedule to schedule hard real time user space tasks among
themselves and to and from the Linux context, with soft flags disabled (cli()),
a lot of new data needed are found just above it, the name should self explain
them;

-  added function lxrt_do_steal to be run from the bh timer to schedule a new
hard real time process;

-  added the pointer rthal_enint to save the trapped trap rtahl.enint in order
to diagnose enable from within rt user space modules;

-  added lxrt_enint to actually do the above trapping;

-  added lxrt_sigfun to lxrt_schedule when getting back to Linux from the rtai
schedulers;

-  added steal_from_linux to make a Linux process a user space hard real time
module;

-  added give_back_to_linux to return a user space module to the Linux
processes;

-  added linux_syscall_handler to save the trapped Linux sys handler;

-  added lxrt_linux_syscall_handler to diagnose calls to sys from hard real
time processes;

-  print_to_screen to allow a safe printing of diagnosting messages from within
user space modules working in hard real time mode.

User functions:

-  print_to_screen(const char *format, ...): to safely print information and
diagnostic messages in hard real time user space modules;

-  void rt_make_soft_real_time(void): to return a hard real time user space
process to soft Linux POSIX real time;

-  void rt_make_hard_real_time(void): to make a soft Linux POSIX real time
process a hard real time LXRT process;

-  rt_allow_nonroot_hrt(void): to allow a non root user the make a process
Linux POSIX real time, lock process memory in ram and carry out IO operations
from user space.

Tests:

There is a wealth of examples to show extended lxrt operations, both in soft
and hard real time mode. They can be useful also in giving you some clues for
your applications.

Tests list:

-  single task (directory one);
-  two tasks   (directory two);
-  many tasks  (directory many);
-  many tasks  (directory forked);
-  many pthreads (directory threads);
-  latency calibration (directory latency_calibration);
-  sound test (directory sound);
-  digital clock with semaphores (directory sem_clock);
-  digital clock with messages (directory msg_clock).
-  task resumed from an interrupt handler (directory resumefromintr).
-  press test (directory pressa);
-  resume in user space directly from the timer interrupt handler(directory
resumefromint).

The possibility of using pthread_create to generate Linux processes is very
useful since it allows a task layout that is close to the structure of
modules.   That could make it easier the translation to kernel modules for
maximum performances.   Also to be remarked is the possibility of resuming user
space modules directly from interrupt handlers, see example reseumefromint.

If you want to check the jitter while one of the clocks or the sound example
are running, you should enter the latency_calibration directory under another
screen and type "./rt_process 1 &" followed by "./check".   Try it varying
Linux load.   Be carefull, you must end it before closing the clocks/sound
tests, see a more detailed comment within README in latency_calibration
directory.

Have a look at the README files in each directory for more information.

It is important to remark that what is found under this directory can be used
for any application but it is intended mainly for development work.   It will
be soon ported to lxrt-informed for a safer production use.
Thus it is remarked that you must install a SIGINT handler if you want to
safely terminate your LXRT processes, cleaning up any RTAI resource they use,
after Ctrl-C.   Some examples show how it can be done.
We remind once more that what you find in directory lxrt is the final
development version, the related production version is in lxrt-informed.
It may happen that under this directory you can find features not yet ported in
lxrt-informed.   It will likely be so for a very short time.   So take care of
abnormal terminations yourself or wait for help from lxrt-informed.

APPENDIX C

A general overview of RTAI fifos.

The new fifo implementation for RTAI maintains full compatibility with the
basic services provided by its original NMT-RTL counterpart while adding many
more.

It is important to remark that even if RTAI fifo APIs appears as before the
implementation behind them is based on the mailbox concepts, already available
in RTAI and symmetrically usable from kernel modules and Linux processes.   The
only notable difference, apart from the file style API functions to be used in
Linux processes, is that on the module side you always have only non blocking
put/get, so that any different policy should be enforced by using appropriate
user handler functions.

With regard to fifo handlers it is now possible to install also one with a
read/write argument (read 'r', write 'w'). In this way you have a handler that
can know what it has been called for.   It is useful when you open read-write
fifos or to check against miscalls.
For that you can have a handler prototyped as:

            int x_handler(unsigned int fifo, int rw);

that can be installed by using:

            rtf_create_handler(fifo_numver, X_FIFO_HANDLER(x_handler).

see rtai_fifos.h for the X_FIFO_HANDLER macro definition.
The handler code is likely to be a kind of:

            int x_handler(unsigned int fifo, int rw);
            {
                        if (rw == 'r') {
                                   // do stuff for a call from read and return
appropriate value.
                        } else {
                                   // do stuff for a call from write and return
appropriate value.
                        }
            }

Even if fifos are strictly no more required in RTAI, because of the
availability of LXRT and LXRT-INFORMED, they are kept both for compatibility
reasons and because they are very useful tools to be used to communicate with
interrupt handlers, since they do not require any scheduler to be installed.
In this sense you can see this new implementation of fifos as a kind of
universal form of device drivers, since once you have your interrupt handler
installed you can use fifo services to do all the rest.

However the new implementation made it easy to add some new services.   One of
these is the possibility of using asyncronous signals to notify data
availability by catching a user set signal.   It is implemented in a standard
way, see the function:

rtf_set_async_sig(int fd, int signum) (default signum is SIGIO);

and standard Linux man for fcntl and signal/sigaction, while the others are
specific to this implementation.

A complete picture of what is available can be obtained from a look at
rtai_fifos.h prototypes.

It is important to remark that now fifos allows multiple readers/writers so the
select/poll mechanism to synchronize with in/out data can lead to unexpected
blocks for such cases.   For example: you poll and get that there are data
available, then read/write them sure not to be blocked, meanwhile another user
gets into and stoles all of your data, when you ask for them you get blocked.

To avoid such problems you have available the functions:

            rtf_read_all_at_once(fd, buf, count);

that blocks till all count bytes are available;

rtf_read_timed(fd, buf, count, ms_delay);

            rtf_write_timed(fd, buf, count, ms_delay);

that block just for the specified delay in milliseconds but are queued in real
time Linux process priority order.   If ms_delay is zero they return
immediately with all the data they could get, even if you did not set
O_NONBLOCK at fifo opening.
So by mixing normal read/writes with their friends above you can easily
implement blocking, non blocking and timed IOs.   They are not standard and so
not portable, but far easy to use then the select/poll mechanism.
The standard llseek is also available but it is equivalent to calling
rtf_reset, whatever fifo place you point at in the call.

For an easier timing you have available also:

            rtf_suspend_timed(fd, ms_delay).

To make them easier to use, fifos can now be created by the user at open
time.   If a fifo that does not exist already is opened, it is created with a
1K buffer.   Any following creation on modules side resizes it without any loss
of data.   Again if you want to create a fifo from the user side with a desired
buffer size you can use:

            rtf_open_sized(const char *dev, perm, size).

Since they had to be there already to implement our mailboxes we have made
available also binary semaphores.   They can be used for many things, e.g. to
synchronize shared memory access without any scheduler installed and in place
of using blocking fifos read/writes with dummy data, just to synchronize.
The semaphore services available are:

            rtf_sem_init(fd, init_val);

            rtf_sem_wait(fd);

            rtf_sem_trywait(fd);

            rtf_sem_timed_wait(fd, ms_delay);

            rtf_sem_post(fd);

            rtf_sem_destroy(fd);

Note that fd is the file descriptor, a semaphore is always associated to a fifo
and you must get a file descriptor by opening the corresponding fifo.

Naturally the above functions are symmetrically available in kernel space but,
except for init and create, only for the nonblocking services, i.e: trywait and
post.

INDEX

C
count2nano..................................................... 29
count2nano_cpuid........................................... 29
F
free_RTirq..................................................... 73
N
nam2num....................................................... 85
nano2count..................................................... 29
nano2count_cpuid........................................... 29
next_period.................................................... 31
num2nam....................................................... 85
R
request_RTirq................................................ 73
rt_ack_irq...................................................... 69
rt_allow_nonroot_hrt...................................... 93
rt_assign_irq_to_cpu...................................... 72
rt_busy_sleep................................................. 32
rt_change_prio............................................... 24
rt_disable_irq................................................. 69
rt_drg_on_adr................................................ 91
rt_drg_on_name............................................. 91
rt_enable_irq.................................................. 69
rt_find_tasklet_by_id...................................... 98
rt_free_apic_timers........................................ 79
rt_free_global_irq........................................... 73
rt_free_linux_irq............................................. 74
rt_free_srq..................................................... 76
rt_free_timer.................................................. 78
rt_get_adr...................................................... 91
rt_get_cpu_time_ns........................................ 30
rt_get_inher_prio............................................ 24
rt_get_name................................................... 91
rt_get_task_state............................................ 17
rt_get_time.................................................... 30
rt_get_time_cpuid........................................... 30
rt_get_time_ns............................................... 30
rt_global_cli................................................... 67
rt_global_restore_flags................................... 68
rt_global_save_flags....................................... 68
rt_global_save_flags_and_cli.......................... 68
rt_global_sti................................................... 67
rt_insert_tasklet.............................................. 97
rt_insert_timer.............................................. 100
rt_isrpc.......................................................... 52
rt_linux_use_fpu............................................. 21
rt_make_hard_real_time................................. 92
rt_make_soft_real_time.................................. 92
rt_mask_and_ack_irq..................................... 69
rt_mbx_delete................................................ 56
rt_mbx_init............................................... 55; 90
rt_mbx_receive.............................................. 61
rt_mbx_receive_if.......................................... 63
rt_mbx_receive_timed.................................... 64
rt_mbx_receive_until...................................... 64
rt_mbx_receive_wp........................................ 62
rt_mbx_send.................................................. 57
rt_mbx_send_if.............................................. 59
rt_mbx_send_timed........................................ 60
rt_mbx_send_until.......................................... 60
rt_mbx_send_wp............................................ 58
rt_mount_rtai................................................. 80
rt_pend_linux_irq............................................ 75
rt_pend_linux_srq........................................... 77
rt_preempt_always......................................... 22
rt_preempt_always_cpuid............................... 22
rt_receive...................................................... 45
rt_receive_if.................................................. 46
rt_receive_timed............................................ 47
rt_receive_until.............................................. 47
rt_register...................................................... 91
rt_remove_tasklet........................................... 97
rt_remove_timer........................................... 100
rt_request_apic_timers................................... 79
rt_request_global_irq...................................... 73
rt_request_linux_irq........................................ 74
rt_request_srq................................................ 76
rt_request_timer................................. 78; 83; 84
rt_reset_irq_to_sym_mode............................. 72
rt_return........................................................ 53
rt_rpc............................................................ 49
rt_rpc_if........................................................ 50
rt_rpc_timed.................................................. 51
rt_rpc_until.................................................... 51
rt_sched_lock................................................. 23
rt_sched_unlock............................................. 23
rt_sem_delete................................................ 36
rt_sem_init............................................... 35; 89
rt_sem_signal................................................. 37
rt_sem_wait................................................... 38
rt_sem_wait_if............................................... 39
rt_sem_wait_timed......................................... 40
rt_sem_wait_until........................................... 40
rt_send.......................................................... 42
rt_send_if...................................................... 43
rt_send_timed................................................ 44
rt_send_until.................................................. 44
rt_set_oneshot_mode...................................... 26
rt_set_periodic_mode..................................... 26
rt_set_runnable_on_cpuid............................... 20
rt_set_runnable_on_cpus................................ 20
rt_set_timer_data......................................... 104
rt_set_timer_firing_time................................ 102
rt_set_timer_handler..................................... 103
rt_set_timer_period...................................... 102
rt_set_timer_priority..................................... 101
rt_shutdown_irq............................................. 69
rt_sleep.......................................................... 32
rt_sleep_until.................................................. 32
rt_startup_irq................................................. 69
rt_task_delete................................................ 11
rt_task_init................................................. 9; 88
rt_task_init_cpuid............................................. 9
rt_task_make_periodic.................................... 12
rt_task_make_periodic_relative_ns.................. 12
rt_task_suspend............................................. 15
rt_task_use_fpu............................................. 21
rt_task_wait_period........................................ 13
rt_task_yield.................................................. 14
rt_tasklet_delete............................................. 96
rt_tasklet_exec............................................... 98
rt_tasklet_init................................................. 96
rt_tasklets_use_fpu...................................... 105
rt_timer_delete............................................... 99
rt_timer_init................................................... 99
rt_typed_sem_init........................................... 34
rt_umount_rtai................................................ 80
rt_unmask_irq................................................ 69
rt_whoami...................................................... 18
rtai_free......................................................... 84
rtai_kfree....................................................... 84
rtai_kmalloc................................................... 83
rtai_malloc..................................................... 83
rtai_malloc_adr.............................................. 83
rtf_create..................................................... 108
rtf_create_handler........................................ 117
rtf_destroy................................................... 109
rtf_get......................................................... 114
rtf_open_sized.............................................. 108
rtf_put......................................................... 112
rtf_read_all_at_once.................................... 116
rtf_read_timed............................................. 115
rtf_reset....................................................... 110
rtf_resize..................................................... 111
rtf_sem_destroy................................... 120; 122
rtf_sem_init.......................................... 120; 121
rtf_sem_post........................................ 120; 123
rtf_sem_timed_wait.............................. 120; 126
rtf_sem_trywait.................................... 120; 125
rtf_sem_wait........................................ 120; 124
rtf_set_async_sig......................................... 119
rtf_suspend_timed........................................ 118
rtf_write_timed............................................ 113
S
send_ipi_logical.............................................. 71
send_ipi_shorthand......................................... 71
start_rt_apic_timer......................................... 28
start_rt_timer................................................. 27
stop_rt_apic_timer.......................................... 28
stop_rt_timer.................................................. 27

