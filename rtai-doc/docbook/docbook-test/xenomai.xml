<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" 
          "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<article>
  <articleinfo>
    <title>The XENOMAI project Implementing a RTOS emulation framework
      on GNU/Linux</title>
    <releaseinfo>First Edition</releaseinfo>
    <pubdate>January 2004</pubdate>
    <author>
      <firstname>Philippe</firstname>
      <surname>Gerum</surname>	
    </author>
    <corpauthor>Company name</corpauthor>
    <copyright>
      <year>2004</year>
    </copyright>
    
    <abstract>
      <para>Xenomai is a GNU/Linux-based framework which aims at being
      a foundation for a set of traditional RTOS API emulators
      running on top of a host software architecture, such as RTAI
      when hard real-time support is required.</para>

      <para>Generally speaking, this project aims at helping
      application designers relying on traditional RTOS to move as
      smoothly as possible to a GNU/Linux-based execution environment,
      without having to rewrite their application entirely.</para>

      <para>This paper discusses the motivations for proposing this
      framework, the general observations concerning the traditional
      RTOS directing this project, and some in-depth details about its
      undergoing implementation.</para>

      <para>The Xenomai project has been launched in August 2001. It
      is hosted by the <ulink
      url="http://freesoftware.fsf.org/projects/xenomai/">free
      software foundation.</ulink> </para>

      <para>Linux is a registered trademark of Linus Torvalds. Other
      trademarks cited in this paper are the property of their
      respective owner.</para>

      <para>&copy; 2002</para>

    </abstract>

    <legalnotice>
      <para>This is my legal notice that I put here... Be careful :
      this notice is legal!</para>
    </legalnotice>

  </articleinfo>


  <!-- ================================================================= -->
  <!-- ===                      THE WHITE-PAPER                     ==== -->
  <!-- ================================================================= -->

  <sect1 id="whitepaper" xreflabel="white paper">
    <title><phrase role="level1">White paper</phrase></title>

    <!-- ================================================================ -->
    <!-- ===                       Introduction                       === -->
    <!-- ================================================================ -->

    <sect2 id="introduction" xreflabel="introduction">
      <title><phrase role="level2">Introduction</phrase></title>

      <para>A simpler migration path from traditional RTOS to
      GNU/Linux can favour a wider acceptance of the latter as a
      real-time embedded platform. Providing emulators to mimic the
      traditional RTOS APIs is one of the initiative the free software
      community can take to fill the gap between the very fragmented
      traditional RTOS world and the GNU/Linux world, in order for the
      application designers relying on traditional RTOS to move as
      smoothly as possible to the GNU/</para>

      <para>There is a lack of common software framework for
      developing these emulators, whereas the behavioral similarities
      between the traditional RTOS are obvious.</para>

      <para>The Xenomai project aims at fulfilling this gap, by
      providing a consistent architecture-neutral and generic
      emulation layer taking advantage of these similarities. It is
      also committed to provide an increasing set of traditional RTOS
      emulators built on top of this layer.</para>

      <para>The Xenomai project relies on the common features and
      behaviors found between many embedded traditional RTOS,
      especially from the thread scheduling and synchronization
      standpoints. These similarities are exploited to implement a
      nanokernel exporting a set of generic services. These services
      grouped in a high-level interface can be used in turn to
      implement emulation modules of real-time application programming
      interfaces, which mimic the corresponding real-time kernel
      APIs.</para>

      <para>A similar approach was used for the <ulink
      url="http://freesoftware.fsf.org/projects/carbonkernel">CarbonKernel</ulink>
      project [1] in the simulation field, in which RTOS simulation
      models are built on top of a generic virtual RTOS based on
      event-driven techniques. </para>

    </sect2>

    <!-- ====================================================================== -->
    <!-- ===    Porting traditional RTOS-based applications to GNU/Linux    === -->
    <!-- ====================================================================== -->

    <sect2 id="porting-rtos"
	   xreflabel="porting traditional rtos-based applications to
	   GNU/Linux">
      <title>Porting traditional RTOS-based applications to GNU/Linux</title>

      <para>The idea of using GNU/Linux <note> <para> Ceci est une
      petite note sur GNU/Linux</para></note> as an embedded system
      with real-time capabilities is not novel. The reader can refer
      to Jerry Epplin's article in the October 97 issue of Embedded
      Systems Programming for a discussion about GNU/Linux potential
      in the embedded field [2].</para>

      <para>Throughout this document, we will use the expression
      <emphasis>source RTOS</emphasis> to indicate the traditional
      real-time operating from which the application is to be ported,
      and<emphasis>target OS</emphasis>to indicate GNU/Linux or any
      other free operating system to which the application could be
      ported.</para>

      <!-- ===           Limited high-level code modification             === -->
      <sect3 id="highlevel-code" xreflabel="limited
	     high-level code modification">
	<title><phrase role="level3">Limited high-level code modification</phrase></title>

	<para>Keeping the initial design and implementation of a hard
	real-time application when attempting to port it to another
	architecture is obviously of the greatest
	interest. Reliability and performance may have been obtained
	after a long, complex and costly engineering process one does
	not want to compromise. Consequently, the best situation is to
	have the closest possible equivalence between the source and
	destination RTOS programming interfaces, as far as both the
	syntax and the semantics are concerned.</para>

	<para>For instance, if the application needs dynamic memory
	allocation with success guarantee for its real-time threads
	(which is different from a real-time guarantee), porting it to
	a GNU/Linux hard real-time extension (such as RTAI or RTLinux)
	raises the following issues:

	<itemizedlist>

	    <listitem>
	      <para>Linux kernel's
	      <emphasis>kmalloc()/kfree()</emphasis> services should
	      ne be called on behalf of a real-time thread, since
	      these services are not reentrant.  Consequently, the
	      needed memory has to be pre-allocated statically or
	      during the application startup, on behalf of the Linux
	      kernel context.</para>
	    </listitem>

	    <listitem>
	      <para>A dynamic allocator callable from a real-time
	      context is provided by RTAI
	      (i.e. <emphasis>rt_mem_mgr</emphasis>), but its services
	      are based on an algorithm
	      <emphasis>anticipating</emphasis>the memory starvations
	      using an asynchronous pre-allocation technique, but
	      <emphasis>not guaranteeing</emphasis>that no failure
	      could occur. To give a reasonable guarantee of success
	      in allocating memory blocks, i.e. to be sure that valid
	      memory will always be returned to the real-time thread
	      as soon as it is available from the Linux kernel, the
	      calling thread should be put in a wait state until the
	      memory it has requested is available.</para>
	    </listitem>

	  </itemizedlist>

	</para>

	<para>In both cases, it may be necessary to adapt the memory
	management strategy according to these constraints, which
	could be quite difficult and error-prone task.</para>

	<para>Another example can be taken from the support of a
	priority inheritance protocol [3] by the mutual exclusion
	services. These services allow concurrent threads to protect
	themselves from race conditions that could occur into critical
	sections of code. The purpose of this discussion is not to
	argue whether relying on priority inheritance for resolving
	priority inversion problems is a major design flaw or a
	necessary safety belt for a real-time application, but only to
	emphasize that any cases, if this feature is used in the
	source RTOS, but not available from the target OS, the
	resource management strategy must be reevaluated for the
	application, since priority inversion risks will
	exists.</para>

      </sect3>

      <!-- ===               RTOS behavioral compatibility                === -->
      <sect3 id="rtos-compat" xreflabel="rtos behavioral
	     compatibility">
	<title>RTOS behavioral compatibility</title>

	<para>During the past years, major embedded RTOS, such as
	VRTX, VxWorks, pSOS+ and a few others, have implemented a
	real-time kernel behavior which has become a de facto
	standard, notably for thread scheduling, inter-thread
	synchronization, and asynchronous event management. To
	illustrate this, let us talk about a specific concern in the
	interrupt service management.</para>

	<para>A well-known behavior of such RTOS is to lock the
	rescheduling procedure until the outer interrupt service
	routine (or ISR) - called first upon possibly nested
	interrupts - has exited, after which a global rescheduling is
	finally stated. This way, an interrupt service routine
	can always assume that no synchronous thread activity may run
	until it has exited. Moreover, all changes impacting the
	scheduling order of threads, due to actions taken by any
	number of nested ISRs (e.g. signaling a synchronization object
	on which one or more threads are pending) are considered once
	and conjunctively, instead of disjunctively.</para>

	<para>For instance, if a suspended thread is first resumed by
	an ISR, then forcibly suspended later by another part of the
	same ISR, the outcome will be that the thread will not run,
	and remain suspended after the ISR has exited. In the other
	hand, if the RTOS sees ISRs as non-specific code that can be
	preempted by threads, the considered thread will be given the
	opportunity to execute immediately after it is resumed, until
	it is suspended anew. Obviously, the respective resulting
	situations won't be identical.</para>

      </sect3>

      <!-- ===          reevaluation of the real-time constraints         === -->
      <sect3 id="reevalutation"
	     xreflabel="Reevaluation of the real-time constraints">
	<title>Reevaluation of the real-time constraints</title>

	<para>Making GNU/Linux a hard real-time system is currently
	achieved by using a co-kernel approach which takes control of
	the hardware interrupt management, and allows running
	real-time tasks seamlessly aside of the hosting GNU/Linux
	system [4]. The 'regular' Linux kernel is eventually seen as a
	low-priority, background of the small real-time executive. The
	<ulink url="http://www.rtai.org">RTAI</ulink> and <ulink
	url="http://www.rtlinux.org">RTLinux</ulink>projects are
	representative of this technical path. However, this approach
	has a major drawback when it comes to port complex
	applications from a foreign software platform: since the
	real-time tasks run outside the Linux kernel control, the
	GNU/Linux programming model cannot be preserved when porting
	these applications. The result is an increased complexity in
	redesigning and debugging the ported code.</para>

	<para>In some cases, choosing a traditional RTOS to run an
	embedded application has been initially dictated by the memory
	constraints imposed by the target hardware, instead of actual
	real-time constraints imposed by the application itself. Since
	embedded devices tend to exhibit ever increasing memory and
	processing horsepower, it seems judicious to reevaluate the
	need for real-time guarantee when considering the porting
	effort to GNU/Linux on a new target hardware. This way, the
	best underlying software architecture can be selected. In this
	respect, the following, the following criteria need to be
	considered:

	<itemizedlist>

	    <listitem>
	      <para><emphasis>Determinism and
	      criticality.</emphasis></para><para>What is the worst
	      case interrupt and dispatch latencies needed
	      ?</para><para>Does a missed deadline lead to a
	      catastrophic failure ?</para>
	    </listitem>

	    <listitem>
	      <para><emphasis>Programming model</emphasis></para>
	      <para>What is the overall application complexity,
	      provided taht the highest the complexity, the greatest
	      the need for powerful debugging aid and monitoring
	      tools.</para>
	    </listitem>

	    <listitem>
	      <para>Is there a need need for low-level hardware
	      control ? </para> <para>Is the real-time activity
	      coupled to non real-time services, such as GUI or
	      databases, requiring sophisticated communications with
	      the non real-time world ?</para>
	    </listitem>

	  </itemizedlist>
	</para>
      </sect3>

      <!-- ===                   Some existing solutions                  === -->
      <sect3 id="existing-solutions" xreflabel="some existing
	     solutions">
	<title>Some existing solutions</title>

	<para>In order to get whether hard or soft real-time support,
	several GNU/Linux-based solutions exist [5][6]. It is not the
	purpose of this paper to present them all exhaustively. We
	will only consider a two fold approach based on free software
	solutions which is likely to be suited for many porting
	taskings, depending on the actual real-time constraints
	imposed by the application.</para>

	<!-- Partial rewriting using a real-time GNU/Linux extension -->
	<sect4 id="partial-rewriting" xreflabel="partial rewriting
	       using a rt linux extension">

	  <title>Partial rewriting using a real-time GNU/Linux
	  extension</title>

	  <para><emphasis>Real-time enabling GNU/Linux using
	  RTAI.</emphasis>Strictly speaking Linux/RTAI [7] is not a
	  real-time operating system but rather a real-time Linux
	  kernel extension, which allows running real-time tasks
	  seamlessly aside of the hosting GNU/Linux system. The RTAI
	  co-kernel is hooked to the hosting GNU/Linux through an
	  hardware abstraction layer (HAL) which redirects external
	  events to it, thus ensuring low interrupt latencies. RTAI
	  provides a fixed-priority driver scheduler to run concurrent
	  real-time activities loaded from dynamic kernel
	  modules. Globally-scoped scheduling decisions are made by
	  the co-kernel which always considers the host Linux kernel
	  as its lowest-priority thread of activity. In other words,
	  RTAI considers the Linux kernel as a background task that
	  should run when no real-time activity occurs, a kind of idle
	  task for common RTOS. RTAI provides a wealth of other useful
	  services, including counting semaphores, POSIX 1003.1-1996
	  facilities such as pthreads, mutexes and condition
	  variables, also adding remote procedure call facility,
	  mailboxes, and precision timers.</para>

	  <para>Moreover, RTAI provides a mean to execute hard
	  real-time tasks in user-space context, but still outside the
	  Linux kernel control, which is best described as running
	  'user-space kernel modules'. This feature, namely LXRT, is a
	  major step toward a simpler migration path from traditional
	  RTOS, since programming errors occuring within real-time
	  tasks don't jeopardize the overall GNU/Linux system sanity,
	  at the expense of a few microseconds more latency.</para>

	  <para><emphasis>Ad hoc serices emulation.</emphasis>A first
	  approach consists in emulating each real-time facility
	  needed by the application using a combination of the RTAI
	  services. An ad hoc wrapping interface has to be written to
	  support the needed function calls. The benefit of the
	  wrapping approach lies in the limited modifications made to
	  the original code. However, some RTAI behaviors may not be
	  compliant with the source operating system's. For the very
	  same reason, conflicts between the emulated and native RTAI
	  services may occur in some way.</para>

	  <para><emphasis>Complete port to RTAI.</emphasis>A second
	  approach consists in fully porting the application natively
	  to RTAI. In such a case, RTAI facilities are globally
	  substituted from the facilities from the source RTOS. This
	  solution brings improved consistency at the expense of a
	  possible large-scale rewriting of the application, due to
	  some fundamental behavioral differences that may exist
	  between the traditional RTOS and RTAI.</para>

	</sect4>

	<sect4 id="uspace-emul"
	       xreflabel="unconstrained user-space emulations">
	  <title>Unconstrained user-space emulations</title>

	  <para>A few traditional RTOS emulators exists in the free
	  software world. There are generally designed on top of the
	  GNU/Linux POSIX 1003.1-1996 layer, and allow to emulate the
	  source RTOS API in a user-space execution context, under the
	  control of the Linux kernel.</para>

	  <para>One of the most proeminent effort in this area is the
	  Legacy2linux project [8]. This project, sponsored by
	  Montavista Software, aims at providing <citation>"a series
	  of Linux-resident emulators for various legacy RTOS
	  kernels."</citation>Just like Xenomai, <citation>these
	  emulators are designed to ease the task of porting legacy
	  RTOS code to an embedded Linux environment".</citation>Two
	  emulators are currenlty available from this project,
	  respectively mimicking the APIs of WindRiver's pSOS+ and
	  VxWorks real-time operating systems.</para>

	  <para>The benefits of this approach is mainly to keep the
	  development process in the GNU/Linux user-space environment,
	  instead of moving to a rather 'hostile' kernel/supervisor
	  mode context. This way, the rich set of existing tools such
	  as debuggers, code profilers, and monitors usable in this
	  context are immediatly available to the application
	  developer. Moreover, the standard GNU/Linux programming
	  model is preserved, allowing the application to use the full
	  set of of facilities existing in the user space (e.g. full
	  POSIX support, including inter-process communication). Last
	  but not least, programming errors occuring in this context
	  don't jeopardize the overall GNU/Linux system stability,
	  unlike what can happen if a bug is encountered on behalf of
	  a hard real-time RTAI task which could cause serious damages
	  to the running Linux kernel.
	  </para>

	  <para>However, we can see at least three problems in using
	  these emulators, depending on the application constraints:
	  </para>

	  <para><itemizedlist>

	      <listitem>
		<para>First, the emulated API they provide is usually
		incomplete for an easy port from the source RTOS. In
		other words, only a limited syntactic compatibility is
		available.</para>
	      </listitem>

	      <listitem>
		<para>Second, the exact behavior of the source RTOS is
		not reproduced for all the functional areas. In other
		words, the semantic compatibility might not be
		guaranteed.</para>
	      </listitem>

	      <listitem>
		<para>These emulators don't share any common code base
		for implementing the fundamental real-time behaviors,
		even so both pSOS+ and VxWorks share most of them. The
		resulting situation leads to redundant implementation
		efforts, without any benefit one can see in code
		mutualization.</para>
	      </listitem>

	      <listitem>
		<para>And finally, even combined to existing Linux
		kernel patches providing fixed-priority scheduling
		(Montavista's RTSched) and fine-grain kernel
		preemption (Ingo Molnar's Linux kernel patches for
		improved preemptability), these emulators cannot
		deliver hard real-time performance.</para>
	      </listitem>

	    </itemizedlist>
	</para>

	</sect4>
      </sect3>
    </sect2>

    <!-- ================================================================== -->
    <!-- ===                A common emulation framework                === -->
    <!-- ================================================================== -->

    <sect2 id="common-framework" xreflabel="a common
	   emulation framework">
      <title>A common emulation framework</title>

      <!-- ===             Common traditional RTOS behaviors              === -->
      <sect3 id="rtos-behaviors"
	     xreflabel="common traditional rtos behaviors">
	<title>Common traditional RTOS behaviors</title>

	<para>In order to build a generic and versatile framework for
	emulating traditional RTOS, we chose to concentrate on a set
	of common behaviors they all exhibit. A limited set of
	specific RTOS features which are not so common, but would be
	more efficiently implemented into the nanokernel than into the
	emulators, has also been retained. The basic behaviors
	selected cover four distinct fields:</para>


	<!-- Multi-threading -->
	<sect4 id="multi-threading" xreflabel="multi-threading">
	  <title>Multi-threading</title>

	  <para>Multi-threading provides the fundamental mechanism for
	  an application to control and react to multiple, discrete
	  external events. The nanokernel should provide the basic
	  multi-threading environment.</para>

	  <para><emphasis>Thread states.</emphasis> The nanokernel has
	  to maintain the current state of each thread in the
	  system. A state transition from one state to another may
	  occur as the result of specific nanokernel services called
	  by the RTOS emulator. The fundamental thread states that
	  should be defined are:</para>

	  <para><itemizedlist>

	      <listitem>
		<para>WAITING and SUSPENDED states are cumulative,
		meaning that the newly created thread will still
		remain in a suspended state after being resumed from
		the WAITING state.</para>
	      </listitem>

	      <listitem>
		<para>PENDING and SUSPENDED states are cumulative too,
		meaning that a thread can be forcibly suspended by
		another thread or service routine while pending on a
		synchronization resource (e.g. semaphore, message
		queue). In such a case, the resource is dispatched to
		it, but it remains suspended until explicitely resumed
		by the proper nanokernel service.</para>
	      </listitem>

	      <listitem>
		<para>PENDING and DELAYED states may be combined to
		express a timed wait on a resource. In such a case,
		the time the thread can be blocked is bound to a limit
		enforced by a watchdog.</para>
	      </listitem>

	    </itemizedlist>
	</para>

	  <para> <emphasis>Scheduling policies</emphasis>. By default,
	  threads are scheduled according to a fixed priority value,
	  using a preemptive algorithm. There must also be a support
	  for round-robin scheduling among a group of threads having
	  the same priority, allowing them to run during a given time
	  slice, in rotation. Moreover, each thread undergoing the
	  round-robin scheduling should be given an individual time
	  quantum.</para>

	  <para><emphasis>Priority management.</emphasis> It should be
	  possible to use whether an increasing or decreasing thread
	  priority ordering, depending on an initial configuration. In
	  other words, numerically highest priority values could
	  whether represent highest or lowest scheduling priorities
	  depending on the configuration choosen. This feature is
	  motivated by the existence of this two possible ordering
	  among traditional RTOS. For instance, VxWorks, VRTX, ThreadX
	  and Chorus O/S use a reversed priority management scheme,
	  where the highest the value, the lowest the priority. pSOS+
	  instead uses the opposite ordering, in which the highest the
	  value, the highest the priority.</para>

	  <para><emphasis>Running thread.</emphasis> At any given
	  time, the highest priority thread which has been ready to
	  run for the longuest time among the currently runnable
	  threads (i.e. not currently blocked by any delay or resource
	  wait) should be elected to run by the scheduler.</para>

	  <para><emphasis>Preemption.</emphasis> When preempted by a
	  more prioritary thread, the running thread should be put at
	  front of the ready thread queue waiting for the processor
	  resource, provided it has not been suspended or blocked in
	  any way. Thus it is expected to regain the processor
	  resource as soon as no other prioritary activity (i.e. a
	  thread having a higher priority level, or an interrupt
	  service routine) is eligible for running.</para>

	  <para>Manual round-robin.<emphasis></emphasis> As a
	  side-effect of attempting to resume an already runnable
	  thread or the running thread itself, this thread should be
	  moved at the end of its priority group in the ready thread
	  queue. This operation should be functionally equivalent to a
	  manual round-robin scheduling.</para>

	  <para>Even if they are not as widespread as those above in
	  traditional RTOS, the following features are also retained
	  for the sake of efficiency in the implementation of some
	  emulators:</para>

	  <para><emphasis>Priority inversion.</emphasis> In order to
	  provide support for preventing priority inversion when using
	  inter-thread synchronization services, the priority
	  inheritance protocol should be implemented.</para>

	  <para><emphasis>Signaling.</emphasis> A support for sending
	  signals to threads and running asynchronous service routines
	  to process them should be implemented. The asynchronous
	  service routine should run on behalf of the signaled thread
	  context the next time it returns from the nanokernel level
	  of execution, as soon as one or more signals are
	  pending.</para>

	  <para><emphasis>Disjunctive wait.</emphasis> A thread should
	  be able to wait in a disjunctive manner on multiple
	  resources. The nanokernel should unblock the thread when at
	  least one among the pended resources is available.</para>

	</sect4>

	<!-- Thread synchronization -->
	<sect4 id="thread-synchro" xreflabel="thread
	       synchronization">
	  <title>Thread synchronization</title>

	  <para>Traditional RTOS provide a large spectrum of
	  inter-thread communication facilities involving thread
	  synchronization, such as semaphores, message queues, event
	  flags or mailboxes. Looking at them closely, we can
	  define the characteristics of a basic mecanism which will be
	  usable in turn to build these facilities.</para>

	  <para><emphasis>Pending mode.</emphasis> The thread
	  synchronization facility should provide a mean for threads
	  to pend either by priority or FIFO ordering. Multiple
	  threads should be able to pend on a single resource.</para>

	  <para><emphasis>Priority inheritance protocol.</emphasis> In
	  order to prevent priority inversion problems, the thread
	  synchronization facility should implement a priority
	  inheritance protocol in conjunction with the thread
	  scheduler. The implementation should allow for supporting
	  the priority ceiling protocol as a derivative of the
	  priority inheritance protocol.</para>

	  <para><emphasis>Time-bounded wait.</emphasis> The thread
	  synchronization facility should provide a mean to limit the
	  time a thread waits for a given resource using a
	  watchdog.</para>

	  <para><emphasis>Forcible deletion.</emphasis> It should be
	  legal to destroy a resource while threads are pending on
	  it. This action should resume all waiters atomically.</para>

	</sect4>

	<!-- Interrupt management -->
	<sect4 id="it-management" xreflabel="interrupt management">
	  <title>Interrupt management</title>

	  <para>Since the handling of interrupts is one of the least
	  well defined areas in RTOS design, we will focus on
	  providing a generalized mechanism with sufficient hooks for
	  specific implementations to be built onto according to the
	  emulated RTOS flavour.</para>

	  <para><emphasis>Nesting.</emphasis> Interrupt management
	  code should be reentrant in order to support interrupt
	  nesting safely.</para>

	  <para><emphasis>Atomicity.</emphasis> Interrupts need to be
	  associated with dedicated service routines called ISRs. In
	  order for these routines not to be preempted by thread
	  execution, the rescheduling procedure should be locked until
	  the outer ISR has exited (i.e. in case of nested
	  interrupts).</para>

	  <para><emphasis>Priority.</emphasis> ISRs should always be
	  considered as prioritary over thread execution. Interrupt
	  prioritization should be left to the underlying
	  architecture.</para>

	</sect4>



	<!-- Time management -->
	<sect4 id="time-management" xreflabel="time management">
	  <title>Time management</title>

	  <para>Traditional RTOS usually represent time in units of
	  ticks. These are clock-specific time units and are usually
	  the period of the hardware timer interrupt, or a multiple
	  thereof.</para>

	  <para><emphasis>Software timer support.</emphasis> A
	  watchdog facility is needed to manage time-bound operations
	  by the nanokernel.</para>

	  <para><emphasis>Absolute and relative clock.</emphasis> The
	  nanokernel should keep a global clock value which can be set
	  by the RTOS emulator as being the system-defined
	  epoch.</para>

	  <para>Some RTOS like pSOS+ also provide support for
	  date-based timing, but conversion of ticks into conventional
	  time and date units is an uncommon need that should be taken
	  in charge by the RTOS emulator itself. </para>

	</sect4>
      </sect3>

      <!-- ===         An architecture-neutral abstraction layer          === -->
      <sect3 id="abstraction-layer" xreflabel="an
	     architecture-neutral abstraction layer">
	<title>An architecture-neutral abstraction layer</title>

	<para>After having selected the basic behaviors shared by
	traditional RTOS, we can implement them in a nanokernel
	exporting a few service classes. These generic services will
	then serve as a founding layer for developing each emulated
	RTOS API, according to their own flavour and semantics.</para>

	<para>In order for this layer to be architecture neutral, the
	needed support for hardware control and real-time capabilities
	will be obtained from an underlying host software
	architecture, through a rather simple standardized
	interface. Thus, porting the nanokernel to a new real-time
	architecture will solely consist in implementing this
	low-level interface for the target platform.</para>

      </sect3>

      <!-- ===                   Real-time capabilities                   === -->
      <sect3 id="rt-capabilities" xreflabel="real-time capabilities">
	<title>Real-time capabilities</title>

	<para>The host software architecture is expected to provide
	the primary real-time capabilities to the RTOS abstraction
	layer. Basically, the host real-time layer must handle at
	least the following tasks: </para>

	<para><itemizedlist>

	    <listitem>
	      <para>Start/stop dispatching on request the external
	      interrupts to an abstraction layer's specialized handler
	      ;</para>
	    </listitem>

	    <listitem>
	      <para>Provide a mean to mask and unmask interrupts ;
	      </para>
	    </listitem>

	    <listitem>
	      <para>Provide a mean to create new threads of control in
	      their simplest form ; </para>
	    </listitem>

	    <listitem>
	      <para>Provide support for a periodic interrupt source
	      used in timer management ; </para>
	    </listitem>

	    <listitem>
	      <para>Provide support for allocating chunks of
	      non-pageable memory.</para>
	    </listitem>

	  </itemizedlist>
	</para>

	<para>When the host software architecture has no direct access
	to the underlying hardware, such as in a soft real-time
	user-space execution environment, interrupts may be simulated
	by POSIX signals, and hard real-time constraints imposed to
	the services above may be relaxed (e.g. memory can be
	pageable). </para>

      </sect3>

      <!-- ===                           Benefits                         === -->
      <sect3 id="benefits" xreflabel="benefits">
	<title>Benefits</title>

	<para>The project described herein aims at helping application
	designers relying on traditional RTOS to move as smoothly as
	possible to a GNU/Linux-based execution environment, without
	having to rewrite their applications entirely. Aside of the
	advantages of using GNU/Linux as an embedded system, the
	benefits expected from the described approach are:</para>

	<para><emphasis>Reduced complexity in designing new RTOS
	emulations.</emphasis> The architecture-neutral abstraction
	layer provides the foundation for developing accurate
	emulations of traditional RTOS API, saving the burden of
	implementing each time their fundamental real-time
	behaviors. Since the abstraction layer also favours code
	sharing and mutualization, we can expect the RTOS emulations
	to take advantage of them in terms of code stability and
	reliability.</para>

	<para><emphasis>Generic support for RTOS-aware
	tools.</emphasis> One of the most potential show-stopper for a
	broader use of GNU/Linux in the real-time space is probably
	the lack of powerful and user-friendly debugging and
	monitoring tools for real-time applications. However, this gap
	is about to be filled by the maturation of tools like the
	Linux Trace Toolkit (LTT) [9] which now offers unprecedented
	capabilities for inspecting the dynamics of a running
	GNU/Linux system. Since a version of LTT is available for the
	'regular' Linux kernel and Linux/RTAI, the next step will be
	to take advantage of this toolkit, implementing the proper
	hooks to support it into the nanokernel internals and
	interface, in order to provide RTOS-aware tools as soon as
	possible.</para>

      </sect3>
    </sect2>

    <!-- ================================================================= -->
    <!-- ===                  The Xenomai approach                     === -->
    <!-- ================================================================= -->

    <sect2 id="xeno-approach" xreflabel="the xenomai approach">
      <title>The Xenomai approach</title>

      <!-- ===                    Xenomai architecture                    === -->
      <sect3 id="xeno-arch" xreflabel="xenomai architecture">
	<title>Xenomai architecture</title>

	<para>The common emulation framework precedently envisioned
	translates in the Xenomai architecture as follows:</para>

      </sect3>

      <!-- ===                 Host software architecture                 === -->
      <sect3 id="host-arch" xreflabel="host software
	     architecture">
	<title>Host software architecture</title>

	<para>Xenomai's nanokernel relies on an host software
	architecture to provide the needed hardware control and
	real-time capabilities. </para>

	<para>The nanokernel is connected to the host architecture
	through a standardized interface. The following services
	compose the nanokernel-to-real-time subsystem
	interface:</para>

	<informaltable>
	  <tgroup cols="2">
	    <tbody>

	      <row>
		<entry>xnarch_init</entry>
		<entry>Mount the real-time subsystem</entry>
	      </row>

	      <row>
		<entry>xnarch_exit</entry>
		<entry>Unmount the real-time subsystem</entry>
	      </row>

	      <row>
		<entry>xnarch_hook_irq</entry>
		<entry>Attach a handler to an interrupt line</entry>
	      </row>

	      <row>
		<entry>xnarch_release_irq</entry>
		<entry>Detach a handler from an interrupt</entry>
	      </row>

	      <row>
		<entry>xnarch_enable_irq</entry>
		<entry>Enable dispatching of an interrupt</entry>
	      </row>

	      <row>
		<entry>xnarch_disable_irq</entry>
		<entry>Disable dispatching of an interrupt</entry>
	      </row>

	      <row>
		<entry>xnarch_chain_irq</entry>
		<entry>Pass the interrupt request to the handler</entry>
	      </row>

	      <row>
		<entry>xnarch_start_timer</entry>
		<entry>Stop the periodic timer</entry>
	      </row>

	      <row>
		<entry>xnarch_stop_timer</entry>
		<entry>Stop the periodic timer</entry>
	      </row>

	      <row>
		<entry>xnarch_enter_realtime</entry>
		<entry>Switch current context to real-time</entry>
	      </row>

	      <row>
		<entry>xnarch_exit_realtime</entry>
		<entry>Switch current context to non real-time</entry>
	      </row>

	      <row>
		<entry>xnarch_init_stack</entry>
		<entry>Initialize a new thread's stack</entry>
	      </row>

	      <row>
		<entry>xnarch_save_fpu</entry>
		<entry>Save FPU registers for an outgoing thread</entry>
	      </row>

	      <row>
		<entry>xnarch_restore_fpu</entry>
		<entry>Restore FPU registers for an incoming thread</entry>
	      </row>

	      <row>
		<entry>xnarch_init_fpu</entry>
		<entry>Initialize a thread's FPU context</entry>
	      </row>

	      <row>
		<entry>xnarch_set_imask</entry>
		<entry>Set the global interrupt mask</entry>
	      </row>

	      <row>
		<entry>xnarch_sysalloc</entry>
		<entry>Allocate non-pageable memory</entry>
	      </row>

	      <row>
		<entry>xnarch_sysfree</entry>
		<entry>Free memory obtained from xnarch_sysalloc()</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Depending on the execution environment, some of the
	above services may be emulated or simply stubbed as soon as
	they are not needed. However, all of them are needed for
	porting the nanokernel on top of RTAI. For instance, the
	interrupt-related services can be emulated by the POSIX signal
	feature when running a combination of the nanokernel, the RTOS
	emulator and the (soft) real-time application as a user-space
	GNU/Linux process. In the same spirit, the real-time context
	switch routines have no purpose, thus can be empty in such
	environment. </para>

	<!-- Using RTAI as the host software architecture -->
	<sect4 id="rtai-softarch" xreflabel="using rtai as the
	       host software architecture">
	  <title>Using RTAI as the host software architecture</title>

	  <para>The Real-Time Application Interface (RTAI) is a
	  real-time GNU/Linux extension, which allows running
	  real-time tasks seamlessly aside of the hosting GNU/Linux
	  system. The RTAI co-kernel is hooked to the hosting system
	  through an hardware abstraction layer (HAL). RTAI considers
	  the Linux kernel as a background task that should run when
	  no real-time activity occurs. RTAI applications run in
	  supervisor mode, in the Linux kernel address space.</para>

	  <para>When running on top of RTAI, the Xenomai framework
	  gains hard real-time capabilities, replacing the standard
	  RTAI scheduler module (namely rtai_sched) in order to
	  provide the real-time scheduling subsystem. RTOS emulation
	  modules can then be loaded on top of Xenomai's nanokernel,
	  followed by a client application module using the emulated
	  API.</para>

	  <para>RTAI port of Xenomai is based on the facilities
	  provided by the core HAL module (namely rtai). The
	  nanokernel-to-host software architecture interface is
	  implemented using the real-time services exported by this
	  module. For instance, let us look to the implementation of
	  two critical functions, which respectively allow to enter
	  and exit the RTAI context, thus preempting then reinstating
	  the Linux kernel context.</para>

	  <para>From the file
	  <emphasis>xenomai/include/arch/rtai-386.h,</emphasis></para>

	  <programlisting>
		#define INTERFACE_TO_LINUX
		#include "asm/rtai_sched.h"
		#include "rtai.h"

		DEFINE_LINUX_CR0

		static inline void xnarch_enter_realtime () {
			rt_switch_to_real_time(0);
			save_cr0_and_clts(linux_cr0);
 		}

		static inline void xnarch_exit_realtime () {
			rt_switch_to_linux(0);
			restore_cr0(linux_cr0);
		}
	</programlisting>

	</sect4>

	<!-- Using the POSIX 1003.1-1996 layer as host software architecture -->
	<sect4 id="posix-arch" xreflabel="using posix layer
	       as the host software architecture">
	  <title>Using the POSIX 1003.1-1996 layer as the software
	  architecture</title>

	  <para>The aftermaths of the real-time constraints
	  reevaluation - that we suggest to conduct when considering a
	  port of a real-time application to a GNU/Linux system - may
	  lead to envision a user-space execution, since soft
	  real-time capabilities may be sufficient to support the
	  requirements.</para>

	  <para>In such a case, implementing the nanokernel-to-host
	  software architecture interface should be quite
	  straightforward. For instance, the thread-related services
	  can be mapped to the POSIX thread facility, and the periodic
	  timer can be obtained from the POSIX virtual timer
	  facility.</para>

	  <para>Combined to existing Linux kernel patches providing
	  fixed-priority scheduling and fine-grain kernel
	  preemptability, Xenomai's user-space execution may well
	  deliver the expected soft to firm real-time performance
	  needed while preserving the standard GNU/Linux programming
	  model.</para>

	</sect4>

	<!-- Using CarbonKernel to support Xenomai's Virtual Architecture -->
	<sect4 id="carbonkernel" xreflabel="using carbonkernel to
	support xenomai's va"> 
	  <title>Using CarbonKernel to support Xenomai's Virtual
	  Architecture</title>

	  <para>CarbonKernel is a RTOS simulator based on event-driven
	  simulation techniques. The main idea is to provide a
	  consistent framework for building simulation models which
	  mimic the behavior of real-time operating systems on a
	  workstation. The simulated RTOS kernels are built on top of
	  a generic virtual RTOS. CarbonKernel allows tracing the
	  execution of embedded software at source code level, running
	  in a single regular GNU/Linux process, with concurrent
	  target debugging capabilities, dynamic control of kernel
	  resources, UI simulation, and much more. In other words,
	  Xenomai can be thought as CarbonKernel's companion project,
	  the former providing support for emulating RTOS APIs on the
	  real target, whereas the latter simulates the RTOS APIs on a
	  GNU/Linux workstation.</para>

	  <para>Since CarbonKernel is a powerful tool for
	  understanding the dynamics of a real-time system, it is very
	  well suited for helping in the nanokernel and RTOS emulators
	  development. Moreover, it alleviates the burden of debugging
	  a complex software in a rather 'hostile' kernel environment,
	  especially in the first stages of its development. The idea
	  is to implement a trivial CarbonKernel simulation model
	  standing for a virtual architecture on top of which Xenomai
	  can run. This way, Xenomai's internals could be debugged
	  like mere application code running in a simulated
	  environment. </para>

	  <para>A RTOS simulation model (called a 'personality')
	  stacked on top of CarbonKernel is able to run, debug and
	  stress an embedded application using the RTOS' native
	  API. Simulating the RTOS behavior in a host-based
	  environment instead of emulating the machine code of the
	  target platform has a lot of advantages: it's faster, does
	  not require the cross-development tools, gives extended
	  debugging, monitoring and tracing features and provides an
	  easy way to stress the application under test with run-time
	  situations otherwise barely conceivable on a real
	  target. For instance, one can easily generate bursts of
	  simulated interrupts at a very unreasonable rate while still
	  being able to observe and analyze the resulting
	  situation.</para>

	  <para>Xenomai's Virtual Architecture (VA) is implemented as
	  a CarbonKernel model exporting a limited set of services
	  which provides a trivial thread management facility
	  (i.e. basically: creation, deletion, suspension,
	  resuming). The interrupt management is directly handled by
	  the CarbonKernel built-in simulation facilities, whilst raw
	  memory is obtained from the standard ANSI-C malloc
	  routines.</para>

	  <para>From the file
	  <emphasis>xenomai/include/arch/va.h,</emphasis></para>

	  <programlisting>
	#include "va/va.h" /* Include the VA model interface file */ 

	typedef struct xnarchtcb { /* Per-thread arch-dependent block */
	ckhandle_t vahandle; /* The underlying VA thread handle */
	void *cookie; /* XENO thread cookie passed on entry */ 
	int imask; /* Initial interrupt mask */
	 unsigned stacksize; /* Aligned size of stack (bytes) */
	 int *sp; /* Saved stack pointer - unused */
	 int *stackbase; /* Stack space - unused */
 	} xnarchtcb_t ;

	static inline void xnarch_switch_to (xnarchtcb_t *outtcb, xnarchtcb_t *intcb) {
		va_thread_resume(intcb->vahandle);
		va_thread_suspend(outtcb->vahandle);
	}
	</programlisting>

	  <para>Here is a snapshot of a CarbonKernel debug session
	  running the Xenomai's nanokernel on top of the Virtual
	  Architecture:</para>

	</sect4>
      </sect3>

      <!-- ===                   Nanokernel description                   === -->
      <sect3 id="nanokernel" xreflabel="nanokernel description">
	<title>Nanokernel description</title>

	<para>Xenomai's Virtual Architecture (VA) is implemented as a
	CarbonKernel model exporting a limited set of services which
	provides a trivial thread management facility (i.e. basically:
	Xenomai's nanokernel implements a set of generic services
	aimed at being a foundation for a set of RTOS API emulators
	running on top of a host software architecture. These services
	exhibit common traditional RTOS behaviors.</para>

	<para>RTOS emulations are software modules which connects to
	the nanokernel through the pod abstraction. Only one pod can
	be active at a given time on top of the host software
	architecture. The pod is responsible for the critical
	housekeeping chores, and the real-time scheduling of
	threads.</para>

	<!-- Using CarbonKernel to support Xenomai's Virtual Architecture -->
	<sect4 id="multi-threading-support" xreflabel="multi-threading
	       support">
	  <title>Multi-threading support</title>

	  <para> The nanokernel provides thread object (xnthread) and
	  pod (xnpod) abstractions which exhibit the following
	  characteristics:</para>

	  <para><itemizedlist>
	      <listitem>
		<para>Threads are scheduled according to a 32bit
		integer priority value, using a preemptive
		algorithm. Priority ordering can be increasing or
		decreasing depending on the pod configuration. </para>
	      </listitem>

	      <listitem>
		<para>A thread can be either waiting for
		initialization, forcibly suspended, pending on a
		resource, delayed for a count of ticks, ready-to-run
		or running.</para>
	      </listitem>

	      <listitem>
		<para>Timed wait for a resource can be bounded by a
		per-thread watchdog.</para>
	      </listitem>

	      <listitem>
		<para>The priority inheritance protocol is supported
		to prevent thread priority inversion when it is
		detected by a synchronization object.</para>
	      </listitem>

	      <listitem>
		<para>A group of threads having the same base priority
		can undergo a round-robin scheduling, each of them
		being given an individual time quantum.</para>
	      </listitem>

	      <listitem>
		<para>A support for sending signals to threads and
		running asynchronous service routines (ASR) to process
		them is built-in.</para>
	      </listitem>

	      <listitem>
		<para>FPU support can be optionally enabled or
		disabled for any thread at creation time.</para>
	      </listitem>

	      <listitem>
		<para>Each thread can enter a disjunctive wait on
		multiple resources.</para>
	      </listitem>

	    </itemizedlist>
	</para>

	  <informaltable>
	    <tgroup cols="2">
	      <tbody>
		<row>
		  <entry>xnpod_thread</entry>
		  <entry>Create a new thread (left suspended)</entry>
		</row>

		<row>
		  <entry>xnpod_delete_thread</entry>
		  <entry>Delete a thread</entry>
		</row>

		<row>
		  <entry>xnpod_start_thread</entry>
		  <entry>Start a newly created thread</entry>
		</row>

		<row>
		  <entry>xnpod_suspend_thread</entry>
		  <entry>Make a thread enter a suspended state</entry>
		</row>

		<row>
		  <entry>xnpod_resume_thread</entry>
		  <entry>Resume a thread from a suspended state</entry>
		</row>

		<row>
		  <entry>xnpod_unblock_thread</entry>
		  <entry>Unblock a thread waiting for a resource</entry>
		</row>

		<row>
		  <entry>xnpod_renice_thread</entry>
		  <entry>Change a thread's base priority</entry>
		</row>

		<row>
		  <entry>xnpod_boost_thread</entry>
		  <entry>Boost a thread's current priority (inheritance)</entry>
		</row>

		<row>
		  <entry>xnpod_lock_sched</entry>
		  <entry>Disable the rescheduling procedure</entry>
		</row>

		<row>
		  <entry>xnpod_unlock_sched</entry>
		  <entry>Re-enable the rescheduling procedure</entry>
		</row>

		<row>
		  <entry>xnpod_activate_rr</entry>
		  <entry>Enable the round-robin scheduling</entry>
		</row>

		<row>
		  <entry>xnpod_deactivate_rr</entry>
		  <entry>Disable the undergoing round-scheduling</entry>
		</row>

		<row>
		  <entry>xnpod_reschedule</entry>
		  <entry>Start the rescheduling procedure</entry>
		</row>

	      </tbody>
	    </tgroup>
	  </informaltable>

	</sect4>

	<!-- Basic synchronization support-->
	<sect4 id="synchro-support" xreflabel="basic
	       synchronization support">
	  <title>Basic synchronization support</title>

	  <para>The nanokernel provides a synchronization object
	  abstraction <emphasis>(xnsynch)</emphasis> aimed at
	  implementing the common behavior of RTOS resources, which
	  has the following characteristics:</para>

	  <para><itemizedlist>

	      <listitem>
		<para>Support for the priority inheritance protocol,
		in order to prevent priority inversion problems. The
		implementation is shared with the scheduler
		code.</para>
	      </listitem>

	      <listitem>
		<para>Support for time-bounded wait and forcible
		deletion with waiters awakening.</para>
	      </listitem>

	    </itemizedlist>
	</para>

	  <informaltable>
	    <tgroup cols="2">
	      <tbody>

		<row>
		  <entry>xnsynch_init</entry>
		  <entry>Initialize a synchronization object</entry>
		</row>

		<row>
		  <entry>xnsynch_destroy</entry>
		  <entry>Flush and destroy a synchronization object</entry>
		</row>

		<row>
		  <entry>xnsynch_block_thread</entry>
		  <entry>Make a thread pending on the resource</entry>
		</row>

		<row>
		  <entry>xnsynch_unblock_thread</entry>
		  <entry>Release a thread from pending on the resource</entry>
		</row>

		<row>
		  <entry>xnsynch_flush</entry>
		  <entry>Release all threads from pending on the resource</entry>
		</row>

		<row>
		  <entry>xnsynch_enter_pip</entry>
		  <entry>Make a thread own the resource</entry>
		</row>

		<row>
		  <entry>xnsynch_apply_pip</entry>
		  <entry>Prevent priority inversion (inheritance)</entry>
		</row>

		<row>
		  <entry>xnsynch_exit_pip</entry>
		  <entry>Release the ownership on the resource</entry>
		</row>

	      </tbody>
	    </tgroup>
	  </informaltable>

	</sect4>

	<!-- Interrupt management -->
	<sect4 id="irq-management" xreflabel="interrupt management">
	  <title>Interrupt management</title>

	  <para> Xenomai's nanokernel exhibits a split interrupt
	  handling scheme, in which interrupt handling is separated
	  into two parts. The first part is known as the Interrupt
	  Service Routine (ISR), the second being the Deferred Service
	  Routine (DSR). When an interrupt occurs, the ISR may be run
	  with interrupts disabled, thus it should run as quickly as
	  possible. To reduce this unpreemptable delay, lengthy
	  processing can be delegated by the ISR to an associated DSR
	  which will run later, outside the interrupt context, as soon
	  as all pending interrupts are processed. This scheme allows
	  for the DSRs to be run with interrupts enabled, thus
	  allowing other potentially higher priority interrupts to be
	  taken and processed.</para>

	  <para>This rather sophisticated scheme allows to easily
	  emulate virtually all RTOS interrupt handling scheme on top
	  of the nanokernel. Xenomai's interrupt-related services are
	  the following:</para>

	  <informaltable>
	    <tgroup cols="2">
	      <tbody>

		<row>
		  <entry>xnpod_enter_interrupt</entry>
		  <entry>Signal an ISR entry to the scheduler</entry>
		</row>

		<row>
		  <entry>xnpod_exit_interrupt</entry>
		  <entry>xnpod_exit_interrupt</entry>
		</row>

	      </tbody>
	    </tgroup>
	  </informaltable>
	</sect4>

	<!-- Timer and clock management -->
	<sect4 id="timer-clock" xreflabel="timer
	       and clock management">
	  <title>Timer and clock management</title>

	  <para>Xenomai's nanokernel measures time as a count of
	  periodic clock ticks. The periodic source is usually an
	  external interrupt controlled by the underlying host
	  architecture. Under RTAI/x86 for instance, the 8254 chip can
	  be programmed to generate a periodic interrupt which can be
	  hooked to a user-defined handler through the
	  <emphasis>rt_request_timer()</emphasis> service. Each
	  incoming clock tick is announced to the timer manager which
	  fires in turn the timeout handlers of elapsed timers. The
	  scheduler itself uses per-thread watchdogs to wake up
	  threads undergoing a bounded time wait, while waiting for a
	  resource availability or being delayed.</para>

	  <para>A special care has been taken to offer bounded
	  worst-case time for starting, stopping and maintaining
	  timers. The timer facility is based on the timer wheel
	  algorithm[11] described by Adam M. Costello and George
	  Varghese, which is implemented in the NetBSD operating
	  system for instance.</para>

	  <para>The nanokernel globally maintains three distinct time
	  values, all expressed in clock ticks:</para>

	  <itemizedlist>
	    <listitem>
	      <para>
The absolute number of elapsed ticks announced
	    since the nanokernel is running,</para></listitem>

	    <listitem><para>The last date set by a call to
	    xnpod_set_date(),</para></listitem>

	    <listitem><para>The number of clock ticks announced since the
	    last time the date was set.</para></listitem>
	  </itemizedlist>

	  <informaltable>
	    <tgroup cols="2">
	      <tbody>

		<row>
		  <entry>xnpod_tick_announce</entry>
		  <entry>Announce a new clock tick to the scheduler</entry>
		</row>

		<row>
		  <entry>xnpod_set_date</entry>
		  <entry>Set the system date (in ticks)</entry>
		</row>

		<row>
		  <entry>xnpod_get_date</entry>
		  <entry>Get the system date (in ticks)</entry>
		</row>

		<row>
		  <entry>xntimer_init</entry>
		  <entry>Initialize a timer</entry>
		</row>

		<row>
		  <entry>xntimer_destroy</entry>
		  <entry>Stop and destroy a timer</entry>
		</row>

		<row>
		  <entry>xntimer_start</entry>
		  <entry>Start a timer</entry>
		</row>

		<row>
		  <entry>xntimer_stop</entry>
		  <entry>Stop a timer</entry>
		</row>

		<row>
		  <entry>xntimer_do_tick</entry>
		  <entry>Signal an incoming clock tick to the timer manager</entry>
		</row>

	      </tbody>
	    </tgroup>
	  </informaltable>
	</sect4>

	<!-- Basic memory allocation -->
	<sect4 id="memory-allocation" xreflabel="basic
	       memory allocation">
	  <title>Basic memory allocation</title>

	  <para>Xenomai's nanokernel provides dynamic memory
	  allocation support with real-time guarantee, based on
	  McKusick's and Karels' proposal for a general purpose memory
	  allocator[10]. Any number of memory heaps can be maintained
	  dynamically by Xenomai, only limited by the actual amount of
	  system memory.</para>

	  <para>The memory chunks are obtained from the underlying
	  software architecture. As far as RTAI is concerned, the
	  memory pages composing the allocation heap are managed using
	  the <emphasis>kmalloc()/kfree()</emphasis> Linux kernel
	  routines. As soon as it is called on behalf of a real-time
	  thread, the allocator transparently switches to the Linux
	  kernel context using the RTAI-to-Linux service request
	  feature when needed
	  (i.e. <emphasis>rt_pend_linux_srq()</emphasis>). The
	  proposed services are synchronous to the calling
	  thread.</para>

	  <para>Memory-related services are the following:</para>

	  <informaltable>
	    <tgroup cols="2">
	      <tbody>
		<row>
		  <entry>xnheap_init</entry>
		  <entry>Initialize a new memory heap</entry>
		</row>

		<row>
		  <entry>xnheap_destroy</entry>
		  <entry>Destroy a memory heap</entry>
		</row>

		<row>
		  <entry>xnheap_alloc</entry>
		  <entry>Allocate a variable-size block of memory</entry>
		</row>

		<row>
		  <entry>xnheap_free</entry>
		  <entry>Free a block of memory</entry>
		</row>

	      </tbody>
	    </tgroup>
	  </informaltable>
	</sect4>
      </sect3>
    </sect2>

<!-- ================================================================= -->
<!-- ===            Emulating pSOS+ on top of Xenomai              === -->
<!-- ================================================================= -->

    <sect2 id="emulating-psos" xreflabel="emulating
	   psos on top of xenomai">
      <title>Emulating pSOS+ on top of Xenomai</title>

      <para>As a practical example explaining how traditional RTOS
      emulators can be built on top of Xenomai, let us have a brief
      look to details of the undergoing implementation of a <ulink
      url="http://freesoftware.fsf.org/projects/xenomai/emulators/psos4xeno/">pSOS+
      emulator</ulink>. </para>

      <para>Eight pSOS+ kernel call families are targeted:</para>

      <itemizedlist>

	<listitem>
	  <para>Task management,</para>
	</listitem>

	<listitem>
	  <para>Task signaling and synchronous service routines,</para>
	</listitem>

	<listitem>
	  <para>Timer management,</para>
	</listitem>

	<listitem>
	  <para>Counting semaphores,</para>
	</listitem>

	<listitem>
	  <para>Event flags synchronization,</para>
	</listitem>

	<listitem>
	  <para>Message queues,</para>
	</listitem>

	<listitem>
	  <para>Memory partition (fixed-size memory block allocator),</para>
	</listitem>

	<listitem>
	  <para>Memory region (variable-size memory block allocator).</para>
	</listitem>

      </itemizedlist>

      <para>The following code fragment shows the implementation of
      the t_create() service allowing to create a new pSOS+ task. One
      can observe that a few nanokernel calls are sufficient to obtain
      the basic support for the new task.</para>

    </sect2>
  </sect1>

  <sect1 id="autresection">
    <title>Autre section</title>
    <para>Mon petit paragraphe.</para>
  </sect1>
</article>
