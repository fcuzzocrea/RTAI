<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/asm-cris/rtai.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/asm-cris/rtai.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">Copyright (C) 2002,2003 Axis Communications AB</span>
00003 <span class="comment"></span>
00004 <span class="comment">Authors: Martin P Andersson (martin.andersson@linux.nu)</span>
00005 <span class="comment">         Jens-Henrik Lindskov (mumrick@linux.nu)</span>
00006 <span class="comment"></span>
00007 <span class="comment">This program is free software; you can redistribute it and/or modify</span>
00008 <span class="comment">it under the terms of version 2 of the GNU General Public License as</span>
00009 <span class="comment">published by the Free Software Foundation.</span>
00010 <span class="comment"></span>
00011 <span class="comment">This program is distributed in the hope that it will be useful,</span>
00012 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00013 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00014 <span class="comment">GNU General Public License for more details.</span>
00015 <span class="comment"></span>
00016 <span class="comment">You should have received a copy of the GNU General Public License</span>
00017 <span class="comment">along with this program; if not, write to the Free Software</span>
00018 <span class="comment">Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00019 <span class="comment"></span>
00020 <span class="comment">--------------------------------------------------------------------------</span>
00021 <span class="comment">Acknowledgements</span>
00022 <span class="comment">- Paolo Mantegazza      (mantegazza@aero.polimi.it)</span>
00023 <span class="comment">        creator of RTAI </span>
00024 <span class="comment">--------------------------------------------------------------------------</span>
00025 <span class="comment">*/</span>
00026 
00027 <span class="preprocessor">#ifndef _RTAI_ASM_CRIS_RTAI_H_</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_ASM_CRIS_RTAI_H_</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00031 
00032 <span class="comment">/* Just to make things compile */</span>
00033 
00034 <span class="preprocessor">#define smp_num_cpus 1</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_1_IPI  -1</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_2_IPI  -1</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_3_IPI  -1</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_4_IPI  -1</span>
00039 <span class="preprocessor"></span>
00040 <span class="comment">/* '8254' is used to maintain compatibility with generic code */</span>
00041 
00042 <span class="preprocessor">#define NR_RT_CPUS     1</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define hard_cpu_id()  0</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define TIMER_8254_IRQ 2 </span><span class="comment">/* Timer irq == 2 on ETRAX */</span>
00045 <span class="preprocessor">#define RT_TIME_END 0x7fffffffffffffffLL</span>
00046 <span class="preprocessor"></span>
00047 <span class="comment">/*</span>
00048 <span class="comment"> * unsigned long long multiplication</span>
00049 <span class="comment"> */</span>
00050 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullmul(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m0, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m1)
00051 {
00052         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> res;
00053 
00054         res = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)m0 * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)m1;
00055 
00056         <span class="keywordflow">return</span> res;
00057 }
00058 
00059 <span class="comment">/*</span>
00060 <span class="comment"> * unsigned long long division</span>
00061 <span class="comment"> */</span>
00062 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ulldiv(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ull, 
00063                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> uld, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *r)
00064 {
00065         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> q = ull/(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) uld;
00066 
00067         *r = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (ull - q * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) uld);
00068 
00069         <span class="keywordflow">return</span> q;       
00070 }
00071 
00072 <span class="comment">/*</span>
00073 <span class="comment"> * int multiplication and division</span>
00074 <span class="comment"> */</span>
00075 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> imuldiv(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mult, 
00076                           <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> div)
00077 {
00078         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> q , r;
00079         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> m;
00080 
00081         <span class="keywordflow">if</span> ( mult == div )
00082                 <span class="keywordflow">return</span> i;
00083 
00084         m = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) i * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) mult);
00085         q = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (m / (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) div);
00086         r = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (m - (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) q * 
00087                              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) div );
00088 
00089         <span class="keywordflow">return</span> (r + r) &lt; div ? q : q + 1;
00090 }
00091 
00095 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> llimd(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ull, 
00096                                        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mult, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> div)
00097 {
00098         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> low, high, q;
00099         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> r;
00100 
00101         low  = ullmul(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[0], mult);
00102         high = ullmul(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[1], mult);
00103         q = ulldiv(high,div,&amp;r) &lt;&lt; 32;
00104         high = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) r) &lt;&lt; 32;
00105         q += ulldiv( high + low, div , &amp;r);
00106         <span class="keywordflow">return</span> (r + r) &lt; div ? q : q + 1;
00107 }
00108 
00109 <span class="preprocessor">#ifdef __KERNEL__</span>
00110 <span class="preprocessor"></span>
00111 <span class="preprocessor">#ifndef __cplusplus</span>
00112 <span class="preprocessor"></span><span class="preprocessor">#include &lt;asm/irq.h&gt;</span>
00113 <span class="preprocessor">#include &lt;asm/timex.h&gt;</span>
00114 <span class="preprocessor">#include &lt;linux/kernel.h&gt;</span>
00115 <span class="preprocessor">#include &lt;asm/rtai_atomic.h&gt;</span>
00116 <span class="preprocessor">#include &lt;linux/spinlock.h&gt;</span>
00117 <span class="preprocessor">#endif </span><span class="comment">/* !__cplusplus */</span>
00118 
00119 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> r_timer_ctrl_shadow;
00120 
00121 <span class="comment">/* Interrupt flag is bit 5 on CRIS */</span>
00122 <span class="preprocessor">#define IFLAG 5</span>
00123 <span class="preprocessor"></span><span class="preprocessor">#define IMASK (1 &lt;&lt; IFLAG)</span>
00124 <span class="preprocessor"></span>
00125 <span class="comment">/* Both are needed by the generic code */</span>
00126 <span class="preprocessor">#define hard_save_flags_and_cli(x) hard_save_flags_cli((x))</span>
00127 <span class="preprocessor"></span>
00128 <span class="preprocessor">#define rt_spin_lock(lock)</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#define rt_spin_unlock(lock)</span>
00130 <span class="preprocessor"></span>
00131 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> hard_lock_all(<span class="keywordtype">void</span>)
00132 {
00133         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00134         hard_save_flags_cli(flags);
00135         <span class="keywordflow">return</span> flags;
00136 }
00137 
00138 <span class="preprocessor">#define hard_unlock_all(flags) hard_restore_flags((flags))</span>
00139 <span class="preprocessor"></span>
00140 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rt_spin_lock_irqsave(spinlock_t *lock)          
00141 {
00142         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00143         hard_save_flags_cli(flags);
00144         <span class="keywordflow">return</span> flags;
00145 }
00146 
00147 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_spin_unlock_irqrestore(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags,
00148                                              spinlock_t *lock)
00149 {
00150         hard_restore_flags(flags);
00151 }
00152 
00153 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_spin_lock_irq(<span class="keyword">volatile</span> spinlock_t *lock)          
00154 {
00155         hard_cli(); 
00156         rt_spin_lock(lock);
00157 }
00158 
00159 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_spin_unlock_irq(<span class="keyword">volatile</span> spinlock_t *lock)
00160 {
00161         rt_spin_unlock(lock);
00162         hard_sti();
00163 }
00164 
00165 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_cli(<span class="keywordtype">void</span>)
00166 {
00167         hard_cli();
00168 }
00169 
00170 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_sti(<span class="keywordtype">void</span>)
00171 {
00172         hard_sti();
00173 }
00174 
00175 <span class="comment">/*</span>
00176 <span class="comment"> * Save whether the IMASK was set or not in flags</span>
00177 <span class="comment"> */</span>
00178 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_save_flags(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *flags)
00179 {
00180         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> hflags;
00181 
00182         hard_save_flags(hflags);
00183 
00184         hflags = hflags &amp; IMASK; <span class="comment">/* The interrupts were enabled? */</span>
00185         
00186         *flags = hflags;
00187 }
00188 
00189 <span class="comment">/*</span>
00190 <span class="comment"> * Do cli and return whether the IMASK was set or not before</span>
00191 <span class="comment"> */</span>
00192 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_global_save_flags_and_cli(<span class="keywordtype">void</span>)
00193 {
00194         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00195 
00196         hard_save_flags_cli(flags);
00197 
00198         <span class="keywordflow">return</span> (flags &amp; IMASK);
00199 }
00200 
00201 <span class="comment">/*</span>
00202 <span class="comment"> * If interrupts are enabled in flags then enable them again</span>
00203 <span class="comment"> */</span>
00204 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_restore_flags(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags)
00205 {
00206         <span class="keywordflow">if</span> (flags &amp; IMASK){
00207                 hard_sti();
00208         }
00209         <span class="keywordflow">else</span>{
00210                 hard_cli();
00211         }
00212 }
00213 
00214 <span class="keyword">static</span> __inline__ <span class="keywordtype">void</span> set_bit_non_atomic(<span class="keywordtype">int</span> nr, <span class="keywordtype">int</span>* addr) 
00215 {
00216         *addr |= (1 &lt;&lt; nr);
00217 }
00218 
00219 <span class="keyword">static</span> __inline__ <span class="keywordtype">void</span> set_bit_atomic(<span class="keywordtype">int</span> nr, <span class="keywordtype">int</span>* addr) 
00220 {
00221         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00222         hard_save_flags_cli(flags);
00223         *addr |= (1 &lt;&lt; nr);
00224         hard_restore_flags(flags);
00225 }
00226 
00227 <span class="keyword">static</span> __inline__ <span class="keywordtype">void</span> clear_bit_non_atomic(<span class="keywordtype">int</span> nr, <span class="keywordtype">int</span>* addr)
00228 {
00229         *addr &amp;= ~(1 &lt;&lt; nr);
00230 }
00231 
00232 <span class="keyword">static</span> __inline__ <span class="keywordtype">void</span> clear_bit_atomic(<span class="keywordtype">int</span> nr, <span class="keywordtype">int</span>* addr)
00233 {
00234         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00235         hard_save_flags_cli(flags);
00236         *addr &amp;= ~(1 &lt;&lt; nr);
00237         hard_restore_flags(flags);
00238 }
00239 
00240 <span class="comment">/* </span>
00241 <span class="comment">--------------------------------------------------------------------------</span>
00242 <span class="comment">*/</span>
00243 
00244 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rtai_delay;     <span class="comment">/* Current timer divide factor on timer0 */</span>
00245 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> rtai_tsc; <span class="comment">/* timer0 ticks since we started counting*/</span>
00246 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rtai_lastcount; <span class="comment">/* Last read value on *R_TIMER0_DATA */</span>
00247 
00248 <span class="comment">/*</span>
00249 <span class="comment"> * ETRAX 100LX lacks a cycle counter.</span>
00250 <span class="comment"> * This does _NOT_ work if there is a process blocking the interrupts during </span>
00251 <span class="comment"> * more than one wrap of the timer.</span>
00252 <span class="comment"> * This is a very short time and a potential source of problems.</span>
00253 <span class="comment"> * ETRAX 100LX needs a bigger timer counter in hardware.</span>
00254 <span class="comment"> */</span>
00255 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> rdtsc(<span class="keywordtype">void</span>)
00256 {
00257         RTIME ts;
00258         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00259         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count, ticks;
00260 
00261 <span class="preprocessor">#ifdef CONFIG_ETRAX_DISABLE_CASCADED_TIMERS_IN_RTAI</span>
00262 <span class="preprocessor"></span>        <span class="comment">/* Read the 8 bit count value. */</span>
00263         count = *R_TIMER0_DATA;
00264 <span class="preprocessor">#else</span>
00265 <span class="preprocessor"></span>        <span class="comment">/* Read the 16 bit count value. */</span>
00266         count = *R_TIMER01_DATA;
00267 <span class="preprocessor">#endif</span>
00268 <span class="preprocessor"></span>        
00269         flags = hard_lock_all();
00270 
00271         <span class="comment">/* No timer wrap, just a count down.</span>
00272 <span class="comment">         * Read the timer interrupt to make sure, because the interrupts </span>
00273 <span class="comment">         * could be disabled at this moment.</span>
00274 <span class="comment">         * If the interrupts are disabled for to long this will fail. */</span>
00275         <span class="keywordflow">if</span> ( count &lt; rtai_lastcount &amp;&amp; 
00276              !(*R_VECT_READ &amp; IO_STATE(R_VECT_READ, timer0, active)) ){
00277                 ticks = rtai_lastcount - count;
00278         }
00279         <span class="comment">/* A timer wrap */</span>
00280         <span class="keywordflow">else</span> {
00281                 ticks = rtai_delay - rtai_lastcount + count;
00282         }
00283         rtai_lastcount = count;
00284         rtai_tsc += (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) ticks;
00285 
00286         ts = rtai_tsc;
00287         hard_unlock_all(flags);
00288 
00289         <span class="keywordflow">return</span> ts;
00290 }
00291 
00292 <span class="comment">/*</span>
00293 <span class="comment"> * Set the timer divide factor to delay if x=!0</span>
00294 <span class="comment"> * On cris we have a timer counter which wraps around by</span>
00295 <span class="comment"> * itself so there is nothing to do when delay==0.</span>
00296 <span class="comment"> * Some archs have to reprogram the timer every period,</span>
00297 <span class="comment"> * therefore this function can be called with 0</span>
00298 <span class="comment"> * We use both timers cascaded in this </span>
00299 <span class="comment"> */</span>
00300 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_set_timer_delay(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> delay)
00301 {
00302         <span class="keywordflow">if</span> (delay&lt;=0)
00303                 <span class="keywordflow">return</span>;
00304 
00305 <span class="preprocessor">#ifdef CONFIG_ETRAX_DISABLE_CASCADED_TIMERS_IN_RTAI</span>
00306 <span class="preprocessor"></span>        <span class="comment">/* 8 bit counter */</span>
00307         <span class="keywordflow">if</span> (delay&gt;255)
00308                 delay = 0;
00309 <span class="preprocessor">#else</span>
00310 <span class="preprocessor"></span>        <span class="comment">/* 16 bit counter */</span>
00311         <span class="keywordflow">if</span> (delay&gt;65535)
00312                 delay = 0;
00313 <span class="preprocessor">#endif</span>
00314 <span class="preprocessor"></span>                
00315         <span class="comment">/* So that no ticks are lost when the timer is reprogrammed. */</span>
00316         rdtsc();
00317 
00318 <span class="preprocessor">#ifdef CONFIG_ETRAX_DISABLE_CASCADED_TIMERS_IN_RTAI</span>
00319 <span class="preprocessor"></span>        <span class="comment">/* Clear the corresponding fields of the shadow. */</span>
00320         r_timer_ctrl_shadow = r_timer_ctrl_shadow &amp; (
00321                 ~IO_FIELD(R_TIMER_CTRL, timerdiv0, 255) &amp;
00322                 ~IO_STATE(R_TIMER_CTRL, tm0, reserved));
00323 
00324         <span class="comment">/* Stop the timers and load the new timerdiv0 and timerdiv1 */</span>
00325         *R_TIMER_CTRL = r_timer_ctrl_shadow              | 
00326                 IO_FIELD(R_TIMER_CTRL, timerdiv0, delay) | 
00327                 IO_STATE(R_TIMER_CTRL, tm0, stop_ld);
00328 
00329         <span class="comment">/* Restart the timer and save the changes to r_timer_ctrl_shadow */</span>
00330         *R_TIMER_CTRL = r_timer_ctrl_shadow = r_timer_ctrl_shadow | 
00331                 IO_FIELD(R_TIMER_CTRL, timerdiv0, delay)          | 
00332                 IO_STATE(R_TIMER_CTRL, tm0, run);
00333 <span class="preprocessor">#else</span>
00334 <span class="preprocessor"></span>        <span class="comment">/* Clear the corresponding fields of the shadow. */</span>
00335         r_timer_ctrl_shadow = r_timer_ctrl_shadow &amp; (
00336                 ~IO_FIELD(R_TIMER_CTRL, timerdiv1, 255) &amp;
00337                 ~IO_STATE(R_TIMER_CTRL, tm1, reserved)  &amp;
00338                 ~IO_FIELD(R_TIMER_CTRL, timerdiv0, 255) &amp;
00339                 ~IO_STATE(R_TIMER_CTRL, tm0, reserved));
00340 
00341         <span class="comment">/* Stop the timers and load the new timerdiv0 and timerdiv1 */</span>
00342         *R_TIMER_CTRL = r_timer_ctrl_shadow                     | 
00343                 IO_FIELD(R_TIMER_CTRL, timerdiv1, delay&gt;&gt;8)     | 
00344                 IO_STATE(R_TIMER_CTRL, tm1, stop_ld)            |
00345                 IO_FIELD(R_TIMER_CTRL, timerdiv0, 0xff &amp; delay) | 
00346                 IO_STATE(R_TIMER_CTRL, tm0, stop_ld);
00347 
00348         <span class="comment">/* Restart the timer and save the changes to r_timer_ctrl_shadow */</span>
00349         *R_TIMER_CTRL = r_timer_ctrl_shadow = r_timer_ctrl_shadow | 
00350                 IO_FIELD(R_TIMER_CTRL, timerdiv1, delay&gt;&gt;8)       | 
00351                 IO_STATE(R_TIMER_CTRL, tm1, run)                  |
00352                 IO_FIELD(R_TIMER_CTRL, timerdiv0, 0xff &amp; delay)   | 
00353                 IO_STATE(R_TIMER_CTRL, tm0, run);
00354 
00355 <span class="preprocessor">#endif</span>
00356 <span class="preprocessor"></span>                
00357         <span class="comment">/* Update the delays for use in rdtsc. */</span>
00358         rtai_delay = delay;
00359         rtai_lastcount = delay;
00360 }
00361 
00362 <span class="preprocessor">#ifdef CONFIG_ETRAX_DISABLE_CASCADED_TIMERS_IN_RTAI</span>
00363 <span class="preprocessor"></span><span class="preprocessor">#define FREQ_8254 25000 </span><span class="comment">/* 25 MHz with a prescale of 1000 (kernel &gt;=2.4.19) */</span>
00364 <span class="preprocessor">#else </span><span class="comment">/* !CONFIG_ETRAX_DISABLE_CASCADED_TIMERS_IN_RTAI */</span>
00365 <span class="preprocessor">#define FREQ_8254 6250000 </span><span class="comment">/* 25 MHz with a prescale of 4 */</span>
00366 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_ETRAX_DISABLE_CASCADED_TIMERS_IN_RTAI */</span>
00367 
00368 <span class="preprocessor">#define SETUP_TIME_8254 2800</span>
00369 <span class="preprocessor"></span><span class="preprocessor">#define LATENCY_8254    2800</span>
00370 <span class="preprocessor"></span><span class="preprocessor">#define CPU_FREQ        FREQ_8254</span>
00371 <span class="preprocessor"></span><span class="preprocessor">#define FREQ_APIC       FREQ_8254</span>
00372 <span class="preprocessor"></span>
00373 <span class="preprocessor">#define NR_GLOBAL_IRQS  NR_IRQS</span>
00374 <span class="preprocessor"></span><span class="preprocessor">#define NR_CPU_OWN_IRQS NR_GLOBAL_IRQS</span>
00375 <span class="preprocessor"></span>
00376 <span class="comment">/* Floating point related stuff. There are */</span>
00377 <span class="comment">/* no floating point registers on CRIS */</span>
00378 <span class="preprocessor">#define save_cr0_and_clts(x)</span>
00379 <span class="preprocessor"></span><span class="preprocessor">#define restore_cr0(x)</span>
00380 <span class="preprocessor"></span><span class="preprocessor">#define enable_fpu(x)</span>
00381 <span class="preprocessor"></span><span class="preprocessor">#define save_fpenv(x)</span>
00382 <span class="preprocessor"></span><span class="preprocessor">#define restore_fpenv(x)</span>
00383 <span class="preprocessor"></span>
00384 <span class="keyword">typedef</span> <span class="keyword">struct </span>cris_fpu_env { <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fpu_regs[1]; } FPU_ENV;
00385 
00386 <span class="comment">/* Need to be declared but can be empty */</span>
00387 <span class="preprocessor">#define DECLR_8254_TSC_EMULATION</span>
00388 <span class="preprocessor"></span><span class="preprocessor">#define TICK_8254_TSC_EMULATION</span>
00389 <span class="preprocessor"></span><span class="preprocessor">#define SETUP_8254_TSC_EMULATION</span>
00390 <span class="preprocessor"></span><span class="preprocessor">#define CLEAR_8254_TSC_EMULATION</span>
00391 <span class="preprocessor"></span>
00392 <span class="keyword">extern</span> <span class="keyword">struct </span>calibration_data tuned;
00393 <span class="keyword">struct </span>calibration_data {
00394         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpu_freq;
00395         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> apic_freq;
00396         <span class="keywordtype">int</span> latency;
00397         <span class="keywordtype">int</span> setup_time_TIMER_CPUNIT;
00398         <span class="keywordtype">int</span> setup_time_TIMER_UNIT;
00399         <span class="keywordtype">int</span> timers_tol[NR_RT_CPUS];
00400 };
00401 
00402 <span class="keyword">struct </span>apic_timer_setup_data {
00403         <span class="keywordtype">int</span> mode;
00404         <span class="keywordtype">int</span> count;
00405 };
00406 
00407 <span class="comment">/* FIX: Trap handling. This is not implemented in RTAI/CRIS yet. */</span>
00408 <span class="preprocessor">#define RTAI_NR_TRAPS 32</span>
00409 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> RT_TRAP_HANDLER rt_set_rtai_trap_handler(RT_TRAP_HANDLER handler)
00410 {
00411         <span class="keywordflow">return</span> (RT_TRAP_HANDLER) 0;
00412 }
00413 
00414 <span class="keyword">extern</span> <span class="keyword">struct </span>rt_times rt_times;
00415 
00416 <span class="preprocessor">#define ffnz(ul) (ffs(ul)-1)</span>
00417 <span class="preprocessor"></span>
00418 <span class="comment">/* </span>
00419 <span class="comment">--------------------------------------------------------------------------</span>
00420 <span class="comment">*/</span>
00421 
00422 <span class="preprocessor">#define rt_assign_irq_to_cpu(irq, cpu)</span>
00423 <span class="preprocessor"></span><span class="preprocessor">#define rt_reset_irq_to_sym_mode(irq)</span>
00424 <span class="preprocessor"></span>
00425 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_request_global_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>));
00426 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_free_global_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00427 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_ack_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00428 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_mask_and_ack_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00429 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_unmask_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00430 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rt_startup_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00431 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_shutdown_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00432 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_enable_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00433 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_disable_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00434 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_request_linux_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq,
00435        <span class="keywordtype">void</span> (*linux_handler)(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id, <span class="keyword">struct</span> pt_regs *regs),
00436        <span class="keywordtype">char</span> *linux_handler_id, <span class="keywordtype">void</span> *dev_id);
00437 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_free_linux_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id);
00438 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_request_srq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> label, <span class="keywordtype">void</span> (*rtai_handler)(<span class="keywordtype">void</span>), 
00439                           <span class="keywordtype">long</span> <span class="keywordtype">long</span> (*user_handler)(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> whatever));
00440 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_free_srq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srq);
00441 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_pend_linux_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00442 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_pend_linux_srq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srq);
00443 <span class="preprocessor">#define rt_request_cpu_own_irq(irq, handler) rt_request_global_irq((irq), (handler))</span>
00444 <span class="preprocessor"></span><span class="preprocessor">#define rt_free_cpu_own_irq(irq) rt_free_global_irq((irq))</span>
00445 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">void</span> rt_request_timer(<span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>), <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tick, 
00446                              <span class="keywordtype">int</span> apic);
00447 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__hal.html#a66">rt_free_timer</a>(<span class="keywordtype">void</span>);
00448 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_mount_rtai(<span class="keywordtype">void</span>);
00449 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_umount_rtai(<span class="keywordtype">void</span>);
00450 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_printk(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...);
00451 <span class="keyword">extern</span> <span class="keywordtype">int</span> rtai_print_to_screen(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...);
00452 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_switch_to_linux(<span class="keywordtype">int</span> cpuid);
00453 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_switch_to_real_time(<span class="keywordtype">int</span> cpuid);
00454 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_is_linux(<span class="keywordtype">void</span>);
00455 
00456 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00457 
00458 <span class="preprocessor">#define RTAI_DEFAULT_TICK    200000</span>
00459 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_DEFAULT_STACKSZ 1000</span>
00460 <span class="preprocessor"></span>
00461 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_ASM_CRIS_RTAI_H_ */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:02 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
