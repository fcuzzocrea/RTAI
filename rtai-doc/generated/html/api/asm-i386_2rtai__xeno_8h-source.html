<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/asm-i386/rtai_xeno.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/asm-i386/rtai_xeno.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 2001,2002,2003 Philippe Gerum &lt;rpm@xenomai.org&gt;.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Xenomai is free software; you can redistribute it and/or modify it</span>
00005 <span class="comment"> * under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> * (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Xenomai is distributed in the hope that it will be useful, but</span>
00010 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment"> * General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> * along with Xenomai; if not, write to the Free Software Foundation,</span>
00016 <span class="comment"> * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> * As a special exception, the RTAI project gives permission</span>
00019 <span class="comment"> * for additional uses of the text contained in its release of</span>
00020 <span class="comment"> * Xenomai.</span>
00021 <span class="comment"> *</span>
00022 <span class="comment"> * The exception is that, if you link the Xenomai libraries with other</span>
00023 <span class="comment"> * files to produce an executable, this does not by itself cause the</span>
00024 <span class="comment"> * resulting executable to be covered by the GNU General Public License.</span>
00025 <span class="comment"> * Your use of that executable is in no way restricted on account of</span>
00026 <span class="comment"> * linking the Xenomai libraries code into it.</span>
00027 <span class="comment"> *</span>
00028 <span class="comment"> * This exception does not however invalidate any other reasons why</span>
00029 <span class="comment"> * the executable file might be covered by the GNU General Public</span>
00030 <span class="comment"> * License.</span>
00031 <span class="comment"> *</span>
00032 <span class="comment"> * This exception applies only to the code released by the</span>
00033 <span class="comment"> * RTAI project under the name Xenomai.  If you copy code from other</span>
00034 <span class="comment"> * RTAI project releases into a copy of Xenomai, as the General Public</span>
00035 <span class="comment"> * License permits, the exception does not apply to the code that you</span>
00036 <span class="comment"> * add in this way.  To avoid misleading anyone as to the status of</span>
00037 <span class="comment"> * such modified files, you must delete this exception notice from</span>
00038 <span class="comment"> * them.</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * If you write modifications of your own for Xenomai, it is your</span>
00041 <span class="comment"> * choice whether to permit this exception to apply to your</span>
00042 <span class="comment"> * modifications. If you do not wish that, delete this exception</span>
00043 <span class="comment"> * notice.</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This file implements the interface between the Xenomai nucleus and</span>
00046 <span class="comment"> * RTAI/Adeos in kernel space.</span>
00047 <span class="comment"> */</span>
00048 
00049 <span class="preprocessor">#ifndef _RTAI_ASM_I386_XENO_H</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_ASM_I386_XENO_H</span>
00051 <span class="preprocessor"></span>
00052 <span class="preprocessor">#include &lt;linux/kernel.h&gt;</span>
00053 <span class="preprocessor">#include &lt;linux/version.h&gt;</span>
00054 <span class="preprocessor">#include &lt;linux/module.h&gt;</span>
00055 <span class="preprocessor">#include &lt;linux/slab.h&gt;</span>
00056 <span class="preprocessor">#include &lt;linux/errno.h&gt;</span>
00057 <span class="preprocessor">#include &lt;linux/adeos.h&gt;</span>
00058 <span class="preprocessor">#include &lt;asm/uaccess.h&gt;</span>
00059 <span class="preprocessor">#include &lt;asm/param.h&gt;</span>
00060 <span class="preprocessor">#include &lt;asm/mmu_context.h&gt;</span>
00061 <span class="preprocessor">#include &lt;rtai_config.h&gt;</span>
00062 <span class="preprocessor">#include &lt;asm/rtai_hal.h&gt;</span>
00063 <span class="preprocessor">#include &lt;asm/rtai_xnatomic.h&gt;</span>
00064 <span class="preprocessor">#include &lt;xenomai/shadow.h&gt;</span>
00065 
00066 <span class="preprocessor">#define MODULE_PARM_VALUE(parm) (parm)</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#ifndef MODULE_LICENSE</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#define MODULE_LICENSE(s)</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* MODULE_LICENSE */</span>
00070 
00071 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> spl_t;
00072 
00073 <span class="preprocessor">#define splhigh(x)  rtai_local_irq_save(x)</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#define splexit(x)  rtai_local_irq_restore(x)</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#define splnone()   rtai_sti()</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#define spltest()   rtai_local_irq_test()</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#define splget(x)   rtai_local_irq_flags(x)</span>
00078 <span class="preprocessor"></span>
00079 <span class="preprocessor">#define XNARCH_DEFAULT_TICK   1000000 </span><span class="comment">/* ns, i.e. 1ms */</span>
00080 <span class="preprocessor">#define XNARCH_IRQ_MAX        NR_IRQS</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#define XNARCH_HOST_TICK      (1000000000UL/HZ)</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#define XNARCH_APERIODIC_PREC 1000 </span><span class="comment">/* 1us, aperiodic precision */</span>
00083 <span class="preprocessor">#define XNARCH_SCHED_LATENCY  CONFIG_RTAI_SCHED_8254_LATENCY</span>
00084 <span class="preprocessor"></span>
00085 <span class="preprocessor">#define XNARCH_THREAD_COOKIE  (THIS_MODULE)</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#define XNARCH_THREAD_STACKSZ 4096</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#define XNARCH_ROOT_STACKSZ   0 </span><span class="comment">/* Only a placeholder -- no stack */</span>
00088 
00089 <span class="preprocessor">#define xnarch_printf                printk </span><span class="comment">/* Yup! This is safe under ARTI */</span>
00090 <span class="preprocessor">#define xnarch_ullmod(ull,uld,rem)   (xnarch_ulldiv(ull,uld,rem), (*rem))</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_ulldiv                rtai_ulldiv</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_imuldiv               rtai_imuldiv</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_llimd                 rtai_llimd</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_get_cpu_tsc           rtai_rdtsc</span>
00095 <span class="preprocessor"></span>
00096 <span class="keyword">struct </span>xnthread;
00097 <span class="keyword">struct </span>xnmutex;
00098 <span class="keyword">struct </span>module;
00099 <span class="keyword">struct </span>task_struct;
00100 
00101 <span class="preprocessor">#define xnarch_stack_size(tcb)  ((tcb)-&gt;stacksize)</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_fpu_ptr(tcb)     ((tcb)-&gt;fpup)</span>
00103 <span class="preprocessor"></span>
00104 <span class="keyword">typedef</span> <span class="keyword">struct </span>xnarchtcb {      <span class="comment">/* Per-thread arch-dependent block */</span>
00105 
00106     <span class="comment">/* Kernel mode side */</span>
00107     <span class="keyword">union </span>i387_union fpuenv __attribute__ ((aligned (16))); <span class="comment">/* FPU backup area */</span>
00108     <span class="keywordtype">unsigned</span> stacksize;         <span class="comment">/* Aligned size of stack (bytes) */</span>
00109     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *stackbase;   <span class="comment">/* Stack space */</span>
00110     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> esp;          <span class="comment">/* Saved ESP for kernel-based threads */</span>
00111     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> eip;          <span class="comment">/* Saved EIP for kernel-based threads */</span>
00112     <span class="keyword">struct </span>module *module;      <span class="comment">/* Creator's module */</span>
00113 
00114     <span class="comment">/* User mode side */</span>
00115     <span class="keyword">struct </span>task_struct *user_task;      <span class="comment">/* Shadowed user-space task */</span>
00116     <span class="keyword">struct </span>task_struct *active_task;    <span class="comment">/* Active user-space task */</span>
00117 
00118     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *espp;        <span class="comment">/* Pointer to ESP backup area (&amp;esp or &amp;user-&gt;thread.esp) */</span>
00119     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *eipp;        <span class="comment">/* Pointer to EIP backup area (&amp;eip or &amp;user-&gt;thread.eip) */</span>
00120     <span class="keyword">union </span>i387_union *fpup;     <span class="comment">/* Pointer to the FPU backup area (&amp;fpuenv or &amp;user-&gt;thread.i387.f[x]save */</span>
00121 
00122 } xnarchtcb_t;
00123 
00124 <span class="keyword">typedef</span> <span class="keyword">struct </span>xnarch_fltinfo {
00125 
00126     <span class="keywordtype">unsigned</span> vector;
00127     <span class="keywordtype">long</span> errcode;
00128     <span class="keyword">struct </span>pt_regs *regs;
00129 
00130 } xnarch_fltinfo_t;
00131 
00132 <span class="preprocessor">#define xnarch_fault_trap(fi)  ((fi)-&gt;vector)</span>
00133 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_fault_code(fi)  ((fi)-&gt;errcode)</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_fault_pc(fi)    ((fi)-&gt;regs-&gt;eip)</span>
00135 <span class="preprocessor"></span>
00136 <span class="preprocessor">#ifdef __cplusplus</span>
00137 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00138 <span class="preprocessor">#endif</span>
00139 <span class="preprocessor"></span>
00140 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> xnarch_tsc_to_ns (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ts) {
00141     <span class="keywordflow">return</span> xnarch_llimd(ts,1000000000,RTAI_CPU_FREQ);
00142 }
00143 
00144 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> xnarch_ns_to_tsc (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ns) {
00145     <span class="keywordflow">return</span> xnarch_llimd(ns,RTAI_CPU_FREQ,1000000000);
00146 }
00147 
00148 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> xnarch_get_cpu_time (<span class="keywordtype">void</span>) {
00149     <span class="keywordflow">return</span> xnarch_tsc_to_ns(xnarch_get_cpu_tsc());
00150 }
00151 
00152 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> xnarch_get_cpu_freq (<span class="keywordtype">void</span>) {
00153     <span class="keywordflow">return</span> RTAI_CPU_FREQ;
00154 }
00155 
00156 <span class="preprocessor">#define xnarch_halt(emsg) \</span>
00157 <span class="preprocessor">do { \</span>
00158 <span class="preprocessor">    adeos_set_printk_sync(adp_current); \</span>
00159 <span class="preprocessor">    xnarch_printf("Xenomai: fatal: %s\n",emsg); \</span>
00160 <span class="preprocessor">    BUG(); \</span>
00161 <span class="preprocessor">} while(0)</span>
00162 <span class="preprocessor"></span>
00163 <span class="keywordtype">int</span> xnarch_setimask(<span class="keywordtype">int</span> imask);
00164 
00165 <span class="preprocessor">#ifdef XENO_INTR_MODULE</span>
00166 <span class="preprocessor"></span>
00167 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> xnarch_hook_irq (<span class="keywordtype">unsigned</span> irq,
00168                                    <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">unsigned</span> irq,
00169                                                    <span class="keywordtype">void</span> *cookie),
00170                                    <span class="keywordtype">void</span> *cookie)
00171 {
00172     <span class="keywordtype">int</span> err = rt_request_irq(irq,handler,cookie);
00173 
00174     <span class="keywordflow">if</span> (!err)
00175         rt_enable_irq(irq);
00176 
00177     <span class="keywordflow">return</span> err;
00178 }
00179 
00180 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> xnarch_release_irq (<span class="keywordtype">unsigned</span> irq) {
00181 
00182     <span class="keywordflow">return</span> rt_release_irq(irq);
00183 }
00184 
00185 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> xnarch_enable_irq (<span class="keywordtype">unsigned</span> irq)
00186 
00187 {
00188     <span class="keywordflow">if</span> (irq &gt;= XNARCH_IRQ_MAX)
00189         <span class="keywordflow">return</span> -EINVAL;
00190 
00191     rt_enable_irq(irq);
00192 
00193     <span class="keywordflow">return</span> 0;
00194 }
00195 
00196 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> xnarch_disable_irq (<span class="keywordtype">unsigned</span> irq)
00197 
00198 {
00199     <span class="keywordflow">if</span> (irq &gt;= XNARCH_IRQ_MAX)
00200         <span class="keywordflow">return</span> -EINVAL;
00201 
00202     rt_disable_irq(irq);
00203 
00204     <span class="keywordflow">return</span> 0;
00205 }
00206 
00207 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_isr_chain_irq (<span class="keywordtype">unsigned</span> irq) {
00208     rt_pend_linux_irq(irq);
00209 }
00210 
00211 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_isr_enable_irq (<span class="keywordtype">unsigned</span> irq) {
00212     rt_enable_irq(irq);
00213 }
00214 
00215 <span class="preprocessor">#endif </span><span class="comment">/* XENO_INTR_MODULE */</span>
00216 
00217 <span class="preprocessor">#ifdef XENO_POD_MODULE</span>
00218 <span class="preprocessor"></span>
00219 <span class="keywordtype">void</span> <a class="code" href="group__pod.html#a55">xnpod_welcome_thread</a>(<span class="keyword">struct</span> xnthread *);
00220 
00221 <span class="keywordtype">void</span> <a class="code" href="group__pod.html#a52">xnpod_delete_thread</a>(<span class="keyword">struct</span> xnthread *,
00222                          <span class="keyword">struct</span> xnmutex *mutex);
00223 
00224 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_start_timer (<span class="keywordtype">int</span> ns, <span class="keywordtype">void</span> (*tickhandler)(<span class="keywordtype">void</span>))
00225 
00226 {
00227     <span class="keywordflow">if</span> (ns &gt; 0) <span class="comment">/* Periodic setup. */</span>
00228         {
00229         <span class="keywordtype">unsigned</span> period = (<span class="keywordtype">unsigned</span>)xnarch_llimd(ns,RTAI_FREQ_8254,1000000000);
00230         rt_request_timer(tickhandler,period &gt; LATCH ? LATCH : period,0);
00231         }
00232     <span class="keywordflow">else</span>  <span class="comment">/* Aperiodic setup. */</span>
00233         rt_request_timer(tickhandler,0,0);
00234 }
00235 
00236 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_leave_root (xnarchtcb_t *rootcb)
00237 
00238 {
00239     TRACE_RTAI_SWITCHTO_RT(0);
00240     set_bit(0,&amp;rtai_cpu_realtime);
00241     <span class="comment">/* Remember the preempted non-RT task pointer. */</span>
00242     rootcb-&gt;user_task = rootcb-&gt;active_task = rtai_get_current(0);
00243     <span class="comment">/* So that xnarch_save_fpu() will operate on the right FPU area. */</span>
00244     rootcb-&gt;fpup = &amp;rootcb-&gt;user_task-&gt;thread.i387;
00245 }
00246 
00247 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_enter_root (xnarchtcb_t *rootcb) {
00248     TRACE_RTAI_SWITCHTO_LINUX(0);
00249     clear_bit(0,&amp;rtai_cpu_realtime);
00250 }
00251 
00252 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> __switch_threads(xnarchtcb_t *out_tcb,
00253                                     xnarchtcb_t *in_tcb,
00254                                     <span class="keyword">struct</span> task_struct *outproc,
00255                                     <span class="keyword">struct</span> task_struct *inproc)
00256 {
00257         __asm__ __volatile__( \
00258         <span class="stringliteral">"pushl %%ecx\n\t"</span> \
00259         <span class="stringliteral">"pushl %%edi\n\t"</span> \
00260         <span class="stringliteral">"pushl %%ebp\n\t"</span> \
00261         <span class="stringliteral">"movl %0,%%ecx\n\t"</span> \
00262         <span class="stringliteral">"movl %%esp,(%%ecx)\n\t"</span> \
00263         <span class="stringliteral">"movl %1,%%ecx\n\t"</span> \
00264         <span class="stringliteral">"movl $1f,(%%ecx)\n\t"</span> \
00265         <span class="stringliteral">"movl %2,%%ecx\n\t"</span> \
00266         <span class="stringliteral">"movl %3,%%edi\n\t"</span> \
00267         <span class="stringliteral">"movl (%%ecx),%%esp\n\t"</span> \
00268         <span class="stringliteral">"pushl (%%edi)\n\t"</span> \
00269         <span class="stringliteral">"testl %%edx,%%edx\n\t"</span> \
00270         <span class="stringliteral">"jne  __switch_to\n\t"</span> \
00271         <span class="stringliteral">"ret\n\t"</span> \
00272 <span class="stringliteral">"1:      popl %%ebp\n\t"</span> \
00273         <span class="stringliteral">"popl %%edi\n\t"</span> \
00274         <span class="stringliteral">"popl %%ecx\n\t"</span> \
00275       : <span class="comment">/* no output */</span> \
00276       : <span class="stringliteral">"m"</span> (out_tcb-&gt;espp), \
00277         <span class="stringliteral">"m"</span> (out_tcb-&gt;eipp), \
00278         <span class="stringliteral">"m"</span> (in_tcb-&gt;espp), \
00279         <span class="stringliteral">"m"</span> (in_tcb-&gt;eipp), \
00280         <span class="stringliteral">"b"</span> (out_tcb), \
00281         <span class="stringliteral">"S"</span> (in_tcb), \
00282         <span class="stringliteral">"a"</span> (outproc), \
00283         <span class="stringliteral">"d"</span> (inproc));
00284 }
00285 
00286 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_switch_to (xnarchtcb_t *out_tcb,
00287                                      xnarchtcb_t *in_tcb)
00288 {
00289     <span class="keyword">struct </span>task_struct *outproc = out_tcb-&gt;active_task;
00290     <span class="keyword">struct </span>task_struct *inproc = in_tcb-&gt;user_task;
00291     <span class="keyword">static</span> <span class="keywordtype">int</span> cr0;
00292 
00293     <span class="keywordflow">if</span> (out_tcb-&gt;user_task)
00294         {
00295         __asm__ __volatile__ (<span class="stringliteral">"movl %%cr0,%0"</span>: <span class="stringliteral">"=r"</span> (cr0));
00296         clts();
00297         }
00298 
00299     in_tcb-&gt;active_task = inproc ?: outproc;
00300 
00301     <span class="keywordflow">if</span> (inproc &amp;&amp; inproc != outproc)
00302         {
00303         <span class="keyword">struct </span>mm_struct *oldmm = outproc-&gt;active_mm;
00304 
00305 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,0)</span>
00306 <span class="preprocessor"></span>        switch_mm(oldmm,inproc-&gt;active_mm,inproc,0);
00307 <span class="preprocessor">#else </span><span class="comment">/* &gt;= 2.6.0 */</span>
00308         switch_mm(oldmm,inproc-&gt;active_mm,inproc);
00309 <span class="preprocessor">#endif </span><span class="comment">/* &lt; 2.6.0 */</span>
00310 
00311         <span class="keywordflow">if</span> (!inproc-&gt;mm)
00312 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,0)</span>
00313 <span class="preprocessor"></span>            enter_lazy_tlb(oldmm,inproc,0);
00314 <span class="preprocessor">#else </span><span class="comment">/* &gt;= 2.6.0 */</span>
00315             enter_lazy_tlb(oldmm,inproc);
00316 <span class="preprocessor">#endif </span><span class="comment">/* &lt; 2.6.0 */</span>
00317         }
00318 
00319     __switch_threads(out_tcb,in_tcb,outproc,inproc);
00320 
00321     <span class="comment">/* If TS was set for the restored user-space thread, set it</span>
00322 <span class="comment">       back. */</span>
00323 
00324     <span class="keywordflow">if</span> (out_tcb-&gt;user_task &amp;&amp; (cr0 &amp; 0x8) != 0)
00325         stts();
00326 }
00327 
00328 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_finalize_and_switch (xnarchtcb_t *dead_tcb,
00329                                                xnarchtcb_t *next_tcb) {
00330     xnarch_switch_to(dead_tcb,next_tcb);
00331 }
00332 
00333 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_finalize_no_switch (xnarchtcb_t *dead_tcb) {
00334     <span class="comment">/* Empty */</span>
00335 }
00336 
00337 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_save_fpu (xnarchtcb_t *tcb)
00338 
00339 {
00340 <span class="preprocessor">#ifdef CONFIG_RTAI_FPU_SUPPORT</span>
00341 <span class="preprocessor"></span>
00342     <span class="keywordflow">if</span> (!tcb-&gt;user_task) <span class="comment">/* __switch_to() will take care otherwise. */</span>
00343         {
00344         <span class="keywordflow">if</span> (cpu_has_fxsr)
00345             __asm__ __volatile__ (<span class="stringliteral">"fxsave %0; fnclex"</span> : <span class="stringliteral">"=m"</span> (*tcb-&gt;fpup));
00346         <span class="keywordflow">else</span>
00347             __asm__ __volatile__ (<span class="stringliteral">"fnsave %0; fwait"</span> : <span class="stringliteral">"=m"</span> (*tcb-&gt;fpup));
00348         }
00349 
00350 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_FPU_SUPPORT */</span>
00351 }
00352 
00353 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_restore_fpu (xnarchtcb_t *tcb)
00354 
00355 {
00356 <span class="preprocessor">#ifdef CONFIG_RTAI_FPU_SUPPORT</span>
00357 <span class="preprocessor"></span>
00358     <span class="keywordflow">if</span> (tcb-&gt;user_task)
00359         {
00360         <span class="keywordflow">if</span> (!tcb-&gt;user_task-&gt;used_math)
00361             <span class="keywordflow">return</span>;     <span class="comment">/* Uninit fpu area -- do not restore. */</span>
00362 
00363         <span class="comment">/* Tell Linux that this task has altered the state of the FPU</span>
00364 <span class="comment">           hardware. */</span>
00365         set_tsk_used_fpu(tcb-&gt;user_task);
00366         }
00367 
00368     <span class="comment">/* Restore the FPU hardware with valid fp registers from a</span>
00369 <span class="comment">       user-space or kernel thread. */</span>
00370 
00371     clts();
00372 
00373     <span class="keywordflow">if</span> (cpu_has_fxsr)
00374         __asm__ __volatile__ (<span class="stringliteral">"fxrstor %0"</span>: <span class="comment">/* no output */</span> : <span class="stringliteral">"m"</span> (*tcb-&gt;fpup));
00375     <span class="keywordflow">else</span>
00376         __asm__ __volatile__ (<span class="stringliteral">"frstor %0"</span>: <span class="comment">/* no output */</span> : <span class="stringliteral">"m"</span> (*tcb-&gt;fpup));
00377 
00378 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_FPU_SUPPORT */</span>
00379 }
00380 
00381 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_init_root_tcb (xnarchtcb_t *tcb,
00382                                          <span class="keyword">struct</span> xnthread *thread,
00383                                          <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00384 {
00385     tcb-&gt;module = THIS_MODULE;
00386     tcb-&gt;user_task = current;
00387     tcb-&gt;active_task = NULL;
00388     tcb-&gt;esp = 0;
00389     tcb-&gt;espp = &amp;tcb-&gt;esp;
00390     tcb-&gt;eipp = &amp;tcb-&gt;eip;
00391     tcb-&gt;fpup = &amp;current-&gt;thread.i387;
00392 }
00393 
00394 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_init_tcb (xnarchtcb_t *tcb, <span class="keywordtype">void</span> *adcookie) {
00395 
00396     tcb-&gt;module = (<span class="keyword">struct </span>module *)adcookie;
00397     tcb-&gt;user_task = NULL;
00398     tcb-&gt;active_task = NULL;
00399     tcb-&gt;espp = &amp;tcb-&gt;esp;
00400     tcb-&gt;eipp = &amp;tcb-&gt;eip;
00401     tcb-&gt;fpup = &amp;tcb-&gt;fpuenv;
00402     <span class="comment">/* Must be followed by xnarch_init_thread(). */</span>
00403 }
00404 
00405 <span class="keyword">static</span> <span class="keywordtype">void</span> xnarch_thread_redirect (<span class="keyword">struct</span> xnthread *self,
00406                                     <span class="keywordtype">int</span> imask,
00407                                     <span class="keywordtype">void</span>(*entry)(<span class="keywordtype">void</span> *),
00408                                     <span class="keywordtype">void</span> *cookie)
00409 {
00410     rtai_local_irq_restore(!!imask);
00411     <a class="code" href="group__pod.html#a55">xnpod_welcome_thread</a>(self);
00412     entry(cookie);
00413     <a class="code" href="group__pod.html#a52">xnpod_delete_thread</a>(self,NULL);
00414 }
00415 
00416 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_init_thread (xnarchtcb_t *tcb,
00417                                        <span class="keywordtype">void</span> (*entry)(<span class="keywordtype">void</span> *),
00418                                        <span class="keywordtype">void</span> *cookie,
00419                                        <span class="keywordtype">int</span> imask,
00420                                        <span class="keyword">struct</span> xnthread *thread,
00421                                        <span class="keywordtype">char</span> *name)
00422 {
00423     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> **psp = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> **)&amp;tcb-&gt;esp;
00424 
00425     tcb-&gt;eip = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)&amp;xnarch_thread_redirect;
00426     tcb-&gt;esp = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)tcb-&gt;stackbase;
00427     **psp = 0;  <span class="comment">/* Commit bottom stack memory */</span>
00428     *psp = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)*psp + tcb-&gt;stacksize - 0x10) &amp; ~0xf);
00429     *--(*psp) = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)cookie;
00430     *--(*psp) = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)entry;
00431     *--(*psp) = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)imask;
00432     *--(*psp) = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)thread;
00433     *--(*psp) = 0;
00434 }
00435 
00436 <span class="preprocessor">#ifdef CONFIG_RTAI_FPU_SUPPORT</span>
00437 <span class="preprocessor"></span>
00438 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_init_fpu (xnarchtcb_t *tcb)
00439 
00440 {
00441     <span class="comment">/* Initialize the FPU for an emerging kernel-based RT thread. This</span>
00442 <span class="comment">       must be run on behalf of the emerging thread. */</span>
00443 
00444     __asm__ __volatile__ (<span class="stringliteral">"clts; fninit"</span>);
00445 
00446     <span class="keywordflow">if</span> (cpu_has_xmm)
00447         load_mxcsr(0x1f80);
00448 }
00449 
00450 <span class="preprocessor">#else </span><span class="comment">/* !CONFIG_RTAI_FPU_SUPPORT */</span>
00451 
00452 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_init_fpu (xnarchtcb_t *tcb) {
00453 }
00454 
00455 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_FPU_SUPPORT */</span>
00456 
00457 <span class="keywordtype">int</span> xnarch_setimask (<span class="keywordtype">int</span> imask)
00458 
00459 {
00460     spl_t s;
00461     splhigh(s);
00462     splexit(!!imask);
00463     <span class="keywordflow">return</span> !!s;
00464 }
00465 
00466 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_relay_tick (<span class="keywordtype">void</span>) {
00467 
00468     rt_pend_linux_irq(RTAI_TIMER_8254_IRQ);
00469 }
00470 
00471 <span class="preprocessor">#define xnarch_notify_ready() </span><span class="comment">/* Nullified */</span>
00472 
00473 <span class="preprocessor">#endif </span><span class="comment">/* XENO_POD_MODULE */</span>
00474 
00475 <span class="preprocessor">#ifdef XENO_SHADOW_MODULE</span>
00476 <span class="preprocessor"></span>
00477 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_init_shadow_tcb (xnarchtcb_t *tcb,
00478                                            <span class="keyword">struct</span> xnthread *thread,
00479                                            <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00480 {
00481     <span class="keyword">struct </span>task_struct *task = current;
00482 
00483     tcb-&gt;module = THIS_MODULE;
00484     tcb-&gt;user_task = task;
00485     tcb-&gt;active_task = NULL;
00486     tcb-&gt;esp = 0;
00487     tcb-&gt;espp = &amp;task-&gt;thread.esp;
00488     tcb-&gt;eipp = &amp;task-&gt;thread.eip;
00489     tcb-&gt;fpup = &amp;task-&gt;thread.i387;
00490 }
00491 
00492 <span class="preprocessor">#endif </span><span class="comment">/* XENO_SHADOW_MODULE */</span>
00493 
00494 <span class="preprocessor">#ifdef XENO_HEAP_MODULE</span>
00495 <span class="preprocessor"></span>
00496 <span class="keywordtype">void</span> *xnarch_sysalloc (<span class="keywordtype">unsigned</span> bytes) {
00497 
00498     <span class="keywordflow">return</span> kmalloc(bytes,GFP_ATOMIC);
00499 }
00500 
00501 <span class="keywordtype">void</span> xnarch_sysfree (<span class="keywordtype">void</span> *chunk, <span class="keywordtype">unsigned</span> bytes) {
00502 
00503     kfree(chunk);
00504 }
00505 
00506 <span class="preprocessor">#else </span><span class="comment">/* !XENO_HEAP_MODULE */</span>
00507 
00508 <span class="keywordtype">void</span> *xnarch_sysalloc(<span class="keywordtype">unsigned</span> bytes);
00509 
00510 <span class="keywordtype">void</span> xnarch_sysfree(<span class="keywordtype">void</span> *chunk,
00511                     <span class="keywordtype">unsigned</span> bytes);
00512 
00513 <span class="preprocessor">#endif </span><span class="comment">/* XENO_HEAP_MODULE */</span>
00514 
00515 <span class="preprocessor">#ifdef XENO_TIMER_MODULE</span>
00516 <span class="preprocessor"></span>
00517 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> xnarch_timer_calibration;
00518 
00519 <span class="keywordtype">void</span> xnarch_calibrate_timer (<span class="keywordtype">void</span>) {
00520     <span class="comment">/* Compute the time needed to program the 8254 PIT in aperiodic</span>
00521 <span class="comment">       mode. The stored value is expressed in CPU ticks. */</span>
00522     xnarch_timer_calibration = xnarch_ns_to_tsc(rtai_calibrate_8254());
00523 }
00524 
00525 <span class="keyword">static</span> <span class="keywordtype">void</span> xnarch_program_timer_shot (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> delay) <span class="comment">/* &lt;= in CPU ticks */</span>
00526 
00527 {
00528     <span class="keywordflow">if</span> (delay &lt; xnarch_timer_calibration)
00529         <span class="comment">/* If the delay value is lower than the time needed to program</span>
00530 <span class="comment">           the PIT, increase it to a sane minimum so that we don't</span>
00531 <span class="comment">           lose a tick. */</span>
00532         delay = xnarch_timer_calibration;
00533 
00534     rt_set_timer_delay(rtai_imuldiv(delay,RTAI_FREQ_8254,RTAI_CPU_FREQ));
00535 }
00536 
00537 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_stop_timer (<span class="keywordtype">void</span>) {
00538     <a class="code" href="group__hal.html#a66">rt_free_timer</a>();
00539 }
00540 
00541 <span class="preprocessor">#endif </span><span class="comment">/* XENO_TIMER_MODULE */</span>
00542 
00543 <span class="preprocessor">#ifdef XENO_MAIN_MODULE</span>
00544 <span class="preprocessor"></span>
00545 <span class="keywordtype">int</span> <a class="code" href="group__pod.html#a58">xnpod_trap_fault</a>(xnarch_fltinfo_t *fltinfo);
00546 
00547 <span class="keywordtype">void</span> xnarch_calibrate_timer(<span class="keywordtype">void</span>);
00548 
00549 <span class="keyword">static</span> RT_TRAP_HANDLER xnarch_old_trap_handler;
00550 
00551 <span class="keyword">static</span> <span class="keywordtype">int</span> xnarch_trap_fault (<span class="keywordtype">int</span> vector,
00552                               <span class="keywordtype">int</span> signo,
00553                               <span class="keyword">struct</span> pt_regs *regs,
00554                               <span class="keywordtype">void</span> *dummy)
00555 {
00556     xnarch_fltinfo_t fltinfo;
00557 
00558     fltinfo.vector = vector;
00559     fltinfo.errcode = regs-&gt;orig_eax;
00560     fltinfo.regs = regs;
00561 
00562     <span class="keywordflow">return</span> <a class="code" href="group__pod.html#a58">xnpod_trap_fault</a>(&amp;fltinfo);
00563 }
00564 
00565 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> xnarch_init (<span class="keywordtype">void</span>)
00566 
00567 {
00568     xnarch_old_trap_handler = rt_set_trap_handler(&amp;xnarch_trap_fault);
00569     xnarch_calibrate_timer();
00570     <span class="keywordflow">return</span> xnshadow_init();
00571 }
00572 
00573 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> xnarch_exit (<span class="keywordtype">void</span>) {
00574 
00575     xnshadow_cleanup();
00576     rt_set_trap_handler(xnarch_old_trap_handler);
00577 }
00578 
00579 <span class="preprocessor">#endif </span><span class="comment">/* XENO_MAIN_MODULE */</span>
00580 
00581 <span class="preprocessor">#ifdef __cplusplus</span>
00582 <span class="preprocessor"></span>}
00583 <span class="preprocessor">#endif</span>
00584 <span class="preprocessor"></span>
00585 <span class="comment">/* Dashboard and graph control. */</span>
00586 <span class="preprocessor">#define XNARCH_DECL_DISPLAY_CONTEXT();</span>
00587 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_init_display_context(obj)</span>
00588 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_create_display(obj,name,tag)</span>
00589 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_delete_display(obj)</span>
00590 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_post_graph(obj,state)</span>
00591 <span class="preprocessor"></span><span class="preprocessor">#define xnarch_post_graph_if(obj,state,cond)</span>
00592 <span class="preprocessor"></span>
00593 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_ASM_I386_XENO_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:02 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
