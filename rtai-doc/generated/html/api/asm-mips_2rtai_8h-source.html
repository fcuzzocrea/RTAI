<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/asm-mips/rtai.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/asm-mips/rtai.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * COPYRIGHT (C) 2001  Steve Papacharalambous (stevep@lineo.com)</span>
00003 <span class="comment"> * COPYRIGHT (C) 2000  Paolo Mantegazza (mantegazza@aero.polimi.it)</span>
00004 <span class="comment"> *  </span>
00005 <span class="comment"> *  This library is free software; you can redistribute it and/or</span>
00006 <span class="comment"> *  modify it under the terms of the GNU Lesser General Public</span>
00007 <span class="comment"> *  License as published by the Free Software Foundation; either</span>
00008 <span class="comment"> *  version 2 of the License, or (at your option) any later version.</span>
00009 <span class="comment"> *   </span>
00010 <span class="comment"> *   This library is distributed in the hope that it will be useful,</span>
00011 <span class="comment"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00012 <span class="comment"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00013 <span class="comment"> *   Lesser General Public License for more details.</span>
00014 <span class="comment"> *    </span>
00015 <span class="comment"> *    You should have received a copy of the GNU Lesser General Public</span>
00016 <span class="comment"> *    License along with this library; if not, write to the Free Software</span>
00017 <span class="comment"> *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.</span>
00018 <span class="comment"> *</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> * Modifications for MIPS port - Steve Papacharalambous (stevep@lineo.com)</span>
00023 <span class="comment"> * 19Jun01</span>
00024 <span class="comment"> */</span>
00025 
00026 <span class="comment">/*</span>
00027 <span class="comment"> * More MIPS stuff by Steven Seeger (sseeger@stellartec.com)</span>
00028 <span class="comment"> * </span>
00029 <span class="comment"> */</span>
00030 
00031 <span class="preprocessor">#ifndef _RTAI_ASM_MIPS_RTAI_H_</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_ASM_MIPS_RTAI_H_</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00035 
00036 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullmul(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m0, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m1)
00037 {
00038 
00039         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> __res;
00040 
00041         __asm__ __volatile__ (
00042                         <span class="stringliteral">"multu\t%2,%3\n\t"</span>
00043                         <span class="stringliteral">"mflo\t%0\n\t"</span>
00044                         <span class="stringliteral">"mfhi\t%1\n\t"</span>
00045                         : <span class="stringliteral">"=r"</span> (((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;__res)[0]),
00046                           <span class="stringliteral">"=r"</span> (((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;__res)[1])
00047                         : <span class="stringliteral">"r"</span> (m0), <span class="stringliteral">"r"</span> (m1));
00048 
00049         <span class="keywordflow">return</span>(__res);
00050 
00051 } <span class="comment">/* End function - ullmul */</span>
00052 
00053 <span class="comment">// One of the silly thing of 32 bits MIPS, no 64 by 32 bits divide.</span>
00054 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ulldiv(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ull,
00055                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> uld, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *r)
00056 {
00057         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> q, rf;
00058         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> qh, rh, ql, qf;
00059 
00060         q = 0;
00061         rf = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)(0xFFFFFFFF - (qf = 0xFFFFFFFF / uld) * uld)
00062                                                                         + 1ULL;
00063 
00064         <span class="keywordflow">while</span> (ull &gt;= uld) {
00065                 ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;q)[1] +=
00066                         (qh = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[1] / uld);
00067 
00068                 rh = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[1] - qh * uld;
00069                 q += rh * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)qf +
00070                         (ql = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[0] / uld);
00071 
00072                 ull = rh * rf + (((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[0] - ql * uld);
00073         }
00074 
00075         *r = ull;
00076         <span class="keywordflow">return</span>(q);
00077 }  <span class="comment">/* End function - ulldiv */</span>
00078 
00079 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> imuldiv(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> mult, <span class="keywordtype">int</span> div)
00080 {
00081         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> q, r;
00082 
00083         q = ulldiv(ullmul(i, mult), div, &amp;r);
00084 
00085         <span class="keywordflow">return</span> (r + r) &gt; div ? q + 1 : q;
00086 }  <span class="comment">/* End function - imuldiv */</span>
00087 
00088 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> llimd(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ull,
00089                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mult, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> div)
00090 {
00091         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> low;
00092         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> q, r;
00093 
00094         low  = ullmul(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[0], mult);        
00095         q = ulldiv( ullmul(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[1], mult) +
00096                 ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;low)[1], div, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;low);
00097         low = ulldiv(low, div, &amp;r);
00098         ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;low)[1] += q;
00099 
00100         <span class="keywordflow">return</span> (r + r) &gt; div ? low + 1 : low;
00101 }  <span class="comment">/* End function - llimd */</span>
00102 
00103 
00104 <span class="preprocessor">#ifdef __KERNEL__</span>
00105 <span class="preprocessor"></span>
00106 <span class="preprocessor">#ifndef __cplusplus</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/smp.h&gt;</span>
00108 <span class="preprocessor">#include &lt;linux/spinlock.h&gt;</span>
00109 <span class="preprocessor">#include &lt;linux/irq.h&gt;</span>
00110 <span class="preprocessor">#include &lt;asm/system.h&gt;</span>
00111 <span class="preprocessor">#include &lt;asm/bitops.h&gt;</span>
00112 <span class="preprocessor">#include &lt;asm/mipsregs.h&gt;</span>
00113 <span class="preprocessor">#include &lt;asm/rtai_atomic.h&gt;</span>
00114 <span class="preprocessor">#endif </span><span class="comment">/* !__cplusplus */</span>
00115 
00116 <span class="comment">/*</span>
00117 <span class="comment"> * Pending IRQ bit definitions.</span>
00118 <span class="comment"> */</span>
00119 <span class="preprocessor">#define IRQ_s334 3</span>
00120 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_EIC 5</span>
00121 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_TIMER 7</span>
00122 <span class="preprocessor"></span>
00123 <span class="comment">/*</span>
00124 <span class="comment"> * This needs to be fixed for the specific arch</span>
00125 <span class="comment"> */</span>
00126 <span class="preprocessor">#define RTAI_NR_TRAPS 16</span>
00127 <span class="preprocessor"></span>
00128 <span class="comment">/*</span>
00129 <span class="comment"> * CPU frequency calibration.</span>
00130 <span class="comment"> */</span>
00131 <span class="preprocessor">#define CPU_FREQ (tuned.cpu_freq)</span>
00132 <span class="preprocessor"></span><span class="preprocessor">#define FREQ_DECR CPU_FREQ</span>
00133 <span class="preprocessor"></span><span class="preprocessor">#define CALIBRATED_CPU_FREQ     0 </span><span class="comment">/* Use this if you know better than Linux! */</span>
00134 
00135 <span class="comment">/*</span>
00136 <span class="comment"> * Do not be messed up by macros names below, is a trick for keeping i386 code.</span>
00137 <span class="comment"> */</span>
00138 <span class="preprocessor">#define FREQ_8254 CPU_FREQ</span>
00139 <span class="preprocessor"></span><span class="preprocessor">#define FREQ_APIC CPU_FREQ</span>
00140 <span class="preprocessor"></span><span class="preprocessor">#define LATENCY_8254 3000</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#define SETUP_TIME_8254 500</span>
00142 <span class="preprocessor"></span><span class="preprocessor">#define TIMER_8254_IRQ IRQ_TIMER</span>
00143 <span class="preprocessor"></span>
00144 <span class="preprocessor">#define IFLAG 9</span>
00145 <span class="preprocessor"></span>
00146 <span class="preprocessor">#ifndef CLOCK_TICK_RATE</span>
00147 <span class="preprocessor"></span><span class="preprocessor">#define CLOCK_TICK_RATE 1193180 </span><span class="comment">/* Ok, this makes no sense on MIPS */</span>
00148 <span class="preprocessor">#endif </span><span class="comment">/* CLOCK_TICK_RATE */</span>
00149 
00150 <span class="comment">/*</span>
00151 <span class="comment"> * IE Bit position for MIPS is cp0 status register bit 0</span>
00152 <span class="comment"> */</span>
00153 <span class="preprocessor">#define IFLAG_POS 0</span>
00154 <span class="preprocessor"></span>
00155 <span class="preprocessor">#define NR_RT_CPUS 1</span>
00156 <span class="preprocessor"></span>
00157 <span class="preprocessor">#define rt_write_timer_count(cnt)  do { \</span>
00158 <span class="preprocessor">                write_c0_count(cnt); } while(0)</span>
00159 <span class="preprocessor"></span>
00160 <span class="preprocessor">#define rt_read_timer_countg() read_c0_count();</span>
00161 <span class="preprocessor"></span>
00162 <span class="preprocessor">#define rt_write_timer_comp(cnt)  do { \</span>
00163 <span class="preprocessor">                write_c0_compare(cnt); } while(0)</span>
00164 <span class="preprocessor"></span>
00165 <span class="preprocessor">#define rt_read_timer_comp()      do { \</span>
00166 <span class="preprocessor">                read_c0_compare(); } while(0)</span>
00167 <span class="preprocessor"></span>
00168 <span class="preprocessor">#define rt_set_timer_incr(x)    do { \</span>
00169 <span class="preprocessor">                write_c0_compare((x)); } while(0)</span>
00170 <span class="preprocessor"></span>
00171 <span class="preprocessor">#define hard_cpu_id() hard_smp_processor_id()</span>
00172 <span class="preprocessor"></span>
00173 <span class="preprocessor">#define rt_spin_lock(lock)</span>
00174 <span class="preprocessor"></span><span class="preprocessor">#define rt_spin_unlock(lock)</span>
00175 <span class="preprocessor"></span>
00176 <span class="preprocessor">#define rt_get_global_lock() hard_cli()</span>
00177 <span class="preprocessor"></span><span class="preprocessor">#define rt_release_global_lock()</span>
00178 <span class="preprocessor"></span>
00179 <span class="preprocessor">#define save_fpenv(x)</span>
00180 <span class="preprocessor"></span><span class="preprocessor">#define restore_fpenv(x)</span>
00181 <span class="preprocessor"></span>
00182 <span class="preprocessor">#define RT_TIME_END 0x7fffffffffffffffLL</span>
00183 <span class="preprocessor"></span>
00184 <span class="keyword">struct </span>apic_timer_setup_data;
00185 
00186 <span class="keyword">struct </span>global_rt_status {
00187         <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pending_irqs_l;
00188         <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pending_irqs_h;
00189         <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> activ_irqs;
00190         <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pending_srqs;
00191         <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> activ_srqs;
00192         <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpu_in_sti;
00193         <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> used_by_linux;
00194         <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> locked_cpus;
00195         <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hard_nesting;
00196         <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hard_lock_all_service;
00197 <span class="preprocessor">#ifdef CONFIG_X86_REMOTE_DEBUG</span>
00198 <span class="preprocessor"></span>        <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> used_by_gdbstub;
00199 <span class="preprocessor">#endif</span>
00200 <span class="preprocessor"></span>        spinlock_t hard_lock;
00201         spinlock_t data_lock;
00202 };
00203 
00204 <span class="comment">/* grrr - this should have a arch-independent name */</span>
00205 <span class="keyword">struct </span>apic_timer_setup_data {
00206         <span class="keywordtype">int</span> mode;
00207         <span class="keywordtype">int</span> count;
00208 };
00209 
00210 
00211 
00212 <span class="keyword">struct </span>calibration_data {
00213         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpu_freq;
00214         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> apic_freq;
00215         <span class="keywordtype">int</span> latency;
00216         <span class="keywordtype">int</span> setup_time_TIMER_CPUNIT;
00217         <span class="keywordtype">int</span> setup_time_TIMER_UNIT;
00218         <span class="keywordtype">int</span> timers_tol[NR_RT_CPUS];
00219 };
00220 
00221 
00222 <span class="keyword">typedef</span> <span class="keyword">struct </span>mips_fpu_env { <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fpu_reg[32]; } FPU_ENV;
00223 
00224 <span class="comment">/* unknown stuff */</span>
00225 <span class="preprocessor">#define save_cr0_and_clts(x)</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#define restore_cr0(x)</span>
00227 <span class="preprocessor"></span><span class="preprocessor">#define enable_fpu()</span>
00228 <span class="preprocessor"></span><span class="preprocessor">#define DECLR_8254_TSC_EMULATION</span>
00229 <span class="preprocessor"></span><span class="preprocessor">#define TICK_8254_TSC_EMULATION</span>
00230 <span class="preprocessor"></span><span class="preprocessor">#define SETUP_8254_TSC_EMULATION</span>
00231 <span class="preprocessor"></span><span class="preprocessor">#define CLEAR_8254_TSC_EMULATION</span>
00232 <span class="preprocessor"></span>
00233 
00234 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> *locked_cpus;
00235 
00236 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_spin_lock_irq(spinlock_t *lock)
00237 {
00238         hard_cli();
00239         rt_spin_lock(lock);
00240 }  <span class="comment">/* End function - rt_spin_lock_irq */</span>
00241 
00242 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_spin_unlock_irq(spinlock_t *lock)
00243 {
00244         rt_spin_unlock(lock);
00245         hard_sti();
00246 }  <span class="comment">/* End function - rt_spin_unlock_irq */</span>
00247 
00248 
00249 <span class="comment">/*</span>
00250 <span class="comment"> * Note that the spinlock calling convention below for irqsave/restore is</span>
00251 <span class="comment"> * slightly different from the one used in Linux. Done on purpose to get an</span>
00252 <span class="comment"> * error if you use Linux spinlocks in real time applications as they do not</span>
00253 <span class="comment"> * guarantee any protection because of the soft irq disable. Be careful and</span>
00254 <span class="comment"> * sure to call the other spinlocks the right way, as they are compatible</span>
00255 <span class="comment"> * with Linux.</span>
00256 <span class="comment"> */</span>
00257 
00258 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rt_spin_lock_irqsave(spinlock_t *lock)
00259 {
00260         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00261         hard_save_flags_and_cli(flags);
00262         rt_spin_lock(lock);
00263         <span class="keywordflow">return</span> flags;
00264 } <span class="comment">/* End function - rt_spin_lock_irqsave */</span>
00265 
00266 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_spin_unlock_irqrestore(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags,
00267                                                         spinlock_t *lock)
00268 {
00269         rt_spin_unlock(lock);
00270         hard_restore_flags(flags);
00271 } <span class="comment">/* End function - rt_spin_unlock_irqrestore */</span>
00272 
00273 
00274 <span class="comment">/*</span>
00275 <span class="comment"> * Global interrupts and flags control (simplified, and modified, version of</span>
00276 <span class="comment"> * similar global stuff in Linux irq.c).</span>
00277 <span class="comment"> */</span>
00278  
00279 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_cli(<span class="keywordtype">void</span>)
00280 {
00281         rt_get_global_lock();
00282 } <span class="comment">/* End function - rt_global_cli */</span>
00283  
00284 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_sti(<span class="keywordtype">void</span>)
00285 {
00286         rt_release_global_lock();
00287         hard_sti();
00288 } <span class="comment">/* End function - rt_global_sti */</span>
00289 
00290  
00291 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_global_save_flags_and_cli(<span class="keywordtype">void</span>)
00292 {
00293         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00294 
00295         hard_save_flags_and_cli(flags);
00296         <span class="keywordflow">if</span> (!test_and_set_bit(hard_cpu_id(), locked_cpus)) {
00297                 <span class="keywordflow">while</span> (test_and_set_bit(31, locked_cpus));
00298                 <span class="keywordflow">return</span> ((flags &amp; (1 &lt;&lt; IFLAG)) + 1);
00299         } <span class="keywordflow">else</span> {
00300                 <span class="keywordflow">return</span> (flags &amp; (1 &lt;&lt; IFLAG));
00301         }
00302 } <span class="comment">/* End function - rt_global_save_flags_and_cli */</span>
00303 
00304 
00305 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_save_flags(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *flags)
00306 {
00307         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> hflags, rflags;
00308 
00309         hard_save_flags_and_cli(hflags);
00310         hflags = hflags &amp; (1 &lt;&lt; IFLAG);
00311         rflags = hflags | !test_bit(hard_cpu_id(), locked_cpus);
00312         <span class="keywordflow">if</span> (hflags) {
00313                 hard_sti();
00314         }
00315         *flags = rflags;
00316 } <span class="comment">/* End function - rt_global_save_flags */</span>
00317 
00318 
00319 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_restore_flags(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags)
00320 {
00321         <span class="keywordflow">switch</span> (flags) {
00322         <span class="keywordflow">case</span> (1 &lt;&lt; IFLAG) | 1:  rt_release_global_lock();
00323                 hard_sti();
00324                 <span class="keywordflow">break</span>;
00325         <span class="keywordflow">case</span> (1 &lt;&lt; IFLAG) | 0:  rt_get_global_lock();
00326                 hard_sti();
00327                 <span class="keywordflow">break</span>;
00328         <span class="keywordflow">case</span> (0 &lt;&lt; IFLAG) | 1:  rt_release_global_lock();
00329                 <span class="keywordflow">break</span>;
00330         <span class="keywordflow">case</span> (0 &lt;&lt; IFLAG) | 0:  rt_get_global_lock();
00331                 <span class="keywordflow">break</span>;
00332         }
00333 } <span class="comment">/* End function - rt_global_restore_flags */</span>
00334 
00335 
00336 <span class="keyword">extern</span> <span class="keyword">struct </span>rt_times rt_times;
00337 <span class="keyword">extern</span> <span class="keyword">struct </span>rt_times rt_smp_times[NR_RT_CPUS];
00338 <span class="keyword">extern</span> <span class="keyword">struct </span>calibration_data tuned;
00339 
00340 
00341 <span class="comment">/*</span>
00342 <span class="comment"> * This has been copied from the Linux kernel source for ffz and modified</span>
00343 <span class="comment"> * to return the position of the first non zero bit. - Stevep</span>
00344 <span class="comment"> *</span>
00345 <span class="comment"> * ffnz = Find First Non Zero in word. Undefined if no one exists,</span>
00346 <span class="comment"> * so code should check against ~0xffffffffUL first..</span>
00347 <span class="comment"> *</span>
00348 <span class="comment"> */</span>
00349 <span class="keyword">extern</span> __inline__ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ffnz(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> word)
00350 {
00351         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    __res;
00352         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    __mask = 1;
00353 
00354         __asm__ (
00355                 <span class="stringliteral">".set\tnoreorder\n\t"</span>
00356                 <span class="stringliteral">".set\tnoat\n\t"</span>
00357                 <span class="stringliteral">"move\t%0,$0\n"</span>
00358                 <span class="stringliteral">"1:\tand\t$1,%2,%1\n\t"</span>
00359                 <span class="stringliteral">"bnez\t$1,2f\n\t"</span>
00360                 <span class="stringliteral">"sll\t%1,1\n\t"</span>
00361                 <span class="stringliteral">"bnez\t%1,1b\n\t"</span>
00362                 <span class="stringliteral">"addiu\t%0,1\n\t"</span>
00363                 <span class="stringliteral">".set\tat\n\t"</span>
00364                 <span class="stringliteral">".set\treorder\n"</span>
00365                 <span class="stringliteral">"2:\n\t"</span>
00366                 : <span class="stringliteral">"=&amp;r"</span> (__res), <span class="stringliteral">"=r"</span> (__mask)
00367                 : <span class="stringliteral">"r"</span> (word), <span class="stringliteral">"1"</span> (__mask)
00368                 : <span class="stringliteral">"$1"</span>);
00369 
00370         <span class="keywordflow">return</span> __res;
00371 } <span class="comment">/* End function - ffnz */</span>
00372 
00373 
00374 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> rdtsc(<span class="keywordtype">void</span>)
00375 {
00376         <span class="keyword">extern</span> <span class="keyword">struct </span>rt_hal rthal;
00377         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> count;
00378         <span class="keywordtype">long</span> flags;
00379 
00380         count = read_c0_count();
00381         hard_save_flags_and_cli(flags);
00382         rthal.tsc.hltsc[1] += (count &lt; rthal.tsc.hltsc[0]);
00383         rthal.tsc.hltsc[0] = count;
00384         hard_restore_flags(flags);
00385         <span class="keywordflow">return</span> rthal.tsc.tsc;
00386 
00387 }  <span class="comment">/* End function - rdtsc */</span>
00388 
00389 <span class="comment">/*</span>
00390 <span class="comment"> * Temporary section as include asm-generic/rtai.h causes building problems.</span>
00391 <span class="comment"> * Stevep - 7Jan02</span>
00392 <span class="comment"> */</span>
00393 
00394 <span class="keywordtype">int</span> rt_request_global_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>));
00395 <span class="keywordtype">int</span> rt_free_global_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00396 <span class="keywordtype">void</span> rt_ack_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00397 <span class="keywordtype">void</span> rt_mask_and_ack_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00398 <span class="keywordtype">void</span> rt_unmask_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00399 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rt_startup_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00400 <span class="keywordtype">void</span> rt_shutdown_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00401 <span class="keywordtype">void</span> rt_enable_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00402 <span class="keywordtype">void</span> rt_disable_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00403 <span class="keywordtype">int</span> rt_request_linux_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq,
00404         <span class="keywordtype">void</span> (*linux_handler)(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id, <span class="keyword">struct</span> pt_regs *regs), 
00405         <span class="keywordtype">char</span> *linux_handler_id, <span class="keywordtype">void</span> *dev_id);
00406 <span class="keywordtype">int</span> rt_free_linux_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id);
00407 <span class="keywordtype">void</span> rt_pend_linux_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00408 <span class="keywordtype">int</span> rt_request_srq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> label, <span class="keywordtype">void</span> (*rtai_handler)(<span class="keywordtype">void</span>),
00409         <span class="keywordtype">long</span> <span class="keywordtype">long</span> (*user_handler)(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> whatever));
00410 <span class="keywordtype">int</span> rt_free_srq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srq);
00411 <span class="keywordtype">void</span> rt_pend_linux_srq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srq);
00412 <span class="keywordtype">int</span> rt_request_cpu_own_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>));
00413 <span class="keywordtype">int</span> rt_free_cpu_own_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00414 <span class="keywordtype">int</span> rt_request_timer(<span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>), <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tick, <span class="keywordtype">int</span> apic);
00415 <span class="keywordtype">int</span> <a class="code" href="group__hal.html#a66">rt_free_timer</a>(<span class="keywordtype">void</span>);
00416 <span class="keywordtype">void</span> rt_request_apic_timers(<span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>),
00417                         <span class="keyword">struct</span> apic_timer_setup_data *apic_timer_data);
00418 <span class="keywordtype">void</span> rt_free_apic_timers(<span class="keywordtype">void</span>);
00419 <span class="keywordtype">void</span> rt_mount_rtai(<span class="keywordtype">void</span>);
00420 <span class="keywordtype">void</span> rt_umount_rtai(<span class="keywordtype">void</span>);
00421 <span class="keywordtype">int</span> rt_printk(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...);
00422 <span class="keywordtype">int</span> rtai_print_to_screen(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...);
00423 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_switch_to_linux(<span class="keywordtype">int</span> cpuid);
00424 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_switch_to_real_time(<span class="keywordtype">int</span> cpuid);
00425 
00426 <span class="preprocessor">#define rt_assign_irq_to_cpu(irq, cpu)</span>
00427 <span class="preprocessor"></span><span class="preprocessor">#define rt_reset_irq_to_sym_mode(irq)</span>
00428 <span class="preprocessor"></span>
00429 <span class="comment">/*</span>
00430 <span class="comment"> * NOTE: delay MUST be 0 if a periodic timer is being used.</span>
00431 <span class="comment"> *       This must go below the inclusion of the generic rtai.h header</span>
00432 <span class="comment"> *       file as it need the prototye for rt_enable_irq.</span>
00433 <span class="comment"> */</span>
00434 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_set_timer_delay(<span class="keywordtype">int</span> delay)
00435 {
00436         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00437 
00438         hard_save_flags_and_cli(flags);
00439         write_c0_compare(read_c0_count() +
00440                         (delay ? delay : rt_times.periodic_tick));
00441         hard_restore_flags(flags);
00442         rt_enable_irq(TIMER_8254_IRQ);
00443 
00444 }  <span class="comment">/* End function - rt_set_timer_delay */</span>
00445 
00446 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00447 
00448 <span class="preprocessor">#define RTAI_DEFAULT_TICK    200000</span>
00449 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_DEFAULT_STACKSZ 1000</span>
00450 <span class="preprocessor"></span>
00451 <span class="preprocessor">#endif // _RTAI_ASM_MIPS_RTAI_H_</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:02 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
