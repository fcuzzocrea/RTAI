<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: fifos.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/ipc/fifos/fifos.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Implementation of the <a class="el" href="group__fifos.html">RTAI FIFO module</a>. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>Paolo Mantegazza</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Copyright &copy; 1999-2003 Paolo Mantegazza &lt;<a href="mailto:mantegazza@aero.polimi.it">mantegazza@aero.polimi.it</a>&gt;</dd></dl>
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.<p>
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.<p>
You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
<p>

<p>
Include dependency graph for fifos.c:<p><center><img src="fifos_8c__incl.png" border="0" usemap="#fifos.c_map" alt="Include dependency graph"></center>
<map name="fifos.c_map">
<area href="rtai__fifos_8h.html" shape="rect" coords="307,787,379,806" alt="">
<area href="rtai__lxrt_8h.html" shape="rect" coords="155,740,222,759" alt="">
<area href="rtai__sched_8h-source.html" shape="rect" coords="25,715,107,734" alt="">
<area href="rtai__trace_8h-source.html" shape="rect" coords="305,830,382,848" alt="">
<area href="rtai__proc__fs_8h-source.html" shape="rect" coords="297,872,390,891" alt="">
</map>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__fifos__ipc.html#a6">rtf_reset</a> (unsigned int minor)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__fifos__ipc.html#a7">rtf_resize</a> (unsigned int minor, int size)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="fifos_8c.html#a64">rtf_create</a> (unsigned int minor, int size)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="fifos_8c.html#a65">rtf_destroy</a> (unsigned int minor)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__fifos__ipc.html#a10">rtf_create_handler</a> (unsigned int minor, int(*handler)(unsigned int fifo))</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__fifos__ipc.html#a11">rtf_put</a> (unsigned int minor, void *buf, int count)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="fifos_8c.html#a70">rtf_get</a> (unsigned int minor, void *buf, int count)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__fifos__sem.html#a2">rtf_sem_init</a> (unsigned int minor, int value)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__fifos__sem.html#a3">rtf_sem_post</a> (unsigned int minor)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__fifos__sem.html#a4">rtf_sem_trywait</a> (unsigned int minor)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__fifos__sem.html#a5">rtf_sem_destroy</a> (unsigned int minor)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a64" doxytag="fifos.c::rtf_create" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rtf_create </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>minor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a real-time FIFO<p>
rtf_create creates a real-time fifo (RT-FIFO) of initial size <em>size</em> and assigns it the identifier <em>fifo</em>. It must be used only in kernel space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>minor</em>&nbsp;</td><td>is a positive integer that identifies the fifo on further operations. It has to be less than RTF_NO.</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>is the requested size for the fifo.</td></tr>
  </table>
</dl>
<em>fifo</em> may refer to an existing RT-FIFO. In this case the size is adjusted if necessary.<p>
The RT-FIFO is a character based mechanism to communicate among real-time tasks and ordinary Linux processes. The rtf_* functions are used by the real-time tasks; Linux processes use standard character device access functions such as read, write, and select.<p>
If this function finds an existing fifo of lower size it resizes it to the larger new size. Note that the same condition apply to the standard Linux device open, except that when it does not find any already existing fifo it creates it with a default size of 1K bytes.<p>
It must be remarked that practically any fifo size can be asked for. In fact if <em>size</em> is within the constraint allowed by kmalloc such a function is used, otherwise vmalloc is called, thus allowing any size that can fit into the available core memory.<p>
Multiple calls of this function are allowed, a counter is kept internally to track their number, and avoid destroying/closing a fifo that is still used.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>size</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign=top><em>ENODEV</em>&nbsp;</td><td>if fifo is greater than or equal to RTF_NO </td></tr>
    <tr><td valign=top><em>ENOMEM</em>&nbsp;</td><td>if the necessary size could not be allocated for the RT-FIFO. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a65" doxytag="fifos.c::rtf_destroy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rtf_destroy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>minor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a real-time FIFO<p>
rtf_destroy closes, in kernel space, a real-time fifo previously created or reopened with <a class="el" href="group__fifos__ipc.html#a8">rtf_create()</a> or <a class="el" href="group__fifos__ipc.html#a1">rtf_open_sized()</a>. An internal mechanism counts how many times a fifo was opened. Opens and closes must be in pair. rtf_destroy should be called as many times as rtf_create was. After the last close the fifo is really destroyed.<p>
No need for any particular function for the same service in user space, simply use the standard Unix close.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a non-negative value on success. Actually it is the open counter, that means how many times rtf_destroy should be called yet to destroy the fifo.<p>
a a negative value is returned as described below. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ENODEV</em>&nbsp;</td><td>if <em>fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td valign=top><em>EINVAL</em>&nbsp;</td><td>if <em>fifo</em> refers to a not opened fifo.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The equivalent of rtf_destroy in user space is the standard UNIX close. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a70" doxytag="fifos.c::rtf_get" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rtf_get </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>minor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read data from FIFO<p>
rtf_get tries to read a block of data from a real-time fifo previously created with a call to <a class="el" href="group__fifos__ipc.html#a8">rtf_create()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>minor</em>&nbsp;</td><td>is the ID with which the RT-FIFO was created. </td></tr>
    <tr><td valign=top><em>buf</em>&nbsp;</td><td>points a buffer provided by the caller. </td></tr>
    <tr><td valign=top><em>count</em>&nbsp;</td><td>is the size of <em>buf</em> in bytes.</td></tr>
  </table>
</dl>
This mechanism is available only to real-time tasks; Linux processes use a read from the corresponding fifo device to dequeue data from a fifo. Similarly, Linux processes use write or similar functions to write the data to be read via <a class="el" href="group__fifos__ipc.html#a11">rtf_put()</a> by a real-time task.<p>
rtf_get is often used in conjunction with <a class="el" href="group__fifos__ipc.html#a10">rtf_create_handler()</a> to process data received asynchronously from a Linux process. A handler is installed via <a class="el" href="group__fifos__ipc.html#a10">rtf_create_handler()</a>; this handler calls rtf_get to receive any data present in the RT-FIFO as it becomes available. In this way, polling is not necessary; the handler is called only when data is present in the fifo.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the size of the received data block on success. Note that this value may be less than count if count bytes of data is not available in the fifo. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ENODEV</em>&nbsp;</td><td>if <em>fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td valign=top><em>EINVAL</em>&nbsp;</td><td>if <em>fifo</em> refers to a not opened fifo.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The equivalent of rtf_get in user space is the standard UNIX read, which can be either blocking or nonblocking according to how you opened the related device. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:13 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
