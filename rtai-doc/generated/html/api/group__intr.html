<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Interrupt management.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Interrupt management.<br>
<small>
[<a class="el" href="group__xenomai.html">Xenomai scheduler.</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Interrupt management. 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="intr_8c.html">intr.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupt management. <br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__intr.html#a2">xnintr_init</a> (xnintr_t *intr, unsigned irq, int priority, xnisr_t isr, xnist_t ist, xnflags_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize an interrupt object. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__intr.html#a3">xnintr_destroy</a> (xnintr_t *intr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy an interrupt object. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__intr.html#a4">xnintr_attach</a> (xnintr_t *intr, void *cookie)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach an interrupt object. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__intr.html#a5">xnintr_detach</a> (xnintr_t *intr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach an interrupt object. </em> <a href="#a5"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a4" doxytag="intr.h::xnintr_attach" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnintr_attach </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnintr_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>intr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>cookie</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attach an interrupt object. 
<p>
Attach an interrupt object previously initialized by <a class="el" href="group__intr.html#a2">xnintr_init()</a>. After this operation is completed, all IRQs received from the corresponding interrupt channel are directed to the object's ISR/IST handlers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to attach.</td></tr>
    <tr><td valign=top><em>cookie</em>&nbsp;</td><td>A user-defined opaque value which is stored into the interrupt object descriptor for further retrieval by the ISR/ISR handlers.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XN_OK is returned on success. Otherwise, XNERR_NOSYS is returned if a low-level error occurred while attaching the interrupt. XNERR_BUSY is specifically returned if the interrupt object was already attached.</dd></dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine must be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="intr.h::xnintr_destroy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnintr_destroy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnintr_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>intr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy an interrupt object. 
<p>
Destroys an interrupt object previously initialized by <a class="el" href="group__intr.html#a2">xnintr_init()</a>. The interrupt object is automatically detached by a call to <a class="el" href="group__intr.html#a5">xnintr_detach()</a>. No more IRQs will be dispatched by this object after this service has returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to destroy.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XN_OK is returned on success. Otherwise, XNERR_BUSY is returned if an error occurred while detaching the interrupt (see <a class="el" href="group__intr.html#a5">xnintr_detach()</a>).</dd></dl>
Side-effect: This routine calls the rescheduling procedure as a result of an interrupt service thread deleting its own interrupt object (this should rarely happen though).<p>
Context: This routine must be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="intr.h::xnintr_detach" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnintr_detach </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnintr_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>intr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Detach an interrupt object. 
<p>
Detach an interrupt object previously attached by <a class="el" href="group__intr.html#a4">xnintr_attach()</a>. After this operation is completed, no more IRQs are directed to the object's ISR/IST handlers, but the interrupt object itself remains valid. A detached interrupt object can be attached again by a subsequent call to <a class="el" href="group__intr.html#a4">xnintr_attach()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to detach.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XN_OK is returned on success. Otherwise, XNERR_BUSY is returned if a low-level error occurred while detaching the interrupt. Detaching a non-attached interrupt object leads to a null-effect and returns XN_OK.</dd></dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine must be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="intr.h::xnintr_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnintr_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnintr_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>intr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>irq</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnisr_t&nbsp;</td>
          <td class="mdname" nowrap> <em>isr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnist_t&nbsp;</td>
          <td class="mdname" nowrap> <em>ist</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnflags_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize an interrupt object. 
<p>
The nanokernel defines a threaded interrupt model in order to:<p>
<ul>
<li>provide a mean for prioritizing interrupt handling by software.</li></ul>
<p>
<ul>
<li>allow the interrupt code to synchronize with other system code using mutexes, therefore reducing the need for hard interrupt masking in critical sections.</li></ul>
<p>
Xenomai's nanokernel exhibits a split interrupt handling scheme separated into two parts. The first part is known as the Interrupt Service Routine (ISR), the second is the Interrupt Service Tasklet (IST).<p>
When an interrupt occurs, the ISR is fired in order to deal with the hardware event as fast as possible, without any interaction with the nanokernel. If the interrupt service code needs to reenter the nanokernel, the ISR may require an associated interrupt service tasklet to be scheduled immediately upon return. The IST has a lightweight thread context that allows it to invoke all nanokernel services safely. A Xenomai interrupt object may be associated with an ISR and/or an IST to process each IRQ event.<p>
[WARNING] Interrupt service threads/tasklets are deprecated in newer versions of the Xenomai nucleus, basically due to design and performance issues. Do not use the IST facility if you plan to port to RTAI/fusion.<p>
Upon receipt of an IRQ, the ISR/IST invocation policy is as follows:<p>
<ul>
<li>if an ISR has been defined, it is immediately called on behalf of the interrupt stack context.</li></ul>
<p>
<ul>
<li>if an IST has been defined, then its is scheduled upon return of the ISR if the XN_ISR_SCHED_T bit set in its return code or if no ISR has been defined for this interrupt object. The tasklet will run after all ISRs have completed and all more prioritary IST have returned. In any cases, the IST will run before any regular real-time threads (i.e. all but interrupt service threads).</li></ul>
<p>
If an ISR has been defined, the following bits are checked from its return value:<p>
<ul>
<li>XN_ISR_ENABLE asks the nanokernel to re-enable the IRQ line. Over some real-time control layers which mask and acknowledge IRQs, this operation is necessary to revalidate the interrupt channel so that more interrupts can be notified. The presence of such bit in the ISR's return code causes Xenomai to ask the real-time control layer to re-enable the interrupt.</li></ul>
<p>
<ul>
<li>XN_ISR_CHAINED tells the nanokernel to require the real-time control layer to forward the IRQ. For instance, this would cause the Adeos control layer to propagate the interrupt down the interrupt pipeline to other Adeos domains, such as Linux. This is the regular way to share interrupts between Xenomai and the host system.</li></ul>
<p>
<ul>
<li>XN_ISR_SCHED_T tells the nanokernel to schedule the interrupt service tasklet (IST) which will be in charge of completing the interrupt processing on behalf of a lightweight thread context.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>intr</em>&nbsp;</td><td>The address of a interrupt object descriptor Xenomai will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign=top><em>irq</em>&nbsp;</td><td>The hardware interrupt channel associated with the interrupt object. This value is architecture-dependent. An interrupt object must then be attached to the hardware interrupt vector using the <a class="el" href="group__intr.html#a4">xnintr_attach()</a> service for the associated IRQs to be directed to this object.</td></tr>
    <tr><td valign=top><em>priority</em>&nbsp;</td><td>The priority level of the interrupt. If a valid interrupt service thread is passed in ist, this value will be used to compute the base priority of the service thread. This value must range from [0 .. XNINTR_MAX_PRIORITY] (inclusive). The higher the value, the higher the priority, whatever the current pod priority scheme is.</td></tr>
    <tr><td valign=top><em>isr</em>&nbsp;</td><td>The address of a valid low-level interrupt service routine if this parameter is non-zero. This handler will be called each time the corresponding IRQ is delivered on behalf of an interrupt context. When called, the ISR is passed the descriptor address of the interrupt object.</td></tr>
    <tr><td valign=top><em>ist</em>&nbsp;</td><td>If non-zero, this parameter should contain the address of a valid hi-level interrupt service tasklet. The tasklet will be called on behalf of an interrupt service thread each time the associated ISR sets the XN_ISR_SCHED_T bit in its return code. The underlying lightweight thread is immediately started with a stack of XNARCH_THREAD_STACKSZ bytes.</td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td>A set of creation flags affecting the operation. Since no flags are currently defined, zero should be passed for this parameter.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XN_OK is returned upon success. Otherwise XNERR_PARAM is returned if the interrupt priority level is out of range.</dd></dl>
Side-effect: This routine calls the rescheduling procedure as a result of starting the interrupt service thread (if any).<p>
Context: This routine must be called on behalf of a thread context.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:22 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
