<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: LXRT module.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>LXRT module.</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
LXRT services (soft-hard real time in user space). 
<p>
LXRT is a module that allows you to use all the services made available by RTAI and its schedulers in user space, both for soft and hard real time. At the moment it is a feature youll find nowhere but with RTAI. For an explanation of how it works see <a class="el" href="lxrt_faq.html">Pierre Cloutiers LXRT-INFORMED FAQs</a>, and the explanation of <a class="el" href="whatis_lxrt.html">the implementation of hard real time in user space</a> (contributed by: Pierre Cloutier, Paolo Mantegazza, Steve Papacharalambous).<p>
LXRT-INFORMED should be the production version of LXRT, the latter being the development version. So it can happen that LXRT-INFORMED could be lagging slightly behind LXRT. If you need to hurry to the services not yet ported to LXRT-INFORMED do it without pain. Even if you are likely to miss some useful services found only in LXRT-INFORMED, we release only when a feature is relatively stable.<p>
From what said above there should be no need for anything specific as all the functions you can use in user space have been already documented in this manual. There are however a few exceptions that need to be explained.<p>
Note also that, as already done for the shared memory services in user space, the function calls for Linux processes are inlined in the file rtai_lxrt.h. This approach has been preferred to a library since it is simpler, more effective, the calls are short and simple so that, even if it is likely that there can be more than just a few per process, they could never be charged of making codes too bigger. Also common to shared memory is the use of unsigned int to identify LXRT objects. If you want to use string identifiers the same support functions, i.e. <a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>, can be used. 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="common_8c.html">common.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common scheduling function. <br><br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="rtai__lxrt_8h.html">rtai_lxrt.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LXRT main header. <br><br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="rtai__mbx_8h.html">rtai_mbx.h</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="rtai__nam2num_8h.html">rtai_nam2num.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion between characters strings and unsigned long identifiers. <br><br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="rtai__registry_8h.html">rtai_registry.h</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="rtai__sem_8h.html">rtai_sem.h</a></td></tr>

<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a346">rt_mbx_init</a>(name, size)&nbsp;&nbsp;&nbsp;rt_typed_mbx_init(name, size, FIFO_Q)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a347">rt_sem_init</a>(name, value)&nbsp;&nbsp;&nbsp;rt_typed_sem_init(name, value, CNT_SEM)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a348">rt_cond_init</a>(name)&nbsp;&nbsp;&nbsp;rt_typed_sem_init(name, 0, BIN_SEM)</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a0">rt_get_adr</a> (unsigned long name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an object address by its name. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a1">rt_get_name</a> (void *adr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an object name by its address. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RT_TASK *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a3">rt_task_init</a> (int name, int priority, int stack_size, int max_msg_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new real time task in user space. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a5">rt_change_prio</a> (RT_TASK *task, int priority)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a task priority. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a6">rt_make_soft_real_time</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a hard real time Linux process, or pthread to the standard Linux behavior. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a7">rt_task_delete</a> (RT_TASK *task)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a8">rt_task_yield</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Yield the current task. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a9">rt_task_suspend</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rt_task_suspend suspends execution of the task task. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a10">rt_task_resume</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume a task. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a11">rt_task_make_periodic</a> (RT_TASK *task, RTIME start_time, RTIME period)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a task run periodically. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a12">rt_task_make_periodic_relative_ns</a> (RT_TASK *task, RTIME start_delay, RTIME period)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a task run periodically. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a13">rt_task_wait_period</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait till next period. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a14">rt_sleep</a> (RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay/suspend execution for a while. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a15">rt_sleep_until</a> (RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay/suspend execution for a while. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a17">start_rt_timer</a> (int period)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start timer. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a18">stop_rt_timer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop timer. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a19">rt_get_time</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a20">count2nano</a> (RTIME count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert internal count units to nanoseconds. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a21">nano2count</a> (RTIME nanos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert nanoseconds to internal count units. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a22">rt_busy_sleep</a> (int ns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay/suspend execution for a while. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a23">rt_set_periodic_mode</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set timer mode. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a24">rt_set_oneshot_mode</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set timer mode. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a25">rt_task_signal_handler</a> (RT_TASK *task, void(*handler)(void))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the signal handler of a task. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a26">rt_task_use_fpu</a> (RT_TASK *task, int use_fpu_flag)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a28">rt_linux_use_fpu</a> (int use_fpu_flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set indication of FPU usage. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a29">rt_preempt_always</a> (int yes_no)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable hard preemption. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a30">rt_get_time_ns</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a31">rt_get_cpu_time_ns</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a32">rt_set_runnable_on_cpus</a> (RT_TASK *task, unsigned long cpu_mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign CPUs to a task. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a33">rt_set_runnable_on_cpuid</a> (RT_TASK *task, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign CPUs to a task. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a35">start_rt_apic_timers</a> (struct apic_timer_setup_data *setup_mode, unsigned int rcvr_jiffies_cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start local apic timer. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a36">rt_preempt_always_cpuid</a> (int yes_no, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable hard preemption. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a37">count2nano_cpuid</a> (RTIME count, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert internal count units to nanoseconds. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a38">nano2count_cpuid</a> (RTIME nanos, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert nanoseconds to internal count units. </em> <a href="#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a39">rt_get_time_cpuid</a> (unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a40">rt_get_time_ns_cpuid</a> (unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a40"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a57">rt_make_hard_real_time</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give a Linux process, or pthread, hard real time execution capabilities allowing full kernel preemption. </em> <a href="#a57"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a58">rt_allow_nonroot_hrt</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows a non root user to use the Linux POSIX soft real time process management and memory lock functions, and allows it to do any input-output operation from user space. </em> <a href="#a58"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a67">rt_register</a> (unsigned long nam, void *adr, int typ, struct task_struct *tsk)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a68">rt_drg_on_name</a> (unsigned long name)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__lxrt.html#a69">rt_drg_on_adr</a> (void *adr)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a348" doxytag="rtai_sem.h::rt_cond_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rt_cond_init</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_typed_sem_init(name, 0, BIN_SEM)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a condition variable.<p>
Allocates and initializes a condition variable to be referred by <em>name</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>name of the condition variable.</td></tr>
  </table>
</dl>
It is important to remark that the returned pointer cannot be used directly, it is for kernel space data, but just passed as arguments when needed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the condition variable to be used in related calls or 0 if an error has occured. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a346" doxytag="rtai_mbx.h::rt_mbx_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rt_mbx_init</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_typed_mbx_init(name, size, FIFO_Q)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize mailbox.<p>
Initializes a mailbox referred to by <em>name</em> of size <em>size</em>.<p>
It is important to remark that the returned task pointer cannot be used directly, they are for kernel space data, but just passed as arguments when needed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>On success a pointer to the mail box to be used in related calls. <p>
A 0 value is returned if it was not possible to setup the semaphore or something using the same name was found. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a347" doxytag="rtai_sem.h::rt_sem_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rt_sem_init</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>value&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_typed_sem_init(name, value, CNT_SEM)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a counting semaphore.<p>
Allocates and initializes a semaphore to be referred by <em>name</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>name of the semaphore.</td></tr>
    <tr><td valign=top><em>value</em>&nbsp;</td><td>is the initial value of the semaphore</td></tr>
  </table>
</dl>
It is important to remark that the returned task pointer cannot be used directly, they are for kernel space data, but just passed as arguments when needed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the semaphore to be used in related calls or 0 if an error has occured. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a20" doxytag="rtai_lxrt.h::count2nano" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME count2nano </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>counts</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert internal count units to nanoseconds. 
<p>
<a class="anchor" name="count2nano"></a> <p>
This function converts the time of timercounts internal count units into nanoseconds. Remember that the count units are related to the time base being used (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>counts</em>&nbsp;</td><td>internal count units.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="rtai_lxrt.h::count2nano_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME count2nano_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>counts</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert internal count units to nanoseconds. 
<p>
<a class="anchor" name="count2nano_cpuid"></a> <p>
This function converts the time of timercounts internal count units into nanoseconds. It is to be used with the MUP scheduler since with such a scheduler it is possible to have independent timers, i.e. periodic of different periods or a mixing of periodic and oneshot, so that it is impossible to establish which conversion units should be used in the case one asks for a conversion from any CPU for any other CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>counts</em>&nbsp;</td><td>internal count units.</td></tr>
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>Identifier of the CPU (FIXME).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="rtai_lxrt.h::nano2count" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME nano2count </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ns</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert nanoseconds to internal count units. 
<p>
<a class="anchor" name="nano2count"></a> <p>
This function converts the time of nanosecs <em>nanoseconds</em> into internal counts units. Remember that the count units are related to the time base being used (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
The versions ending with_cpuid are to be used with the MUP scheduler since with such a scheduler it is possible to have independent timers, i.e. periodic of different periods or a mixing of periodic and oneshot, so that it is impossible to establish which conversion units should be used in the case one asks for a conversion from any CPU for any other CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ns</em>&nbsp;</td><td>Number of nanoseconds.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="rtai_lxrt.h::nano2count_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME nano2count_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>ns</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert nanoseconds to internal count units. 
<p>
<a class="anchor" name="nano2count_cpuid"></a> <p>
This function converts the time of nanosecs <em>nanoseconds</em> into internal counts units. Remember that the count units are related to the time base being used (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
This function is to be used with the MUP scheduler since with such a scheduler it is possible to have independent timers, i.e. periodic of different periods or a mixing of periodic and oneshot, so that it is impossible to establish which conversion units should be used in the case one asks for a conversion from any CPU for any other CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ns</em>&nbsp;</td><td>Number of nanoseconds.</td></tr>
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>Identifier of the CPU (FIXME).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a58" doxytag="rtai_lxrt.h::rt_allow_nonroot_hrt" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_allow_nonroot_hrt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allows a non root user to use the Linux POSIX soft real time process management and memory lock functions, and allows it to do any input-output operation from user space. 
<p>
Only the process itself can use this functions, it is not possible to impose the related transition from another process.     </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="rtai_lxrt.h::rt_busy_sleep" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_busy_sleep </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ns</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delay/suspend execution for a while. 
<p>
<a class="anchor" name="rt_busy_sleep"></a><p>
rt_busy_sleep delays the execution of the caller task without giving back the control to the scheduler. This function burns away CPU cycles in a busy wait loop so it should be used only for very short synchronization delays. On machine not having a TSC clock it can lead to many microseconds uncertain busy sleeps because of the need of reading the 8254 timer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ns</em>&nbsp;</td><td>is the number of nanoseconds to wait.</td></tr>
  </table>
</dl>
See also: <a class="el" href="rtai__lxrt_8h.html#rt_sleep">rt_sleep</a>(), <a class="el" href="rtai__lxrt_8h.html#rt_sleep_until">rt_sleep_until</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>A higher priority task or interrupt handler can run before the task goes to sleep, so the actual time spent in these functions may be longer than that specified. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="rtai_lxrt.h::rt_change_prio" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_change_prio </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change a task priority. 
<p>
<a class="anchor" name="rt_change_prio"></a><p>
rt_change_prio changes the base priority of task <em>task</em> to <em>prio</em>.<p>
Recall that a task has a base native priority, assigned at its birth or by <a class="el" href="rtai__lxrt_8h.html#rt_change_prio">rt_change_prio</a>(), and an actual, inherited, priority. They can be different because of priority inheritance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is the affected task.</td></tr>
    <tr><td valign=top><em>priority</em>&nbsp;</td><td>is the new priority, it can range within 0 &lt; prio &lt; RT_SCHED_LOWEST_PRIORITY.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>rt_change_prio returns the base priority task <em>task</em> had before the change.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx (FIXME). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a69" doxytag="rtai_registry.h::rt_drg_on_adr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_drg_on_adr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>adr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deregister an object by its address.<p>
rt_drg_on_adr deregisters the object identified by its <em>adr</em>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a positive number on success, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a68" doxytag="rtai_registry.h::rt_drg_on_name" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_drg_on_name </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deregister an object by its name.<p>
rt_drg_on_name deregisters the object identified by its <em>name</em>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a positive number on success, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="rtai_lxrt.h::rt_get_adr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* rt_get_adr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get an object address by its name. 
<p>
rt_get_adr returns the address associated to <em>name</em>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the address associated to <em>name</em> on success, 0 on failure </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="rtai_lxrt.h::rt_get_cpu_time_ns" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_cpu_time_ns </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_cpu_time_ns"></a> <p>
rt_get_cpu_time_ns always returns the CPU time in nanoseconds whatever timer is in use.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="rtai_lxrt.h::rt_get_name" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long rt_get_name </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>adr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get an object name by its address. 
<p>
rt_get_name returns the name pointed by the address <em>adr</em>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the identifier pointed by the address <em>adr</em> on success, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="rtai_lxrt.h::rt_get_time" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time"></a> <p>
rt_get_time returns the time, in internal count units, since start_rt_timer was called. In periodic mode this number is in multiples of the periodic tick. In oneshot mode it is directly the TSC count for CPUs having a time stamp clock (TSC), while it is a (FIXME) on 8254 units for those not having it (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="rtai_lxrt.h::rt_get_time_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cpuid</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time_cpuid"></a> <p>
rt_get_time_cpuid returns the time, in internal count units, since start_rt_timer was called. In periodic mode this number is in multiples of the periodic tick. In oneshot mode it is directly the TSC count for CPUs having a time stamp clock (TSC), while it is a (FIXME) on 8254 units for those not having it (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation). This version ending with _cpuid must be used with the MUP scheduler when there is the need to declare from which cpuid the time must be gotten (FIXME). In fact one can need to get the time of another CPU and timers can differ from CPU to CPU. (FIXME) All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>corresponds to the CPUI identifier.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="rtai_lxrt.h::rt_get_time_ns" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time_ns </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time_ns"></a> <p>
rt_get_time_ns is the same as <a class="el" href="sched__lxrt_8c.html#rt_get_time">rt_get_time</a>() but the returned time is converted to nanoseconds.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="rtai_lxrt.h::rt_get_time_ns_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time_ns_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cpuid</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time_ns_cpuid"></a> <p>
rt_get_time_ns is the same as rt_get_time but the returned time is converted to nanoseconds. The version ending with _cpuid must be used with the MUP scheduler when there is the need to declare from which cpuidthe time must be got. In fact one can need to get the time of another CPU and timers can differ from CPU to CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>corresponds to the CPUI identifier.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="rtai_lxrt.h::rt_linux_use_fpu" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_linux_use_fpu </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>use_fpu_flag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set indication of FPU usage. 
<p>
<a class="anchor" name="rt_linux_use_fpu"></a><p>
rt_linux_use_fpu informs the scheduler that floating point arithmetic operations will be used also by foreground Linux processes, i.e. the Linux kernel itself (unlikely) and any of its processes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>use_fpu_flag</em>&nbsp;</td><td>If this parameter has a nonzero value, the Floating Point Unit (FPU) context is also switched when <em>task</em> or the kernel becomes active. This makes task switching slower, negligibly, on all 32 bits CPUs but 386s and the oldest 486s. This flag can be set also by rt_task_init when the real time task is created. With UP and MUP schedulers care is taken to avoid useless saves/ restores of the FPU environment. Under SMP tasks can be moved from CPU to CPU so saves/restores for tasks using the FPU are always carried out. Note that by default Linux has this flag cleared. Beside by using rt_linux_use_fpu you can change the Linux FPU flag when you insmod any RTAI scheduler module by setting the LinuxFpu command line parameter of the rtai_sched module itself.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="rtai__lxrt_8h.html#rt_linux_use_fpu">rt_linux_use_fpu</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a57" doxytag="rtai_lxrt.h::rt_make_hard_real_time" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_make_hard_real_time </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Give a Linux process, or pthread, hard real time execution capabilities allowing full kernel preemption. 
<p>
rt_make_hard_real_time makes the soft Linux POSIX real time process, from which it is called, a hard real time LXRT process. It is important to remark that this function must be used only with soft Linux POSIX processes having their memory locked in memory. See Linux man pages.<p>
Only the process itself can use this functions, it is not possible to impose the related transition from another process.<p>
Note that processes made hard real time should avoid making any Linux System call that can lead to a task switch as Linux cannot run anymore processes that are made hard real time. To interact with Linux you should couple the process that was made hard real time with a Linux buddy server, either standard or POSIX soft real time. To communicate and synchronize with the buddy you can use the wealth of available RTAI, and its schedulers, services.<p>
After all it is pure nonsense to use a non hard real time Operating System, i.e. Linux, from within hard real time processes.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="rtai_lxrt.h::rt_make_soft_real_time" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_make_soft_real_time </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a hard real time Linux process, or pthread to the standard Linux behavior. 
<p>
rt_make_soft_real_time returns to soft Linux POSIX real time a process, from which it is called, that was made hard real time by a call to rt_make_hard_real_time.<p>
Only the process itself can use this functions, it is not possible to impose the related transition from another process.     </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="rtai_lxrt.h::rt_preempt_always" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_preempt_always </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>yes_no</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable hard preemption. 
<p>
<a class="anchor" name="rt_preempt_always"></a> <p>
In the oneshot mode the next timer expiration is programmed after a timer shot by choosing among the timed tasks the one with a priority higher than the task chosen to run as current, with the constraint of always assuring a correct Linux timing. In such a view there is no need to fire the timer immediately. In fact it can happen that the current task can be so fast to get suspended and rerun before the one that was devised to time the next shot when it was made running. In such a view <b>RTAI</b> schedulers try to shoot only when strictly needed. This minimizes the number of slow setups of the 8254 timer used with UP and 8254 based SMP schedulers. While such a policy minimizes the number of actual shots, greatly enhancing efficiency, it can be unsuitable when an application has to be guarded against undesired program loops or other unpredicted error causes. Calling these functions with a nonzero value assures that a timed high priority preempting task is always programmed to be fired while another task is currently running. The default is no immediate preemption in oneshot mode, i.e. firing of the next shot programmed only when strictly needed to satisfy tasks timings.<p>
<dl compact><dt><b>Note:</b></dt><dd>With UP and SMP schedulers there is always only a timing source so that cpu_idinrt_preempt_always_cpuid is not used. With the MUP scheduler you have an independent timer for each CPU, so rt_preempt_always applies to all the CPUs while rt_preempt_always_cpuid should be used when preemption is to be forced only on a specific CPU. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="rtai_lxrt.h::rt_preempt_always_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_preempt_always_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>yes_no</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable hard preemption. 
<p>
<a class="anchor" name="rt_preempt_always_cpuid"></a> <p>
In the oneshot mode the next timer expiration is programmed after a timer shot by choosing among the timed tasks the one with a priority higher than the task chosen to run as current, with the constraint of always assuring a correct Linux timing. In such a view there is no need to fire the timer immediately. In fact it can happen that the current task can be so fast to get suspended and rerun before the one that was devised to time the next shot when it was made running. In such a view <b>RTAI</b> schedulers try to shoot only when strictly needed. This minimizes the number of slow setups of the 8254 timer used with UP and 8254 based SMP schedulers. While such a policy minimizes the number of actual shots, greatly enhancing efficiency, it can be unsuitable when an application has to be guarded against undesired program loops or other unpredicted error causes. Calling these functions with a nonzero value assures that a timed high priority preempting task is always programmed to be fired while another task is currently running. The default is no immediate preemption in oneshot mode, i.e. firing of the next shot programmed only when strictly needed to satisfy tasks timings.<p>
<dl compact><dt><b>Note:</b></dt><dd>With UP and SMP schedulers there is always only a timing source so that cpu_idinrt_preempt_always_cpuid is not used. With the MUP scheduler you have an independent timer for each CPU, so rt_preempt_always applies to all the CPUs while rt_preempt_always_cpuid should be used when preemption is to be forced only on a specific CPU. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a67" doxytag="rtai_registry.h::rt_register" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_register </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>adr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct task_struct *&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register an object.<p>
rt_register registers the object to be identified with <em>name</em>, which is pointed by <em>adr</em>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a positive number on success, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="rtai_lxrt.h::rt_set_oneshot_mode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_oneshot_mode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set timer mode. 
<p>
<a class="anchor" name="rt_set_oneshot_mode"></a> <p>
rt_set_periodic_mode sets the periodic mode for the timer. It consists of a fixed frequency timing of the tasks in multiple of the period set with a call to <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>(). The resolution is that of the 8254 (1193180 Hz) on a UP machine, or if the 8254 based SMP scheduler is being used. For the SMP scheduler timed by the local APIC timer and for the MUP scheduler the timer resolution is that of the local APIC timer frequency, generally the bus frequency divided 16. Any timing request not being an integer multiple of the set timer period is satisfied at the closest period tick. It is the default mode when no call is made to set the oneshot mode.<p>
<dl compact><dt><b>Note:</b></dt><dd>Stopping the timer by <a class="el" href="sched__lxrt_8c.html#stop_rt_timer">stop_rt_timer</a>() sets the timer back into its default (periodic) mode. Always call <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() before each <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>() if you want to be sure to have it oneshot on multiple insmod without rmmoding the RTAI scheduler in use. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="rtai_lxrt.h::rt_set_periodic_mode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_periodic_mode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set timer mode. 
<p>
<a class="anchor" name="rt_set_periodic_mode"></a> <p>
rt_set_periodic_mode sets the periodic mode for the timer. It consists of a fixed frequency timing of the tasks in multiple of the period set with a call to <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>(). The resolution is that of the 8254 (1193180 Hz) on a UP machine, or if the 8254 based SMP scheduler is being used. For the SMP scheduler timed by the local APIC timer and for the MUP scheduler the timer resolution is that of the local APIC timer frequency, generally the bus frequency divided 16. Any timing request not being an integer multiple of the set timer period is satisfied at the closest period tick. It is the default mode when no call is made to set the oneshot mode.<p>
<dl compact><dt><b>Note:</b></dt><dd>Stopping the timer by <a class="el" href="sched__lxrt_8c.html#stop_rt_timer">stop_rt_timer</a>() sets the timer back into its default (periodic) mode. Always call <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() before each <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>() if you want to be sure to have it oneshot on multiple insmod without rmmoding the RTAI scheduler in use. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="rtai_lxrt.h::rt_set_runnable_on_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_runnable_on_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assign CPUs to a task. 
<p>
<a class="anchor" name="rt_set_runnable_on_cpuid"></a> <p>
rt_set_runnable_on_cpuid select one or more CPUs which are allowed to run task <em>task</em>.<p>
rt_set_runnable_on_cpuid assigns a task to a single specific CPU. If no CPU, as selected by cpu_mask or cpuid, is available, both functions choose a possible CPU automatically, following the same rule as above.<p>
<dl compact><dt><b>Note:</b></dt><dd>This call has no effect on UniProcessor (UP) systems.</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_set_runnable_on_cpus">rt_set_runnable_on_cpus</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="rtai_lxrt.h::rt_set_runnable_on_cpus" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_runnable_on_cpus </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>runnable_on_cpus</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assign CPUs to a task. 
<p>
<a class="anchor" name="rt_set_runnable_on_cpus"></a> <p>
rt_set_runnable_on_cpus selects one or more CPUs which are allowed to run task <em>task</em>. rt_set_runnable_on_cpus behaves differently for MUP and SMP schedulers. Under the SMP scheduler bit&lt;n&gt; of cpu_mask enables the task to run on CPU&lt;n&gt;. Under the MUP scheduler it selects the CPU with less running tasks among those allowed by cpu_mask. Recall that with MUP a task must be bounded to run on a single CPU. If no CPU, as selected by cpu_mask or cpuid, is available, both functions choose a possible CPU automatically, following the same rule as above.<p>
<dl compact><dt><b>Note:</b></dt><dd>This call has no effect on UniProcessor (UP) systems.</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_set_runnable_on_cpuid">rt_set_runnable_on_cpuid</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="rtai_lxrt.h::rt_sleep" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_sleep </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>delay</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delay/suspend execution for a while. 
<p>
<a class="anchor" name="rt_sleep"></a><p>
rt_sleep suspends execution of the caller task for a time of delay internal count units. During this time the CPU is used by other tasks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>delay</em>&nbsp;</td><td>Corresponds to the time the task is going to be suspended.</td></tr>
  </table>
</dl>
See also: <a class="el" href="rtai__lxrt_8h.html#rt_busy_sleep">rt_busy_sleep</a>(), <a class="el" href="rtai__lxrt_8h.html#rt_sleep_until">rt_sleep_until</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>A higher priority task or interrupt handler can run before the task goes to sleep, so the actual time spent in these functions may be longer than the the one specified. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="rtai_lxrt.h::rt_sleep_until" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_sleep_until </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>time</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delay/suspend execution for a while. 
<p>
<a class="anchor" name="rt_sleep_until"></a><p>
rt_sleep_until is similar to <a class="el" href="rtai__lxrt_8h.html#rt_sleep">rt_sleep</a>() but the parameter time is the absolute time till the task have to be suspended. If the given time is already passed this call has no effect.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>time</em>&nbsp;</td><td>Absolute time till the task have to be suspended</td></tr>
  </table>
</dl>
See also: <a class="el" href="rtai__lxrt_8h.html#rt_busy_sleep">rt_busy_sleep</a>(), <a class="el" href="rtai__lxrt_8h.html#rt_sleep_until">rt_sleep_until</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>A higher priority task or interrupt handler can run before the task goes to sleep, so the actual time spent in these functions may be longer than the the one specified. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="rtai_lxrt.h::rt_task_delete" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_delete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="anchor" name="rt_task_delete"></a> Delete a real time task.<p>
rt_task_delete deletes a real time task previously created by <a class="el" href="sched__lxrt_8c.html#rt_task_init">rt_task_init</a>() or <a class="el" href="sched__lxrt_8c.html#rt_task_init_cpuid">rt_task_init_cpuid</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is the pointer to the task structure. If task task was waiting on a queue, i.e. semaphore, mailbox, etc, it is removed from such a queue and messaging tasks pending on its message queue are unblocked with an error return.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task does not refer to a valid task. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="rtai_lxrt.h::rt_task_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RT_TASK* rt_task_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>stack_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>max_msg_size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new real time task in user space. 
<p>
rt_task_init provides a real time buddy, also called proxy, task to the Linux process that wants to access RTAI scheduler services. It needs no task function as none is used, but it does need to setup a task structure and initialize it appropriately as the provided services are carried out as if the Linux process has become an RTAI task. Because of that it requires less arguments and returns the pointer to the task that is to be used in related calls.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is a unique identifier that is possibly used by easing referencing the buddy RTAItask, and thus its peer Linux process.</td></tr>
    <tr><td valign=top><em>priority</em>&nbsp;</td><td>is the priority of the buddys priority.</td></tr>
    <tr><td valign=top><em>stack_size</em>&nbsp;</td><td>is just what is implied by such a name and refers to the stack size used by the buddy.</td></tr>
    <tr><td valign=top><em>max_msg_size</em>&nbsp;</td><td>is a hint for the size of the most lengthy message than is likely to be exchanged.</td></tr>
  </table>
</dl>
<em>stack_size</em> and <em>max_msg_size</em> can be zero, in which case the default internal values are used. The assignment of a different value should be required only if you want to use task signal functions. In such a case note that these signal functions are intended to catch asyncrounous events in kernel space and, as such, must be programmed into a companion module and interfaced to their parent Linux process through the available services.<p>
Keep an eye on the default stack (512) and message (256) sizes as they seem to be acceptable, but this API has not been used extensively with complex interrupt service routines. Since the latter are served on the stack of any task being interrupted, and more than one can pile up on the same stack, it can be possible that a larger stack is required. In such a case either recompile lxrt.c with macros STACK_SIZE and MSG_SIZE set appropriately, or explicitly assign larger values at your buddy tasks inits. Note that while the stack size can be critical the message size will not. In fact the module reassigns it, appropriately sized, whenever it is needed. The cost is a kmalloc with GFP_KERNEL that can block, but within the Linux environment. Note also that <em>max_msg_size</em> is for a buffer to be used to copy whatever message, either mailbox or inter task, from user to kernel space, as messages are not necessarily copied immediately, and has nothing to do directly with what you are doing.<p>
It is important to remark that the returned task pointers cannot be used directly, they are for kernel space data, but just passed as arguments when needed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>On success a pointer to the task structure initialized in kernel space. <p>
On failure a 0 value is returned if it was not possible to setup the buddy task or something using the same name was found. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="rtai_lxrt.h::rt_task_make_periodic" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_make_periodic </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>start_time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>period</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a task run periodically. 
<p>
<a class="anchor" name="rt_task_make_periodic"></a> rt_task_make_periodic mark the task <em>task</em>, previously created with <a class="el" href="sched__lxrt_8c.html#rt_task_init">rt_task_init</a>(), as suitable for a periodic execution, with period <em>period</em>, when <a class="el" href="rtai__lxrt_8h.html#rt_task_wait_period">rt_task_wait_period</a>() is called.<p>
The time of first execution is defined through <em>start_time</em> or <em>start_delay</em>. <em>start_time</em> is an absolute value measured in clock ticks. <em>start_delay</em> is relative to the current time and measured in nanoseconds.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is a pointer to the task you want to make periodic.</td></tr>
    <tr><td valign=top><em>start_time</em>&nbsp;</td><td>is the absolute time to wait before the task start running, in clock ticks.</td></tr>
    <tr><td valign=top><em>period</em>&nbsp;</td><td>corresponds to the period of the task, in clock ticks.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>0</em>&nbsp;</td><td>on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task does not refer to a valid task.</li></ul>
</td></tr>
  </table>
</dl>
See also: <a class="el" href="rtai__lxrt_8h.html#rt_task_make_periodic_relative_ns">rt_task_make_periodic_relative_ns</a>(). Recall that the term clock ticks depends on the mode in which the hard timer runs. So if the hard timer was set as periodic a clock tick will last as the period set in start_rt_timer, while if oneshot mode is used a clock tick will last as the inverse of the running frequency of the hard timer in use and irrespective of any period used in the call to start_rt_timer.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="rtai_lxrt.h::rt_task_make_periodic_relative_ns" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_make_periodic_relative_ns </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>start_delay</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>period</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a task run periodically. 
<p>
<a class="anchor" name="rt_task_make_periodic_relative_ns"></a> rt_task_make_periodic_relative_ns mark the task <em>task</em>, previously created with <a class="el" href="sched__lxrt_8c.html#rt_task_init">rt_task_init</a>(), as suitable for a periodic execution, with period <em>period</em>, when <a class="el" href="rtai__lxrt_8h.html#rt_task_wait_period">rt_task_wait_period</a>() is called.<p>
The time of first execution is defined through <em>start_time</em> or <em>start_delay</em>. <em>start_time</em> is an absolute value measured in clock ticks. <em>start_delay</em> is relative to the current time and measured in nanoseconds.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is a pointer to the task you want to make periodic.</td></tr>
    <tr><td valign=top><em>start_delay</em>&nbsp;</td><td>is the time, to wait before the task start running, in nanoseconds.</td></tr>
    <tr><td valign=top><em>period</em>&nbsp;</td><td>corresponds to the period of the task, in nanoseconds.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>0</em>&nbsp;</td><td>on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task does not refer to a valid task.</li></ul>
</td></tr>
  </table>
</dl>
Recall that the term clock ticks depends on the mode in which the hard timer runs. So if the hard timer was set as periodic a clock tick will last as the period set in start_rt_timer, while if oneshot mode is used a clock tick will last as the inverse of the running frequency of the hard timer in use and irrespective of any period used in the call to start_rt_timer.     </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="rtai_lxrt.h::rt_task_resume" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_resume </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resume a task. 
<p>
<a class="anchor" name="rt_task_resume"></a> rt_task_resume resumes execution of the task <em>task</em> previously suspended by <a class="el" href="rtai__lxrt_8h.html#rt_task_suspend">rt_task_suspend</a>(), or makes a newly created task ready to run, if it makes the task ready. Since no account is made for multiple suspend rt_task_resume unconditionally resumes any task it makes ready.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>pointer to a task structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>the new RTAI 24.1.xx (FIXME) development releases take into account multiple suspend and require as many rt_task_resumes as the rt_task_suspends placed on a task. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="rtai_lxrt.h::rt_task_signal_handler" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_signal_handler </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em>)(void)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the signal handler of a task. 
<p>
<a class="anchor" name="rt_task_signal_handler"></a><p>
rt_task_signal_handler installs, or changes, the signal function of a real time task.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is a pointer to the real time task.</td></tr>
    <tr><td valign=top><em>handler</em>&nbsp;</td><td>is the entry point of the signal function.</td></tr>
  </table>
</dl>
A signal handler function can be set also when the task is newly created with <a class="el" href="sched__lxrt_8c.html#rt_task_init">rt_task_init</a>(). The signal handler is a function called within the task environment and with interrupts disabled, when the task becomes the current running task after a context switch, except at its very first scheduling. It allows you to implement whatever signal management policy you think useful, and many other things as well (FIXME).<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success.A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task does not refer to a valid task. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="rtai_lxrt.h::rt_task_suspend" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_suspend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
rt_task_suspend suspends execution of the task task. 
<p>
<a class="anchor" name="rt_task_suspend"></a> It will not be executed until a call to <a class="el" href="rtai__lxrt_8h.html#rt_task_resume">rt_task_resume</a>() or <a class="el" href="rtai__lxrt_8h.html#rt_task_make_periodic">rt_task_make_periodic</a>() is made. No account is made for multiple suspends, i.e. a multiply suspended task is made ready as soon as it is rt_task_resumed, thus immediately resuming its execution if it is the highest in priority.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>pointer to a task structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>the new RTAI 24.1.xx (FIXME) development releases take into account multiple suspend and require as many <a class="el" href="rtai__lxrt_8h.html#rt_task_resume">rt_task_resume</a>() as the rt_task_suspends placed on a task. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="rtai_lxrt.h::rt_task_use_fpu" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_use_fpu </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>use_fpu_flag</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="anchor" name="rt_task_use_fpu"></a><p>
rt_task_use_fpu informs the scheduler that floating point arithmetic operations will be used by the real time task <em>task</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is a pointer to the real time task.</td></tr>
    <tr><td valign=top><em>use_fpu_flag</em>&nbsp;</td><td>If this parameter has a nonzero value, the Floating Point Unit (FPU) context is also switched when <em>task</em> or the kernel becomes active. This makes task switching slower, negligibly, on all 32 bits CPUs but 386s and the oldest 486s. This flag can be set also by <a class="el" href="sched__lxrt_8c.html#rt_task_init">rt_task_init</a>() when the real time task is created. With UP and MUP schedulers care is taken to avoid useless saves/restores of the FPU environment. Under SMP tasks can be moved from CPU to CPU so saves/restores for tasks using the FPU are always carried out.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="rtai__lxrt_8h.html#rt_linux_use_fpu">rt_linux_use_fpu</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="rtai_lxrt.h::rt_task_wait_period" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_task_wait_period </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait till next period. 
<p>
<a class="anchor" name="rt_task_wait_period"></a> rt_task_wait_period suspends the execution of the currently running real time task until the next period is reached. The task must have been previously marked for a periodic execution by calling <a class="el" href="rtai__lxrt_8h.html#rt_task_make_periodic">rt_task_make_periodic</a>() or <a class="el" href="rtai__lxrt_8h.html#rt_task_make_periodic_relative_ns">rt_task_make_periodic_relative_ns</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>The task is suspended only temporarily, i.e. it simply gives up control until the next time period. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="rtai_lxrt.h::rt_task_yield" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_yield </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Yield the current task. 
<p>
<a class="anchor" name="rt_task_yield"></a> <a class="el" href="rtai__lxrt_8h.html#rt_task_yield">rt_task_yield</a>() stops the current task and takes it at the end of the list of ready tasks having its same priority. The scheduler makes the next ready task of the same priority active.<p>
Recall that RTAI schedulers allow only higher priority tasks to preempt the execution of lower priority ones. So equal priority tasks cannot preempt each other and <a class="el" href="rtai__lxrt_8h.html#rt_task_yield">rt_task_yield</a>() should be used if a user needs a cooperative time slicing among equal priority tasks. The implementation of the related policy is wholly in the hand of the user. It is believed that time slicing is too much an overhead for the most demanding real time applications, so it is left up to you.     </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="rtai_lxrt.h::start_rt_apic_timers" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void start_rt_apic_timers </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct apic_timer_setup_data *&nbsp;</td>
          <td class="mdname" nowrap> <em>setup_mode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>rcvr_jiffies_cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start local apic timer. 
<p>
<a class="anchor" name="start_rt_apic_timer"></a> <p>
start_rt_apic_timers starts local APIC timers according to what is found in <em>setup_data</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>setup_mode</em>&nbsp;</td><td>is a pointer to an array of structures apic_timer_setup_data, see function rt_setup_apic_timers (FIXME) in RTAI module functions described further on in this manual. </td></tr>
    <tr><td valign=top><em>rcvr_jiffies_cpuid</em>&nbsp;</td><td>is the CPU number whose time log has to be used to keep Linux timing and pacing in tune. This function is specific to the MUP scheduler. If it is called with either the UP or SMP scheduler it will use:<ul>
<li>a periodic timer if all local APIC timers are periodic with the same period;</li><li>a oneshot timer if all the local APIC timers are oneshot, or have different timing modes, are periodic with different periods. </li></ul>
</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="rtai_lxrt.h::start_rt_timer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME start_rt_timer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>period</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start timer. 
<p>
<a class="anchor" name="start_rt_timer"></a> <p>
start_rt_timer starts the timer with a period <em>period</em>. The period is in internal count units and is required only for the periodic mode. In the oneshot mode the period value is ignored. This functions uses the 8254 with the UP and the 8254 based SMP scheduler. Otherwise it uses a single local APIC with the APIC based SMP schedulers and an APIC for each CPU with the MUP scheduler. In the latter case all local APIC timers are paced in the same way, according to the timer mode set.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The period in internal count units. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="rtai_lxrt.h::stop_rt_timer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void stop_rt_timer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stop timer. 
<p>
<a class="anchor" name="stop_rt_timer"></a> <p>
stop_rt_timer stops the timer. The timer mode is set to periodic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The period in internal count units. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:21 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
