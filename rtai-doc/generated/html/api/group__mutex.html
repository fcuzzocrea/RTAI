<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Nanokernel mutex services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Nanokernel mutex services.<br>
<small>
[<a class="el" href="group__xenomai.html">Xenomai scheduler.</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Nanokernel mutex services.<p>
[WARNING] Mutex services are deprecated in newer versions of the Xenomai nucleus, basically due to design and performance issues. Do not use this facility if you plan to port to RTAI/fusion.<p>
Mutexes are internal synchronization objects that do NOT rely on the standard nanokernel scheduling routines to operate. However, they share the same protocol inheritance scheme with the regular xnsynch objects for the sake of clarity and efficiency. In other words, code in <a class="el" href="mutex_8c.html">mutex.c</a> and <a class="el" href="synch_8c.html">synch.c</a> cooperate on the same logic and data structures for handling PIP both for kernel mutexes and regular resources.<p>
One should keep in mind that a thread claiming a mutex is NOT actually suspended, but the current mutex owner is simply rescheduled before the "sleeper" instead. Priority inheritance allows to boost the current mutex owner so that it can release the lock as soon as possible.<p>
Consequently, blocking or suspending a thread that holds a mutex is a BUG! However, the nanokernel provides for a special mechanism that releases a given interface mutex atomically when <a class="el" href="group__pod.html#a53">xnpod_suspend_thread()</a> is called for the current thread, reacquiring it on return of this routine. This mechanism should be understood as a lock-breaking preemption point atomically performed just before the current thread is switched out. <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__pod.html#a57">xnpod_schedule()</a> for more on this. </dd></dl>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mutex_8c.html">mutex.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nanokernel mutex services. <br><br></td></tr>

<p>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:22 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
