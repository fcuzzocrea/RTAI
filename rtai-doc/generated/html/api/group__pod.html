<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Real-time pod services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Real-time pod services.<br>
<small>
[<a class="el" href="group__xenomai.html">Xenomai scheduler.</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Real-time pod services. 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="pod_8c.html">pod.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real-time pod services. <br><br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="pod_8h.html">pod.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real-time pod interface header. <br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structxnpod.html">xnpod</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real-time pod descriptor. </em> <a href="structxnpod.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structxnsched.html">xnsched</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheduling information structure. </em> <a href="structxnsched.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a0" doxytag="pod::xnsched_t" ></a>
typedef <a class="el" href="structxnsched.html">xnsched</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a0">xnsched_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheduling information structure. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structxnpod.html">xnpod</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a1">xnpod_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real-time pod descriptor. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a4">xnpod_schedule_runnable</a> (xnthread_t *thread, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hidden rescheduling procedure - INTERNAL. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a16">xnpod_init</a> (<a class="el" href="structxnpod.html">xnpod_t</a> *pod, int minpri, int maxpri, xnflags_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a new pod. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a18">xnpod_stop_timer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop the periodic timer. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a19">xnpod_shutdown</a> (int xtype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default shutdown handler. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a20">xnpod_init_thread</a> (xnthread_t *thread, const  char *name, int prio, xnflags_t flags, unsigned stacksize, void *adcookie, unsigned magic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a new thread. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a21">xnpod_start_thread</a> (xnthread_t *thread, xnflags_t mode, int imask, void(*entry)(void *cookie), void *cookie)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initial start of a newly created thread. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>xnflags_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a24">xnpod_set_thread_mode</a> (xnthread_t *thread, xnflags_t clrmask, xnflags_t setmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a thread's control mode. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a26">xnpod_resume_thread</a> (xnthread_t *thread, xnflags_t mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume a thread. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a27">xnpod_unblock_thread</a> (xnthread_t *thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock a thread. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a28">xnpod_renice_thread</a> (xnthread_t *thread, int prio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the base priority of a thread. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a29">xnpod_rotate_readyq</a> (int prio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a priority level in the ready queue. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a34">xnpod_activate_rr</a> (xnticks_t quantum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Globally activate the round-robin scheduling. </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a35">xnpod_deactivate_rr</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Globally deactivate the round-robin scheduling. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a36">xnpod_set_time</a> (xnticks_t newtime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the nanokernel idea of time. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>xnticks_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a37">xnpod_get_time</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the nanokernel idea of time. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a39">xnpod_add_hook</a> (int type, void(*routine)(xnthread_t *))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a nanokernel hook. </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a40">xnpod_remove_hook</a> (int type, void(*routine)(xnthread_t *))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a nanokernel hook. </em> <a href="#a40"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a50">xnpod_preempt_current_thread</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preempts the current thread - INTERNAL. </em> <a href="#a50"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a51">xnpod_restart_thread</a> (xnthread_t *thread, xnmutex_t *imutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restart a thread. </em> <a href="#a51"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a52">xnpod_delete_thread</a> (xnthread_t *thread, xnmutex_t *imutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a thread. </em> <a href="#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a53">xnpod_suspend_thread</a> (xnthread_t *thread, xnflags_t mask, xnticks_t timeout, xnsynch_t *wchan, xnmutex_t *imutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend a thread. </em> <a href="#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a54">xnpod_dispatch_signals</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deliver pending asynchronous signals to the running thread - INTERNAL. </em> <a href="#a54"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a55">xnpod_welcome_thread</a> (xnthread_t *thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread prologue - INTERNAL. </em> <a href="#a55"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a57">xnpod_schedule</a> (xnmutex_t *imutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rescheduling procedure entry point. </em> <a href="#a57"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a58">xnpod_trap_fault</a> (void *fltinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default fault handler. </em> <a href="#a58"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a60">xnpod_start_timer</a> (u_long nstick, xnist_t tickhandler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the system timer. </em> <a href="#a60"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__pod.html#a61">xnpod_announce_tick</a> (xnintr_t *intr, int hits)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Announce a new clock tick. </em> <a href="#a61"></a><em><br><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a1" doxytag="pod.h::xnpod_t" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="structxnpod.html">xnpod</a>  <a class="el" href="structxnpod.html">xnpod_t</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Real-time pod descriptor. 
<p>
The source of all Xenomai magic.     </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a34" doxytag="pod.h::xnpod_activate_rr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_activate_rr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnticks_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>quantum</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Globally activate the round-robin scheduling. 
<p>
This service activates the round-robin scheduling for all threads which have the XNRRB flag set in their status mask (see <a class="el" href="group__pod.html#a24">xnpod_set_thread_mode()</a>). Each of them will run for the given time quantum, then preempted and moved at the end of its priority group in the ready queue. This process is repeated until the round-robin scheduling is disabled for those threads.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>quantum</em>&nbsp;</td><td>The time credit which will be given to each rr-enabled thread (in ticks).</td></tr>
  </table>
</dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="pod.h::xnpod_add_hook" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnpod_add_hook </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>routine</em>)(xnthread_t *)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Install a nanokernel hook. 
<p>
The nanokernel allows to register user-defined routines which get called whenever a specific scheduling event occurs. Multiple hooks can be chained for a single event type, and get called on a FIFO basis.<p>
The scheduling is locked while a hook is executing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>type</em>&nbsp;</td><td>Defines the kind of hook to install:</td></tr>
  </table>
</dl>
<ul>
<li>XNHOOK_THREAD_START: The user-defined routine will be called on behalf of the starter thread whenever a new thread starts. The descriptor address of the started thread is passed to the routine.</li></ul>
<p>
<ul>
<li>XNHOOK_THREAD_DELETE: The user-defined routine will be called on behalf of the deletor thread whenever a thread is deleted. The descriptor address of the deleted thread is passed to the routine.</li></ul>
<p>
<ul>
<li>XNHOOK_THREAD_SWITCH: The user-defined routine will be called on behalf of the resuming thread whenever a context switch takes place. The descriptor address of the thread which has been switched out is passed to the routine.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>routine</em>&nbsp;</td><td>The address of the user-supplied routine to call.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XN_OK is returned on success. Otherwise, one of the following error codes indicates the cause of the failure:</dd></dl>
<ul>
<li>XNERR_PARAM is returned if type is incorrect.</li></ul>
<p>
<ul>
<li>XNERR_NOMEM is returned if not enough memory is available from the system heap to add the new hook.</li></ul>
<p>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a61" doxytag="pod.c::xnpod_announce_tick" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_announce_tick </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnintr_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>intr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>hits</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Announce a new clock tick. 
<p>
This is the default service routine for clock ticks which performs the necessary housekeeping chores for time-related services managed by the nanokernel. In a way or another, this routine must be called to announce each incoming clock tick to the nanokernel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object underlying the timer interrupt.</td></tr>
    <tr><td valign=top><em>hits</em>&nbsp;</td><td>The number of pending interrupt hits to process in a row.</td></tr>
  </table>
</dl>
Side-effect: Since this routine manages the round-robin scheduling, the running thread (which has been preempted by the timer interrupt) can be switched out as a result of its time credit being exhausted. The nanokernel always calls the rescheduling procedure after the outer interrupt has been processed.<p>
Context: The caller must have a valid nanokernel context (regular or interrupt service thread).     </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="pod.h::xnpod_deactivate_rr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_deactivate_rr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Globally deactivate the round-robin scheduling. 
<p>
This service deactivates the round-robin scheduling for all threads which have the XNRRB flag set in their status mask (see <a class="el" href="group__pod.html#a24">xnpod_set_thread_mode()</a>).<p>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a52" doxytag="pod.c::xnpod_delete_thread" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_delete_thread </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnmutex_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>imutex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a thread. 
<p>
Terminates a thread and releases all the nanokernel resources it currently holds. A thread exists in the system since <a class="el" href="group__pod.html#a20">xnpod_init_thread()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>thread</em>&nbsp;</td><td>The descriptor address of the terminated thread.</td></tr>
    <tr><td valign=top><em>imutex</em>&nbsp;</td><td>The address of an interface mutex currently held by the caller which will be subject to a lock-breaking preemption if the current thread is deleted. This parameter only makes sense for self-deleting threads. Passing NULL when no lock-breaking preemption is required is valid. See <a class="el" href="group__pod.html#a57">xnpod_schedule()</a> for more on lock-breaking preemption points.</td></tr>
  </table>
</dl>
The DELETE hooks are called on behalf of the calling context (if any). The information stored in the thread control block remains valid until all hooks have been called.<p>
Self-terminating a thread is allowed. In such a case, this service does not return to the caller.<p>
Side-effect: This routine calls the rescheduling procedure.<p>
Context: This routine must be called on behalf of a thread context.     </td>
  </tr>
</table>
<a class="anchor" name="a54" doxytag="pod.c::xnpod_dispatch_signals" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_dispatch_signals </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deliver pending asynchronous signals to the running thread - INTERNAL. 
<p>
This internal routine checks for the presence of asynchronous signals directed to the running thread, and attempt to start the asynchronous service routine (ASR) if any.     </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="pod.h::xnpod_get_time" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> xnticks_t xnpod_get_time </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the nanokernel idea of time. 
<p>
This service gets the nanokernel (external) clock time.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current nanokernel time (in ticks) if the underlying time source runs in periodic mode, or the CPU tick count if the aperiodic mode is in effect, or no timer is running.</dd></dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of any context.     </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="pod.h::xnpod_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnpod_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structxnpod.html">xnpod_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pod</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>minpri</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxpri</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnflags_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a new pod. 
<p>
Initializes a new pod which can subsequently be used to start real-time activities. Once a pod is active, real-time APIs can be stacked over. There can only be a single pod active in the host environment. Such environment can be confined to a process though (e.g. MVM or POSIX layers), or expand to the whole system (e.g. Adeos or RTAI).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pod</em>&nbsp;</td><td>The address of a pod descriptor Xenomai will use to store the pod-specific data. This descriptor must always be valid while the pod is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign=top><em>minpri</em>&nbsp;</td><td>The value of the lowest priority level which is valid for threads created on behalf of this pod.</td></tr>
    <tr><td valign=top><em>maxpri</em>&nbsp;</td><td>The value of the highest priority level which is valid for threads created on behalf of this pod.</td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td>A set of creation flags affecting the operation. The only defined flag is XNDREORD (Disable REORDering), which tells the nanokernel that the (xnsynch_t) pend queue should not be reordered whenever the priority of a blocked thread it holds is changed. If this flag is not specified, changing the priority of a blocked thread using <a class="el" href="group__pod.html#a28">xnpod_renice_thread()</a> will cause the pended queue to be reordered according to the new priority level, provided the synchronization object makes the waiters wait by priority order on the awaited resource (XNSYNCH_PRIO).</td></tr>
  </table>
</dl>
minpri might be numerically higher than maxpri if the upper real-time interface exhibits a reverse priority scheme. For instance, some APIs may define a range like minpri=255, maxpri=0 specifying that thread priorities increase as the priority level decreases numerically.<p>
Context: This routine must be called on behalf of a context allowing immediate memory allocation requests (e.g. an <a class="el" href="legacy_8c.html#a111">init_module()</a> routine).     </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="pod.h::xnpod_init_thread" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnpod_init_thread </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>prio</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnflags_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>stacksize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>adcookie</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>magic</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a new thread. 
<p>
Initializes a new thread attached to the active pod. The thread is left in an innocuous mode until it is actually started by <a class="el" href="group__pod.html#a21">xnpod_start_thread()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>thread</em>&nbsp;</td><td>The address of a thread descriptor Xenomai will use to store the thread-specific data. This descriptor must always be valid while the thread is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign=top><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the thread. This name is copied to a safe place into the thread descriptor. This name might be used in various situations by the nanokernel for issuing human-readable diagnostic messages, so it is usually a good idea to provide a sensible value here. The MVM layer even uses this name intensively to identify threads in the debugging GUI it provides. However, passing NULL is always legal and means "anonymous".</td></tr>
    <tr><td valign=top><em>prio</em>&nbsp;</td><td>The base priority of the new thread. This value must range from [minpri .. maxpri] (inclusive) as specified when calling the <a class="el" href="group__pod.html#a16">xnpod_init()</a> service.</td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td>A set of creation flags affecting the operation. The only defined flag available to the upper interfaces is XNFPU (enable FPU), which tells the nanokernel that the new thread will use the floating-point unit. In such a case, the nanokernel will handle the FPU context save/restore ops upon thread switches at the expense of a few additional cycles per context switch. By default, a thread is not expected to use the FPU. This flag is simply ignored when Xenomai runs on behalf of a userspace-based real-time control layer since the FPU management is always active if present.</td></tr>
    <tr><td valign=top><em>stacksize</em>&nbsp;</td><td>The size of the stack (in bytes) for the new thread. If zero is passed, the nanokernel will use a reasonable pre-defined size depending on the underlying real-time control layer.</td></tr>
    <tr><td valign=top><em>adcookie</em>&nbsp;</td><td>An architecture-dependent cookie. The caller should pass the XNARCH_THREAD_COOKIE value defined for all real-time control layers in their respective interface file. This system-defined cookie must not be confused with the user-defined thread cookie passed to the <a class="el" href="group__pod.html#a21">xnpod_start_thread()</a> service.</td></tr>
    <tr><td valign=top><em>magic</em>&nbsp;</td><td>A magic cookie each skin can define to unambiguously identify threads created in their realm. This value is copied as-is to the "magic" field of the thread struct. 0 is a conventional value for "no magic".</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XN_OK is returned on success. Otherwise, one of the following error codes indicates the cause of the failure:</dd></dl>
<ul>
<li>XNERR_PARAM is returned if <em>flags</em> has invalid bits set.</li></ul>
<p>
<ul>
<li>XNERR_NOMEM is returned if <em>thread</em> is NULL or not enough memory is available from the system heap to create the new thread's stack.</li></ul>
<p>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine must be called on behalf of a thread context.     </td>
  </tr>
</table>
<a class="anchor" name="a50" doxytag="pod.c::xnpod_preempt_current_thread" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_preempt_current_thread </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Preempts the current thread - INTERNAL. 
<p>
Preempts the running thread (because a more prioritary thread has just been readied). The thread is re-inserted at the front of its priority group in the ready thread queue.     </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="pod.h::xnpod_remove_hook" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnpod_remove_hook </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>routine</em>)(xnthread_t *)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a nanokernel hook. 
<p>
This service removes a nanokernel hook previously registered using <a class="el" href="group__pod.html#a39">xnpod_add_hook()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>type</em>&nbsp;</td><td>Defines the kind of hook to remove among XNHOOK_THREAD_START, XNHOOK_THREAD_DELETE and XNHOOK_THREAD_SWITCH.</td></tr>
    <tr><td valign=top><em>routine</em>&nbsp;</td><td>The address of the user-supplied routine to remove.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XN_OK is returned on success. Otherwise, XNERR_PARAM is returned if type is incorrect or if the routine has never been registered before.</dd></dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="pod.h::xnpod_renice_thread" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_renice_thread </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>prio</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the base priority of a thread. 
<p>
Changes the base priority of a thread. If the XNDREORD flag has not been passed to <a class="el" href="group__pod.html#a16">xnpod_init()</a> and the reniced thread is currently blocked waiting in priority-pending mode (XNSYNCH_PRIO) for a synchronization object to be signaled, the nanokernel will attempt to reorder the object's pend queue so that it reflects the new sleeper's priority.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread.</td></tr>
    <tr><td valign=top><em>prio</em>&nbsp;</td><td>The new thread priority.</td></tr>
  </table>
</dl>
It is absolutely required to use this service to change a thread priority, in order to have all the needed housekeeping chores correctly performed. i.e. Do *not* change the thread.cprio field by hand, unless the thread is known to be in an innocuous state (e.g. dormant).<p>
Side-effects:<p>
<ul>
<li>This service does not call the rescheduling procedure but may affect the ready queue.</li></ul>
<p>
<ul>
<li>Assigning the same priority to a running or ready thread moves it at the end of the ready queue, thus might cause a manual round-robin effect.</li></ul>
<p>
<ul>
<li>If the reniced thread is a user-space shadow, propagate the request to the mated Linux task.</li></ul>
<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a51" doxytag="pod.c::xnpod_restart_thread" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_restart_thread </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnmutex_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>imutex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restart a thread. 
<p>
Restarts a previously started thread. The thread is first terminated then respawned using the same information that prevailed when it was first started, including the mode bits and interrupt mask initially passed to the <a class="el" href="group__pod.html#a21">xnpod_start_thread()</a> service. As a consequence of this call, the thread entry point is rerun.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread which must have been previously started by the <a class="el" href="group__pod.html#a21">xnpod_start_thread()</a> service.</td></tr>
    <tr><td valign=top><em>imutex</em>&nbsp;</td><td>The address of an interface mutex currently held by the caller which will be subject to a lock-breaking preemption if the current thread restarts itself. Passing NULL when no lock-breaking preemption is required is valid. See <a class="el" href="group__pod.html#a57">xnpod_schedule()</a> for more on lock-breaking preemption points.</td></tr>
  </table>
</dl>
Self-restarting a thread is allowed. However, restarting the root thread is not.<p>
Side-effect: This routine calls the rescheduling procedure.<p>
Context: This routine must be called on behalf of a thread context.     </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="pod.h::xnpod_resume_thread" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_resume_thread </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnflags_t&nbsp;</td>
          <td class="mdname" nowrap> <em>mask</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resume a thread. 
<p>
Resumes the execution of a thread previously suspended by one or more calls to <a class="el" href="group__pod.html#a53">xnpod_suspend_thread()</a>. This call removes a suspensive condition affecting the target thread. When all suspensive conditions are gone, the thread is left in a READY state at which point it becomes eligible anew for scheduling.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>thread</em>&nbsp;</td><td>The descriptor address of the resumed thread.</td></tr>
    <tr><td valign=top><em>mask</em>&nbsp;</td><td>The suspension mask specifying the suspensive condition to remove from the thread's wait mask. Possible values usable by the caller are:</td></tr>
  </table>
</dl>
<ul>
<li>XNSUSP. This flag removes the explicit suspension condition. This condition might be additive to the XNPEND condition.</li></ul>
<p>
<ul>
<li>XNDELAY. This flag removes the counted delay wait condition.</li></ul>
<p>
<ul>
<li>XNPEND. This flag removes the resource wait condition. If a watchdog is armed, it is automatically disarmed by this call.</li></ul>
<p>
When the thread is eventually resumed by one or more calls to <a class="el" href="group__pod.html#a26">xnpod_resume_thread()</a>, the caller of <a class="el" href="group__pod.html#a53">xnpod_suspend_thread()</a> in the awakened thread that suspended itself should check for the following bits in its own status mask to determine what caused its wake up:<p>
<ul>
<li>XNRMID means that the caller must assume that the pended synchronization object has been destroyed (see <a class="el" href="group__synch.html#a7">xnsynch_flush()</a>).</li></ul>
<p>
<ul>
<li>XNTIMEO means that the delay elapsed, or the watchdog went off before the corresponding synchronization object was signaled.</li></ul>
<p>
<ul>
<li>XNBREAK means that the wait has been forcibly broken by a call to <a class="el" href="group__pod.html#a27">xnpod_unblock_thread()</a>.</li></ul>
<p>
Side-effect: This service does not call the rescheduling procedure but may affect the ready queue.<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="pod.h::xnpod_rotate_readyq" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_rotate_readyq </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>prio</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Rotate a priority level in the ready queue. 
<p>
The thread at the head of the ready queue of the given priority level is moved to the end of this queue. Therefore, the execution of threads having the same priority is switched. Round-robin scheduling policies may be implemented by periodically issuing this call in a given period of time. It should be noted that the nanokernel already provides a built-in round-robin mode though (see <a class="el" href="group__pod.html#a34">xnpod_activate_rr()</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>prio</em>&nbsp;</td><td>The priority level to rotate. if XNPOD_RUNPRI is given, the running thread priority is used to rotate the queue.</td></tr>
  </table>
</dl>
The priority level which is considered is always the base priority of a thread, not the possibly PIP-boosted current priority value. Specifying a priority level with no thread on it is harmless, and will simply lead to a null-effect.<p>
Side-effect: This service does not call the rescheduling procedure but affects the ready queue.<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a57" doxytag="pod.c::xnpod_schedule" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_schedule </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnmutex_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>imutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Rescheduling procedure entry point. 
<p>
This is the central rescheduling routine which should be called to validate and apply changes which have previously been made to the nanokernel scheduling state, such as suspending, resuming or changing the priority of threads. This call first determines if a thread switch should take place, and performs it as needed. <a class="el" href="group__pod.html#a57">xnpod_schedule()</a> actually switches threads if:<p>
<ul>
<li>the running thread has been blocked or deleted.</li><li>or, the running thread has become less prioritary than the first ready to run thread.</li><li>or, the running thread does not lead no more the ready threads (round-robin).</li><li>or, a real-time thread became ready to run, ending the scheduler idle state (i.e. The root thread was running so far).</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>imutex</em>&nbsp;</td><td>The address of an interface mutex currently held by the caller which will be subject to a lock-breaking preemption before the current thread is actually switched out. The corresponding kernel mutex will be automatically reacquired by the nanokernel when the thread is eventually switched in again, before <a class="el" href="group__pod.html#a57">xnpod_schedule()</a> returns to its caller. Passing NULL when no lock-breaking preemption is required is valid. See below.</td></tr>
  </table>
</dl>
The nanokernel implements a lazy rescheduling scheme so that most of the services affecting the threads state MUST be followed by a call to the rescheduling procedure for the new scheduling state to be applied. In other words, multiple changes on the scheduler state can be done in a row, waking threads up, blocking others, without being immediately translated into the corresponding context switches, like it would be necessary would it appear that a more prioritary thread than the current one became runnable for instance. When all changes have been applied, the rescheduling procedure is then called to consider those changes, and possibly replace the current thread by another.<p>
As a notable exception to the previous principle however, every action which ends up suspending or deleting the current thread begets an immediate call to the rescheduling procedure on behalf of the service causing the state transition. For instance, self-suspension, self-destruction, or sleeping on a synchronization object automatically leads to a call to the rescheduling procedure, therefore the caller does not need to explicitely issue <a class="el" href="group__pod.html#a57">xnpod_schedule()</a> after such operations.<p>
Lock-breaking preemption is a mean by which a thread who holds a nanokernel mutex (i.e. xnmutex_t) can rely on <a class="el" href="group__pod.html#a57">xnpod_schedule()</a> to release such mutex and switch in another thread atomically. The incoming thread can then grab this mutex while the initial holder is suspended. The nanokernel automatically reacquires the mutex on behalf of the initial holder when it eventually resumes execution. This is a desirable feature which provides a simple and safe way for the upper interfaces to deal with scheduling points inside critical sections. Since the aforementioned mutex is usually defined by a client real-time interface to protect from races when concurrent threads access its internal data structures, it is dubbed the "interface mutex" in the Xenomai documentation.<p>
The rescheduling procedure always leads to a null-effect if the scheduler is locked (XNLOCK bit set in the status mask of the running thread), or if it is called on behalf of an interrupt service thread. (ISVC threads have a separate internal rescheduling procedure named <a class="el" href="group__pod.html#a4">xnpod_schedule_runnable()</a>).<p>
Calling this procedure with no applicable context switch pending is harmless and simply leads to a null-effect.<p>
Side-effects:<p>
<ul>
<li>If an asynchronous service routine exists, the pending asynchronous signals are delivered to a resuming thread or on behalf of the caller before it returns from the procedure if no context switch has taken place. This behaviour can be disabled by setting the XNASDI flag in the thread's status mask by calling <a class="el" href="group__pod.html#a24">xnpod_set_thread_mode()</a>.</li></ul>
<p>
<ul>
<li>The switch hooks are called on behalf of the resuming thread.</li></ul>
<p>
<ul>
<li>This call may affect the ready queue and switch thread contexts.</li></ul>
<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="pod.h::xnpod_schedule_runnable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_schedule_runnable </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Hidden rescheduling procedure - INTERNAL. 
<p>
This internal routine should NEVER be used directly by the upper interfaces. It reinserts the given thread into the ready queue then switches to the most prioritary runnable thread. It must be called interrupts off.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>thread</em>&nbsp;</td><td>The descriptor address of the thread to reinsert into the ready queue.</td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td>A bitmask composed as follows:</td></tr>
  </table>
</dl>
<ul>
<li>XNPOD_SCHEDLIFO causes the target thread to be inserted at front of its priority group in the ready queue. Otherwise, the FIFO ordering is applied.</li></ul>
<p>
<ul>
<li>XNPOD_NOSWITCH reorders the ready queue without switching contexts. This feature is used by the nanokernel mutex code to preserve the atomicity of some operations. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="pod.h::xnpod_set_thread_mode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> xnflags_t xnpod_set_thread_mode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnflags_t&nbsp;</td>
          <td class="mdname" nowrap> <em>clrmask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnflags_t&nbsp;</td>
          <td class="mdname" nowrap> <em>setmask</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change a thread's control mode. 
<p>
Change the control mode of a given thread. The control mode affects the behaviour of the nanokernel regarding the specified thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread.</td></tr>
    <tr><td valign=top><em>clrmask</em>&nbsp;</td><td>Clears the corresponding bits from the control field before setmask is applied. The scheduler lock held by the current thread can be forcibly released by passing the XNLOCK bit in this mask. In this case, the lock nesting count is also reset to zero.</td></tr>
    <tr><td valign=top><em>setmask</em>&nbsp;</td><td>The new thread mode. The following flags can be part of this bitmask, each of them affecting the nanokernel behaviour regarding the thread:</td></tr>
  </table>
</dl>
<ul>
<li>XNLOCK causes the thread to lock the scheduler. The target thread will have to call the <a class="el" href="group__pod.html#a32">xnpod_unlock_sched()</a> service to unlock the scheduler or clear the XNLOCK bit forcibly using this service.</li></ul>
<p>
<ul>
<li>XNRRB causes the thread to be marked as undergoing the round-robin scheduling policy. The contents of the thread.rrperiod field determines the time quantum (in ticks) allowed for its next slice. If the thread is already undergoing the round-robin scheduling policy at the time this service is called, the time quantum remains unchanged.</li></ul>
<p>
<ul>
<li>XNASDI disables the asynchronous signal handling for this thread. See <a class="el" href="group__pod.html#a57">xnpod_schedule()</a> for more on this.</li></ul>
<p>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="pod.h::xnpod_set_time" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_set_time </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnticks_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>newtime</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the nanokernel idea of time. 
<p>
The nanokernel tracks the current time as a monotonously increasing count of ticks announced by the timer source since the epoch. The epoch is initially defined by the time the nanokernel has started. This service changes the epoch. Running timers use a different time base thus are not affected by this operation. The nanokernel time is only accounted when the system timer runs in periodic mode.<p>
Side-effect:<p>
<ul>
<li>This routine does not call the rescheduling procedure.</li></ul>
<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="pod.h::xnpod_shutdown" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_shutdown </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>xtype</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default shutdown handler. 
<p>
Forcibly shutdowns the active pod. All existing nanokernel threads (but the root one) are terminated, and the system heap is freed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>xtype</em>&nbsp;</td><td>An exit code passed to the host environment who started the nanokernel. Zero is always interpreted as a successful return.</td></tr>
  </table>
</dl>
The nanokernel will not call this routine directly but rather use the routine pointed at by the pod.svctable.shutdown member in the service table. This allows upper interfaces to interpose their own shutdown handlers so that they have their word before any action is taken. Usually, the interface-defined handlers should end up calling <a class="el" href="group__pod.html#a19">xnpod_shutdown()</a> after their own housekeeping chores have been carried out.<p>
Context: This routine must be called on behalf of the root thread (e.g. a <a class="el" href="legacy_8c.html#a112">cleanup_module()</a> routine).     </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="pod.h::xnpod_start_thread" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_start_thread </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnflags_t&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>imask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>entry</em>)(void *cookie), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>cookie</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initial start of a newly created thread. 
<p>
Starts a (newly) created thread, scheduling it for the first time. This call releases the target thread from the XNDORMANT state. This service also sets the initial mode and interrupt mask for the new thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread which must have been previously initialized by the <a class="el" href="group__pod.html#a20">xnpod_init_thread()</a> service.</td></tr>
    <tr><td valign=top><em>mode</em>&nbsp;</td><td>The initial thread mode. The following flags can be part of this bitmask, each of them affecting the nanokernel behaviour regarding the started thread:</td></tr>
  </table>
</dl>
<ul>
<li>XNLOCK causes the thread to lock the scheduler when it starts. The target thread will have to call the <a class="el" href="group__pod.html#a32">xnpod_unlock_sched()</a> service to unlock the scheduler.</li></ul>
<p>
<ul>
<li>XNRRB causes the thread to be marked as undergoing the round-robin scheduling policy at startup. The contents of the thread.rrperiod field determines the time quantum (in ticks) allowed for its next slice.</li></ul>
<p>
<ul>
<li>XNASDI disables the asynchronous signal handling for this thread. See <a class="el" href="group__pod.html#a57">xnpod_schedule()</a> for more on this.</li></ul>
<p>
<ul>
<li>XNSUSP makes the thread start in a suspended state. In such a case, the thread will have to be explicitely resumed using the <a class="el" href="group__pod.html#a26">xnpod_resume_thread()</a> service for its execution to actually begin.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>imask</em>&nbsp;</td><td>The interrupt mask that should be asserted when the thread starts. The processor interrupt state will be set to the given value when the thread starts running. The interpretation of this value might be different across real-time layers, but a non-zero value should always mark an interrupt masking in effect (e.g. cli()). Conversely, a zero value should always mark a fully preemptible state regarding interrupts (i.e. sti()).</td></tr>
    <tr><td valign=top><em>entry</em>&nbsp;</td><td>The address of the thread's body routine. In other words, it is the thread entry point.</td></tr>
    <tr><td valign=top><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the nanokernel will pass to the emerging thread as the sole argument of its entry point.</td></tr>
  </table>
</dl>
The START hooks are called on behalf of the calling context (if any).<p>
Side-effect: This routine calls the rescheduling procedure.<p>
Context: This routine must be called on behalf of a thread context.     </td>
  </tr>
</table>
<a class="anchor" name="a60" doxytag="pod.c::xnpod_start_timer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnpod_start_timer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_long&nbsp;</td>
          <td class="mdname" nowrap> <em>nstick</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnist_t&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start the system timer. 
<p>
The nanokernel needs a time source to provide the time-related services to the upper interfaces. <a class="el" href="group__pod.html#a60">xnpod_start_timer()</a> tunes the timer hardware so that a user-defined routine is called according to a given frequency. On architectures that provide a oneshot-programmable time source, the system timer can operate whether in aperiodic or periodic mode. Using the aperiodic mode still allows to run periodic nanokernel timers over it: the underlying hardware will simply be reprogrammed after each tick by the timer manager using the appropriate interval value (see <a class="el" href="timer_8c.html#a8">xntimer_start()</a>).<p>
The time interval that elapses between two consecutive invocations of the handler is called a tick.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>nstick</em>&nbsp;</td><td>The timer period in nanoseconds. XNPOD_DEFAULT_TICK can be used to set this value according to the arch-dependent settings. If this parameter is equal to XNPOD_APERIODIC_TICK, the underlying hardware timer is set to operate in oneshot-programmable mode. In this mode, timing accuracy is higher - since it is not rounded to a constant time slice - at the expense of a lesser efficicency when many timers are simultaneously active. The aperiodic mode gives better results in configuration involving a few threads requesting timing services over different time scales that cannot be easily expressed as multiples of a single base tick, or would lead to a waste of high frequency periodical ticks.</td></tr>
    <tr><td valign=top><em>handler</em>&nbsp;</td><td>The address of the interrupt service thread which will process each incoming tick. XNPOD_DEFAULT_TICKHANDLER can be passed to use the system-defined entry point (i.e. <a class="el" href="group__pod.html#a61">xnpod_announce_tick()</a>). In any case, a user-supplied handler should end up calling <a class="el" href="group__pod.html#a61">xnpod_announce_tick()</a> to inform the nanokernel of the incoming tick.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XN_OK is returned on success. Otherwise:</dd></dl>
<ul>
<li>XNERR_BUSY is returned if the timer has already been set. <a class="el" href="group__pod.html#a18">xnpod_stop_timer()</a> must be issued before <a class="el" href="group__pod.html#a60">xnpod_start_timer()</a> is called again.</li></ul>
<p>
<ul>
<li>XNERR_PARAM is returned if an invalid null tick handler has been passed, or if the timer precision cannot represent the duration of a single host tick.</li></ul>
<p>
<ul>
<li>XNERR_NOSYS is returned if the underlying architecture does not support the requested aperiodic timing, or if no active pod exists.</li></ul>
<p>
Side-effect: A host timing service is started in order to relay the canonical periodical tick to the underlying architecture, regardless of the frequency used for Xenomai's system tick. This routine does not call the rescheduling procedure.<p>
Context: This routine must be called on behalf of a context allowing immediate memory allocation requests (e.g. an <a class="el" href="legacy_8c.html#a111">init_module()</a> routine).     </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="pod.h::xnpod_stop_timer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_stop_timer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stop the periodic timer. 
<p>
Stops the periodic timer previously started by a call to <a class="el" href="group__pod.html#a60">xnpod_start_timer()</a>.<p>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="pod.c::xnpod_suspend_thread" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int xnpod_suspend_thread </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnflags_t&nbsp;</td>
          <td class="mdname" nowrap> <em>mask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnticks_t&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnsynch_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>wchan</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnmutex_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>imutex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Suspend a thread. 
<p>
Suspends the execution of a thread according to a given suspensive condition. This thread will not be eligible for scheduling until it all the pending suspensive conditions set by this service are removed by one or more calls to <a class="el" href="group__pod.html#a26">xnpod_resume_thread()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>thread</em>&nbsp;</td><td>The descriptor address of the suspended thread.</td></tr>
    <tr><td valign=top><em>mask</em>&nbsp;</td><td>The suspension mask specifying the suspensive condition to add to the thread's wait mask. Possible values usable by the caller are:</td></tr>
  </table>
</dl>
<ul>
<li>XNSUSP. This flag forcibly suspends a thread, regardless of any resource to wait for. The wchan parameter should not be significant when using this suspension condition. A reverse call to <a class="el" href="group__pod.html#a26">xnpod_resume_thread()</a> specifying the XNSUSP bit must be issued to remove this condition, which is cumulative with other suspension bits.</li></ul>
<p>
<ul>
<li>XNDELAY. This flags denotes a counted delay wait (in ticks) which duration is defined by the value of the timeout parameter.</li></ul>
<p>
<ul>
<li>XNPEND. This flag denotes a wait for a synchronization object to be signaled. The wchan argument must points to this object. A timeout value can be passed to bound the wait. This suspension mode should not be used directly by the upper interface, but rather through the <a class="el" href="group__synch.html#a2">xnsynch_sleep_on()</a> call.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>timeout</em>&nbsp;</td><td>The timeout which may be used to limit the time the thread pends for a resource. This value is a wait time given in ticks. Passing XN_INFINITE specifies an unbounded wait. All other values are used to initialize a watchdog timer.</td></tr>
    <tr><td valign=top><em>wchan</em>&nbsp;</td><td>The address of a pended resource. This parameter is used internally by the synchronization object implementation code to specify on which object the suspended thread pends.</td></tr>
    <tr><td valign=top><em>imutex</em>&nbsp;</td><td>The address of an interface mutex currently held by the caller which will be subject to a lock-breaking preemption before the current thread is actually switched out. The corresponding kernel mutex will be automatically reacquired by the nanokernel when the suspended thread is eventually resumed, before <a class="el" href="group__pod.html#a53">xnpod_suspend_thread()</a> returns to its caller. This parameter only makes sense for self-suspending threads. Passing NULL when no lock-breaking preemption is required is valid. See <a class="el" href="group__pod.html#a57">xnpod_schedule()</a> for more on lock-breaking preemption points.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns true if a thread switch took place as a result of this call, false otherwise.</dd></dl>
Side-effect: A rescheduling immediately occurs if the caller self-suspends, in which case true is always returned.<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a58" doxytag="pod.c::xnpod_trap_fault" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_trap_fault </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>fltinfo</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default fault handler. 
<p>
This is the default handler which is called whenever an uncontrolled exception or fault is caught. If the fault is caught on behalf of a real-time thread, the fault handler stored into the service table (svctable.faulthandler) is invoked and the fault is not propagated to the host system. Otherwise, the fault is unhandled by the nanokernel and simply propagated.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>fltinfo</em>&nbsp;</td><td>An opaque pointer to the arch-specific buffer describing the fault. The actual layout is defined by the xnarch_fltinfo_t type in each arch-dependent layer file. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="pod.h::xnpod_unblock_thread" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_unblock_thread </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thread</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unblock a thread. 
<p>
Breaks the thread out of any wait it is currently in. This call removes the XNDELAY and XNPEND suspensive conditions previously put by <a class="el" href="group__pod.html#a53">xnpod_suspend_thread()</a> on the target thread. If all suspensive conditions are gone, the thread is left in a READY state at which point it becomes eligible anew for scheduling.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>thread</em>&nbsp;</td><td>The descriptor address of the unblocked thread.</td></tr>
  </table>
</dl>
This call neither releases the thread from the XNSUSP, XNRELAX, XNFROZEN nor the XNDORMANT suspensive conditions.<p>
When the thread resumes execution, the XNBREAK bit is set in the unblocked thread's status mask. Unblocking a non-blocked thread is perfectly harmless.<p>
Side-effect: This service does not call the rescheduling procedure but may affect the ready queue.<p>
Context: This routine can be called on behalf of a thread or IST context.     </td>
  </tr>
</table>
<a class="anchor" name="a55" doxytag="pod.c::xnpod_welcome_thread" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnpod_welcome_thread </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thread</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Thread prologue - INTERNAL. 
<p>
This internal routine is called on behalf of a (re)starting thread's prologue before the user entry point is invoked. This call is reserved for internal housekeeping chores and cannot be inlined.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:22 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
