<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Real-time shadow services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Real-time shadow services.<br>
<small>
[<a class="el" href="group__xenomai.html">Xenomai scheduler.</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Real-time shadow services. 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="shadow_8c.html">shadow.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real-time shadow services. <br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shadow.html#a48">xnshadow_harden</a> (xnmutex_t *imutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Migrate a Linux task to the RTAI domain -- INTERNAL. </em> <a href="#a48"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shadow.html#a49">xnshadow_relax</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch a shadow thread back to the Linux domain -- INTERNAL. </em> <a href="#a49"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shadow.html#a55">xnshadow_map</a> (xnthread_t *thread, const  char *name, int prio, pid_t syncpid, int *u_syncp, unsigned magic, xnmutex_t *imutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a shadow thread context -- INTERNAL. </em> <a href="#a55"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a48" doxytag="shadow.c::xnshadow_harden" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnshadow_harden </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnmutex_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>imutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Migrate a Linux task to the RTAI domain -- INTERNAL. 
<p>
This service causes the transition of "current" from the Linux domain to RTAI. This is obtained by asking the gatekeeper to resume the shadow mated with "current" then triggering the rescheduling procedure in the RTAI domain. The shadow will resume in the RTAI domain as returning from schedule().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>imutex</em>&nbsp;</td><td>The address of an interface mutex currently held by the caller which will be subject to a lock-breaking preemption before the rescheduling takes place in the __xn_sys_sched service. The ability to pass a mutex through this service is indirectly used by skins when creating a new shadow thread (see <a class="el" href="group__shadow.html#a55">xnshadow_map()</a>), thus preventing any deletion while the thread descriptor is accessed by the internal bootstrap code. Passing NULL when no lock-breaking preemption is required is valid. See <a class="el" href="group__pod.html#a57">xnpod_schedule()</a> for more on lock-breaking preemption points.</td></tr>
  </table>
</dl>
Side-effect: This routine indirectly triggers the rescheduling procedure (see __xn_sys_sched service).<p>
Context: This routine must be called on behalf of a user-space task from the Linux domain.     </td>
  </tr>
</table>
<a class="anchor" name="a55" doxytag="shadow.c::xnshadow_map" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> xnthread_t * xnshadow_map </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>prio</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>pid_t&nbsp;</td>
          <td class="mdname" nowrap> <em>syncpid</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>u_syncp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>magic</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>xnmutex_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>imutex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a shadow thread context -- INTERNAL. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>thread</em>&nbsp;</td><td>The descriptor address of the new shadow thread to be mapped to "current".</td></tr>
    <tr><td valign=top><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the shadow thread.</td></tr>
    <tr><td valign=top><em>prio</em>&nbsp;</td><td>The base priority of the new thread. This value must range from [minpri .. maxpri] (inclusive) as specified when calling the <a class="el" href="group__pod.html#a16">xnpod_init()</a> service from the skin initialization routine.</td></tr>
    <tr><td valign=top><em>syncpid</em>&nbsp;</td><td>If non-zero, this must be the pid of a Linux task to wake up when the shadow has been initialized. In this case, u_syncp must be valid to, and the new shadow thread is left in a dormant state (XNDORMANT) after its creation, leading to the suspension of "current" in the RTAI domain. Otherwise, the shadow thread is immediately started and "current" exits from this service without being suspended.</td></tr>
    <tr><td valign=top><em>u_syncp</em>&nbsp;</td><td>If non-zero, this must be a pointer to an integer variable into the caller's address space in user-space which will be used as a semaphore. This semaphore will be posted to wakeup the task identified by pid before "current" is suspended in dormant state by this service. The awaken Linux task is expected to invoke a syscall hat ends up calling <a class="el" href="group__shadow.html#a56">xnshadow_start()</a> to finally start the newly created shadow. Passing a null pointer here has the same effect as passing a zero pid argument, and there will be no attempt to wake up any task.</td></tr>
    <tr><td valign=top><em>magic</em>&nbsp;</td><td>A magic value aimed at identifying unambiguously the skin to which the shadow belongs to. This value must be non-zero.</td></tr>
    <tr><td valign=top><em>imutex</em>&nbsp;</td><td>The address of an interface mutex currently held by the caller which will be subject to a lock-breaking preemption before the rescheduling takes place in the __xn_sys_sched service. Passing NULL when no lock-breaking preemption is required is valid. See <a class="el" href="group__pod.html#a57">xnpod_schedule()</a> for more on lock-breaking preemption points.</td></tr>
  </table>
</dl>
Side-effect: This routine indirectly calls the rescheduling procedure.<p>
Context: This routine must be called on behalf of the Linux user-space task which is being shadowed.     </td>
  </tr>
</table>
<a class="anchor" name="a49" doxytag="shadow.h::xnshadow_relax" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void xnshadow_relax </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Switch a shadow thread back to the Linux domain -- INTERNAL. 
<p>
This service yields the control of the running shadow back to Linux. This is obtained by suspending the shadow and scheduling a wake up call for the mated user task inside the Linux domain. The Linux task will resume on return from <a class="el" href="group__pod.html#a53">xnpod_suspend_thread()</a> on behalf of the root thread.<p>
Side-effect: This routine indirectly calls the rescheduling procedure.<p>
Context: This routine must be called on behalf of a real-time shadow inside the RTAI domain.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:22 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
