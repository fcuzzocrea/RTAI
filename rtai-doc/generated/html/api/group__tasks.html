<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Task functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Task functions<br>
<small>
[<a class="el" href="group__sched.html">RTAI schedulers modules</a>]</small>
</h1>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html">sched_up.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheduling function for uni-processor. <br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__tasks.html#a0">rt_task_init</a> (RT_TASK *task, void(*rt_thread)(int), int data, int stack_size, int priority, int uses_fpu, void(*signal)(void))</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__tasks.html#a1">rt_task_init_cpuid</a> (RT_TASK *task, void(*rt_thread)(int), int data, int stack_size, int priority, int uses_fpu, void(*signal)(void), unsigned int cpuid)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__tasks.html#a2">rt_set_runnable_on_cpus</a> (RT_TASK *task, unsigned long run_on_cpus)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign CPUs to a task. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__tasks.html#a3">rt_set_runnable_on_cpuid</a> (RT_TASK *task, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign CPUs to a task. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__tasks.html#a4">rt_sched_lock</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the scheduling of tasks. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__tasks.html#a5">rt_sched_unlock</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the scheduling of tasks. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__tasks.html#a6">rt_task_delete</a> (RT_TASK *task)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__tasks.html#a7">rt_preempt_always</a> (int yes_no)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable hard preemption. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__tasks.html#a8">rt_preempt_always_cpuid</a> (int yes_no, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable hard preemption. </em> <a href="#a8"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a7" doxytag="sched_lxrt.c::rt_preempt_always" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_preempt_always </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>yes_no</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable hard preemption. 
<p>
<a class="anchor" name="rt_preempt_always"></a> <p>
In the oneshot mode the next timer expiration is programmed after a timer shot by choosing among the timed tasks the one with a priority higher than the task chosen to run as current, with the constraint of always assuring a correct Linux timing. In such a view there is no need to fire the timer immediately. In fact it can happen that the current task can be so fast to get suspended and rerun before the one that was devised to time the next shot when it was made running. In such a view <b>RTAI</b> schedulers try to shoot only when strictly needed. This minimizes the number of slow setups of the 8254 timer used with UP and 8254 based SMP schedulers. While such a policy minimizes the number of actual shots, greatly enhancing efficiency, it can be unsuitable when an application has to be guarded against undesired program loops or other unpredicted error causes. Calling these functions with a nonzero value assures that a timed high priority preempting task is always programmed to be fired while another task is currently running. The default is no immediate preemption in oneshot mode, i.e. firing of the next shot programmed only when strictly needed to satisfy tasks timings.<p>
<dl compact><dt><b>Note:</b></dt><dd>With UP and SMP schedulers there is always only a timing source so that cpu_idinrt_preempt_always_cpuid is not used. With the MUP scheduler you have an independent timer for each CPU, so rt_preempt_always applies to all the CPUs while rt_preempt_always_cpuid should be used when preemption is to be forced only on a specific CPU. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="sched_lxrt.c::rt_preempt_always_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_preempt_always_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>yes_no</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable hard preemption. 
<p>
<a class="anchor" name="rt_preempt_always_cpuid"></a> <p>
In the oneshot mode the next timer expiration is programmed after a timer shot by choosing among the timed tasks the one with a priority higher than the task chosen to run as current, with the constraint of always assuring a correct Linux timing. In such a view there is no need to fire the timer immediately. In fact it can happen that the current task can be so fast to get suspended and rerun before the one that was devised to time the next shot when it was made running. In such a view <b>RTAI</b> schedulers try to shoot only when strictly needed. This minimizes the number of slow setups of the 8254 timer used with UP and 8254 based SMP schedulers. While such a policy minimizes the number of actual shots, greatly enhancing efficiency, it can be unsuitable when an application has to be guarded against undesired program loops or other unpredicted error causes. Calling these functions with a nonzero value assures that a timed high priority preempting task is always programmed to be fired while another task is currently running. The default is no immediate preemption in oneshot mode, i.e. firing of the next shot programmed only when strictly needed to satisfy tasks timings.<p>
<dl compact><dt><b>Note:</b></dt><dd>With UP and SMP schedulers there is always only a timing source so that cpu_idinrt_preempt_always_cpuid is not used. With the MUP scheduler you have an independent timer for each CPU, so rt_preempt_always applies to all the CPUs while rt_preempt_always_cpuid should be used when preemption is to be forced only on a specific CPU. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="sched_lxrt.c::rt_sched_lock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_sched_lock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lock the scheduling of tasks. 
<p>
<a class="anchor" name="rt_sched_lock"></a> <p>
rt_sched_lock, lock on the CPU on which they are called, any scheduler activity, thus preventing a higher priority task to preempt a lower priority one. They can be nested, provided unlocks are paired to locks in reversed order. It can be used for synchronization access to data among tasks. Note however that under MP the lock is active only for the CPU on which it has been issued, so it cannot be used to avoid races with tasks that can run on any other available CPU. Interrupts are not affected by such calls. Any task that needs rescheduling while a scheduler lock is in placewill be only at the issuing of the last unlock<p>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx.</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_sched_unlock">rt_sched_unlock</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="sched_lxrt.c::rt_sched_unlock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_sched_unlock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock the scheduling of tasks. 
<p>
<a class="anchor" name="rt_sched_unlock"></a> <p>
rt_sched_unlock, unlock on the CPU on which they are called, any scheduler activity, thus preventing a higher priority task to preempt a lower priority one. They can be nested, provided unlocks are paired to locks in reversed order. It can be used for synchronization access to data among tasks. Note however that under MP the lock is active only for the CPU on which it has been issued, so it cannot be used to avoid races with tasks that can run on any other available CPU. Interrupts are not affected by such calls. Any task that needs rescheduling while a scheduler lock is in placewill be only at the issuing of the last unlock<p>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx.</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_sched_unlock">rt_sched_unlock</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="sched_lxrt.c::rt_set_runnable_on_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_runnable_on_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assign CPUs to a task. 
<p>
<a class="anchor" name="rt_set_runnable_on_cpuid"></a> <p>
rt_set_runnable_on_cpuid select one or more CPUs which are allowed to run task <em>task</em>.<p>
rt_set_runnable_on_cpuid assigns a task to a single specific CPU. If no CPU, as selected by cpu_mask or cpuid, is available, both functions choose a possible CPU automatically, following the same rule as above.<p>
<dl compact><dt><b>Note:</b></dt><dd>This call has no effect on UniProcessor (UP) systems.</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_set_runnable_on_cpus">rt_set_runnable_on_cpus</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="sched_lxrt.c::rt_set_runnable_on_cpus" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_runnable_on_cpus </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>runnable_on_cpus</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assign CPUs to a task. 
<p>
<a class="anchor" name="rt_set_runnable_on_cpus"></a> <p>
rt_set_runnable_on_cpus selects one or more CPUs which are allowed to run task <em>task</em>. rt_set_runnable_on_cpus behaves differently for MUP and SMP schedulers. Under the SMP scheduler bit&lt;n&gt; of cpu_mask enables the task to run on CPU&lt;n&gt;. Under the MUP scheduler it selects the CPU with less running tasks among those allowed by cpu_mask. Recall that with MUP a task must be bounded to run on a single CPU. If no CPU, as selected by cpu_mask or cpuid, is available, both functions choose a possible CPU automatically, following the same rule as above.<p>
<dl compact><dt><b>Note:</b></dt><dd>This call has no effect on UniProcessor (UP) systems.</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_set_runnable_on_cpuid">rt_set_runnable_on_cpuid</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="sched_lxrt.c::rt_task_delete" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_delete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="anchor" name="rt_task_delete"></a> Delete a real time task.<p>
rt_task_delete deletes a real time task previously created by <a class="el" href="sched__lxrt_8c.html#rt_task_init">rt_task_init</a>() or <a class="el" href="sched__lxrt_8c.html#rt_task_init_cpuid">rt_task_init_cpuid</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is the pointer to the task structure. If task task was waiting on a queue, i.e. semaphore, mailbox, etc, it is removed from such a queue and messaging tasks pending on its message queue are unblocked with an error return.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task does not refer to a valid task. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="sched_lxrt.c::rt_task_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>rt_thread</em>)(int), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>stack_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>uses_fpu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>signal</em>)(void)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="anchor" name="rt_task_init"></a> Creates a new real time task.<p>
The newly created real time task is initially in a suspend state. It can be made active by calling: rt_task_make_periodic, rt_task_make_periodic_relative_ns, rt_task_resume.<p>
When used with the MUP scheduler rt_task_init automatically selects which CPU the task will run on, while with the SMP scheduler the task defaults to using any of the available CPUs. This assignment may be changed by calling rt_set_runnable_on_cpus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is a pointer to an RT_TASK type structure whose space must be provided by the application. It must be kept during the whole lifetime of the real time task.</td></tr>
    <tr><td valign=top><em>rt_thread</em>&nbsp;</td><td>is the entry point of the task function.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The parent task can pass a single integer value data to the new task being created. Recall that an appropriately type casting allows data to be a pointer to whatever data structure one would like to pass to the task, so you can indirectly pass whatever you want to the task.</td></tr>
    <tr><td valign=top><em>stack_size</em>&nbsp;</td><td>is the size of the stack to be used by the new task. In sizing it, recall to make room for any real time interrupt handler, as real time interrupts run on the stack of the task they interrupt. So try to avoid being too sparing.</td></tr>
    <tr><td valign=top><em>priority</em>&nbsp;</td><td>is the priority to be given to the task. The highest priority is 0, while the lowest is RT_SCHED_LOWEST_PRIORITY.</td></tr>
    <tr><td valign=top><em>uses_fpu</em>&nbsp;</td><td>is a flag. A nonzero value indicates that the task will use the floating point unit.</td></tr>
    <tr><td valign=top><em>signal</em>&nbsp;</td><td>is a function that is called, within the task environment and with interrupts disabled, when the task becomes the current running task after a context switch. Note however that signal is not called at the very first scheduling of the task. Such a function can be assigned and/or changed dynamically whenever needed (see function rt_task_signal_handler.)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task structure pointed by task is already in use;</li><li><b>ENOMEM</b>: stack_size bytes could not be allocated for the stack.</li></ul>
</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_task_init_cpuid">rt_task_init_cpuid</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="sched_lxrt.c::rt_task_init_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_init_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>rt_thread</em>)(int), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>stack_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>uses_fpu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>signal</em>)(void), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="anchor" name="rt_task_init_cpuid"></a> Creates a new real time task and assigns it to a single specific CPU.<p>
The newly created real time task is initially in a suspend state. It can be made active by calling: rt_task_make_periodic, rt_task_make_periodic_relative_ns, rt_task_resume.<p>
When used with the MUP scheduler rt_task_init automatically selects which CPU the task will run on, while with the SMP scheduler the task defaults to using any of the available CPUs. This assignment may be changed by calling rt_set_runnable_on_cpus or rt_set_runnable_on_cpuid. If cpuid is invalid rt_task_init_cpuid falls back to automatic CPU selection.<p>
Whatever scheduler is used on multiprocessor systems rt_task_init_cpuid allows to create a task and assign it to a single specific CPU cpuid from its very beginning, without any need to call rt_set_runnable_on_cpuid later on.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is a pointer to an RT_TASK type structure whose space must be provided by the application. It must be kept during the whole lifetime of the real time task.</td></tr>
    <tr><td valign=top><em>rt_thread</em>&nbsp;</td><td>is the entry point of the task function.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The parent task can pass a single integer value data to the new task being created. Recall that an appropriately type casting allows data to be a pointer to whatever data structure one would like to pass to the task, so you can indirectly pass whatever you want to the task.</td></tr>
    <tr><td valign=top><em>stack_size</em>&nbsp;</td><td>is the size of the stack to be used by the new task. In sizing it recall to make room for any real time interrupt handler, as real time interrupts run on the stack of the task they interrupt. So try to avoid being too sparing.</td></tr>
    <tr><td valign=top><em>priority</em>&nbsp;</td><td>is the priority to be given to the task. The highest priority is 0, while the lowest is RT_SCHED_LOWEST_PRIORITY.</td></tr>
    <tr><td valign=top><em>uses_fpu</em>&nbsp;</td><td>is a flag. A nonzero value indicates that the task will use the floating point unit.</td></tr>
    <tr><td valign=top><em>signal</em>&nbsp;</td><td>is a function that is called, within the task environment and with interrupts disabled, when the task becomes the current running task after a context switch. Note however that signal is not called at the very first scheduling of the task. Such a function can be assigned and/or changed dynamically whenever needed (see function rt_task_signal_handler.)</td></tr>
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>FIXME</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task structure pointed by task is already in use;</li><li><b>ENOMEM</b>: stack_size bytes could not be allocated for the stack.</li></ul>
</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_task_init">rt_task_init</a>().     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:21 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
