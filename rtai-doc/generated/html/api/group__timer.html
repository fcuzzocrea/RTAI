<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Timer functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Timer functions<br>
<small>
[<a class="el" href="group__sched.html">RTAI schedulers modules</a>]</small>
</h1>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html">sched_up.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheduling function for uni-processor. <br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a0">rt_set_periodic_mode</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set timer mode. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a1">rt_set_oneshot_mode</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set timer mode. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a2">start_rt_timer</a> (int period)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start timer. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a3">start_rt_apic_timers</a> (struct apic_timer_setup_data *setup_mode, unsigned int rcvr_jiffies_cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start local apic timer. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a4">stop_rt_timer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop timer. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a5">count2nano</a> (RTIME counts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert internal count units to nanoseconds. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a6">nano2count</a> (RTIME ns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert nanoseconds to internal count units. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a7">count2nano_cpuid</a> (RTIME counts, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert internal count units to nanoseconds. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a8">nano2count_cpuid</a> (RTIME ns, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert nanoseconds to internal count units. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a9">rt_get_time</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a10">rt_get_time_cpuid</a> (unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a11">rt_get_time_ns</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a12">rt_get_time_ns_cpuid</a> (unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__timer.html#a13">rt_get_cpu_time_ns</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a13"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a5" doxytag="sched_lxrt.c::count2nano" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME count2nano </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>counts</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert internal count units to nanoseconds. 
<p>
<a class="anchor" name="count2nano"></a> <p>
This function converts the time of timercounts internal count units into nanoseconds. Remember that the count units are related to the time base being used (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>counts</em>&nbsp;</td><td>internal count units.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="sched_lxrt.c::count2nano_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME count2nano_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>counts</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert internal count units to nanoseconds. 
<p>
<a class="anchor" name="count2nano_cpuid"></a> <p>
This function converts the time of timercounts internal count units into nanoseconds. It is to be used with the MUP scheduler since with such a scheduler it is possible to have independent timers, i.e. periodic of different periods or a mixing of periodic and oneshot, so that it is impossible to establish which conversion units should be used in the case one asks for a conversion from any CPU for any other CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>counts</em>&nbsp;</td><td>internal count units.</td></tr>
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>Identifier of the CPU (FIXME).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="sched_lxrt.c::nano2count" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME nano2count </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ns</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert nanoseconds to internal count units. 
<p>
<a class="anchor" name="nano2count"></a> <p>
This function converts the time of nanosecs <em>nanoseconds</em> into internal counts units. Remember that the count units are related to the time base being used (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
The versions ending with_cpuid are to be used with the MUP scheduler since with such a scheduler it is possible to have independent timers, i.e. periodic of different periods or a mixing of periodic and oneshot, so that it is impossible to establish which conversion units should be used in the case one asks for a conversion from any CPU for any other CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ns</em>&nbsp;</td><td>Number of nanoseconds.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="sched_lxrt.c::nano2count_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME nano2count_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>ns</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert nanoseconds to internal count units. 
<p>
<a class="anchor" name="nano2count_cpuid"></a> <p>
This function converts the time of nanosecs <em>nanoseconds</em> into internal counts units. Remember that the count units are related to the time base being used (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
This function is to be used with the MUP scheduler since with such a scheduler it is possible to have independent timers, i.e. periodic of different periods or a mixing of periodic and oneshot, so that it is impossible to establish which conversion units should be used in the case one asks for a conversion from any CPU for any other CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ns</em>&nbsp;</td><td>Number of nanoseconds.</td></tr>
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>Identifier of the CPU (FIXME).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="sched_lxrt.c::rt_get_cpu_time_ns" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_cpu_time_ns </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_cpu_time_ns"></a> <p>
rt_get_cpu_time_ns always returns the CPU time in nanoseconds whatever timer is in use.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="sched_lxrt.c::rt_get_time" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time"></a> <p>
rt_get_time returns the time, in internal count units, since start_rt_timer was called. In periodic mode this number is in multiples of the periodic tick. In oneshot mode it is directly the TSC count for CPUs having a time stamp clock (TSC), while it is a (FIXME) on 8254 units for those not having it (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="sched_lxrt.c::rt_get_time_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cpuid</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time_cpuid"></a> <p>
rt_get_time_cpuid returns the time, in internal count units, since start_rt_timer was called. In periodic mode this number is in multiples of the periodic tick. In oneshot mode it is directly the TSC count for CPUs having a time stamp clock (TSC), while it is a (FIXME) on 8254 units for those not having it (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation). This version ending with _cpuid must be used with the MUP scheduler when there is the need to declare from which cpuid the time must be gotten (FIXME). In fact one can need to get the time of another CPU and timers can differ from CPU to CPU. (FIXME) All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>corresponds to the CPUI identifier.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="sched_lxrt.c::rt_get_time_ns" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time_ns </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time_ns"></a> <p>
rt_get_time_ns is the same as <a class="el" href="sched__lxrt_8c.html#rt_get_time">rt_get_time</a>() but the returned time is converted to nanoseconds.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="sched_lxrt.c::rt_get_time_ns_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time_ns_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cpuid</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time_ns_cpuid"></a> <p>
rt_get_time_ns is the same as rt_get_time but the returned time is converted to nanoseconds. The version ending with _cpuid must be used with the MUP scheduler when there is the need to declare from which cpuidthe time must be got. In fact one can need to get the time of another CPU and timers can differ from CPU to CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>corresponds to the CPUI identifier.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="sched_lxrt.c::rt_set_oneshot_mode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_oneshot_mode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set timer mode. 
<p>
<a class="anchor" name="rt_set_oneshot_mode"></a> <p>
rt_set_periodic_mode sets the periodic mode for the timer. It consists of a fixed frequency timing of the tasks in multiple of the period set with a call to <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>(). The resolution is that of the 8254 (1193180 Hz) on a UP machine, or if the 8254 based SMP scheduler is being used. For the SMP scheduler timed by the local APIC timer and for the MUP scheduler the timer resolution is that of the local APIC timer frequency, generally the bus frequency divided 16. Any timing request not being an integer multiple of the set timer period is satisfied at the closest period tick. It is the default mode when no call is made to set the oneshot mode.<p>
<dl compact><dt><b>Note:</b></dt><dd>Stopping the timer by <a class="el" href="sched__lxrt_8c.html#stop_rt_timer">stop_rt_timer</a>() sets the timer back into its default (periodic) mode. Always call <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() before each <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>() if you want to be sure to have it oneshot on multiple insmod without rmmoding the RTAI scheduler in use. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="sched_lxrt.c::rt_set_periodic_mode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_periodic_mode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set timer mode. 
<p>
<a class="anchor" name="rt_set_periodic_mode"></a> <p>
rt_set_periodic_mode sets the periodic mode for the timer. It consists of a fixed frequency timing of the tasks in multiple of the period set with a call to <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>(). The resolution is that of the 8254 (1193180 Hz) on a UP machine, or if the 8254 based SMP scheduler is being used. For the SMP scheduler timed by the local APIC timer and for the MUP scheduler the timer resolution is that of the local APIC timer frequency, generally the bus frequency divided 16. Any timing request not being an integer multiple of the set timer period is satisfied at the closest period tick. It is the default mode when no call is made to set the oneshot mode.<p>
<dl compact><dt><b>Note:</b></dt><dd>Stopping the timer by <a class="el" href="sched__lxrt_8c.html#stop_rt_timer">stop_rt_timer</a>() sets the timer back into its default (periodic) mode. Always call <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() before each <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>() if you want to be sure to have it oneshot on multiple insmod without rmmoding the RTAI scheduler in use. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="sched_lxrt.c::start_rt_apic_timers" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void start_rt_apic_timers </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct apic_timer_setup_data *&nbsp;</td>
          <td class="mdname" nowrap> <em>setup_mode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>rcvr_jiffies_cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start local apic timer. 
<p>
<a class="anchor" name="start_rt_apic_timer"></a> <p>
start_rt_apic_timers starts local APIC timers according to what is found in <em>setup_data</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>setup_mode</em>&nbsp;</td><td>is a pointer to an array of structures apic_timer_setup_data, see function rt_setup_apic_timers (FIXME) in RTAI module functions described further on in this manual. </td></tr>
    <tr><td valign=top><em>rcvr_jiffies_cpuid</em>&nbsp;</td><td>is the CPU number whose time log has to be used to keep Linux timing and pacing in tune. This function is specific to the MUP scheduler. If it is called with either the UP or SMP scheduler it will use:<ul>
<li>a periodic timer if all local APIC timers are periodic with the same period;</li><li>a oneshot timer if all the local APIC timers are oneshot, or have different timing modes, are periodic with different periods. </li></ul>
</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="sched_lxrt.c::start_rt_timer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME start_rt_timer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>period</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start timer. 
<p>
<a class="anchor" name="start_rt_timer"></a> <p>
start_rt_timer starts the timer with a period <em>period</em>. The period is in internal count units and is required only for the periodic mode. In the oneshot mode the period value is ignored. This functions uses the 8254 with the UP and the 8254 based SMP scheduler. Otherwise it uses a single local APIC with the APIC based SMP schedulers and an APIC for each CPU with the MUP scheduler. In the latter case all local APIC timers are paced in the same way, according to the timer mode set.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The period in internal count units. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="sched_lxrt.c::stop_rt_timer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void stop_rt_timer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stop timer. 
<p>
<a class="anchor" name="stop_rt_timer"></a> <p>
stop_rt_timer stops the timer. The timer mode is set to periodic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The period in internal count units. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:22 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
