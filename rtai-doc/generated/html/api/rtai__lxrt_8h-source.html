<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_lxrt.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">rtai-core</a>&nbsp;/&nbsp;<a class="el" href="dir_000019.html">include</a></div>
<h1>rtai_lxrt.h</h1><a href="rtai__lxrt_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00066 <span class="preprocessor">#ifndef _RTAI_LXRT_H</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_LXRT_H</span>
00068 <span class="preprocessor"></span>
00069 <span class="preprocessor">#include &lt;rtai_sched.h&gt;</span>
00070 <span class="preprocessor">#include &lt;<a class="code" href="rtai__nam2num_8h.html">rtai_nam2num.h</a>&gt;</span>
00071 
00072 <span class="comment">// scheduler</span>
00073 <span class="preprocessor">#define YIELD                            0</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#define SUSPEND                          1</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#define RESUME                           2</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_PERIODIC                    3</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#define WAIT_PERIOD                      4</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#define SLEEP                            5</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#define SLEEP_UNTIL                      6</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#define START_TIMER                      7</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#define STOP_TIMER                       8</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME                         9</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#define COUNT2NANO                      10</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#define NANO2COUNT                      11</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#define BUSY_SLEEP                      12</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#define SET_PERIODIC_MODE               13</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#define SET_ONESHOT_MODE                14</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#define SIGNAL_HANDLER                  15</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#define TASK_USE_FPU                    16</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#define LINUX_USE_FPU                   17</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define PREEMPT_ALWAYS_GEN              18</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_NS                     19</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#define GET_CPU_TIME_NS                 20</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#define SET_RUNNABLE_ON_CPUS            21 </span>
00095 <span class="preprocessor"></span><span class="preprocessor">#define SET_RUNNABLE_ON_CPUID           22       </span>
00096 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIMER_CPU                   23       </span>
00097 <span class="preprocessor"></span><span class="preprocessor">#define START_RT_APIC_TIMERS            24</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#define PREEMPT_ALWAYS_CPUID            25</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#define COUNT2NANO_CPUID                26</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#define NANO2COUNT_CPUID                27</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_CPUID                  28</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_NS_CPUID               29</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_PERIODIC_NS                30</span>
00104 <span class="preprocessor"></span><span class="preprocessor">#define SET_SCHED_POLICY                31</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#define SET_RESUME_END                  32</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#define SPV_RMS                         33</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#define WAKEUP_SLEEPING                 34</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#define CHANGE_TASK_PRIO                35</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#define SET_RESUME_TIME                 36</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#define SET_PERIOD                      37</span>
00111 <span class="preprocessor"></span><span class="preprocessor">#define HARD_TIMER_RUNNING              38</span>
00112 <span class="preprocessor"></span>
00113 <span class="comment">// semaphores</span>
00114 <span class="preprocessor">#define TYPED_SEM_INIT                  39</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#define SEM_DELETE                      40</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SEM_INIT                  41</span>
00117 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SEM_DELETE                42</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#define SEM_SIGNAL                      43</span>
00119 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT                        44</span>
00120 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_IF                     45</span>
00121 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_UNTIL                  46</span>
00122 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_TIMED                  47</span>
00123 <span class="preprocessor"></span><span class="preprocessor">#define SEM_BROADCAST                   48</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_BARRIER                49</span>
00125 <span class="preprocessor"></span><span class="preprocessor">#define SEM_COUNT                       50</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT                       51</span>
00127 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT_UNTIL                 52</span>
00128 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT_TIMED                 53</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#define RWL_INIT                        54</span>
00130 <span class="preprocessor"></span><span class="preprocessor">#define RWL_DELETE                      55</span>
00131 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_RWL_INIT                  56</span>
00132 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_RWL_DELETE                57</span>
00133 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK                      58</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_IF                   59</span>
00135 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_UNTIL                60</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_TIMED                61</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK                      62      </span>
00138 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_IF                   63</span>
00139 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_UNTIL                64</span>
00140 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_TIMED                65</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#define RWL_UNLOCK                      66</span>
00142 <span class="preprocessor"></span><span class="preprocessor">#define SPL_INIT                        67</span>
00143 <span class="preprocessor"></span><span class="preprocessor">#define SPL_DELETE                      68</span>
00144 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SPL_INIT                  69</span>
00145 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SPL_DELETE                70</span>
00146 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK                        71      </span>
00147 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK_IF                     72</span>
00148 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK_TIMED                  73</span>
00149 <span class="preprocessor"></span><span class="preprocessor">#define SPL_UNLOCK                      74</span>
00150 <span class="preprocessor"></span>
00151 <span class="comment">// mail boxes</span>
00152 <span class="preprocessor">#define TYPED_MBX_INIT                  75</span>
00153 <span class="preprocessor"></span><span class="preprocessor">#define MBX_DELETE                      76</span>
00154 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MBX_INIT                  77</span>
00155 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MBX_DELETE                78</span>
00156 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND                        79</span>
00157 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_WP                     80</span>
00158 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_IF                     81</span>
00159 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_UNTIL                  82</span>
00160 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_TIMED                  83</span>
00161 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE                     84</span>
00162 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_WP                  85</span>
00163 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_IF                  86</span>
00164 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_UNTIL               87</span>
00165 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_TIMED               88</span>
00166 <span class="preprocessor"></span><span class="preprocessor">#define MBX_EVDRP                       89</span>
00167 <span class="preprocessor"></span><span class="preprocessor">#define MBX_OVRWR_SEND                  90</span>
00168 <span class="preprocessor"></span>
00169 <span class="comment">// short intertask messages</span>
00170 <span class="preprocessor">#define SENDMSG                         91</span>
00171 <span class="preprocessor"></span><span class="preprocessor">#define SEND_IF                         92</span>
00172 <span class="preprocessor"></span><span class="preprocessor">#define SEND_UNTIL                      93</span>
00173 <span class="preprocessor"></span><span class="preprocessor">#define SEND_TIMED                      94</span>
00174 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEMSG                      95</span>
00175 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_IF                      96</span>
00176 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_UNTIL                   97</span>
00177 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_TIMED                   98</span>
00178 <span class="preprocessor"></span><span class="preprocessor">#define RPCMSG                          99</span>
00179 <span class="preprocessor"></span><span class="preprocessor">#define RPC_IF                         100</span>
00180 <span class="preprocessor"></span><span class="preprocessor">#define RPC_UNTIL                      101</span>
00181 <span class="preprocessor"></span><span class="preprocessor">#define RPC_TIMED                      102</span>
00182 <span class="preprocessor"></span><span class="preprocessor">#define EVDRP                          103</span>
00183 <span class="preprocessor"></span><span class="preprocessor">#define ISRPC                          104</span>
00184 <span class="preprocessor"></span><span class="preprocessor">#define RETURNMSG                      105</span>
00185 <span class="preprocessor"></span>
00186 <span class="comment">// extended intertask messages</span>
00187 <span class="preprocessor">#define RPCX                           106</span>
00188 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_IF                        107</span>
00189 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_UNTIL                     108</span>
00190 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_TIMED                     109</span>
00191 <span class="preprocessor"></span><span class="preprocessor">#define SENDX                          110</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_IF                       111</span>
00193 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_UNTIL                    112</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_TIMED                    113</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#define RETURNX                        114</span>
00196 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX                       115</span>
00197 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_IF                    116</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_UNTIL                 117</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_TIMED                 118</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#define EVDRPX                         119</span>
00201 <span class="preprocessor"></span>
00202 <span class="comment">// proxies</span>
00203 <span class="preprocessor">#define PROXY_ATTACH                   120</span>
00204 <span class="preprocessor"></span><span class="preprocessor">#define PROXY_DETACH                   121</span>
00205 <span class="preprocessor"></span><span class="preprocessor">#define PROXY_TRIGGER                  122</span>
00206 <span class="preprocessor"></span>
00207 
00208 <span class="comment">// synchronous user space specific intertask messages and related proxies</span>
00209 <span class="preprocessor">#define RT_SEND                        123</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#define RT_RECEIVE                     124</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#define RT_CRECEIVE                    125</span>
00212 <span class="preprocessor"></span><span class="preprocessor">#define RT_REPLY                       126</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#define RT_PROXY_ATTACH                127</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#define RT_PROXY_DETACH                128</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#define RT_TRIGGER                     129</span>
00216 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_ATTACH                 130</span>
00217 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_DETACH                 131</span>
00218 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_LOCATE                 132</span>
00219 <span class="preprocessor"></span>
00220 <span class="comment">// bits</span>
00221 <span class="preprocessor">#define BITS_INIT                      133      </span>
00222 <span class="preprocessor"></span><span class="preprocessor">#define BITS_DELETE                    134</span>
00223 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_BITS_INIT                135</span>
00224 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_BITS_DELETE              136</span>
00225 <span class="preprocessor"></span><span class="preprocessor">#define BITS_GET                       137</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#define BITS_RESET                     138</span>
00227 <span class="preprocessor"></span><span class="preprocessor">#define BITS_SIGNAL                    139</span>
00228 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT                      140</span>
00229 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_IF                   141              </span>
00230 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_UNTIL                142</span>
00231 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_TIMED                143</span>
00232 <span class="preprocessor"></span>
00233 <span class="comment">// typed mail boxes</span>
00234 <span class="preprocessor">#define TBX_INIT                       144</span>
00235 <span class="preprocessor"></span><span class="preprocessor">#define TBX_DELETE                     145</span>
00236 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TBX_INIT                 146</span>
00237 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TBX_DELETE               147</span>
00238 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND                       148</span>
00239 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_IF                    149</span>
00240 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_UNTIL                 150</span>
00241 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_TIMED                 151</span>
00242 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE                    152</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_IF                 153</span>
00244 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_UNTIL              154</span>
00245 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_TIMED              155</span>
00246 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST                  156</span>
00247 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_IF               157</span>
00248 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_UNTIL            158</span>
00249 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_TIMED            159</span>
00250 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT                     160</span>
00251 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_IF                  161</span>
00252 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_UNTIL               162</span>
00253 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_TIMED               163</span>
00254 <span class="preprocessor"></span>
00255 <span class="comment">// pqueue</span>
00256 <span class="preprocessor">#define MQ_OPEN                        164</span>
00257 <span class="preprocessor"></span><span class="preprocessor">#define MQ_RECEIVE                     165</span>
00258 <span class="preprocessor"></span><span class="preprocessor">#define MQ_SEND                        166</span>
00259 <span class="preprocessor"></span><span class="preprocessor">#define MQ_CLOSE                       167</span>
00260 <span class="preprocessor"></span><span class="preprocessor">#define MQ_GETATTR                     168</span>
00261 <span class="preprocessor"></span><span class="preprocessor">#define MQ_SETATTR                     169</span>
00262 <span class="preprocessor"></span><span class="preprocessor">#define MQ_NOTIFY                      170</span>
00263 <span class="preprocessor"></span><span class="preprocessor">#define MQ_UNLINK                      171</span>
00264 <span class="preprocessor"></span><span class="preprocessor">#define MQ_TIMEDRECEIVE                172</span>
00265 <span class="preprocessor"></span><span class="preprocessor">#define MQ_TIMEDSEND                   173</span>
00266 <span class="preprocessor"></span>
00267 <span class="comment">// named tasks init/delete</span>
00268 <span class="preprocessor">#define NAMED_TASK_INIT                174</span>
00269 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TASK_INIT_CPUID          175</span>
00270 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TASK_DELETE              176</span>
00271 <span class="preprocessor"></span>
00272 <span class="comment">// registry</span>
00273 <span class="preprocessor">#define GET_ADR                        177</span>
00274 <span class="preprocessor"></span><span class="preprocessor">#define GET_NAME                       178</span>
00275 <span class="preprocessor"></span>
00276 <span class="comment">// netrpc</span>
00277 <span class="preprocessor">#define NETRPC                         179</span>
00278 <span class="preprocessor"></span><span class="preprocessor">#define SEND_REQ_REL_PORT              180</span>
00279 <span class="preprocessor"></span><span class="preprocessor">#define DDN2NL                         181</span>
00280 <span class="preprocessor"></span><span class="preprocessor">#define SET_THIS_NODE                  182</span>
00281 <span class="preprocessor"></span><span class="preprocessor">#define FIND_ASGN_STUB                 183</span>
00282 <span class="preprocessor"></span><span class="preprocessor">#define REL_STUB                       184      </span>
00283 <span class="preprocessor"></span><span class="preprocessor">#define WAITING_RETURN                 185</span>
00284 <span class="preprocessor"></span>
00285 <span class="comment">// a semaphore extension</span>
00286 <span class="preprocessor">#define COND_SIGNAL                    186</span>
00287 <span class="preprocessor"></span>
00288 <span class="comment">// new shm</span>
00289 <span class="preprocessor">#define SHM_ALLOC                      187</span>
00290 <span class="preprocessor"></span><span class="preprocessor">#define SHM_FREE                       188</span>
00291 <span class="preprocessor"></span><span class="preprocessor">#define SHM_SIZE                       189</span>
00292 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_SET                       190</span>
00293 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_ALLOC                     191</span>
00294 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_FREE                      192</span>
00295 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_NAMED_ALLOC               193</span>
00296 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_NAMED_FREE                194</span>
00297 <span class="preprocessor"></span><span class="preprocessor">#define MALLOC                         195</span>
00298 <span class="preprocessor"></span><span class="preprocessor">#define FREE                           196</span>
00299 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MALLOC                   197</span>
00300 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_FREE                     198</span>
00301 <span class="preprocessor"></span>
00302 <span class="preprocessor">#define MAX_LXRT_FUN                   200</span>
00303 <span class="preprocessor"></span>
00304 <span class="comment">// not recovered yet </span>
00305 <span class="comment">// Qblk's </span>
00306 <span class="preprocessor">#define RT_INITTICKQUEUE                69</span>
00307 <span class="preprocessor"></span><span class="preprocessor">#define RT_RELEASETICKQUEUE             70</span>
00308 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNALLOC                    71</span>
00309 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNFREE                     72</span>
00310 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNINIT                     73</span>
00311 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKWAIT                     74</span>
00312 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKREPEAT                   75</span>
00313 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKSOON                     76</span>
00314 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKDEQUEUE                  77</span>
00315 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKCANCEL                   78</span>
00316 <span class="preprocessor"></span><span class="preprocessor">#define RT_QSYNC                        79</span>
00317 <span class="preprocessor"></span><span class="preprocessor">#define RT_QRECEIVE                     80</span>
00318 <span class="preprocessor"></span><span class="preprocessor">#define RT_QLOOP                        81</span>
00319 <span class="preprocessor"></span><span class="preprocessor">#define RT_QSTEP                        82</span>
00320 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKBEFORE                   83</span>
00321 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKAFTER                    84</span>
00322 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKUNHOOK                   85</span>
00323 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKRELEASE                  86</span>
00324 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKCOMPLETE                 87</span>
00325 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKFLUSH                   88</span>
00326 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKATHEAD                   89</span>
00327 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKATTAIL                   90</span>
00328 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKINIT                    91</span>
00329 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKRELEASE                 92</span>
00330 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKSCHEDULE                 93</span>
00331 <span class="preprocessor"></span><span class="preprocessor">#define RT_GETTICKQUEUEHOOK             94</span>
00332 <span class="preprocessor"></span><span class="comment">// Testing</span>
00333 <span class="preprocessor">#define RT_BOOM                         95</span>
00334 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_MALLOC                     96</span>
00335 <span class="preprocessor"></span><span class="preprocessor">#define RT_FREE                         97</span>
00336 <span class="preprocessor"></span><span class="preprocessor">#define RT_MMGR_STATS                   98</span>
00337 <span class="preprocessor"></span><span class="preprocessor">#define RT_STOMP                        99</span>
00338 <span class="preprocessor"></span><span class="comment">// VC</span>
00339 <span class="preprocessor">#define RT_VC_ATTACH                    100</span>
00340 <span class="preprocessor"></span><span class="preprocessor">#define RT_VC_RELEASE                   101</span>
00341 <span class="preprocessor"></span><span class="preprocessor">#define RT_VC_RESERVE                   102</span>
00342 <span class="preprocessor"></span><span class="comment">// Linux Signal Support</span>
00343 <span class="preprocessor">#define RT_GET_LINUX_SIGNAL             103</span>
00344 <span class="preprocessor"></span><span class="preprocessor">#define RT_GET_ERRNO                    104</span>
00345 <span class="preprocessor"></span><span class="preprocessor">#define RT_SET_LINUX_SIGNAL_HANDLER     105</span>
00346 <span class="preprocessor"></span><span class="comment">// end of not recovered yet</span>
00347 
00348 <span class="preprocessor">#define LXRT_GET_ADR            1000</span>
00349 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_GET_NAME           1001</span>
00350 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_TASK_INIT          1002</span>
00351 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_TASK_DELETE        1003</span>
00352 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SEM_INIT           1004</span>
00353 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SEM_DELETE         1005</span>
00354 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_MBX_INIT           1006</span>
00355 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_MBX_DELETE         1007</span>
00356 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_SOFT_RT            1008</span>
00357 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_HARD_RT            1009</span>
00358 <span class="preprocessor"></span><span class="preprocessor">#define PRINT_TO_SCREEN         1010</span>
00359 <span class="preprocessor"></span><span class="preprocessor">#define NONROOT_HRT             1011</span>
00360 <span class="preprocessor"></span><span class="preprocessor">#define RT_BUDDY                1012</span>
00361 <span class="preprocessor"></span><span class="preprocessor">#define HRT_USE_FPU             1013</span>
00362 <span class="preprocessor"></span><span class="preprocessor">#define USP_SIGHDL              1014</span>
00363 <span class="preprocessor"></span><span class="preprocessor">#define GET_USP_FLAGS           1015</span>
00364 <span class="preprocessor"></span><span class="preprocessor">#define SET_USP_FLAGS           1016</span>
00365 <span class="preprocessor"></span><span class="preprocessor">#define GET_USP_FLG_MSK         1017</span>
00366 <span class="preprocessor"></span><span class="preprocessor">#define SET_USP_FLG_MSK         1018</span>
00367 <span class="preprocessor"></span><span class="preprocessor">#define IS_HARD                 1019</span>
00368 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_FORK               1020</span>
00369 <span class="preprocessor"></span><span class="preprocessor">#define ALLOC_REGISTER          1021</span>
00370 <span class="preprocessor"></span><span class="preprocessor">#define DELETE_DEREGISTER       1022</span>
00371 <span class="preprocessor"></span><span class="preprocessor">#define FORCE_TASK_SOFT         1023</span>
00372 <span class="preprocessor"></span><span class="preprocessor">#define PRINTK                  1024</span>
00373 <span class="preprocessor"></span><span class="preprocessor">#define GET_EXECTIME            1025</span>
00374 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIMEORIG            1026</span>
00375 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_RWL_INIT           1027</span>
00376 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_RWL_DELETE         1028</span>
00377 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SPL_INIT           1029</span>
00378 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SPL_DELETE         1030</span>
00379 <span class="preprocessor"></span>
00380 <span class="preprocessor">#define FORCE_SOFT 0x80000000</span>
00381 <span class="preprocessor"></span>
00382 <span class="comment">// Keep LXRT call enc/decoding together, so you are ure to act consistently.</span>
00383 <span class="comment">// This is the encoding, note " |  0x8000" to ensure not a Linux syscall, ...</span>
00384 <span class="preprocessor">#define ENCODE_LXRT_REQ(dynx, srq, lsize)  (((dynx) &lt;&lt; 28) | (((srq) &amp; 0xFFF) &lt;&lt; 16) | 0x8000 | (lsize))</span>
00385 <span class="preprocessor"></span><span class="comment">// ... and this is the decoding.</span>
00386 <span class="preprocessor">#define SRQ(x)   (((x) &gt;&gt; 16) &amp; 0xFFF)</span>
00387 <span class="preprocessor"></span><span class="preprocessor">#define NARG(x)  ((x) &amp; 0x7FFF)</span>
00388 <span class="preprocessor"></span><span class="preprocessor">#define INDX(x)  (((x) &gt;&gt; 28) &amp; 0xF)</span>
00389 <span class="preprocessor"></span>
00390 <span class="preprocessor">#ifdef __KERNEL__</span>
00391 <span class="preprocessor"></span>
00392 <span class="preprocessor">#include &lt;asm/rtai_lxrt.h&gt;</span>
00393 
00394 <span class="comment">/*</span>
00395 <span class="comment">     Encoding of system call argument</span>
00396 <span class="comment">            31                                    0  </span>
00397 <span class="comment">soft SRQ    .... |||| |||| |||| .... .... .... ....  0 - 4095 max</span>
00398 <span class="comment">int  NARG   .... .... .... .... |||| |||| |||| ||||  </span>
00399 <span class="comment">arg  INDX   |||| .... .... .... .... .... .... ....</span>
00400 <span class="comment">*/</span>
00401 
00402 <span class="comment">/*</span>
00403 <span class="comment">These USP (unsigned long long) type fields allow to read and write up to 2 arguments.  </span>
00404 <span class="comment">                                               </span>
00405 <span class="comment">RW marker .... .... .... .... .... .... .... ..|| .... .... .... .... .... .... .... ...|</span>
00406 <span class="comment"></span>
00407 <span class="comment">HIGH unsigned long encodes writes</span>
00408 <span class="comment">W ARG1 BF .... .... .... .... .... ...| |||| ||..</span>
00409 <span class="comment">W ARG1 SZ .... .... .... .... |||| |||. .... ....</span>
00410 <span class="comment">W ARG2 BF .... .... .||| |||| .... .... .... ....</span>
00411 <span class="comment">W ARG2 SZ ..|| |||| |... .... .... .... .... ....</span>
00412 <span class="comment">W 1st  LL .|.. .... .... .... .... .... .... ....</span>
00413 <span class="comment">W 2nd  LL |... .... .... .... .... .... .... ....</span>
00414 <span class="comment"></span>
00415 <span class="comment">LOW unsigned long encodes reads</span>
00416 <span class="comment">R ARG1 BF .... .... .... .... .... ...| |||| ||..</span>
00417 <span class="comment">R ARG1 SZ .... .... .... .... |||| |||. .... ....</span>
00418 <span class="comment">R ARG2 BF .... .... .||| |||| .... .... .... ....</span>
00419 <span class="comment">R ARG2 SZ ..|| |||| |... .... .... .... .... ....</span>
00420 <span class="comment">R 1st  LL .|.. .... .... .... .... .... .... ....</span>
00421 <span class="comment">R 2nd  LL |... .... .... .... .... .... .... ....</span>
00422 <span class="comment"></span>
00423 <span class="comment">LOW unsigned long encodes also</span>
00424 <span class="comment">RT Switch .... .... .... .... .... .... .... ...|</span>
00425 <span class="comment"></span>
00426 <span class="comment">and </span>
00427 <span class="comment">Always 0  .... .... .... .... .... .... .... ..|.</span>
00428 <span class="comment"></span>
00429 <span class="comment">If SZ is zero sizeof(int) is copied by default, if LL bit is set sizeof(long long) is copied.</span>
00430 <span class="comment">*/</span>
00431 
00432 <span class="comment">// These are for setting appropriate bits in any function entry structure, OR</span>
00433 <span class="comment">// them in fun entry type to obtain the desired encoding</span>
00434 
00435 <span class="comment">// for writes</span>
00436 <span class="preprocessor">#define UW1(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9))) &lt;&lt; 32) | 0x300000001LL)</span>
00437 <span class="preprocessor"></span><span class="preprocessor">#define UW2(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23))) &lt;&lt; 32) | 0x300000001LL)</span>
00438 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ1LL      (0x4000000300000001LL)</span>
00439 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ2LL      (0x8000000300000001LL)</span>
00440 <span class="preprocessor"></span>
00441 <span class="comment">// for reads</span>
00442 <span class="preprocessor">#define UR1(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9) | 0x300000001LL)</span>
00443 <span class="preprocessor"></span><span class="preprocessor">#define UR2(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23) | 0x300000001LL)</span>
00444 <span class="preprocessor"></span><span class="preprocessor">#define URSZ1LL      (0x340000001LL)</span>
00445 <span class="preprocessor"></span><span class="preprocessor">#define URSZ2LL      (0x380000001LL)</span>
00446 <span class="preprocessor"></span>
00447 <span class="comment">// and these are for deciding what to do in lxrt.c</span>
00448 <span class="preprocessor">#define NEED_TO_RW(x)   (((unsigned long *)&amp;(x))[HIGH])</span>
00449 <span class="preprocessor"></span>
00450 <span class="preprocessor">#define NEED_TO_R(x)    (((unsigned long *)&amp;(x))[LOW]  &amp; 0x0000FFFC)</span>
00451 <span class="preprocessor"></span><span class="preprocessor">#define NEED_TO_W(x)    (((unsigned long *)&amp;(x))[HIGH] &amp; 0x0000FFFC)</span>
00452 <span class="preprocessor"></span>
00453 <span class="preprocessor">#define NEED_TO_R2ND(x) (((unsigned long *)&amp;(x))[LOW]  &amp; 0x3FFF0000)</span>
00454 <span class="preprocessor"></span><span class="preprocessor">#define NEED_TO_W2ND(x) (((unsigned long *)&amp;(x))[HIGH] &amp; 0x3FFF0000)</span>
00455 <span class="preprocessor"></span>
00456 <span class="preprocessor">#define USP_RBF1(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt;  2) &amp; 0x7F)</span>
00457 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ1(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt;  9) &amp; 0x7F)</span>
00458 <span class="preprocessor"></span><span class="preprocessor">#define USP_RBF2(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt; 16) &amp; 0x7F)</span>
00459 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ2(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt; 23) &amp; 0x7F)</span>
00460 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ1LL(x)   (((unsigned long *)&amp;(x))[LOW] &amp; 0x40000000)</span>
00461 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ2LL(x)   (((unsigned long *)&amp;(x))[LOW] &amp; 0x80000000)</span>
00462 <span class="preprocessor"></span>
00463 <span class="preprocessor">#define USP_WBF1(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt;  2) &amp; 0x7F)</span>
00464 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ1(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt;  9) &amp; 0x7F)</span>
00465 <span class="preprocessor"></span><span class="preprocessor">#define USP_WBF2(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt; 16) &amp; 0x7F)</span>
00466 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ2(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt; 23) &amp; 0x7F)</span>
00467 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ1LL(x)   (((unsigned long *)&amp;(x))[HIGH] &amp; 0x40000000)</span>
00468 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ2LL(x)   (((unsigned long *)&amp;(x))[HIGH] &amp; 0x80000000)</span>
00469 <span class="preprocessor"></span>
00470 <span class="keyword">struct </span>rt_fun_entry {
00471     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> type;
00472     <span class="keywordtype">void</span> *fun;
00473 };
00474 
00475 <span class="keyword">struct </span>rt_native_fun_entry {
00476     <span class="keyword">struct </span>rt_fun_entry fun;
00477     <span class="keywordtype">int</span> index;
00478 };
00479 
00480 <span class="keyword">extern</span> <span class="keyword">struct </span>rt_fun_entry rt_fun_lxrt[];
00481 
00482 <span class="keywordtype">void</span> reset_rt_fun_entries(<span class="keyword">struct</span> rt_native_fun_entry *entry);
00483 
00484 <span class="keywordtype">int</span> set_rt_fun_entries(<span class="keyword">struct</span> rt_native_fun_entry *entry);
00485 
00486 <span class="preprocessor">#ifdef __cplusplus</span>
00487 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00488 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00489 
00490 <span class="preprocessor">#if CONFIG_RTAI_INTERNAL_LXRT_SUPPORT</span>
00491 <span class="preprocessor"></span> 
00492 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>rt_task_struct *pid2rttask(pid_t pid)
00493 {
00494         <span class="keywordflow">return</span> ((<span class="keywordtype">unsigned</span> long)pid) &gt; PID_MAX_LIMIT ? (<span class="keyword">struct </span>rt_task_struct *)pid : find_task_by_pid(pid)-&gt;this_rt_task[0];
00495 }
00496 
00497 <span class="keyword">static</span> <span class="keyword">inline</span> pid_t rttask2pid(<span class="keyword">struct</span> rt_task_struct * task)
00498 {
00499     <span class="keywordflow">return</span> task-&gt;lnxtsk ? task-&gt;lnxtsk-&gt;pid : (int) task;
00500 }
00501 
00502 <span class="preprocessor">#else </span><span class="comment">/* !CONFIG_RTAI_INTERNAL_LXRT_SUPPORT */</span>
00503 
00504 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>rt_task_struct *pid2rttask(pid_t pid)
00505 {
00506     <span class="keywordflow">return</span> 0;
00507 }
00508 
00509 <span class="comment">// The following might look strange but it must be so to work with</span>
00510 <span class="comment">// buddies also.</span>
00511 <span class="keyword">static</span> <span class="keyword">inline</span> pid_t rttask2pid(<span class="keyword">struct</span> rt_task_struct * task)
00512 {
00513     <span class="keywordflow">return</span> (int) task;
00514 }
00515 
00516 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_INTERNAL_LXRT_SUPPORT */</span>
00517 
00518 <span class="keywordtype">int</span> set_rtai_callback(<span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span>));
00519 
00520 <span class="keywordtype">void</span> remove_rtai_callback(<span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span>));
00521 
00522 RT_TASK *rt_lxrt_whoami(<span class="keywordtype">void</span>);
00523 
00524 <span class="keywordtype">void</span> exec_func(<span class="keywordtype">void</span> (*func)(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> evn),
00525                <span class="keywordtype">void</span> *data,
00526                <span class="keywordtype">int</span> evn);
00527 
00528 <span class="keywordtype">int</span>  set_rt_fun_ext_index(<span class="keyword">struct</span> rt_fun_entry *fun,
00529                           <span class="keywordtype">int</span> idx);
00530 
00531 <span class="keywordtype">void</span> reset_rt_fun_ext_index(<span class="keyword">struct</span> rt_fun_entry *fun,
00532                             <span class="keywordtype">int</span> idx);
00533 
00534 <span class="preprocessor">#ifdef __cplusplus</span>
00535 <span class="preprocessor"></span>}
00536 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00537 
00538 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00539 
00540 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00541 <span class="preprocessor">#include &lt;sched.h&gt;</span>
00542 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00543 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00544 <span class="preprocessor">#include &lt;string.h&gt;</span>
00545 <span class="preprocessor">#include &lt;asm/rtai_lxrt.h&gt;</span>
00546 
00547 <span class="keyword">struct </span>apic_timer_setup_data;
00548 
00549 <span class="preprocessor">#define rt_grow_and_lock_stack(incr) \</span>
00550 <span class="preprocessor">        do { \</span>
00551 <span class="preprocessor">                char buf[incr]; \</span>
00552 <span class="preprocessor">                memset(buf, 0, incr); \</span>
00553 <span class="preprocessor">                mlockall(MCL_CURRENT | MCL_FUTURE); \</span>
00554 <span class="preprocessor">        } while (0)</span>
00555 <span class="preprocessor"></span>
00556 <span class="preprocessor">#define BIDX   0 // rt_fun_ext[0]</span>
00557 <span class="preprocessor"></span><span class="preprocessor">#define SIZARG sizeof(arg)</span>
00558 <span class="preprocessor"></span>
00559 <span class="preprocessor">#ifdef __cplusplus</span>
00560 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00561 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00562 
<a name="l00570"></a><a class="code" href="group__lxrt.html#ga0">00570</a> RTAI_PROTO(<span class="keywordtype">void</span> *,rt_get_adr,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name))
00571 {
00572         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name; } arg = { name };
00573         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_GET_ADR, &amp;arg).v[LOW];
00574 } 
00575 
<a name="l00584"></a><a class="code" href="group__lxrt.html#ga1">00584</a> RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_name,(<span class="keywordtype">void</span> *adr))
00585 {
00586         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *adr; } arg = { adr };
00587         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_GET_NAME, &amp;arg).i[LOW];
00588 }
00589 
00590 RTAI_PROTO(RT_TASK *,rt_task_init_schmod,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> max_msg_size, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> cpus_allowed))
00591 {
00592         <span class="keyword">struct </span>sched_param mysched;
00593         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, priority, stack_size, max_msg_size, cpus_allowed; } arg = { name, priority, stack_size, max_msg_size, cpus_allowed };
00594 
00595         mysched.sched_priority = sched_get_priority_max(policy) - priority;
00596         <span class="keywordflow">if</span> (mysched.sched_priority &lt; 1 ) {
00597                 mysched.sched_priority = 1;
00598         }
00599         <span class="keywordflow">if</span> (sched_setscheduler(0, policy, &amp;mysched) &lt; 0) {
00600                 <span class="keywordflow">return</span> 0;
00601         }
00602 
00603         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, LXRT_TASK_INIT, &amp;arg).v[LOW];
00604 }
00605 
00606 
<a name="l00660"></a><a class="code" href="group__lxrt.html#ga3">00660</a> RTAI_PROTO(RT_TASK *,rt_task_init,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> max_msg_size))
00661 {
00662         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, priority, stack_size, max_msg_size, cpus_allowed; } arg = { name, priority, stack_size, max_msg_size, 0xFF };
00663         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, LXRT_TASK_INIT, &amp;arg).v[LOW];
00664 }
00665 
00666 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_sched_policy,(RT_TASK *task, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> rr_quantum_ns))
00667 {
00668         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> policy; <span class="keywordtype">int</span> rr_quantum_ns; } arg = { task, policy, rr_quantum_ns };
00669         rtai_lxrt(BIDX, SIZARG, SET_SCHED_POLICY, &amp;arg);
00670 }
00671 
00672 RTAI_PROTO(<span class="keywordtype">int</span>,rt_change_prio,(RT_TASK *task, <span class="keywordtype">int</span> priority))
00673 {
00674         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> priority; } arg = { task, priority };
00675         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, CHANGE_TASK_PRIO, &amp;arg).i[LOW];
00676 }
00677 
<a name="l00690"></a><a class="code" href="group__lxrt.html#ga6">00690</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_make_soft_real_time,(<span class="keywordtype">void</span>))
00691 {
00692         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00693         rtai_lxrt(BIDX, SIZARG, MAKE_SOFT_RT, &amp;arg);
00694 }
00695 
00696 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_delete,(RT_TASK *task))
00697 {
00698         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00699         <a class="code" href="group__lxrt.html#ga6">rt_make_soft_real_time</a>();
00700         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_TASK_DELETE, &amp;arg).i[LOW];
00701 }
00702 
00703 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_yield,(<span class="keywordtype">void</span>))
00704 {
00705         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00706         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, YIELD, &amp;arg).i[LOW];
00707 }
00708 
00709 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_suspend,(RT_TASK *task))
00710 {
00711         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00712         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SUSPEND, &amp;arg).i[LOW];
00713 }
00714 
00715 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_resume,(RT_TASK *task))
00716 {
00717         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00718         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RESUME, &amp;arg).i[LOW];
00719 }
00720 
00721 RTAI_PROTO(<span class="keywordtype">int</span>, rt_task_make_periodic,(RT_TASK *task, RTIME start_time, RTIME period))
00722 {
00723         <span class="keyword">struct </span>{ RT_TASK *task; RTIME start_time, period; } arg = { task, start_time, period };
00724         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MAKE_PERIODIC, &amp;arg).i[LOW];
00725 }
00726 
00727 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_make_periodic_relative_ns,(RT_TASK *task, RTIME start_delay, RTIME period))
00728 {
00729         <span class="keyword">struct </span>{ RT_TASK *task; RTIME start_time, period; } arg = { task, start_delay, period };
00730         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MAKE_PERIODIC_NS, &amp;arg).i[LOW];
00731 }
00732 
00733 RTAI_PROTO(<span class="keywordtype">void</span>,rt_task_wait_period,(<span class="keywordtype">void</span>))
00734 {
00735         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00736         rtai_lxrt(BIDX, SIZARG, WAIT_PERIOD, &amp;arg);
00737 }
00738 
00739 RTAI_PROTO(<span class="keywordtype">void</span>,rt_sleep,(RTIME delay))
00740 {
00741         <span class="keyword">struct </span>{ RTIME delay; } arg = { delay };
00742         rtai_lxrt(BIDX, SIZARG, SLEEP, &amp;arg);
00743 }
00744 
00745 RTAI_PROTO(<span class="keywordtype">void</span>,rt_sleep_until,(RTIME time))
00746 {
00747         <span class="keyword">struct </span>{ RTIME time; } arg = { time };
00748         rtai_lxrt(BIDX, SIZARG, SLEEP_UNTIL, &amp;arg);
00749 }
00750 
00751 RTAI_PROTO(<span class="keywordtype">int</span>,rt_is_hard_timer_running,(<span class="keywordtype">void</span>))
00752 {
00753         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00754         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, HARD_TIMER_RUNNING, &amp;arg).i[LOW];
00755 }
00756 
00757 RTAI_PROTO(RTIME, start_rt_timer,(<span class="keywordtype">int</span> period))
00758 {
00759         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> period; } arg = { period };
00760         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, START_TIMER, &amp;arg).rt;
00761 }
00762 
00763 RTAI_PROTO(<span class="keywordtype">void</span>, stop_rt_timer,(<span class="keywordtype">void</span>))
00764 {
00765         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00766         rtai_lxrt(BIDX, SIZARG, STOP_TIMER, &amp;arg);
00767 }
00768 
00769 RTAI_PROTO(RTIME,rt_get_time,(<span class="keywordtype">void</span>))
00770 {
00771         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00772         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME, &amp;arg).rt;
00773 }
00774 
00775 RTAI_PROTO(RTIME,count2nano,(RTIME count))
00776 {
00777         <span class="keyword">struct </span>{ RTIME count; } arg = { count };
00778         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COUNT2NANO, &amp;arg).rt;
00779 }
00780 
00781 RTAI_PROTO(RTIME,nano2count,(RTIME nanos))
00782 {
00783         <span class="keyword">struct </span>{ RTIME nanos; } arg = { nanos };
00784         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NANO2COUNT, &amp;arg).rt;
00785 }
00786 
00787 RTAI_PROTO(<span class="keywordtype">void</span>,rt_busy_sleep,(<span class="keywordtype">int</span> ns))
00788 {
00789         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> ns; } arg = { ns };
00790         rtai_lxrt(BIDX, SIZARG, BUSY_SLEEP, &amp;arg);
00791 }
00792 
00793 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_periodic_mode,(<span class="keywordtype">void</span>))
00794 {
00795         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00796         rtai_lxrt(BIDX, SIZARG, SET_PERIODIC_MODE, &amp;arg);
00797 }
00798 
00799 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_oneshot_mode,(<span class="keywordtype">void</span>))
00800 {
00801         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00802         rtai_lxrt(BIDX, SIZARG, SET_ONESHOT_MODE, &amp;arg);
00803 }
00804 
00805 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_signal_handler,(RT_TASK *task, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>)))
00806 {
00807         <span class="keyword">struct </span>{ RT_TASK *task; void (*handler)(void); } arg = { task, handler };
00808         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SIGNAL_HANDLER, &amp;arg).i[LOW];
00809 }
00810 
00811 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_use_fpu,(RT_TASK *task, <span class="keywordtype">int</span> use_fpu_flag))
00812 {
00813         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> use_fpu_flag; } arg = { task, use_fpu_flag };
00814         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, RT_BUDDY, &amp;arg).v[LOW] != task) {
00815                 <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, TASK_USE_FPU, &amp;arg).i[LOW];
00816         } <span class="keywordflow">else</span> {
00817 <span class="comment">// note that it would be enough to do whatever FP op here to have it OK. But</span>
00818 <span class="comment">// that is scary if it is done when already in hard real time, and we do not</span>
00819 <span class="comment">// want to force users to call this before making it hard.</span>
00820                 rtai_lxrt(BIDX, SIZARG, HRT_USE_FPU, &amp;arg);
00821                 <span class="keywordflow">return</span> 0;
00822         }
00823 }
00824 
00825 RTAI_PROTO(<span class="keywordtype">int</span>,rt_buddy_task_use_fpu,(RT_TASK *task, <span class="keywordtype">int</span> use_fpu_flag))
00826 {
00827         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> use_fpu_flag; } arg = { task, use_fpu_flag };
00828         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, TASK_USE_FPU, &amp;arg).i[LOW];
00829 }
00830 
00831 RTAI_PROTO(<span class="keywordtype">int</span>,rt_linux_use_fpu,(<span class="keywordtype">int</span> use_fpu_flag))
00832 {
00833         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> use_fpu_flag; } arg = { use_fpu_flag };
00834         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LINUX_USE_FPU, &amp;arg).i[LOW];
00835 }
00836 
00837 RTAI_PROTO(<span class="keywordtype">void</span>,rt_preempt_always,(<span class="keywordtype">int</span> yes_no))
00838 {
00839         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> yes_no; } arg = { yes_no };
00840         rtai_lxrt(BIDX, SIZARG, PREEMPT_ALWAYS_GEN, &amp;arg);
00841 }
00842 
00843 RTAI_PROTO(RTIME,rt_get_time_ns,(<span class="keywordtype">void</span>))
00844 {
00845         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00846         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_NS, &amp;arg).rt;
00847 }
00848 
00849 RTAI_PROTO(RTIME,rt_get_cpu_time_ns,(<span class="keywordtype">void</span>))
00850 {
00851         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00852         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_CPU_TIME_NS, &amp;arg).rt;
00853 }
00854 
00855 <span class="preprocessor">#define rt_named_task_init(task_name, thread, data, stack_size, prio, uses_fpu, signal) \</span>
00856 <span class="preprocessor">        rt_task_init(nam2num(task_name), thread, data, stack_size, prio, uses_fpu, signal)</span>
00857 <span class="preprocessor"></span>
00858 <span class="preprocessor">#define rt_named_task_init_cpuid(task_name, thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu) \</span>
00859 <span class="preprocessor">        rt_task_init_cpuid(nam2num(task_name), thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu)</span>
00860 <span class="preprocessor"></span>
00861 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_runnable_on_cpus,(RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cpu_mask))
00862 {
00863         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cpu_mask; } arg = { task, cpu_mask };
00864         rtai_lxrt(BIDX, SIZARG, SET_RUNNABLE_ON_CPUS, &amp;arg);
00865 }
00866 
00867 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_runnable_on_cpuid,(RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00868 {
00869         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { task, cpuid };
00870         rtai_lxrt(BIDX, SIZARG, SET_RUNNABLE_ON_CPUID, &amp;arg);
00871 }
00872 
00873 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_timer_cpu,(<span class="keywordtype">void</span>))
00874 {
00875         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00876         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIMER_CPU, &amp;arg).i[LOW];
00877 }
00878 
00879 RTAI_PROTO(<span class="keywordtype">void</span>,start_rt_apic_timers,(<span class="keyword">struct</span> apic_timer_setup_data *setup_mode, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rcvr_jiffies_cpuid))
00880 {
00881         <span class="keyword">struct </span>{ <span class="keyword">struct </span>apic_timer_setup_data *setup_mode; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rcvr_jiffies_cpuid; } arg = { setup_mode, rcvr_jiffies_cpuid };
00882         rtai_lxrt(BIDX, SIZARG, START_RT_APIC_TIMERS, &amp;arg);
00883 }
00884 
00885 RTAI_PROTO(<span class="keywordtype">void</span>,rt_preempt_always_cpuid,(<span class="keywordtype">int</span> yes_no, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00886 {
00887         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> yes_no; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { yes_no, cpuid };
00888         rtai_lxrt(BIDX, SIZARG, PREEMPT_ALWAYS_CPUID, &amp;arg);
00889 }
00890 
00891 RTAI_PROTO(RTIME,count2nano_cpuid,(RTIME count, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00892 {
00893         <span class="keyword">struct </span>{ RTIME count; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { count, cpuid };
00894         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COUNT2NANO_CPUID, &amp;arg).rt;
00895 }
00896 
00897 RTAI_PROTO(RTIME,nano2count_cpuid,(RTIME nanos, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00898 {
00899         <span class="keyword">struct </span>{ RTIME nanos; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { nanos, cpuid };
00900         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NANO2COUNT_CPUID, &amp;arg).rt;
00901 }
00902 
00903 RTAI_PROTO(RTIME,rt_get_time_cpuid,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00904 {
00905         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
00906         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_CPUID, &amp;arg).rt;
00907 }
00908 
00909 RTAI_PROTO(RTIME,rt_get_time_ns_cpuid,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00910 {
00911         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
00912         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_NS_CPUID, &amp;arg).rt;
00913 }
00914 
00915 RTAI_PROTO(<span class="keywordtype">void</span>,rt_boom,(<span class="keywordtype">void</span>))
00916 {
00917         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00918         rtai_lxrt(BIDX, SIZARG, RT_BOOM, &amp;arg);
00919 }
00920 
00921 RTAI_PROTO(<span class="keywordtype">void</span>,rt_mmgr_stats,(<span class="keywordtype">void</span>))
00922 {
00923         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00924         rtai_lxrt(BIDX, SIZARG, RT_MMGR_STATS, &amp;arg);
00925 }
00926 
00927 RTAI_PROTO(<span class="keywordtype">void</span>,rt_stomp,(<span class="keywordtype">void</span>) )
00928 {
00929         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00930         rtai_lxrt(BIDX, SIZARG, RT_STOMP, &amp;arg);
00931 }
00932 
00933 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_linux_signal,(RT_TASK *task))
00934 {
00935     <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00936     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_GET_LINUX_SIGNAL, &amp;arg).i[LOW];
00937 }
00938 
00939 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_errno,(RT_TASK *task))
00940 {
00941     <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00942     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_GET_ERRNO, &amp;arg).i[LOW];
00943 }
00944 
00945 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_linux_signal_handler,(RT_TASK *task, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">int</span> sig)))
00946 {
00947     <span class="keyword">struct </span>{ RT_TASK *task; void (*handler)(<span class="keywordtype">int</span> sig); } arg = { task, handler };
00948     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_SET_LINUX_SIGNAL_HANDLER, &amp;arg).i[LOW];
00949 }
00950 
00951 RTAI_PROTO(<span class="keywordtype">int</span>, rt_lxrt_fork,(<span class="keywordtype">int</span> is_a_clone))
00952 {
00953     <span class="keyword">struct </span>{ <span class="keywordtype">int</span> is_a_clone; } arg = { is_a_clone };
00954     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_FORK, &amp;arg).i[LOW];
00955 }
00956 
00957 RTAI_PROTO(<span class="keywordtype">int</span>,rtai_print_to_screen,(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...))
00958 {
00959         <span class="keywordtype">char</span> display[256];
00960         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *display; <span class="keywordtype">int</span> nch; } arg = { display, 0 };
00961         va_list args;
00962 
00963         va_start(args, format);
00964         arg.nch = vsprintf(display, format, args);
00965         va_end(args);
00966         rtai_lxrt(BIDX, SIZARG, PRINT_TO_SCREEN, &amp;arg);
00967         <span class="keywordflow">return</span> arg.nch;
00968 }
00969 
00970 RTAI_PROTO(<span class="keywordtype">int</span>,rt_printk,(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...))
00971 {
00972         <span class="keywordtype">char</span> display[256];
00973         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *display; <span class="keywordtype">int</span> nch; } arg = { display, 0 };
00974         va_list args;
00975 
00976         va_start(args, format);
00977         arg.nch = vsprintf(display, format, args);
00978         va_end(args);
00979         rtai_lxrt(BIDX, SIZARG, PRINTK, &amp;arg);
00980         <span class="keywordflow">return</span> arg.nch;
00981 }
00982 
00983 RTAI_PROTO(<span class="keywordtype">int</span>,rt_usp_signal_handler,(<span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>)))
00984 {
00985         <span class="keyword">struct </span>{ void (*handler)(void); } arg = { handler };
00986         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, USP_SIGHDL, &amp;arg).i[0];
00987 }
00988 
00989 RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_usp_flags,(RT_TASK *rt_task))
00990 {
00991         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
00992         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_USP_FLAGS, &amp;arg).i[LOW];
00993 }
00994 
00995 RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_usp_flags_mask,(RT_TASK *rt_task))
00996 {
00997         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
00998         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_USP_FLG_MSK, &amp;arg).i[LOW];
00999 }
01000 
01001 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_usp_flags,(RT_TASK *rt_task, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags))
01002 {
01003         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags; } arg = { rt_task, flags };
01004         rtai_lxrt(BIDX, SIZARG, SET_USP_FLAGS, &amp;arg);
01005 }
01006 
01007 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_usp_flags_mask,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags_mask))
01008 {
01009         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags_mask; } arg = { flags_mask };
01010         rtai_lxrt(BIDX, SIZARG, SET_USP_FLG_MSK, &amp;arg);
01011 }
01012 
01013 RTAI_PROTO(RT_TASK *,rt_force_task_soft,(<span class="keywordtype">int</span> pid))
01014 {
01015         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> pid; } arg = { pid };
01016         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, FORCE_TASK_SOFT, &amp;arg).v[LOW];
01017 }
01018 
01019 RTAI_PROTO(RT_TASK *,rt_agent,(<span class="keywordtype">void</span>))
01020 {
01021         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01022         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, RT_BUDDY, &amp;arg).v[LOW];
01023 }
01024 
01025 <span class="preprocessor">#define rt_buddy() rt_agent()</span>
01026 <span class="preprocessor"></span>
<a name="l01049"></a><a class="code" href="group__lxrt.html#ga57">01049</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_make_hard_real_time,(<span class="keywordtype">void</span>))
01050 {
01051         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01052         rtai_lxrt(BIDX, SIZARG, MAKE_HARD_RT, &amp;arg);
01053 }
01054 
<a name="l01063"></a><a class="code" href="group__lxrt.html#ga58">01063</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_allow_nonroot_hrt,(<span class="keywordtype">void</span>))
01064 {
01065         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01066         rtai_lxrt(BIDX, SIZARG, NONROOT_HRT, &amp;arg);
01067 }
01068 
01069 RTAI_PROTO(<span class="keywordtype">int</span>,rt_is_hard_real_time,(RT_TASK *rt_task))
01070 {
01071         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
01072         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IS_HARD, &amp;arg).i[LOW];
01073 }
01074 
01075 <span class="preprocessor">#define rt_is_soft_real_time(rt_task) (!rt_is_hard_real_time((rt_task)))</span>
01076 <span class="preprocessor"></span>
01077 RTAI_PROTO(<span class="keywordtype">void</span>,rt_task_set_resume_end_times,(RTIME resume, RTIME end))
01078 {
01079         <span class="keyword">struct </span>{ RTIME resume, end; } arg = { resume, end };
01080         rtai_lxrt(BIDX, SIZARG, SET_RESUME_END, &amp;arg);
01081 }
01082 
01083 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_resume_time,(RT_TASK *rt_task, RTIME new_resume_time))
01084 {
01085         <span class="keyword">struct </span>{ RT_TASK *rt_task; RTIME new_resume_time; } arg = { rt_task, new_resume_time };
01086         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SET_RESUME_TIME, &amp;arg).i[LOW];
01087 }
01088 
01089 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_period,(RT_TASK *rt_task, RTIME new_period))
01090 {
01091         <span class="keyword">struct </span>{ RT_TASK *rt_task; RTIME new_period; } arg = { rt_task, new_period };
01092         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SET_PERIOD, &amp;arg).i[LOW];
01093 }
01094 
01095 RTAI_PROTO(<span class="keywordtype">void</span>,rt_spv_RMS,(<span class="keywordtype">int</span> cpuid))
01096 {
01097         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
01098         rtai_lxrt(BIDX, SIZARG, SPV_RMS, &amp;arg);
01099 }
01100 
01101 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_wakeup_sleeping,(RT_TASK *task))
01102 {
01103         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
01104         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, WAKEUP_SLEEPING, &amp;arg).i[LOW];
01105 }
01106 
01107 RTAI_PROTO(<span class="keywordtype">void</span>,rt_get_exectime,(RT_TASK *task, RTIME *exectime))
01108 {
01109         RTIME lexectime[] = { 0LL, 0LL, 0LL };
01110         <span class="keyword">struct </span>{ RT_TASK *task; RTIME *lexectime; } arg = { task, lexectime };
01111         rtai_lxrt(BIDX, SIZARG, GET_EXECTIME, &amp;arg);
01112         memcpy(exectime, lexectime, <span class="keyword">sizeof</span>(lexectime));
01113 }
01114 
01115 RTAI_PROTO(<span class="keywordtype">void</span>,rt_gettimeorig,(RTIME time_orig[]))
01116 {
01117         <span class="keyword">struct </span>{ RTIME *time_orig; } arg = { time_orig };
01118         rtai_lxrt(BIDX, SIZARG, GET_TIMEORIG, &amp;arg);
01119 }
01120 
01121 <span class="preprocessor">#ifdef __cplusplus</span>
01122 <span class="preprocessor"></span>}
01123 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
01124 
01125 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
01126 
01129 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_LXRT_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 21 00:14:01 2004 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
