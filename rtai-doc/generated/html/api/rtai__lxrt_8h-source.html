<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_lxrt.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/rtai_lxrt.h</h1><a href="rtai__lxrt_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00066 <span class="preprocessor">#ifndef _RTAI_LXRT_H</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_LXRT_H</span>
00068 <span class="preprocessor"></span>
00069 <span class="preprocessor">#include &lt;rtai_sched.h&gt;</span>
00070 <span class="preprocessor">#include &lt;<a class="code" href="rtai__nam2num_8h.html">rtai_nam2num.h</a>&gt;</span>
00071 
00072 <span class="comment">// scheduler</span>
00073 <span class="preprocessor">#define YIELD                            0</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#define SUSPEND                          1</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#define RESUME                           2</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_PERIODIC                    3</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#define WAIT_PERIOD                      4</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#define SLEEP                            5</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#define SLEEP_UNTIL                      6</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#define START_TIMER                      7</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#define STOP_TIMER                       8</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME                         9</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#define COUNT2NANO                      10</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#define NANO2COUNT                      11</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#define BUSY_SLEEP                      12</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#define SET_PERIODIC_MODE               13</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#define SET_ONESHOT_MODE                14</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#define SIGNAL_HANDLER                  15</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#define TASK_USE_FPU                    16</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#define LINUX_USE_FPU                   17</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define PREEMPT_ALWAYS_GEN              18</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_NS                     19</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#define GET_CPU_TIME_NS                 20</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#define SET_RUNNABLE_ON_CPUS            21 </span>
00095 <span class="preprocessor"></span><span class="preprocessor">#define SET_RUNNABLE_ON_CPUID           22       </span>
00096 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIMER_CPU                   23       </span>
00097 <span class="preprocessor"></span><span class="preprocessor">#define START_RT_APIC_TIMERS            24</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#define PREEMPT_ALWAYS_CPUID            25</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#define COUNT2NANO_CPUID                26</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#define NANO2COUNT_CPUID                27</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_CPUID                  28</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_NS_CPUID               29</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_PERIODIC_NS                30</span>
00104 <span class="preprocessor"></span><span class="preprocessor">#define SET_SCHED_POLICY                31</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#define SET_RESUME_END                  32</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#define SPV_RMS                         33</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#define WAKEUP_SLEEPING                 34</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#define CHANGE_TASK_PRIO                35</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#define SET_RESUME_TIME                 36</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#define SET_PERIOD                      37</span>
00111 <span class="preprocessor"></span><span class="preprocessor">#define HARD_TIMER_RUNNING              38</span>
00112 <span class="preprocessor"></span>
00113 <span class="comment">// semaphores</span>
00114 <span class="preprocessor">#define TYPED_SEM_INIT                  39</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#define SEM_DELETE                      40</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SEM_INIT                  41</span>
00117 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SEM_DELETE                42</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#define SEM_SIGNAL                      43</span>
00119 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT                        44</span>
00120 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_IF                     45</span>
00121 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_UNTIL                  46</span>
00122 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_TIMED                  47</span>
00123 <span class="preprocessor"></span><span class="preprocessor">#define SEM_BROADCAST                   48</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_BARRIER                49</span>
00125 <span class="preprocessor"></span><span class="preprocessor">#define SEM_COUNT                       50</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT                       51</span>
00127 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT_UNTIL                 52</span>
00128 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT_TIMED                 53</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#define RWL_INIT                        54</span>
00130 <span class="preprocessor"></span><span class="preprocessor">#define RWL_DELETE                      55</span>
00131 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_RWL_INIT                  56</span>
00132 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_RWL_DELETE                57</span>
00133 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK                      58</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_IF                   59</span>
00135 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_UNTIL                60</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_TIMED                61</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK                      62      </span>
00138 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_IF                   63</span>
00139 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_UNTIL                64</span>
00140 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_TIMED                65</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#define RWL_UNLOCK                      66</span>
00142 <span class="preprocessor"></span><span class="preprocessor">#define SPL_INIT                        67</span>
00143 <span class="preprocessor"></span><span class="preprocessor">#define SPL_DELETE                      68</span>
00144 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SPL_INIT                  69</span>
00145 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SPL_DELETE                70</span>
00146 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK                        71      </span>
00147 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK_IF                     72</span>
00148 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK_TIMED                  73</span>
00149 <span class="preprocessor"></span><span class="preprocessor">#define SPL_UNLOCK                      74</span>
00150 <span class="preprocessor"></span>
00151 <span class="comment">// mail boxes</span>
00152 <span class="preprocessor">#define TYPED_MBX_INIT                  75</span>
00153 <span class="preprocessor"></span><span class="preprocessor">#define MBX_DELETE                      76</span>
00154 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MBX_INIT                  77</span>
00155 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MBX_DELETE                78</span>
00156 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND                        79</span>
00157 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_WP                     80</span>
00158 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_IF                     81</span>
00159 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_UNTIL                  82</span>
00160 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_TIMED                  83</span>
00161 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE                     84</span>
00162 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_WP                  85</span>
00163 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_IF                  86</span>
00164 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_UNTIL               87</span>
00165 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_TIMED               88</span>
00166 <span class="preprocessor"></span><span class="preprocessor">#define MBX_EVDRP                       89</span>
00167 <span class="preprocessor"></span><span class="preprocessor">#define MBX_OVRWR_SEND                  90</span>
00168 <span class="preprocessor"></span>
00169 <span class="comment">// short intertask messages</span>
00170 <span class="preprocessor">#define SENDMSG                         91</span>
00171 <span class="preprocessor"></span><span class="preprocessor">#define SEND_IF                         92</span>
00172 <span class="preprocessor"></span><span class="preprocessor">#define SEND_UNTIL                      93</span>
00173 <span class="preprocessor"></span><span class="preprocessor">#define SEND_TIMED                      94</span>
00174 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEMSG                      95</span>
00175 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_IF                      96</span>
00176 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_UNTIL                   97</span>
00177 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_TIMED                   98</span>
00178 <span class="preprocessor"></span><span class="preprocessor">#define RPCMSG                          99</span>
00179 <span class="preprocessor"></span><span class="preprocessor">#define RPC_IF                         100</span>
00180 <span class="preprocessor"></span><span class="preprocessor">#define RPC_UNTIL                      101</span>
00181 <span class="preprocessor"></span><span class="preprocessor">#define RPC_TIMED                      102</span>
00182 <span class="preprocessor"></span><span class="preprocessor">#define EVDRP                          103</span>
00183 <span class="preprocessor"></span><span class="preprocessor">#define ISRPC                          104</span>
00184 <span class="preprocessor"></span><span class="preprocessor">#define RETURNMSG                      105</span>
00185 <span class="preprocessor"></span>
00186 <span class="comment">// extended intertask messages</span>
00187 <span class="preprocessor">#define RPCX                           106</span>
00188 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_IF                        107</span>
00189 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_UNTIL                     108</span>
00190 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_TIMED                     109</span>
00191 <span class="preprocessor"></span><span class="preprocessor">#define SENDX                          110</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_IF                       111</span>
00193 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_UNTIL                    112</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_TIMED                    113</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#define RETURNX                        114</span>
00196 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX                       115</span>
00197 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_IF                    116</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_UNTIL                 117</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_TIMED                 118</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#define EVDRPX                         119</span>
00201 <span class="preprocessor"></span>
00202 <span class="comment">// proxies</span>
00203 <span class="preprocessor">#define PROXY_ATTACH                   120</span>
00204 <span class="preprocessor"></span><span class="preprocessor">#define PROXY_DETACH                   121</span>
00205 <span class="preprocessor"></span><span class="preprocessor">#define PROXY_TRIGGER                  122</span>
00206 <span class="preprocessor"></span>
00207 
00208 <span class="comment">// synchronous user space specific intertask messages and related proxies</span>
00209 <span class="preprocessor">#define RT_SEND                        123</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#define RT_RECEIVE                     124</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#define RT_CRECEIVE                    125</span>
00212 <span class="preprocessor"></span><span class="preprocessor">#define RT_REPLY                       126</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#define RT_PROXY_ATTACH                127</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#define RT_PROXY_DETACH                128</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#define RT_TRIGGER                     129</span>
00216 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_ATTACH                 130</span>
00217 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_DETACH                 131</span>
00218 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_LOCATE                 132</span>
00219 <span class="preprocessor"></span>
00220 <span class="comment">// bits</span>
00221 <span class="preprocessor">#define BITS_INIT                      133      </span>
00222 <span class="preprocessor"></span><span class="preprocessor">#define BITS_DELETE                    134</span>
00223 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_BITS_INIT                135</span>
00224 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_BITS_DELETE              136</span>
00225 <span class="preprocessor"></span><span class="preprocessor">#define BITS_GET                       137</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#define BITS_RESET                     138</span>
00227 <span class="preprocessor"></span><span class="preprocessor">#define BITS_SIGNAL                    139</span>
00228 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT                      140</span>
00229 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_IF                   141              </span>
00230 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_UNTIL                142</span>
00231 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_TIMED                143</span>
00232 <span class="preprocessor"></span>
00233 <span class="comment">// typed mail boxes</span>
00234 <span class="preprocessor">#define TBX_INIT                       144</span>
00235 <span class="preprocessor"></span><span class="preprocessor">#define TBX_DELETE                     145</span>
00236 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TBX_INIT                 146</span>
00237 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TBX_DELETE               147</span>
00238 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND                       148</span>
00239 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_IF                    149</span>
00240 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_UNTIL                 150</span>
00241 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_TIMED                 151</span>
00242 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE                    152</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_IF                 153</span>
00244 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_UNTIL              154</span>
00245 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_TIMED              155</span>
00246 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST                  156</span>
00247 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_IF               157</span>
00248 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_UNTIL            158</span>
00249 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_TIMED            159</span>
00250 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT                     160</span>
00251 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_IF                  161</span>
00252 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_UNTIL               162</span>
00253 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_TIMED               163</span>
00254 <span class="preprocessor"></span>
00255 <span class="comment">// pqueue</span>
00256 <span class="preprocessor">#define MQ_OPEN                        164</span>
00257 <span class="preprocessor"></span><span class="preprocessor">#define MQ_RECEIVE                     165</span>
00258 <span class="preprocessor"></span><span class="preprocessor">#define MQ_SEND                        166</span>
00259 <span class="preprocessor"></span><span class="preprocessor">#define MQ_CLOSE                       167</span>
00260 <span class="preprocessor"></span><span class="preprocessor">#define MQ_GETATTR                     168</span>
00261 <span class="preprocessor"></span><span class="preprocessor">#define MQ_SETATTR                     169</span>
00262 <span class="preprocessor"></span><span class="preprocessor">#define MQ_NOTIFY                      170</span>
00263 <span class="preprocessor"></span><span class="preprocessor">#define MQ_UNLINK                      171</span>
00264 <span class="preprocessor"></span><span class="preprocessor">#define MQ_TIMEDRECEIVE                172</span>
00265 <span class="preprocessor"></span><span class="preprocessor">#define MQ_TIMEDSEND                   173</span>
00266 <span class="preprocessor"></span>
00267 <span class="comment">// named tasks init/delete</span>
00268 <span class="preprocessor">#define NAMED_TASK_INIT                174</span>
00269 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TASK_INIT_CPUID          175</span>
00270 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TASK_DELETE              176</span>
00271 <span class="preprocessor"></span>
00272 <span class="comment">// registry</span>
00273 <span class="preprocessor">#define GET_ADR                        177</span>
00274 <span class="preprocessor"></span><span class="preprocessor">#define GET_NAME                       178</span>
00275 <span class="preprocessor"></span>
00276 <span class="comment">// netrpc</span>
00277 <span class="preprocessor">#define NETRPC                         179</span>
00278 <span class="preprocessor"></span><span class="preprocessor">#define SEND_REQ_REL_PORT              180</span>
00279 <span class="preprocessor"></span><span class="preprocessor">#define DDN2NL                         181</span>
00280 <span class="preprocessor"></span><span class="preprocessor">#define SET_THIS_NODE                  182</span>
00281 <span class="preprocessor"></span><span class="preprocessor">#define FIND_ASGN_STUB                 183</span>
00282 <span class="preprocessor"></span><span class="preprocessor">#define REL_STUB                       184      </span>
00283 <span class="preprocessor"></span><span class="preprocessor">#define WAITING_RETURN                 185</span>
00284 <span class="preprocessor"></span>
00285 <span class="comment">// a semaphore extension</span>
00286 <span class="preprocessor">#define COND_SIGNAL                    186</span>
00287 <span class="preprocessor"></span>
00288 <span class="comment">// new shm</span>
00289 <span class="preprocessor">#define SHM_ALLOC                      187</span>
00290 <span class="preprocessor"></span><span class="preprocessor">#define SHM_FREE                       188</span>
00291 <span class="preprocessor"></span><span class="preprocessor">#define SHM_SIZE                       189</span>
00292 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_SET                       190</span>
00293 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_ALLOC                     191</span>
00294 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_FREE                      192</span>
00295 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_NAMED_ALLOC               193</span>
00296 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_NAMED_FREE                194</span>
00297 <span class="preprocessor"></span><span class="preprocessor">#define MALLOC                         195</span>
00298 <span class="preprocessor"></span><span class="preprocessor">#define FREE                           196</span>
00299 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MALLOC                   197</span>
00300 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_FREE                     198</span>
00301 <span class="preprocessor"></span>
00302 <span class="preprocessor">#define MAX_LXRT_FUN                   200</span>
00303 <span class="preprocessor"></span>
00304 <span class="comment">// not recovered yet </span>
00305 <span class="comment">// Qblk's </span>
00306 <span class="preprocessor">#define RT_INITTICKQUEUE                69</span>
00307 <span class="preprocessor"></span><span class="preprocessor">#define RT_RELEASETICKQUEUE             70</span>
00308 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNALLOC                    71</span>
00309 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNFREE                     72</span>
00310 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNINIT                     73</span>
00311 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKWAIT                     74</span>
00312 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKREPEAT                   75</span>
00313 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKSOON                     76</span>
00314 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKDEQUEUE                  77</span>
00315 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKCANCEL                   78</span>
00316 <span class="preprocessor"></span><span class="preprocessor">#define RT_QSYNC                        79</span>
00317 <span class="preprocessor"></span><span class="preprocessor">#define RT_QRECEIVE                     80</span>
00318 <span class="preprocessor"></span><span class="preprocessor">#define RT_QLOOP                        81</span>
00319 <span class="preprocessor"></span><span class="preprocessor">#define RT_QSTEP                        82</span>
00320 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKBEFORE                   83</span>
00321 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKAFTER                    84</span>
00322 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKUNHOOK                   85</span>
00323 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKRELEASE                  86</span>
00324 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKCOMPLETE                 87</span>
00325 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKFLUSH                   88</span>
00326 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKATHEAD                   89</span>
00327 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKATTAIL                   90</span>
00328 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKINIT                    91</span>
00329 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKRELEASE                 92</span>
00330 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKSCHEDULE                 93</span>
00331 <span class="preprocessor"></span><span class="preprocessor">#define RT_GETTICKQUEUEHOOK             94</span>
00332 <span class="preprocessor"></span><span class="comment">// Testing</span>
00333 <span class="preprocessor">#define RT_BOOM                         95</span>
00334 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_MALLOC                     96</span>
00335 <span class="preprocessor"></span><span class="preprocessor">#define RT_FREE                         97</span>
00336 <span class="preprocessor"></span><span class="preprocessor">#define RT_MMGR_STATS                   98</span>
00337 <span class="preprocessor"></span><span class="preprocessor">#define RT_STOMP                        99</span>
00338 <span class="preprocessor"></span><span class="comment">// VC</span>
00339 <span class="preprocessor">#define RT_VC_ATTACH                    100</span>
00340 <span class="preprocessor"></span><span class="preprocessor">#define RT_VC_RELEASE                   101</span>
00341 <span class="preprocessor"></span><span class="preprocessor">#define RT_VC_RESERVE                   102</span>
00342 <span class="preprocessor"></span><span class="comment">// Linux Signal Support</span>
00343 <span class="preprocessor">#define RT_GET_LINUX_SIGNAL             103</span>
00344 <span class="preprocessor"></span><span class="preprocessor">#define RT_GET_ERRNO                    104</span>
00345 <span class="preprocessor"></span><span class="preprocessor">#define RT_SET_LINUX_SIGNAL_HANDLER     105</span>
00346 <span class="preprocessor"></span><span class="comment">// end of not recovered yet</span>
00347 
00348 <span class="preprocessor">#define LXRT_GET_ADR            1000</span>
00349 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_GET_NAME           1001</span>
00350 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_TASK_INIT          1002</span>
00351 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_TASK_DELETE        1003</span>
00352 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SEM_INIT           1004</span>
00353 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SEM_DELETE         1005</span>
00354 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_MBX_INIT           1006</span>
00355 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_MBX_DELETE         1007</span>
00356 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_SOFT_RT            1008</span>
00357 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_HARD_RT            1009</span>
00358 <span class="preprocessor"></span><span class="preprocessor">#define PRINT_TO_SCREEN         1010</span>
00359 <span class="preprocessor"></span><span class="preprocessor">#define NONROOT_HRT             1011</span>
00360 <span class="preprocessor"></span><span class="preprocessor">#define RT_BUDDY                1012</span>
00361 <span class="preprocessor"></span><span class="preprocessor">#define HRT_USE_FPU             1013</span>
00362 <span class="preprocessor"></span><span class="preprocessor">#define USP_SIGHDL              1014</span>
00363 <span class="preprocessor"></span><span class="preprocessor">#define GET_USP_FLAGS           1015</span>
00364 <span class="preprocessor"></span><span class="preprocessor">#define SET_USP_FLAGS           1016</span>
00365 <span class="preprocessor"></span><span class="preprocessor">#define GET_USP_FLG_MSK         1017</span>
00366 <span class="preprocessor"></span><span class="preprocessor">#define SET_USP_FLG_MSK         1018</span>
00367 <span class="preprocessor"></span><span class="preprocessor">#define IS_HARD                 1019</span>
00368 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_FORK               1020</span>
00369 <span class="preprocessor"></span><span class="preprocessor">#define ALLOC_REGISTER          1021</span>
00370 <span class="preprocessor"></span><span class="preprocessor">#define DELETE_DEREGISTER       1022</span>
00371 <span class="preprocessor"></span><span class="preprocessor">#define FORCE_TASK_SOFT         1023</span>
00372 <span class="preprocessor"></span><span class="preprocessor">#define PRINTK                  1024</span>
00373 <span class="preprocessor"></span><span class="preprocessor">#define GET_EXECTIME            1025</span>
00374 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIMEORIG            1026</span>
00375 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_RWL_INIT           1027</span>
00376 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_RWL_DELETE         1028</span>
00377 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SPL_INIT           1029</span>
00378 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SPL_DELETE         1030</span>
00379 <span class="preprocessor"></span>
00380 <span class="preprocessor">#define FORCE_SOFT 0x80000000</span>
00381 <span class="preprocessor"></span>
00382 <span class="preprocessor">#ifdef __KERNEL__</span>
00383 <span class="preprocessor"></span>
00384 <span class="preprocessor">#include &lt;asm/rtai_lxrt.h&gt;</span>
00385 
00386 <span class="comment">/*</span>
00387 <span class="comment">     Encoding of system call argument</span>
00388 <span class="comment">            31                                    0  </span>
00389 <span class="comment">soft SRQ    .... |||| |||| |||| .... .... .... ....  0 - 4095 max</span>
00390 <span class="comment">int  NARG   .... .... .... .... |||| |||| |||| ||||  </span>
00391 <span class="comment">arg  INDX   |||| .... .... .... .... .... .... ....</span>
00392 <span class="comment">*/</span>
00393 
00394 <span class="comment">/*</span>
00395 <span class="comment">These USP (unsigned long long) type fields allow to read and write up to 2 arguments.  </span>
00396 <span class="comment">                                               </span>
00397 <span class="comment">RW marker .... .... .... .... .... .... .... ..|| .... .... .... .... .... .... .... ...|</span>
00398 <span class="comment"></span>
00399 <span class="comment">HIGH unsigned long encodes writes</span>
00400 <span class="comment">W ARG1 BF .... .... .... .... .... ...| |||| ||..</span>
00401 <span class="comment">W ARG1 SZ .... .... .... .... |||| |||. .... ....</span>
00402 <span class="comment">W ARG2 BF .... .... .||| |||| .... .... .... ....</span>
00403 <span class="comment">W ARG2 SZ ..|| |||| |... .... .... .... .... ....</span>
00404 <span class="comment">W 1st  LL .|.. .... .... .... .... .... .... ....</span>
00405 <span class="comment">W 2nd  LL |... .... .... .... .... .... .... ....</span>
00406 <span class="comment"></span>
00407 <span class="comment">LOW unsigned long encodes reads</span>
00408 <span class="comment">R ARG1 BF .... .... .... .... .... ...| |||| ||..</span>
00409 <span class="comment">R ARG1 SZ .... .... .... .... |||| |||. .... ....</span>
00410 <span class="comment">R ARG2 BF .... .... .||| |||| .... .... .... ....</span>
00411 <span class="comment">R ARG2 SZ ..|| |||| |... .... .... .... .... ....</span>
00412 <span class="comment">R 1st  LL .|.. .... .... .... .... .... .... ....</span>
00413 <span class="comment">R 2nd  LL |... .... .... .... .... .... .... ....</span>
00414 <span class="comment"></span>
00415 <span class="comment">LOW unsigned long encodes also</span>
00416 <span class="comment">RT Switch .... .... .... .... .... .... .... ...|</span>
00417 <span class="comment"></span>
00418 <span class="comment">and </span>
00419 <span class="comment">Always 0  .... .... .... .... .... .... .... ..|.</span>
00420 <span class="comment"></span>
00421 <span class="comment">If SZ is zero sizeof(int) is copied by default, if LL bit is set sizeof(long long) is copied.</span>
00422 <span class="comment">*/</span>
00423 
00424 <span class="comment">// These are for setting appropriate bits in any function entry structure, OR</span>
00425 <span class="comment">// them in fun entry type to obtain the desired encoding</span>
00426 
00427 <span class="comment">// for writes</span>
00428 <span class="preprocessor">#define UW1(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9))) &lt;&lt; 32) | 0x300000001LL)</span>
00429 <span class="preprocessor"></span><span class="preprocessor">#define UW2(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23))) &lt;&lt; 32) | 0x300000001LL)</span>
00430 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ1LL      (0x4000000300000001LL)</span>
00431 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ2LL      (0x8000000300000001LL)</span>
00432 <span class="preprocessor"></span>
00433 <span class="comment">// for reads</span>
00434 <span class="preprocessor">#define UR1(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9) | 0x300000001LL)</span>
00435 <span class="preprocessor"></span><span class="preprocessor">#define UR2(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23) | 0x300000001LL)</span>
00436 <span class="preprocessor"></span><span class="preprocessor">#define URSZ1LL      (0x340000001LL)</span>
00437 <span class="preprocessor"></span><span class="preprocessor">#define URSZ2LL      (0x380000001LL)</span>
00438 <span class="preprocessor"></span>
00439 <span class="comment">// and these are for deciding what to do in lxrt.c</span>
00440 <span class="preprocessor">#define NEED_TO_RW(x)   (((unsigned long *)&amp;(x))[HIGH])</span>
00441 <span class="preprocessor"></span>
00442 <span class="preprocessor">#define NEED_TO_R(x)    (((unsigned long *)&amp;(x))[LOW]  &amp; 0x0000FFFC)</span>
00443 <span class="preprocessor"></span><span class="preprocessor">#define NEED_TO_W(x)    (((unsigned long *)&amp;(x))[HIGH] &amp; 0x0000FFFC)</span>
00444 <span class="preprocessor"></span>
00445 <span class="preprocessor">#define NEED_TO_R2ND(x) (((unsigned long *)&amp;(x))[LOW]  &amp; 0x3FFF0000)</span>
00446 <span class="preprocessor"></span><span class="preprocessor">#define NEED_TO_W2ND(x) (((unsigned long *)&amp;(x))[HIGH] &amp; 0x3FFF0000)</span>
00447 <span class="preprocessor"></span>
00448 <span class="preprocessor">#define USP_RBF1(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt;  2) &amp; 0x7F)</span>
00449 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ1(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt;  9) &amp; 0x7F)</span>
00450 <span class="preprocessor"></span><span class="preprocessor">#define USP_RBF2(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt; 16) &amp; 0x7F)</span>
00451 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ2(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt; 23) &amp; 0x7F)</span>
00452 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ1LL(x)   (((unsigned long *)&amp;(x))[LOW] &amp; 0x40000000)</span>
00453 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ2LL(x)   (((unsigned long *)&amp;(x))[LOW] &amp; 0x80000000)</span>
00454 <span class="preprocessor"></span>
00455 <span class="preprocessor">#define USP_WBF1(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt;  2) &amp; 0x7F)</span>
00456 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ1(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt;  9) &amp; 0x7F)</span>
00457 <span class="preprocessor"></span><span class="preprocessor">#define USP_WBF2(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt; 16) &amp; 0x7F)</span>
00458 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ2(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt; 23) &amp; 0x7F)</span>
00459 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ1LL(x)   (((unsigned long *)&amp;(x))[HIGH] &amp; 0x40000000)</span>
00460 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ2LL(x)   (((unsigned long *)&amp;(x))[HIGH] &amp; 0x80000000)</span>
00461 <span class="preprocessor"></span>
00462 <span class="preprocessor">#define SRQ(x)   (((x) &gt;&gt; 16) &amp; 0xFFF)</span>
00463 <span class="preprocessor"></span><span class="preprocessor">#define NARG(x)  ((x) &amp; 0xFFFF)</span>
00464 <span class="preprocessor"></span><span class="preprocessor">#define INDX(x)  (((x) &gt;&gt; 28) &amp; 0xF)</span>
00465 <span class="preprocessor"></span>
00466 <span class="keyword">struct </span>rt_fun_entry {
00467     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> type;
00468     <span class="keywordtype">void</span> *fun;
00469 };
00470 
00471 <span class="keyword">struct </span>rt_native_fun_entry {
00472     <span class="keyword">struct </span>rt_fun_entry fun;
00473     <span class="keywordtype">int</span> index;
00474 };
00475 
00476 <span class="keyword">extern</span> <span class="keyword">struct </span>rt_fun_entry rt_fun_lxrt[];
00477 
00478 <span class="keywordtype">void</span> reset_rt_fun_entries(<span class="keyword">struct</span> rt_native_fun_entry *entry);
00479 
00480 <span class="keywordtype">int</span> set_rt_fun_entries(<span class="keyword">struct</span> rt_native_fun_entry *entry);
00481 
00482 <span class="preprocessor">#ifdef __cplusplus</span>
00483 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00484 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00485 
00486 <span class="preprocessor">#if CONFIG_RTAI_INTERNAL_LXRT_SUPPORT</span>
00487 <span class="preprocessor"></span> 
00488 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>rt_task_struct *pid2rttask(pid_t pid)
00489 {
00490         <span class="keywordflow">return</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)pid) &gt; PID_MAX_LIMIT ? (<span class="keyword">struct </span>rt_task_struct *)pid : find_task_by_pid(pid)-&gt;this_rt_task[0];
00491 }
00492 
00493 <span class="keyword">static</span> <span class="keyword">inline</span> pid_t rttask2pid(<span class="keyword">struct</span> rt_task_struct * task)
00494 {
00495     <span class="keywordflow">return</span> task-&gt;lnxtsk ? task-&gt;lnxtsk-&gt;pid : (<span class="keywordtype">int</span>) task;
00496 }
00497 
00498 <span class="preprocessor">#else </span><span class="comment">/* !CONFIG_RTAI_INTERNAL_LXRT_SUPPORT */</span>
00499 
00500 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>rt_task_struct *pid2rttask(pid_t pid)
00501 {
00502     <span class="keywordflow">return</span> 0;
00503 }
00504 
00505 <span class="comment">// The following might look strange but it must be so to work with</span>
00506 <span class="comment">// buddies also.</span>
00507 <span class="keyword">static</span> <span class="keyword">inline</span> pid_t rttask2pid(<span class="keyword">struct</span> rt_task_struct * task)
00508 {
00509     <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) task;
00510 }
00511 
00512 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_INTERNAL_LXRT_SUPPORT */</span>
00513 
00514 <span class="keywordtype">int</span> set_rtai_callback(<span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span>));
00515 
00516 <span class="keywordtype">void</span> remove_rtai_callback(<span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span>));
00517 
00518 RT_TASK *rt_lxrt_whoami(<span class="keywordtype">void</span>);
00519 
00520 <span class="keywordtype">void</span> exec_func(<span class="keywordtype">void</span> (*func)(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> evn),
00521                <span class="keywordtype">void</span> *data,
00522                <span class="keywordtype">int</span> evn);
00523 
00524 <span class="keywordtype">int</span>  set_rt_fun_ext_index(<span class="keyword">struct</span> rt_fun_entry *fun,
00525                           <span class="keywordtype">int</span> idx);
00526 
00527 <span class="keywordtype">void</span> reset_rt_fun_ext_index(<span class="keyword">struct</span> rt_fun_entry *fun,
00528                             <span class="keywordtype">int</span> idx);
00529 
00530 <span class="preprocessor">#ifdef __cplusplus</span>
00531 <span class="preprocessor"></span>}
00532 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00533 
00534 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00535 
00536 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00537 <span class="preprocessor">#include &lt;sched.h&gt;</span>
00538 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00539 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00540 <span class="preprocessor">#include &lt;string.h&gt;</span>
00541 <span class="preprocessor">#include &lt;asm/rtai_lxrt.h&gt;</span>
00542 
00543 <span class="keyword">struct </span>apic_timer_setup_data;
00544 
00545 <span class="preprocessor">#define rt_grow_and_lock_stack(incr) \</span>
00546 <span class="preprocessor">        do { \</span>
00547 <span class="preprocessor">                char buf[incr]; \</span>
00548 <span class="preprocessor">                memset(buf, 0, incr); \</span>
00549 <span class="preprocessor">                mlockall(MCL_CURRENT | MCL_FUTURE); \</span>
00550 <span class="preprocessor">        } while (0)</span>
00551 <span class="preprocessor"></span>
00552 <span class="preprocessor">#define BIDX   0 // rt_fun_ext[0]</span>
00553 <span class="preprocessor"></span><span class="preprocessor">#define SIZARG sizeof(arg)</span>
00554 <span class="preprocessor"></span>
00555 <span class="preprocessor">#ifdef __cplusplus</span>
00556 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00557 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00558 
<a name="l00566"></a><a class="code" href="group__lxrt.html#a0">00566</a> RTAI_PROTO(<span class="keywordtype">void</span> *,rt_get_adr,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name))
00567 {
00568         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name; } arg = { name };
00569         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_GET_ADR, &amp;arg).v[LOW];
00570 } 
00571 
<a name="l00580"></a><a class="code" href="group__lxrt.html#a1">00580</a> RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_name,(<span class="keywordtype">void</span> *adr))
00581 {
00582         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *adr; } arg = { adr };
00583         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_GET_NAME, &amp;arg).i[LOW];
00584 }
00585 
00586 RTAI_PROTO(RT_TASK *,rt_task_init_schmod,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> max_msg_size, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> cpus_allowed))
00587 {
00588         <span class="keyword">struct </span>sched_param mysched;
00589         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, priority, stack_size, max_msg_size, cpus_allowed; } arg = { name, priority, stack_size, max_msg_size, cpus_allowed };
00590 
00591         mysched.sched_priority = sched_get_priority_max(policy) - priority;
00592         <span class="keywordflow">if</span> (mysched.sched_priority &lt; 1 ) {
00593                 mysched.sched_priority = 1;
00594         }
00595         <span class="keywordflow">if</span> (sched_setscheduler(0, policy, &amp;mysched) &lt; 0) {
00596                 <span class="keywordflow">return</span> 0;
00597         }
00598 
00599         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, LXRT_TASK_INIT, &amp;arg).v[LOW];
00600 }
00601 
00602 
<a name="l00656"></a><a class="code" href="group__lxrt.html#a3">00656</a> RTAI_PROTO(RT_TASK *,rt_task_init,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> max_msg_size))
00657 {
00658         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, priority, stack_size, max_msg_size, cpus_allowed; } arg = { name, priority, stack_size, max_msg_size, 0xFF };
00659         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, LXRT_TASK_INIT, &amp;arg).v[LOW];
00660 }
00661 
00662 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_sched_policy,(RT_TASK *task, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> rr_quantum_ns))
00663 {
00664         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> policy; <span class="keywordtype">int</span> rr_quantum_ns; } arg = { task, policy, rr_quantum_ns };
00665         rtai_lxrt(BIDX, SIZARG, SET_SCHED_POLICY, &amp;arg);
00666 }
00667 
<a name="l00668"></a><a class="code" href="group__lxrt.html#a5">00668</a> RTAI_PROTO(<span class="keywordtype">int</span>,rt_change_prio,(RT_TASK *task, <span class="keywordtype">int</span> priority))
00669 {
00670         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> priority; } arg = { task, priority };
00671         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, CHANGE_TASK_PRIO, &amp;arg).i[LOW];
00672 }
00673 
<a name="l00686"></a><a class="code" href="group__lxrt.html#a6">00686</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_make_soft_real_time,(<span class="keywordtype">void</span>))
00687 {
00688         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00689         rtai_lxrt(BIDX, SIZARG, MAKE_SOFT_RT, &amp;arg);
00690 }
00691 
<a name="l00692"></a><a class="code" href="group__lxrt.html#a7">00692</a> RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_delete,(RT_TASK *task))
00693 {
00694         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00695         <a class="code" href="group__lxrt.html#a6">rt_make_soft_real_time</a>();
00696         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_TASK_DELETE, &amp;arg).i[LOW];
00697 }
00698 
<a name="l00699"></a><a class="code" href="group__lxrt.html#a8">00699</a> RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_yield,(<span class="keywordtype">void</span>))
00700 {
00701         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00702         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, YIELD, &amp;arg).i[LOW];
00703 }
00704 
<a name="l00705"></a><a class="code" href="group__lxrt.html#a9">00705</a> RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_suspend,(RT_TASK *task))
00706 {
00707         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00708         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SUSPEND, &amp;arg).i[LOW];
00709 }
00710 
<a name="l00711"></a><a class="code" href="group__lxrt.html#a10">00711</a> RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_resume,(RT_TASK *task))
00712 {
00713         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00714         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RESUME, &amp;arg).i[LOW];
00715 }
00716 
<a name="l00717"></a><a class="code" href="group__lxrt.html#a11">00717</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_task_make_periodic,(RT_TASK *task, RTIME start_time, RTIME period))
00718 {
00719         <span class="keyword">struct </span>{ RT_TASK *task; RTIME start_time, period; } arg = { task, start_time, period };
00720         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MAKE_PERIODIC, &amp;arg).i[LOW];
00721 }
00722 
<a name="l00723"></a><a class="code" href="group__lxrt.html#a12">00723</a> RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_make_periodic_relative_ns,(RT_TASK *task, RTIME start_delay, RTIME period))
00724 {
00725         <span class="keyword">struct </span>{ RT_TASK *task; RTIME start_time, period; } arg = { task, start_delay, period };
00726         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MAKE_PERIODIC_NS, &amp;arg).i[LOW];
00727 }
00728 
<a name="l00729"></a><a class="code" href="group__lxrt.html#a13">00729</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_task_wait_period,(<span class="keywordtype">void</span>))
00730 {
00731         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00732         rtai_lxrt(BIDX, SIZARG, WAIT_PERIOD, &amp;arg);
00733 }
00734 
<a name="l00735"></a><a class="code" href="group__lxrt.html#a14">00735</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_sleep,(RTIME delay))
00736 {
00737         <span class="keyword">struct </span>{ RTIME delay; } arg = { delay };
00738         rtai_lxrt(BIDX, SIZARG, SLEEP, &amp;arg);
00739 }
00740 
<a name="l00741"></a><a class="code" href="group__lxrt.html#a15">00741</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_sleep_until,(RTIME time))
00742 {
00743         <span class="keyword">struct </span>{ RTIME time; } arg = { time };
00744         rtai_lxrt(BIDX, SIZARG, SLEEP_UNTIL, &amp;arg);
00745 }
00746 
00747 RTAI_PROTO(<span class="keywordtype">int</span>,rt_is_hard_timer_running,(<span class="keywordtype">void</span>))
00748 {
00749         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00750         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, HARD_TIMER_RUNNING, &amp;arg).i[LOW];
00751 }
00752 
<a name="l00753"></a><a class="code" href="group__lxrt.html#a17">00753</a> RTAI_PROTO(RTIME, start_rt_timer,(<span class="keywordtype">int</span> period))
00754 {
00755         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> period; } arg = { period };
00756         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, START_TIMER, &amp;arg).rt;
00757 }
00758 
<a name="l00759"></a><a class="code" href="group__lxrt.html#a18">00759</a> RTAI_PROTO(<span class="keywordtype">void</span>, stop_rt_timer,(<span class="keywordtype">void</span>))
00760 {
00761         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00762         rtai_lxrt(BIDX, SIZARG, STOP_TIMER, &amp;arg);
00763 }
00764 
<a name="l00765"></a><a class="code" href="group__lxrt.html#a19">00765</a> RTAI_PROTO(RTIME,rt_get_time,(<span class="keywordtype">void</span>))
00766 {
00767         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00768         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME, &amp;arg).rt;
00769 }
00770 
<a name="l00771"></a><a class="code" href="group__lxrt.html#a20">00771</a> RTAI_PROTO(RTIME,count2nano,(RTIME count))
00772 {
00773         <span class="keyword">struct </span>{ RTIME count; } arg = { count };
00774         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COUNT2NANO, &amp;arg).rt;
00775 }
00776 
<a name="l00777"></a><a class="code" href="group__lxrt.html#a21">00777</a> RTAI_PROTO(RTIME,nano2count,(RTIME nanos))
00778 {
00779         <span class="keyword">struct </span>{ RTIME nanos; } arg = { nanos };
00780         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NANO2COUNT, &amp;arg).rt;
00781 }
00782 
<a name="l00783"></a><a class="code" href="group__lxrt.html#a22">00783</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_busy_sleep,(<span class="keywordtype">int</span> ns))
00784 {
00785         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> ns; } arg = { ns };
00786         rtai_lxrt(BIDX, SIZARG, BUSY_SLEEP, &amp;arg);
00787 }
00788 
<a name="l00789"></a><a class="code" href="group__lxrt.html#a23">00789</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_periodic_mode,(<span class="keywordtype">void</span>))
00790 {
00791         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00792         rtai_lxrt(BIDX, SIZARG, SET_PERIODIC_MODE, &amp;arg);
00793 }
00794 
<a name="l00795"></a><a class="code" href="group__lxrt.html#a24">00795</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_oneshot_mode,(<span class="keywordtype">void</span>))
00796 {
00797         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00798         rtai_lxrt(BIDX, SIZARG, SET_ONESHOT_MODE, &amp;arg);
00799 }
00800 
<a name="l00801"></a><a class="code" href="group__lxrt.html#a25">00801</a> RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_signal_handler,(RT_TASK *task, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>)))
00802 {
00803         <span class="keyword">struct </span>{ RT_TASK *task; void (*handler)(<span class="keywordtype">void</span>); } arg = { task, handler };
00804         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SIGNAL_HANDLER, &amp;arg).i[LOW];
00805 }
00806 
<a name="l00807"></a><a class="code" href="group__lxrt.html#a26">00807</a> RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_use_fpu,(RT_TASK *task, <span class="keywordtype">int</span> use_fpu_flag))
00808 {
00809         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> use_fpu_flag; } arg = { task, use_fpu_flag };
00810         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, RT_BUDDY, &amp;arg).v[LOW] != task) {
00811                 <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, TASK_USE_FPU, &amp;arg).i[LOW];
00812         } <span class="keywordflow">else</span> {
00813 <span class="comment">// note that it would be enough to do whatever FP op here to have it OK. But</span>
00814 <span class="comment">// that is scary if it is done when already in hard real time, and we do not</span>
00815 <span class="comment">// want to force users to call this before making it hard.</span>
00816                 rtai_lxrt(BIDX, SIZARG, HRT_USE_FPU, &amp;arg);
00817                 <span class="keywordflow">return</span> 0;
00818         }
00819 }
00820 
00821 RTAI_PROTO(<span class="keywordtype">int</span>,rt_buddy_task_use_fpu,(RT_TASK *task, <span class="keywordtype">int</span> use_fpu_flag))
00822 {
00823         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> use_fpu_flag; } arg = { task, use_fpu_flag };
00824         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, TASK_USE_FPU, &amp;arg).i[LOW];
00825 }
00826 
<a name="l00827"></a><a class="code" href="group__lxrt.html#a28">00827</a> RTAI_PROTO(<span class="keywordtype">int</span>,rt_linux_use_fpu,(<span class="keywordtype">int</span> use_fpu_flag))
00828 {
00829         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> use_fpu_flag; } arg = { use_fpu_flag };
00830         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LINUX_USE_FPU, &amp;arg).i[LOW];
00831 }
00832 
<a name="l00833"></a><a class="code" href="group__lxrt.html#a29">00833</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_preempt_always,(<span class="keywordtype">int</span> yes_no))
00834 {
00835         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> yes_no; } arg = { yes_no };
00836         rtai_lxrt(BIDX, SIZARG, PREEMPT_ALWAYS_GEN, &amp;arg);
00837 }
00838 
<a name="l00839"></a><a class="code" href="group__lxrt.html#a30">00839</a> RTAI_PROTO(RTIME,rt_get_time_ns,(<span class="keywordtype">void</span>))
00840 {
00841         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00842         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_NS, &amp;arg).rt;
00843 }
00844 
<a name="l00845"></a><a class="code" href="group__lxrt.html#a31">00845</a> RTAI_PROTO(RTIME,rt_get_cpu_time_ns,(<span class="keywordtype">void</span>))
00846 {
00847         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00848         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_CPU_TIME_NS, &amp;arg).rt;
00849 }
00850 
00851 <span class="preprocessor">#define rt_named_task_init(task_name, thread, data, stack_size, prio, uses_fpu, signal) \</span>
00852 <span class="preprocessor">        rt_task_init(nam2num(task_name), thread, data, stack_size, prio, uses_fpu, signal)</span>
00853 <span class="preprocessor"></span>
00854 <span class="preprocessor">#define rt_named_task_init_cpuid(task_name, thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu) \</span>
00855 <span class="preprocessor">        rt_task_init_cpuid(nam2num(task_name), thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu)</span>
00856 <span class="preprocessor"></span>
<a name="l00857"></a><a class="code" href="group__lxrt.html#a32">00857</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_runnable_on_cpus,(RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cpu_mask))
00858 {
00859         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cpu_mask; } arg = { task, cpu_mask };
00860         rtai_lxrt(BIDX, SIZARG, SET_RUNNABLE_ON_CPUS, &amp;arg);
00861 }
00862 
<a name="l00863"></a><a class="code" href="group__lxrt.html#a33">00863</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_runnable_on_cpuid,(RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00864 {
00865         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { task, cpuid };
00866         rtai_lxrt(BIDX, SIZARG, SET_RUNNABLE_ON_CPUID, &amp;arg);
00867 }
00868 
00869 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_timer_cpu,(<span class="keywordtype">void</span>))
00870 {
00871         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00872         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIMER_CPU, &amp;arg).i[LOW];
00873 }
00874 
<a name="l00875"></a><a class="code" href="group__lxrt.html#a35">00875</a> RTAI_PROTO(<span class="keywordtype">void</span>,start_rt_apic_timers,(<span class="keyword">struct</span> apic_timer_setup_data *setup_mode, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rcvr_jiffies_cpuid))
00876 {
00877         <span class="keyword">struct </span>{ <span class="keyword">struct </span>apic_timer_setup_data *setup_mode; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rcvr_jiffies_cpuid; } arg = { setup_mode, rcvr_jiffies_cpuid };
00878         rtai_lxrt(BIDX, SIZARG, START_RT_APIC_TIMERS, &amp;arg);
00879 }
00880 
<a name="l00881"></a><a class="code" href="group__lxrt.html#a36">00881</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_preempt_always_cpuid,(<span class="keywordtype">int</span> yes_no, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00882 {
00883         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> yes_no; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { yes_no, cpuid };
00884         rtai_lxrt(BIDX, SIZARG, PREEMPT_ALWAYS_CPUID, &amp;arg);
00885 }
00886 
<a name="l00887"></a><a class="code" href="group__lxrt.html#a37">00887</a> RTAI_PROTO(RTIME,count2nano_cpuid,(RTIME count, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00888 {
00889         <span class="keyword">struct </span>{ RTIME count; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { count, cpuid };
00890         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COUNT2NANO_CPUID, &amp;arg).rt;
00891 }
00892 
<a name="l00893"></a><a class="code" href="group__lxrt.html#a38">00893</a> RTAI_PROTO(RTIME,nano2count_cpuid,(RTIME nanos, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00894 {
00895         <span class="keyword">struct </span>{ RTIME nanos; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { nanos, cpuid };
00896         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NANO2COUNT_CPUID, &amp;arg).rt;
00897 }
00898 
<a name="l00899"></a><a class="code" href="group__lxrt.html#a39">00899</a> RTAI_PROTO(RTIME,rt_get_time_cpuid,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00900 {
00901         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
00902         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_CPUID, &amp;arg).rt;
00903 }
00904 
<a name="l00905"></a><a class="code" href="group__lxrt.html#a40">00905</a> RTAI_PROTO(RTIME,rt_get_time_ns_cpuid,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00906 {
00907         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
00908         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_NS_CPUID, &amp;arg).rt;
00909 }
00910 
00911 RTAI_PROTO(<span class="keywordtype">void</span>,rt_boom,(<span class="keywordtype">void</span>))
00912 {
00913         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00914         rtai_lxrt(BIDX, SIZARG, RT_BOOM, &amp;arg);
00915 }
00916 
00917 RTAI_PROTO(<span class="keywordtype">void</span>,rt_mmgr_stats,(<span class="keywordtype">void</span>))
00918 {
00919         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00920         rtai_lxrt(BIDX, SIZARG, RT_MMGR_STATS, &amp;arg);
00921 }
00922 
00923 RTAI_PROTO(<span class="keywordtype">void</span>,rt_stomp,(<span class="keywordtype">void</span>) )
00924 {
00925         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00926         rtai_lxrt(BIDX, SIZARG, RT_STOMP, &amp;arg);
00927 }
00928 
00929 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_linux_signal,(RT_TASK *task))
00930 {
00931     <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00932     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_GET_LINUX_SIGNAL, &amp;arg).i[LOW];
00933 }
00934 
00935 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_errno,(RT_TASK *task))
00936 {
00937     <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00938     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_GET_ERRNO, &amp;arg).i[LOW];
00939 }
00940 
00941 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_linux_signal_handler,(RT_TASK *task, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">int</span> sig)))
00942 {
00943     <span class="keyword">struct </span>{ RT_TASK *task; void (*handler)(<span class="keywordtype">int</span> sig); } arg = { task, handler };
00944     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_SET_LINUX_SIGNAL_HANDLER, &amp;arg).i[LOW];
00945 }
00946 
00947 RTAI_PROTO(<span class="keywordtype">int</span>, rt_lxrt_fork,(<span class="keywordtype">int</span> is_a_clone))
00948 {
00949     <span class="keyword">struct </span>{ <span class="keywordtype">int</span> is_a_clone; } arg = { is_a_clone };
00950     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_FORK, &amp;arg).i[LOW];
00951 }
00952 
00953 RTAI_PROTO(<span class="keywordtype">int</span>,rtai_print_to_screen,(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...))
00954 {
00955         <span class="keywordtype">char</span> display[256];
00956         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *display; <span class="keywordtype">int</span> nch; } arg = { display, 0 };
00957         va_list args;
00958 
00959         va_start(args, format);
00960         arg.nch = vsprintf(display, format, args);
00961         va_end(args);
00962         rtai_lxrt(BIDX, SIZARG, PRINT_TO_SCREEN, &amp;arg);
00963         <span class="keywordflow">return</span> arg.nch;
00964 }
00965 
00966 RTAI_PROTO(<span class="keywordtype">int</span>,rt_printk,(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...))
00967 {
00968         <span class="keywordtype">char</span> display[256];
00969         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *display; <span class="keywordtype">int</span> nch; } arg = { display, 0 };
00970         va_list args;
00971 
00972         va_start(args, format);
00973         arg.nch = vsprintf(display, format, args);
00974         va_end(args);
00975         rtai_lxrt(BIDX, SIZARG, PRINTK, &amp;arg);
00976         <span class="keywordflow">return</span> arg.nch;
00977 }
00978 
00979 RTAI_PROTO(<span class="keywordtype">int</span>,rt_usp_signal_handler,(<span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>)))
00980 {
00981         <span class="keyword">struct </span>{ void (*handler)(<span class="keywordtype">void</span>); } arg = { handler };
00982         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, USP_SIGHDL, &amp;arg).i[0];
00983 }
00984 
00985 RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_usp_flags,(RT_TASK *rt_task))
00986 {
00987         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
00988         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_USP_FLAGS, &amp;arg).i[LOW];
00989 }
00990 
00991 RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_usp_flags_mask,(RT_TASK *rt_task))
00992 {
00993         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
00994         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_USP_FLG_MSK, &amp;arg).i[LOW];
00995 }
00996 
00997 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_usp_flags,(RT_TASK *rt_task, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags))
00998 {
00999         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags; } arg = { rt_task, flags };
01000         rtai_lxrt(BIDX, SIZARG, SET_USP_FLAGS, &amp;arg);
01001 }
01002 
01003 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_usp_flags_mask,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags_mask))
01004 {
01005         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags_mask; } arg = { flags_mask };
01006         rtai_lxrt(BIDX, SIZARG, SET_USP_FLG_MSK, &amp;arg);
01007 }
01008 
01009 RTAI_PROTO(RT_TASK *,rt_force_task_soft,(<span class="keywordtype">int</span> pid))
01010 {
01011         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> pid; } arg = { pid };
01012         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, FORCE_TASK_SOFT, &amp;arg).v[LOW];
01013 }
01014 
01015 RTAI_PROTO(RT_TASK *,rt_agent,(<span class="keywordtype">void</span>))
01016 {
01017         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01018         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, RT_BUDDY, &amp;arg).v[LOW];
01019 }
01020 
01021 <span class="preprocessor">#define rt_buddy() rt_agent()</span>
01022 <span class="preprocessor"></span>
<a name="l01045"></a><a class="code" href="group__lxrt.html#a57">01045</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_make_hard_real_time,(<span class="keywordtype">void</span>))
01046 {
01047         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01048         rtai_lxrt(BIDX, SIZARG, MAKE_HARD_RT, &amp;arg);
01049 }
01050 
<a name="l01059"></a><a class="code" href="group__lxrt.html#a58">01059</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_allow_nonroot_hrt,(<span class="keywordtype">void</span>))
01060 {
01061         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01062         rtai_lxrt(BIDX, SIZARG, NONROOT_HRT, &amp;arg);
01063 }
01064 
01065 RTAI_PROTO(<span class="keywordtype">int</span>,rt_is_hard_real_time,(RT_TASK *rt_task))
01066 {
01067         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
01068         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IS_HARD, &amp;arg).i[LOW];
01069 }
01070 
01071 <span class="preprocessor">#define rt_is_soft_real_time(rt_task) (!rt_is_hard_real_time((rt_task)))</span>
01072 <span class="preprocessor"></span>
01073 RTAI_PROTO(<span class="keywordtype">void</span>,rt_task_set_resume_end_times,(RTIME resume, RTIME end))
01074 {
01075         <span class="keyword">struct </span>{ RTIME resume, end; } arg = { resume, end };
01076         rtai_lxrt(BIDX, SIZARG, SET_RESUME_END, &amp;arg);
01077 }
01078 
01079 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_resume_time,(RT_TASK *rt_task, RTIME new_resume_time))
01080 {
01081         <span class="keyword">struct </span>{ RT_TASK *rt_task; RTIME new_resume_time; } arg = { rt_task, new_resume_time };
01082         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SET_RESUME_TIME, &amp;arg).i[LOW];
01083 }
01084 
01085 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_period,(RT_TASK *rt_task, RTIME new_period))
01086 {
01087         <span class="keyword">struct </span>{ RT_TASK *rt_task; RTIME new_period; } arg = { rt_task, new_period };
01088         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SET_PERIOD, &amp;arg).i[LOW];
01089 }
01090 
01091 RTAI_PROTO(<span class="keywordtype">void</span>,rt_spv_RMS,(<span class="keywordtype">int</span> cpuid))
01092 {
01093         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
01094         rtai_lxrt(BIDX, SIZARG, SPV_RMS, &amp;arg);
01095 }
01096 
01097 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_wakeup_sleeping,(RT_TASK *task))
01098 {
01099         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
01100         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, WAKEUP_SLEEPING, &amp;arg).i[LOW];
01101 }
01102 
01103 RTAI_PROTO(<span class="keywordtype">void</span>,rt_get_exectime,(RT_TASK *task, RTIME *exectime))
01104 {
01105         RTIME lexectime[] = { 0LL, 0LL, 0LL };
01106         <span class="keyword">struct </span>{ RT_TASK *task; RTIME *lexectime; } arg = { task, lexectime };
01107         rtai_lxrt(BIDX, SIZARG, GET_EXECTIME, &amp;arg);
01108         memcpy(exectime, lexectime, <span class="keyword">sizeof</span>(lexectime));
01109 }
01110 
01111 RTAI_PROTO(<span class="keywordtype">void</span>,rt_gettimeorig,(RTIME time_orig[]))
01112 {
01113         <span class="keyword">struct </span>{ RTIME *time_orig; } arg = { time_orig };
01114         rtai_lxrt(BIDX, SIZARG, GET_TIMEORIG, &amp;arg);
01115 }
01116 
01117 <span class="preprocessor">#ifdef __cplusplus</span>
01118 <span class="preprocessor"></span>}
01119 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
01120 
01121 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
01122 
01125 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_LXRT_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:02 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
