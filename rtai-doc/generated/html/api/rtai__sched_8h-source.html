<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_sched.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/rtai_sched.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 1999-2003 Paolo Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00005 <span class="comment"> * modify it under the terms of the GNU General Public License as</span>
00006 <span class="comment"> * published by the Free Software Foundation; either version 2 of the</span>
00007 <span class="comment"> * License, or (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> * GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00016 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00017 <span class="comment"> */</span>
00018 
00019 <span class="preprocessor">#ifndef _RTAI_SCHED_H</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_SCHED_H</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include &lt;rtai.h&gt;</span>
00023 <span class="preprocessor">#ifndef __KERNEL__</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00025 <span class="preprocessor">#include &lt;time.h&gt;</span>
00026 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00027 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00028 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00029 
00030 <span class="preprocessor">#define RT_SCHED_UP   1</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SMP  2</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_MUP  3</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#define RT_SCHED_HIGHEST_PRIORITY  0</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_LOWEST_PRIORITY   0x3fffFfff</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_LINUX_PRIORITY    0x7fffFfff</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#define RT_SCHED_READY        1</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SUSPENDED    2</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_DELAYED      4</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SEMAPHORE    8</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SEND        16</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RECEIVE     32</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RPC         64</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RETURN     128</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_MBXSUSP    256</span>
00047 <span class="preprocessor"></span>
00048 <span class="keyword">struct </span>rt_task_struct;
00049 
00050 <span class="preprocessor">#ifdef __KERNEL__</span>
00051 <span class="preprocessor"></span>
00052 <span class="preprocessor">#include &lt;linux/time.h&gt;</span>
00053 <span class="preprocessor">#include &lt;linux/errno.h&gt;</span>
00054 
00055 <span class="preprocessor">#define RT_TASK_MAGIC 0x754d2774</span>
00056 <span class="preprocessor"></span>
00057 <span class="preprocessor">#ifndef __cplusplus</span>
00058 <span class="preprocessor"></span>
00059 <span class="preprocessor">#include &lt;linux/sched.h&gt;</span>
00060 
00061 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_queue {
00062         <span class="keyword">struct </span>rt_queue *prev;
00063         <span class="keyword">struct </span>rt_queue *next;
00064         <span class="keyword">struct </span>rt_task_struct *task;
00065 } QUEUE;
00066 
00067 <span class="keyword">struct </span>mcb_t {
00068     <span class="keywordtype">void</span> *sbuf;
00069     <span class="keywordtype">int</span> sbytes;
00070     <span class="keywordtype">void</span> *rbuf;
00071     <span class="keywordtype">int</span> rbytes;
00072 };
00073 
00074 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_ExitHandler {
00075     <span class="comment">/* Exit handler functions are called like C++ destructors in</span>
00076 <span class="comment">       rt_task_delete(). */</span>
00077     <span class="keyword">struct </span>rt_ExitHandler *nxt;
00078     void (*fun) (<span class="keywordtype">void</span> *arg1, <span class="keywordtype">int</span> arg2);
00079     <span class="keywordtype">void</span> *arg1;
00080     <span class="keywordtype">int</span>   arg2;
00081 } XHDL;
00082 
00083 <span class="keyword">struct </span>rt_heap_t { <span class="keywordtype">void</span> *heap, *kadr, *uadr; };
00084 
00085 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_task_struct {
00086 
00087     <span class="keywordtype">int</span> *stack;
00088     <span class="keywordtype">int</span> uses_fpu;
00089     <span class="keywordtype">int</span> magic;
00090     <span class="keyword">volatile</span> <span class="keywordtype">int</span> state, running;
00091     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> runnable_on_cpus;
00092     <span class="keywordtype">int</span> *stack_bottom;
00093     <span class="keyword">volatile</span> <span class="keywordtype">int</span> priority;
00094     <span class="keywordtype">int</span> base_priority;
00095     <span class="keywordtype">int</span> policy;
00096     <span class="keywordtype">int</span> sched_lock_priority;
00097     <span class="keyword">struct </span>rt_task_struct *prio_passed_to;
00098     RTIME period;
00099     RTIME resume_time;
00100     RTIME yield_time;
00101     <span class="keywordtype">int</span> rr_quantum;
00102     <span class="keywordtype">int</span> rr_remaining;
00103     <span class="keywordtype">int</span> suspdepth;
00104     <span class="keyword">struct </span>rt_queue queue;
00105     <span class="keywordtype">int</span> owndres;
00106     <span class="keyword">struct </span>rt_queue *blocked_on;
00107     <span class="keyword">struct </span>rt_queue msg_queue;
00108     <span class="keywordtype">int</span> tid;    <span class="comment">/* trace ID */</span>
00109     <span class="keywordtype">unsigned</span> msg;
00110     <span class="keyword">struct </span>rt_queue ret_queue;
00111     void (*signal)(<span class="keywordtype">void</span>);
00112     FPU_ENV fpu_reg;
00113     <span class="keyword">struct </span>rt_task_struct *prev;
00114     <span class="keyword">struct </span>rt_task_struct *next;
00115     <span class="keyword">struct </span>rt_task_struct *tprev;
00116     <span class="keyword">struct </span>rt_task_struct *tnext;
00117     <span class="keyword">struct </span>rt_task_struct *rprev;
00118     <span class="keyword">struct </span>rt_task_struct *rnext;
00119 
00120     <span class="comment">/* Appended for calls from LINUX. */</span>
00121     <span class="keywordtype">int</span> *fun_args, *bstack;
00122     <span class="keyword">struct </span>task_struct *lnxtsk;
00123     <span class="keywordtype">long</span> <span class="keywordtype">long</span> retval;
00124     <span class="keywordtype">char</span> *msg_buf[2];
00125     <span class="keywordtype">int</span> max_msg_size[2];
00126     <span class="keywordtype">char</span> task_name[16];
00127     <span class="keywordtype">void</span> *system_data_ptr;
00128     <span class="keyword">struct </span>rt_task_struct *nextp;
00129     <span class="keyword">struct </span>rt_task_struct *prevp;
00130 
00131     <span class="comment">/* Added to support user specific trap handlers. */</span>
00132     RT_TRAP_HANDLER task_trap_handler[RTAI_NR_TRAPS];
00133 
00134     <span class="comment">/* Added from rtai-22. */</span>
00135     void (*usp_signal)(<span class="keywordtype">void</span>);
00136     <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pstate;
00137     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> usp_flags;
00138     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> usp_flags_mask;
00139     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> force_soft;
00140     <span class="keyword">volatile</span> <span class="keywordtype">int</span> is_hard;
00141 
00142     <span class="comment">/* Added to terminate qBlks. */</span>
00143     <span class="keywordtype">void</span> *tick_queue;
00144 
00145     <span class="comment">/* Added to terminate re-entry of user space functions. */</span>
00146 
00147     <span class="keywordtype">void</span> *trap_handler_data; 
00148     <span class="keywordtype">int</span> trap_signo;
00149 
00150     <span class="comment">/* For use by watchdog. */</span>
00151     <span class="keywordtype">int</span> resync_frame;
00152 
00153     <span class="comment">/* For use by exit handler functions. */</span>
00154     XHDL *ExitHook;
00155     <span class="keywordtype">int</span> linux_signal;
00156     <span class="keywordtype">int</span> errno;
00157     void (*linux_signal_handler)(<span class="keywordtype">int</span> sig);
00158     RTIME exectime[2];
00159     <span class="keyword">struct </span>mcb_t mcb;
00160 
00161         <span class="comment">/* Real time heaps. */</span>
00162         <span class="keyword">struct </span>rt_heap_t heap[2];
00163 
00164 } RT_TASK __attribute__ ((__aligned__ (16)));
00165 
00166 <span class="preprocessor">#else </span><span class="comment">/* __cplusplus */</span>
00167 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00168 <span class="preprocessor">#endif </span><span class="comment">/* !__cplusplus */</span>
00169 
00170 <span class="keywordtype">int</span> <a class="code" href="sched__up_8c.html#a48">rt_task_init</a>(<span class="keyword">struct</span> rt_task_struct *task,
00171                  <span class="keywordtype">void</span> (*rt_thread)(<span class="keywordtype">int</span>),
00172                  <span class="keywordtype">int</span> data,
00173                  <span class="keywordtype">int</span> stack_size,
00174                  <span class="keywordtype">int</span> priority,
00175                  <span class="keywordtype">int</span> uses_fpu,
00176                  <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>));
00177 
00178 <span class="keywordtype">int</span> <a class="code" href="sched__up_8c.html#a49">rt_task_init_cpuid</a>(<span class="keyword">struct</span> rt_task_struct *task,
00179                        <span class="keywordtype">void</span> (*rt_thread)(<span class="keywordtype">int</span>),
00180                        <span class="keywordtype">int</span> data,
00181                        <span class="keywordtype">int</span> stack_size,
00182                        <span class="keywordtype">int</span> priority,
00183                        <span class="keywordtype">int</span> uses_fpu,
00184                        <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>),
00185                        <span class="keywordtype">unsigned</span> run_on_cpu);
00186 
00187 <span class="keywordtype">void</span> <a class="code" href="sched__up_8c.html#a52">rt_set_runnable_on_cpus</a>(<span class="keyword">struct</span> rt_task_struct *task,
00188                              <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cpu_mask);
00189 
00190 <span class="keywordtype">void</span> <a class="code" href="sched__up_8c.html#a53">rt_set_runnable_on_cpuid</a>(<span class="keyword">struct</span> rt_task_struct *task,
00191                               <span class="keywordtype">unsigned</span> cpuid);
00192 
00193 <span class="keywordtype">void</span> rt_set_sched_policy(<span class="keyword">struct</span> rt_task_struct *task,
00194                          <span class="keywordtype">int</span> policy,
00195                          <span class="keywordtype">int</span> rr_quantum_ns);
00196 
00197 <span class="keywordtype">int</span> <a class="code" href="sched__up_8c.html#a59">rt_task_delete</a>(<span class="keyword">struct</span> rt_task_struct *task);
00198 
00199 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a12">rt_get_task_state</a>(<span class="keyword">struct</span> rt_task_struct *task);
00200 
00201 <span class="keywordtype">void</span> rt_gettimeorig(RTIME time_orig[]);
00202 
00203 <span class="keywordtype">int</span> rt_get_timer_cpu(<span class="keywordtype">void</span>);
00204 
00205 <span class="keywordtype">int</span> rt_is_hard_timer_running(<span class="keywordtype">void</span>);
00206 
00207 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a23">rt_set_periodic_mode</a>(<span class="keywordtype">void</span>);
00208 
00209 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a24">rt_set_oneshot_mode</a>(<span class="keywordtype">void</span>);
00210 
00211 RTIME <a class="code" href="sched__up_8c.html#a66">start_rt_timer</a>(<span class="keywordtype">int</span> period);
00212 
00213 RTIME start_rt_timer_cpuid(<span class="keywordtype">int</span> period,
00214                            <span class="keywordtype">int</span> cpuid);
00215 
00216 <span class="preprocessor">#define start_rt_timer_ns(period) start_rt_timer(nano2count((period)))</span>
00217 <span class="preprocessor"></span>
00218 <span class="keywordtype">void</span> <a class="code" href="sched__up_8c.html#a68">start_rt_apic_timers</a>(<span class="keyword">struct</span> apic_timer_setup_data *setup_mode,
00219                           <span class="keywordtype">unsigned</span> rcvr_jiffies_cpuid);
00220 
00221 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a18">stop_rt_timer</a>(<span class="keywordtype">void</span>);
00222 
00223 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="common_8c.html#a8">rt_whoami</a>(<span class="keywordtype">void</span>);
00224 
00225 <span class="keywordtype">int</span> rt_sched_type(<span class="keywordtype">void</span>);
00226 
00227 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a15">rt_task_signal_handler</a>(<span class="keyword">struct</span> rt_task_struct *task,
00228                            <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>));
00229 
00230 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a14">rt_task_use_fpu</a>(<span class="keyword">struct</span> rt_task_struct *task,
00231                     <span class="keywordtype">int</span> use_fpu_flag);
00232   
00233 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a13">rt_linux_use_fpu</a>(<span class="keywordtype">int</span> use_fpu_flag);
00234 
00235 <span class="keywordtype">void</span> <a class="code" href="sched__up_8c.html#a71">rt_preempt_always</a>(<span class="keywordtype">int</span> yes_no);
00236 
00237 <span class="keywordtype">void</span> <a class="code" href="sched__up_8c.html#a72">rt_preempt_always_cpuid</a>(<span class="keywordtype">int</span> yes_no,
00238                              <span class="keywordtype">unsigned</span> cpuid);
00239 
00240 RTIME <a class="code" href="sched__up_8c.html#a82">count2nano</a>(RTIME timercounts);
00241 
00242 RTIME <a class="code" href="sched__up_8c.html#a83">nano2count</a>(RTIME nanosecs);
00243   
00244 RTIME <a class="code" href="sched__up_8c.html#a84">count2nano_cpuid</a>(RTIME timercounts,
00245                        <span class="keywordtype">unsigned</span> cpuid);
00246 
00247 RTIME <a class="code" href="sched__up_8c.html#a85">nano2count_cpuid</a>(RTIME nanosecs,
00248                        <span class="keywordtype">unsigned</span> cpuid);
00249   
00250 RTIME <a class="code" href="group__lxrt.html#a19">rt_get_time</a>(<span class="keywordtype">void</span>);
00251 
00252 RTIME <a class="code" href="sched__up_8c.html#a87">rt_get_time_cpuid</a>(<span class="keywordtype">unsigned</span> cpuid);
00253 
00254 RTIME <a class="code" href="group__lxrt.html#a30">rt_get_time_ns</a>(<span class="keywordtype">void</span>);
00255 
00256 RTIME <a class="code" href="sched__up_8c.html#a89">rt_get_time_ns_cpuid</a>(<span class="keywordtype">unsigned</span> cpuid);
00257 
00258 RTIME <a class="code" href="group__lxrt.html#a31">rt_get_cpu_time_ns</a>(<span class="keywordtype">void</span>);
00259 
00260 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a5">rt_get_prio</a>(<span class="keyword">struct</span> rt_task_struct *task);
00261 
00262 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a6">rt_get_inher_prio</a>(<span class="keyword">struct</span> rt_task_struct *task);
00263 
00264 <span class="keywordtype">void</span> rt_spv_RMS(<span class="keywordtype">int</span> cpuid);
00265 
00266 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a7">rt_change_prio</a>(<span class="keyword">struct</span> rt_task_struct *task,
00267                    <span class="keywordtype">int</span> priority);
00268 
00269 <span class="keywordtype">void</span> <a class="code" href="group__tasks.html#a4">rt_sched_lock</a>(<span class="keywordtype">void</span>);
00270 
00271 <span class="keywordtype">void</span> <a class="code" href="group__tasks.html#a5">rt_sched_unlock</a>(<span class="keywordtype">void</span>);
00272 
00273 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a8">rt_task_yield</a>(<span class="keywordtype">void</span>);
00274 
00275 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a10">rt_task_suspend</a>(<span class="keyword">struct</span> rt_task_struct *task);
00276 
00277 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a11">rt_task_resume</a>(<span class="keyword">struct</span> rt_task_struct *task);
00278 
00279 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a17">rt_task_make_periodic_relative_ns</a>(<span class="keyword">struct</span> rt_task_struct *task,
00280                                       RTIME start_delay,
00281                                       RTIME period);
00282 
00283 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a18">rt_task_make_periodic</a>(<span class="keyword">struct</span> rt_task_struct *task,
00284                           RTIME start_time,
00285                           RTIME period);
00286 
00287 <span class="keywordtype">void</span> rt_task_set_resume_end_times(RTIME resume,
00288                                   RTIME end);
00289 
00290 <span class="keywordtype">int</span> rt_set_resume_time(<span class="keyword">struct</span> rt_task_struct *task,
00291                        RTIME new_resume_time);
00292 
00293 <span class="keywordtype">int</span> rt_set_period(<span class="keyword">struct</span> rt_task_struct *task,
00294                   RTIME new_period);
00295 
00296 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a13">rt_task_wait_period</a>(<span class="keywordtype">void</span>);
00297 
00298 <span class="keywordtype">void</span> rt_schedule(<span class="keywordtype">void</span>);
00299 
00300 RTIME <a class="code" href="common_8c.html#a23">next_period</a>(<span class="keywordtype">void</span>);
00301 
00302 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a24">rt_busy_sleep</a>(<span class="keywordtype">int</span> nanosecs);
00303 
00304 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a25">rt_sleep</a>(RTIME delay);
00305 
00306 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a26">rt_sleep_until</a>(RTIME time);
00307 
00308 <span class="keywordtype">int</span> rt_task_wakeup_sleeping(<span class="keyword">struct</span> rt_task_struct *task);
00309 
00310 <span class="keyword">struct </span>rt_task_struct *rt_named_task_init(<span class="keyword">const</span> <span class="keywordtype">char</span> *task_name,
00311                                           <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>),
00312                                           <span class="keywordtype">int</span> data,
00313                                           <span class="keywordtype">int</span> stack_size,
00314                                           <span class="keywordtype">int</span> prio,
00315                                           <span class="keywordtype">int</span> uses_fpu,
00316                                           <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>));
00317 
00318 <span class="keyword">struct </span>rt_task_struct *rt_named_task_init_cpuid(<span class="keyword">const</span> <span class="keywordtype">char</span> *task_name,
00319                                                 <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>),
00320                                                 <span class="keywordtype">int</span> data,
00321                                                 <span class="keywordtype">int</span> stack_size,
00322                                                 <span class="keywordtype">int</span> prio,
00323                                                 <span class="keywordtype">int</span> uses_fpu,
00324                                                 <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>),
00325                                                 <span class="keywordtype">unsigned</span> run_on_cpu);
00326 
00327 <span class="keywordtype">int</span> rt_named_task_delete(<span class="keyword">struct</span> rt_task_struct *task);
00328 
00329 RT_TRAP_HANDLER rt_set_task_trap_handler(<span class="keyword">struct</span> rt_task_struct *task,
00330                                          <span class="keywordtype">unsigned</span> vec,
00331                                          RT_TRAP_HANDLER handler);
00332 
00333 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timeval2count(<span class="keyword">struct</span> timeval *t)
00334 {
00335         <span class="keywordflow">return</span> <a class="code" href="sched__up_8c.html#a83">nano2count</a>(t-&gt;tv_sec*1000000000LL + t-&gt;tv_usec*1000);
00336 }
00337 
00338 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> count2timeval(RTIME rt, <span class="keyword">struct</span> timeval *t)
00339 {
00340         t-&gt;tv_sec = ulldiv(<a class="code" href="sched__up_8c.html#a82">count2nano</a>(rt), 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_usec);
00341         t-&gt;tv_usec /= 1000;
00342 }
00343 
00344 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timespec2count(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t)
00345 {
00346         <span class="keywordflow">return</span> <a class="code" href="sched__up_8c.html#a83">nano2count</a>(t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec);
00347 }
00348 
00349 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> count2timespec(RTIME rt, <span class="keyword">struct</span> timespec *t)
00350 {
00351         t-&gt;tv_sec = ulldiv(<a class="code" href="sched__up_8c.html#a82">count2nano</a>(rt), 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_nsec);
00352 }
00353 
00354 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timespec2nanos(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t)
00355 {
00356         <span class="keywordflow">return</span> t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec;
00357 }
00358 
00359 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> nanos2timespec(RTIME rt, <span class="keyword">struct</span> timespec *t)
00360 {
00361         t-&gt;tv_sec = ulldiv(rt, 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_nsec);
00362 }
00363 
00364 <span class="preprocessor">#ifdef __cplusplus</span>
00365 <span class="preprocessor"></span>}
00366 <span class="preprocessor">#else </span><span class="comment">/* !__cplusplus */</span>
00367 
00368 <span class="comment">/* FIXME: These calls should move to rtai_schedcore.h */</span>
00369 
00370 RT_TASK *rt_get_base_linux_task(RT_TASK **base_linux_task);
00371 
00372 RT_TASK *rt_alloc_dynamic_task(<span class="keywordtype">void</span>);
00373 
00374 <span class="keywordtype">void</span> rt_enq_ready_edf_task(RT_TASK *ready_task);
00375 
00376 <span class="keywordtype">void</span> rt_enq_ready_task(RT_TASK *ready_task);
00377 
00378 <span class="keywordtype">int</span> rt_renq_ready_task(RT_TASK *ready_task,
00379                        <span class="keywordtype">int</span> priority);
00380 
00381 <span class="keywordtype">void</span> rt_rem_ready_task(RT_TASK *task);
00382 
00383 <span class="keywordtype">void</span> rt_rem_ready_current(RT_TASK *rt_current);
00384 
00385 <span class="keywordtype">void</span> rt_enq_timed_task(RT_TASK *timed_task);
00386 
00387 <span class="keywordtype">void</span> rt_rem_timed_task(RT_TASK *task);
00388 
00389 <span class="keywordtype">void</span> rt_dequeue_blocked(RT_TASK *task);
00390 
00391 RT_TASK **rt_register_watchdog(RT_TASK *wdog,
00392                                <span class="keywordtype">int</span> cpuid);
00393 
00394 <span class="keywordtype">void</span> rt_deregister_watchdog(RT_TASK *wdog,
00395                             <span class="keywordtype">int</span> cpuid);
00396 
00397 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00398 
00399 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00400 
00401 <span class="preprocessor">#if !defined(__KERNEL__) || defined(__cplusplus)</span>
00402 <span class="preprocessor"></span>
00403 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_task_struct {
00404     <span class="keywordtype">int</span> opaque;
00405 } RT_TASK;
00406 
00407 <span class="keyword">typedef</span> <span class="keyword">struct </span>QueueBlock {
00408     <span class="keywordtype">int</span> opaque;
00409 } QBLK;
00410 
00411 <span class="keyword">typedef</span> <span class="keyword">struct </span>QueueHook {
00412     <span class="keywordtype">int</span> opaque;
00413 } QHOOK;
00414 
00415 <span class="preprocessor">#endif </span><span class="comment">/* !__KERNEL__ || __cplusplus */</span>
00416 
00417 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_SCHED_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:02 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
