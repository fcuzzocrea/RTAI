<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_sched.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">rtai-core</a>&nbsp;/&nbsp;<a class="el" href="dir_000019.html">include</a></div>
<h1>rtai_sched.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 1999-2003 Paolo Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00005 <span class="comment"> * modify it under the terms of the GNU General Public License as</span>
00006 <span class="comment"> * published by the Free Software Foundation; either version 2 of the</span>
00007 <span class="comment"> * License, or (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> * GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00016 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00017 <span class="comment"> */</span>
00018 
00019 <span class="preprocessor">#ifndef _RTAI_SCHED_H</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_SCHED_H</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include &lt;rtai.h&gt;</span>
00023 <span class="preprocessor">#ifndef __KERNEL__</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00025 <span class="preprocessor">#include &lt;time.h&gt;</span>
00026 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00027 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00028 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00029 
00030 <span class="preprocessor">#define RT_SCHED_UP   1</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SMP  2</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_MUP  3</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#define RT_SCHED_HIGHEST_PRIORITY  0</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_LOWEST_PRIORITY   0x3fffFfff</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_LINUX_PRIORITY    0x7fffFfff</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#define RT_SCHED_READY        1</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SUSPENDED    2</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_DELAYED      4</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SEMAPHORE    8</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SEND        16</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RECEIVE     32</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RPC         64</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RETURN     128</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_MBXSUSP    256</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SFTRDY     512</span>
00048 <span class="preprocessor"></span>
00049 <span class="keyword">struct </span>rt_task_struct;
00050 
00051 <span class="preprocessor">#ifdef __KERNEL__</span>
00052 <span class="preprocessor"></span>
00053 <span class="preprocessor">#include &lt;linux/time.h&gt;</span>
00054 <span class="preprocessor">#include &lt;linux/errno.h&gt;</span>
00055 
00056 <span class="preprocessor">#define RT_TASK_MAGIC 0x754d2774</span>
00057 <span class="preprocessor"></span>
00058 <span class="preprocessor">#ifndef __cplusplus</span>
00059 <span class="preprocessor"></span>
00060 <span class="preprocessor">#include &lt;linux/sched.h&gt;</span>
00061 
00062 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_queue {
00063         <span class="keyword">struct </span>rt_queue *prev;
00064         <span class="keyword">struct </span>rt_queue *next;
00065         <span class="keyword">struct </span>rt_task_struct *task;
00066 } QUEUE;
00067 
00068 <span class="keyword">struct </span>mcb_t {
00069     <span class="keywordtype">void</span> *sbuf;
00070     <span class="keywordtype">int</span> sbytes;
00071     <span class="keywordtype">void</span> *rbuf;
00072     <span class="keywordtype">int</span> rbytes;
00073 };
00074 
00075 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_ExitHandler {
00076     <span class="comment">/* Exit handler functions are called like C++ destructors in</span>
00077 <span class="comment">       rt_task_delete(). */</span>
00078     <span class="keyword">struct </span>rt_ExitHandler *nxt;
00079     void (*fun) (<span class="keywordtype">void</span> *arg1, <span class="keywordtype">int</span> arg2);
00080     <span class="keywordtype">void</span> *arg1;
00081     <span class="keywordtype">int</span>   arg2;
00082 } XHDL;
00083 
00084 <span class="keyword">struct </span>rt_heap_t { <span class="keywordtype">void</span> *heap, *kadr, *uadr; };
00085 
00086 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_task_struct {
00087 
00088     <span class="keywordtype">int</span> *stack;
00089     <span class="keywordtype">int</span> uses_fpu;
00090     <span class="keywordtype">int</span> magic;
00091     <span class="keyword">volatile</span> <span class="keywordtype">int</span> state, running;
00092     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> runnable_on_cpus;
00093     <span class="keywordtype">int</span> *stack_bottom;
00094     <span class="keyword">volatile</span> <span class="keywordtype">int</span> priority;
00095     <span class="keywordtype">int</span> base_priority;
00096     <span class="keywordtype">int</span> policy;
00097     <span class="keywordtype">int</span> sched_lock_priority;
00098     <span class="keyword">struct </span>rt_task_struct *prio_passed_to;
00099     RTIME period;
00100     RTIME resume_time;
00101     RTIME yield_time;
00102     <span class="keywordtype">int</span> rr_quantum;
00103     <span class="keywordtype">int</span> rr_remaining;
00104     <span class="keywordtype">int</span> suspdepth;
00105     <span class="keyword">struct </span>rt_queue queue;
00106     <span class="keywordtype">int</span> owndres;
00107     <span class="keyword">struct </span>rt_queue *blocked_on;
00108     <span class="keyword">struct </span>rt_queue msg_queue;
00109     <span class="keywordtype">int</span> tid;    <span class="comment">/* trace ID */</span>
00110     <span class="keywordtype">unsigned</span> msg;
00111     <span class="keyword">struct </span>rt_queue ret_queue;
00112     void (*signal)(void);
00113     FPU_ENV fpu_reg;
00114     <span class="keyword">struct </span>rt_task_struct *prev;
00115     <span class="keyword">struct </span>rt_task_struct *next;
00116     <span class="keyword">struct </span>rt_task_struct *tprev;
00117     <span class="keyword">struct </span>rt_task_struct *tnext;
00118     <span class="keyword">struct </span>rt_task_struct *rprev;
00119     <span class="keyword">struct </span>rt_task_struct *rnext;
00120 
00121     <span class="comment">/* Appended for calls from LINUX. */</span>
00122     <span class="keywordtype">int</span> *fun_args, *bstack;
00123     <span class="keyword">struct </span>task_struct *lnxtsk;
00124     <span class="keywordtype">long</span> <span class="keywordtype">long</span> retval;
00125     <span class="keywordtype">char</span> *msg_buf[2];
00126     <span class="keywordtype">int</span> max_msg_size[2];
00127     <span class="keywordtype">char</span> task_name[16];
00128     <span class="keywordtype">void</span> *system_data_ptr;
00129     <span class="keyword">struct </span>rt_task_struct *nextp;
00130     <span class="keyword">struct </span>rt_task_struct *prevp;
00131 
00132     <span class="comment">/* Added to support user specific trap handlers. */</span>
00133     RT_TRAP_HANDLER task_trap_handler[RTAI_NR_TRAPS];
00134 
00135     <span class="comment">/* Added from rtai-22. */</span>
00136     void (*usp_signal)(void);
00137     <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pstate;
00138     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> usp_flags;
00139     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> usp_flags_mask;
00140     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> force_soft;
00141     <span class="keyword">volatile</span> <span class="keywordtype">int</span> is_hard;
00142 
00143     <span class="comment">/* Added to terminate qBlks. */</span>
00144     <span class="keywordtype">void</span> *tick_queue;
00145 
00146     <span class="comment">/* Added to terminate re-entry of user space functions. */</span>
00147 
00148     <span class="keywordtype">void</span> *trap_handler_data; 
00149     <span class="keywordtype">int</span> trap_signo;
00150 
00151     <span class="comment">/* For use by watchdog. */</span>
00152     <span class="keywordtype">int</span> resync_frame;
00153 
00154     <span class="comment">/* For use by exit handler functions. */</span>
00155     XHDL *ExitHook;
00156     <span class="keywordtype">int</span> linux_signal;
00157     <span class="keywordtype">int</span> errno;
00158     void (*linux_signal_handler)(<span class="keywordtype">int</span> sig);
00159     RTIME exectime[2];
00160     <span class="keyword">struct </span>mcb_t mcb;
00161 
00162         <span class="comment">/* Real time heaps. */</span>
00163         <span class="keyword">struct </span>rt_heap_t heap[2];
00164 
00165 } RT_TASK __attribute__ ((__aligned__ (16)));
00166 
00167 <span class="preprocessor">#else </span><span class="comment">/* __cplusplus */</span>
00168 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00169 <span class="preprocessor">#endif </span><span class="comment">/* !__cplusplus */</span>
00170 
00171 <span class="keywordtype">int</span> <a class="code" href="group__lxrt.html#ga3">rt_task_init</a>(<span class="keyword">struct</span> rt_task_struct *task,
00172                  <span class="keywordtype">void</span> (*rt_thread)(<span class="keywordtype">int</span>),
00173                  <span class="keywordtype">int</span> data,
00174                  <span class="keywordtype">int</span> stack_size,
00175                  <span class="keywordtype">int</span> priority,
00176                  <span class="keywordtype">int</span> uses_fpu,
00177                  <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>));
00178 
00179 <span class="keywordtype">int</span> <a class="code" href="group__tasks.html#ga1">rt_task_init_cpuid</a>(<span class="keyword">struct</span> rt_task_struct *task,
00180                        <span class="keywordtype">void</span> (*rt_thread)(<span class="keywordtype">int</span>),
00181                        <span class="keywordtype">int</span> data,
00182                        <span class="keywordtype">int</span> stack_size,
00183                        <span class="keywordtype">int</span> priority,
00184                        <span class="keywordtype">int</span> uses_fpu,
00185                        <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>),
00186                        <span class="keywordtype">unsigned</span> run_on_cpu);
00187 
00188 <span class="keywordtype">void</span> <a class="code" href="group__tasks.html#ga2">rt_set_runnable_on_cpus</a>(<span class="keyword">struct</span> rt_task_struct *task,
00189                              <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cpu_mask);
00190 
00191 <span class="keywordtype">void</span> <a class="code" href="group__tasks.html#ga3">rt_set_runnable_on_cpuid</a>(<span class="keyword">struct</span> rt_task_struct *task,
00192                               <span class="keywordtype">unsigned</span> cpuid);
00193 
00194 <span class="keywordtype">void</span> rt_set_sched_policy(<span class="keyword">struct</span> rt_task_struct *task,
00195                          <span class="keywordtype">int</span> policy,
00196                          <span class="keywordtype">int</span> rr_quantum_ns);
00197 
00198 <span class="keywordtype">int</span> <a class="code" href="group__tasks.html#ga6">rt_task_delete</a>(<span class="keyword">struct</span> rt_task_struct *task);
00199 
00200 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a12">rt_get_task_state</a>(<span class="keyword">struct</span> rt_task_struct *task);
00201 
00202 <span class="keywordtype">void</span> rt_gettimeorig(RTIME time_orig[]);
00203 
00204 <span class="keywordtype">int</span> rt_get_timer_cpu(<span class="keywordtype">void</span>);
00205 
00206 <span class="keywordtype">int</span> rt_is_hard_timer_running(<span class="keywordtype">void</span>);
00207 
00208 <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga0">rt_set_periodic_mode</a>(<span class="keywordtype">void</span>);
00209 
00210 <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga1">rt_set_oneshot_mode</a>(<span class="keywordtype">void</span>);
00211 
00212 RTIME <a class="code" href="group__timer.html#ga2">start_rt_timer</a>(<span class="keywordtype">int</span> period);
00213 
00214 RTIME start_rt_timer_cpuid(<span class="keywordtype">int</span> period,
00215                            <span class="keywordtype">int</span> cpuid);
00216 
00217 <span class="preprocessor">#define start_rt_timer_ns(period) start_rt_timer(nano2count((period)))</span>
00218 <span class="preprocessor"></span>
00219 <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga3">start_rt_apic_timers</a>(<span class="keyword">struct</span> apic_timer_setup_data *setup_mode,
00220                           <span class="keywordtype">unsigned</span> rcvr_jiffies_cpuid);
00221 
00222 <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga4">stop_rt_timer</a>(<span class="keywordtype">void</span>);
00223 
00224 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="common_8c.html#a8">rt_whoami</a>(<span class="keywordtype">void</span>);
00225 
00226 <span class="keywordtype">int</span> rt_sched_type(<span class="keywordtype">void</span>);
00227 
00228 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a15">rt_task_signal_handler</a>(<span class="keyword">struct</span> rt_task_struct *task,
00229                            <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>));
00230 
00231 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a14">rt_task_use_fpu</a>(<span class="keyword">struct</span> rt_task_struct *task,
00232                     <span class="keywordtype">int</span> use_fpu_flag);
00233   
00234 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a13">rt_linux_use_fpu</a>(<span class="keywordtype">int</span> use_fpu_flag);
00235 
00236 <span class="keywordtype">void</span> <a class="code" href="group__tasks.html#ga7">rt_preempt_always</a>(<span class="keywordtype">int</span> yes_no);
00237 
00238 <span class="keywordtype">void</span> <a class="code" href="group__tasks.html#ga8">rt_preempt_always_cpuid</a>(<span class="keywordtype">int</span> yes_no,
00239                              <span class="keywordtype">unsigned</span> cpuid);
00240 
00241 RTIME <a class="code" href="group__timer.html#ga5">count2nano</a>(RTIME timercounts);
00242 
00243 RTIME <a class="code" href="group__timer.html#ga6">nano2count</a>(RTIME nanosecs);
00244   
00245 RTIME <a class="code" href="group__timer.html#ga7">count2nano_cpuid</a>(RTIME timercounts,
00246                        <span class="keywordtype">unsigned</span> cpuid);
00247 
00248 RTIME <a class="code" href="group__timer.html#ga8">nano2count_cpuid</a>(RTIME nanosecs,
00249                        <span class="keywordtype">unsigned</span> cpuid);
00250   
00251 RTIME <a class="code" href="group__timer.html#ga9">rt_get_time</a>(<span class="keywordtype">void</span>);
00252 
00253 RTIME <a class="code" href="group__timer.html#ga10">rt_get_time_cpuid</a>(<span class="keywordtype">unsigned</span> cpuid);
00254 
00255 RTIME <a class="code" href="group__timer.html#ga11">rt_get_time_ns</a>(<span class="keywordtype">void</span>);
00256 
00257 RTIME <a class="code" href="group__timer.html#ga12">rt_get_time_ns_cpuid</a>(<span class="keywordtype">unsigned</span> cpuid);
00258 
00259 RTIME <a class="code" href="group__timer.html#ga13">rt_get_cpu_time_ns</a>(<span class="keywordtype">void</span>);
00260 
00261 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a5">rt_get_prio</a>(<span class="keyword">struct</span> rt_task_struct *task);
00262 
00263 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a6">rt_get_inher_prio</a>(<span class="keyword">struct</span> rt_task_struct *task);
00264 
00265 <span class="keywordtype">void</span> rt_spv_RMS(<span class="keywordtype">int</span> cpuid);
00266 
00267 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a7">rt_change_prio</a>(<span class="keyword">struct</span> rt_task_struct *task,
00268                    <span class="keywordtype">int</span> priority);
00269 
00270 <span class="keywordtype">void</span> <a class="code" href="group__tasks.html#ga4">rt_sched_lock</a>(<span class="keywordtype">void</span>);
00271 
00272 <span class="keywordtype">void</span> <a class="code" href="group__tasks.html#ga5">rt_sched_unlock</a>(<span class="keywordtype">void</span>);
00273 
00274 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a9">rt_task_yield</a>(<span class="keywordtype">void</span>);
00275 
00276 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a10">rt_task_suspend</a>(<span class="keyword">struct</span> rt_task_struct *task);
00277 
00278 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a11">rt_task_resume</a>(<span class="keyword">struct</span> rt_task_struct *task);
00279 
00280 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a17">rt_task_make_periodic_relative_ns</a>(<span class="keyword">struct</span> rt_task_struct *task,
00281                                       RTIME start_delay,
00282                                       RTIME period);
00283 
00284 <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a18">rt_task_make_periodic</a>(<span class="keyword">struct</span> rt_task_struct *task,
00285                           RTIME start_time,
00286                           RTIME period);
00287 
00288 <span class="keywordtype">void</span> rt_task_set_resume_end_times(RTIME resume,
00289                                   RTIME end);
00290 
00291 <span class="keywordtype">int</span> rt_set_resume_time(<span class="keyword">struct</span> rt_task_struct *task,
00292                        RTIME new_resume_time);
00293 
00294 <span class="keywordtype">int</span> rt_set_period(<span class="keyword">struct</span> rt_task_struct *task,
00295                   RTIME new_period);
00296 
00297 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a19">rt_task_wait_period</a>(<span class="keywordtype">void</span>);
00298 
00299 <span class="keywordtype">void</span> rt_schedule(<span class="keywordtype">void</span>);
00300 
00301 RTIME <a class="code" href="common_8c.html#a23">next_period</a>(<span class="keywordtype">void</span>);
00302 
00303 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a24">rt_busy_sleep</a>(<span class="keywordtype">int</span> nanosecs);
00304 
00305 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a25">rt_sleep</a>(RTIME delay);
00306 
00307 <span class="keywordtype">void</span> <a class="code" href="common_8c.html#a26">rt_sleep_until</a>(RTIME time);
00308 
00309 <span class="keywordtype">int</span> rt_task_wakeup_sleeping(<span class="keyword">struct</span> rt_task_struct *task);
00310 
00311 <span class="keyword">struct </span>rt_task_struct *rt_named_task_init(<span class="keyword">const</span> <span class="keywordtype">char</span> *task_name,
00312                                           <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>),
00313                                           <span class="keywordtype">int</span> data,
00314                                           <span class="keywordtype">int</span> stack_size,
00315                                           <span class="keywordtype">int</span> prio,
00316                                           <span class="keywordtype">int</span> uses_fpu,
00317                                           <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>));
00318 
00319 <span class="keyword">struct </span>rt_task_struct *rt_named_task_init_cpuid(<span class="keyword">const</span> <span class="keywordtype">char</span> *task_name,
00320                                                 <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>),
00321                                                 <span class="keywordtype">int</span> data,
00322                                                 <span class="keywordtype">int</span> stack_size,
00323                                                 <span class="keywordtype">int</span> prio,
00324                                                 <span class="keywordtype">int</span> uses_fpu,
00325                                                 <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>),
00326                                                 <span class="keywordtype">unsigned</span> run_on_cpu);
00327 
00328 <span class="keywordtype">int</span> rt_named_task_delete(<span class="keyword">struct</span> rt_task_struct *task);
00329 
00330 RT_TRAP_HANDLER rt_set_task_trap_handler(<span class="keyword">struct</span> rt_task_struct *task,
00331                                          <span class="keywordtype">unsigned</span> vec,
00332                                          RT_TRAP_HANDLER handler);
00333 
00334 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timeval2count(<span class="keyword">struct</span> timeval *t)
00335 {
00336         <span class="keywordflow">return</span> <a class="code" href="group__timer.html#ga6">nano2count</a>(t-&gt;tv_sec*1000000000LL + t-&gt;tv_usec*1000);
00337 }
00338 
00339 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> count2timeval(RTIME rt, <span class="keyword">struct</span> timeval *t)
00340 {
00341         t-&gt;tv_sec = ulldiv(<a class="code" href="group__timer.html#ga5">count2nano</a>(rt), 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_usec);
00342         t-&gt;tv_usec /= 1000;
00343 }
00344 
00345 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timespec2count(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t)
00346 {
00347         <span class="keywordflow">return</span> <a class="code" href="group__timer.html#ga6">nano2count</a>(t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec);
00348 }
00349 
00350 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> count2timespec(RTIME rt, <span class="keyword">struct</span> timespec *t)
00351 {
00352         t-&gt;tv_sec = ulldiv(<a class="code" href="group__timer.html#ga5">count2nano</a>(rt), 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_nsec);
00353 }
00354 
00355 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timespec2nanos(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t)
00356 {
00357         <span class="keywordflow">return</span> t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec;
00358 }
00359 
00360 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> nanos2timespec(RTIME rt, <span class="keyword">struct</span> timespec *t)
00361 {
00362         t-&gt;tv_sec = ulldiv(rt, 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_nsec);
00363 }
00364 
00365 <span class="preprocessor">#ifdef __cplusplus</span>
00366 <span class="preprocessor"></span>}
00367 <span class="preprocessor">#else </span><span class="comment">/* !__cplusplus */</span>
00368 
00369 <span class="comment">/* FIXME: These calls should move to rtai_schedcore.h */</span>
00370 
00371 RT_TASK *rt_get_base_linux_task(RT_TASK **base_linux_task);
00372 
00373 RT_TASK *rt_alloc_dynamic_task(<span class="keywordtype">void</span>);
00374 
00375 <span class="keywordtype">void</span> rt_enq_ready_edf_task(RT_TASK *ready_task);
00376 
00377 <span class="keywordtype">void</span> rt_enq_ready_task(RT_TASK *ready_task);
00378 
00379 <span class="keywordtype">int</span> rt_renq_ready_task(RT_TASK *ready_task,
00380                        <span class="keywordtype">int</span> priority);
00381 
00382 <span class="keywordtype">void</span> rt_rem_ready_task(RT_TASK *task);
00383 
00384 <span class="keywordtype">void</span> rt_rem_ready_current(RT_TASK *rt_current);
00385 
00386 <span class="keywordtype">void</span> rt_enq_timed_task(RT_TASK *timed_task);
00387 
00388 <span class="keywordtype">void</span> rt_rem_timed_task(RT_TASK *task);
00389 
00390 <span class="keywordtype">void</span> rt_dequeue_blocked(RT_TASK *task);
00391 
00392 RT_TASK **rt_register_watchdog(RT_TASK *wdog,
00393                                <span class="keywordtype">int</span> cpuid);
00394 
00395 <span class="keywordtype">void</span> rt_deregister_watchdog(RT_TASK *wdog,
00396                             <span class="keywordtype">int</span> cpuid);
00397 
00398 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00399 
00400 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00401 
00402 <span class="preprocessor">#if !defined(__KERNEL__) || defined(__cplusplus)</span>
00403 <span class="preprocessor"></span>
00404 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_task_struct {
00405     <span class="keywordtype">int</span> opaque;
00406 } RT_TASK;
00407 
00408 <span class="keyword">typedef</span> <span class="keyword">struct </span>QueueBlock {
00409     <span class="keywordtype">int</span> opaque;
00410 } QBLK;
00411 
00412 <span class="keyword">typedef</span> <span class="keyword">struct </span>QueueHook {
00413     <span class="keywordtype">int</span> opaque;
00414 } QHOOK;
00415 
00416 <span class="preprocessor">#endif </span><span class="comment">/* !__KERNEL__ || __cplusplus */</span>
00417 
00418 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_SCHED_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun May 29 15:43:51 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
