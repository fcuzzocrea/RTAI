<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_sem.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/rtai_sem.h</h1><a href="rtai__sem_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00024 <span class="preprocessor">#ifndef _RTAI_SEM_H</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_SEM_H</span>
00026 <span class="preprocessor"></span>
00027 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="rtai__nam2num_8h.html">rtai_nam2num.h</a>&gt;</span>
00029 
00030 <span class="preprocessor">#define RT_SEM_MAGIC 0xaabcdeff</span>
00031 <span class="preprocessor"></span>
00032 <span class="preprocessor">#define SEM_TIMOUT (0xFffe)</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#define SEM_ERR (0xFfff)</span>
00035 <span class="preprocessor"></span>
00036 <span class="preprocessor">#if defined(__KERNEL__) &amp;&amp; !defined(__cplusplus)</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#include &lt;rtai_sched.h&gt;</span>
00039 
00040 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore {
00041     <span class="keyword">struct </span>rt_queue queue; <span class="comment">/* &lt;= Must be first in struct. */</span>
00042     <span class="keywordtype">int</span> magic;
00043     <span class="keywordtype">int</span> type;
00044     <span class="keywordtype">int</span> count;
00045     <span class="keyword">struct </span>rt_task_struct *owndby;
00046     <span class="keywordtype">int</span> qtype;
00047 } SEM;
00048 
00049 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ || __cplusplus */</span>
00050 
00051 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore {
00052     <span class="keywordtype">int</span> opaque;
00053 } SEM;
00054 
00055 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ &amp;&amp; !__cplusplus */</span>
00056 
00057 <span class="keyword">typedef</span> SEM CND;
00058 
00059 <span class="preprocessor">#ifdef __KERNEL__</span>
00060 <span class="preprocessor"></span>
00061 <span class="preprocessor">#include &lt;linux/errno.h&gt;</span>
00062 
00063 <span class="keyword">typedef</span> SEM psem_t;
00064 
00065 <span class="keyword">typedef</span> SEM pmutex_t;
00066 
00067 <span class="preprocessor">#ifdef __cplusplus</span>
00068 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00069 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00070 
00071 <span class="keywordtype">int</span> __rtai_sem_init(<span class="keywordtype">void</span>);
00072 
00073 <span class="keywordtype">void</span> __rtai_sem_exit(<span class="keywordtype">void</span>);
00074 
00075 <span class="keywordtype">void</span> <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(SEM *sem,
00076                        <span class="keywordtype">int</span> value,
00077                        <span class="keywordtype">int</span> type);
00078 
00079 SEM *<a class="code" href="group__sem.html#a35">_rt_typed_named_sem_init</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sem_name,
00080                              <span class="keywordtype">int</span> value,
00081                              <span class="keywordtype">int</span> type);
00082 
00083 <span class="keyword">static</span> <span class="keyword">inline</span> SEM *rt_typed_named_sem_init(<span class="keyword">const</span> <span class="keywordtype">char</span> *sem_name,
00084                                            <span class="keywordtype">int</span> value,
00085                                            <span class="keywordtype">int</span> type) {
00086     <span class="keywordflow">return</span> <a class="code" href="group__sem.html#a35">_rt_typed_named_sem_init</a>(<a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sem_name), value, type);
00087 }
00088 
00089 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a347">rt_sem_init</a>(SEM *sem,
00090                  <span class="keywordtype">int</span> value);
00091 
00092 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(SEM *sem);
00093 
00094 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(SEM *sem);
00095 
00096 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a7">rt_sem_broadcast</a>(SEM *sem);
00097 
00098 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(SEM *sem);
00099 
00100 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(SEM *sem);
00101 
00102 <span class="keywordtype">int</span> rt_cntsem_wait_if_and_lock(SEM *sem);
00103 
00104 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(SEM *sem,
00105                       RTIME time);
00106 
00107 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a11">rt_sem_wait_timed</a>(SEM *sem,
00108                       RTIME delay);
00109 
00110 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a12">rt_sem_wait_barrier</a>(SEM *sem);
00111 
00112 <span class="keywordtype">int</span> rt_sem_count(SEM *sem);
00113 
00114 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a13">rt_cond_signal</a>(CND *cnd);
00115 
00116 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a15">rt_cond_wait</a>(CND *cnd,
00117                  SEM *mtx);
00118 
00119 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a16">rt_cond_wait_until</a>(CND *cnd,
00120                        SEM *mtx,
00121                        RTIME time);
00122 
00123 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a17">rt_cond_wait_timed</a>(CND *cnd,
00124                        SEM *mtx,
00125                        RTIME delay);
00126 
00127 <span class="preprocessor">#define rt_named_sem_init(sem_name, value)  rt_typed_named_sem_init(sem_name, value, CNT_SEM)</span>
00128 <span class="preprocessor"></span>
00129 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a36">rt_named_sem_delete</a>(SEM *sem);
00130 
00131 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_init(psem_t *sem, <span class="keywordtype">int</span> pshared, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value)
00132 {
00133         <span class="keywordflow">if</span> (value &lt; SEM_TIMOUT) {
00134                 <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(sem, value, pshared | PRIO_Q);
00135                 <span class="keywordflow">return</span> 0;
00136         }
00137         <span class="keywordflow">return</span> -EINVAL;
00138 }
00139 
00140 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_destroy(psem_t *sem)
00141 {
00142         <span class="keywordflow">if</span> (<a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem) &gt;= 0) {
00143                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00144                 <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(sem);
00145         }
00146         <span class="keywordflow">return</span> -EBUSY;
00147 }
00148 
00149 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_wait(psem_t *sem) {
00150     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(sem) &lt; SEM_TIMOUT ? 0 : -1;
00151 }
00152 
00153 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_timedwait(psem_t *sem, <span class="keyword">struct</span> timespec *abstime) {
00154     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(sem, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -1;
00155 }
00156 
00157 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_trywait(psem_t *sem) {
00158     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem) &gt; 0 ? 0 : -EAGAIN;
00159 }
00160 
00161 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_post(psem_t *sem) {
00162     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00163 }
00164 
00165 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_getvalue(psem_t *sem, <span class="keywordtype">int</span> *sval)
00166 {
00167         <span class="keywordflow">if</span> ((*sval = <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem)) &gt; 0) {
00168                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00169         }
00170         <span class="keywordflow">return</span> 0;
00171 }
00172 
00173 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_init(pmutex_t *mutex, <span class="keywordtype">void</span> *mutexattr)
00174 {
00175         <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(mutex, 1, RES_SEM);
00176         <span class="keywordflow">return</span> 0;
00177 }
00178 
00179 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_destroy(pmutex_t *mutex)
00180 {
00181         <span class="keywordflow">if</span> (<a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(mutex) &gt; 0) {
00182                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(mutex);
00183                 <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(mutex);
00184         }
00185         <span class="keywordflow">return</span> -EBUSY;
00186 }
00187 
00188 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_lock(pmutex_t *mutex) {
00189     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(mutex) &lt; SEM_TIMOUT ? 0 : -EINVAL;
00190 }
00191 
00192 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_trylock(pmutex_t *mutex) {
00193     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(mutex) &gt; 0 ? 0 : -EBUSY;
00194 }
00195 
00196 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_timedlock(pmutex_t *sem, <span class="keyword">struct</span> timespec *abstime) {
00197     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(sem, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -1;
00198 }
00199 
00200 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_unlock(pmutex_t *mutex) {
00201     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(mutex);
00202 }
00203 
00204 <span class="preprocessor">#define rt_mutex_init(mtx)             rt_typed_sem_init(mtx, 1, RES_SEM)</span>
00205 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_delete(mtx)           rt_sem_delete(mtx)</span>
00206 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_destroy(mtx)          rt_sem_delete(mtx)</span>
00207 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_trylock(mtx)          rt_sem_wait_if(mtx)</span>
00208 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_lock(mtx)             rt_sem_wait(mtx)</span>
00209 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_timedlock(mtx, time)  rt_sem_wait_until(mtx, time)</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_unlock(mtx)           rt_sem_signal(mtx)</span>
00211 <span class="preprocessor"></span>
00212 <span class="preprocessor">#define rt_cond_init(cnd)                  rt_typed_sem_init(cnd, 0, BIN_SEM | PRIO_Q)</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_delete(cnd)                rt_sem_delete(cnd)</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_destroy(cnd)               rt_sem_delete(cnd)</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_broadcast(cnd)             rt_sem_broadcast(cnd)</span>
00216 <span class="preprocessor"></span>
00217 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_cond_timedwait(CND *cnd, SEM *mtx, RTIME time) {
00218     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a16">rt_cond_wait_until</a>(cnd, mtx, time) &lt; SEM_TIMOUT ? 0 : -1;
00219 }
00220 
00221 <span class="preprocessor">#ifdef __cplusplus</span>
00222 <span class="preprocessor"></span>}
00223 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00224 
00225 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00226 
00227 <span class="preprocessor">#include &lt;<a class="code" href="rtai__lxrt_8h.html">rtai_lxrt.h</a>&gt;</span>
00228 
00229 <span class="preprocessor">#ifdef __cplusplus</span>
00230 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00231 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00232 
00233 RTAI_PROTO(SEM *, rt_typed_sem_init,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type))
00234 {
00235         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { name, value, type };
00236         <span class="keywordflow">return</span> (SEM *)rtai_lxrt(BIDX, SIZARG, LXRT_SEM_INIT, &amp;arg).v[LOW];
00237 }
00238 
<a name="l00256"></a><a class="code" href="group__lxrt.html#a347">00256</a> <span class="preprocessor">#define rt_sem_init(name, value) rt_typed_sem_init(name, value, CNT_SEM)</span>
00257 <span class="preprocessor"></span>
00258 <span class="preprocessor">#define rt_named_sem_init(sem_name, value) \</span>
00259 <span class="preprocessor">        rt_typed_named_sem_init(sem_name, value, CNT_SEM)</span>
00260 <span class="preprocessor"></span>
<a name="l00261"></a><a class="code" href="group__sem.html#a4">00261</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_delete,(SEM *sem))
00262 {
00263         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00264         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_SEM_DELETE, &amp;arg).i[LOW];
00265 }
00266 
00267 RTAI_PROTO(SEM *, rt_typed_named_sem_init,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type))
00268 {
00269         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name; <span class="keywordtype">int</span> value, type; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(name), value, type };
00270         <span class="keywordflow">return</span> (SEM *)rtai_lxrt(BIDX, SIZARG, NAMED_SEM_INIT, &amp;arg).v[LOW];
00271 }
00272 
<a name="l00273"></a><a class="code" href="group__sem.html#a36">00273</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_named_sem_delete,(SEM *sem))
00274 {
00275         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00276         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NAMED_SEM_DELETE, &amp;arg).i[LOW];
00277 }
00278 
<a name="l00279"></a><a class="code" href="group__sem.html#a6">00279</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_signal,(SEM *sem))
00280 {
00281         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00282         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_SIGNAL, &amp;arg).i[LOW];
00283 }
00284 
<a name="l00285"></a><a class="code" href="group__sem.html#a7">00285</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_broadcast,(SEM *sem))
00286 {
00287         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00288         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_BROADCAST, &amp;arg).i[LOW];
00289 }
00290 
<a name="l00291"></a><a class="code" href="group__sem.html#a8">00291</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait,(SEM *sem))
00292 {
00293         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00294         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT, &amp;arg).i[LOW];
00295 }
00296 
<a name="l00297"></a><a class="code" href="group__sem.html#a9">00297</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_if,(SEM *sem))
00298 {
00299         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00300         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_IF, &amp;arg).i[LOW];
00301 }
00302 
<a name="l00303"></a><a class="code" href="group__sem.html#a10">00303</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_until,(SEM *sem, RTIME time))
00304 {
00305         <span class="keyword">struct </span>{ SEM *sem; RTIME time; } arg = { sem, time };
00306         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_UNTIL, &amp;arg).i[LOW];
00307 }
00308 
<a name="l00309"></a><a class="code" href="group__sem.html#a11">00309</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_timed,(SEM *sem, RTIME delay))
00310 {
00311         <span class="keyword">struct </span>{ SEM *sem; RTIME delay; } arg = { sem, delay };
00312         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_TIMED, &amp;arg).i[LOW];
00313 }
00314 
<a name="l00315"></a><a class="code" href="group__sem.html#a12">00315</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_barrier,(SEM *sem))
00316 {
00317         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00318         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_BARRIER, &amp;arg).i[LOW];
00319 }
00320 
00321 RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_count,(SEM *sem))
00322 {
00323         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00324         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_COUNT, &amp;arg).i[LOW];
00325 }
00326 
<a name="l00342"></a><a class="code" href="group__lxrt.html#a348">00342</a> <span class="preprocessor">#define rt_cond_init(name)                 rt_typed_sem_init(name, 0, BIN_SEM)</span>
00343 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_delete(cnd)                rt_sem_delete(cnd)</span>
00344 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_destroy(cnd)               rt_sem_delete(cnd)</span>
00345 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_broadcast(cnd)             rt_sem_broadcast(cnd)</span>
00346 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_timedwait(cnd, mtx, time)  rt_cond_wait_until(cnd, mtx, time)</span>
00347 <span class="preprocessor"></span>
<a name="l00348"></a><a class="code" href="group__sem.html#a13">00348</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_signal,(CND *cnd))
00349 {
00350         <span class="keyword">struct </span>{ CND *cnd; } arg = { cnd };
00351         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_SIGNAL, &amp;arg).i[LOW];
00352 }
00353 
<a name="l00354"></a><a class="code" href="group__sem.html#a15">00354</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_wait,(CND *cnd, SEM  *mutex))
00355 {
00356         <span class="keyword">struct </span>{ CND *cnd; SEM *mutex; } arg = { cnd, mutex };
00357         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT, &amp;arg).i[LOW];
00358 }
00359 
<a name="l00360"></a><a class="code" href="group__sem.html#a16">00360</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_wait_until,(CND *cnd, SEM *mutex, RTIME time))
00361 {
00362         <span class="keyword">struct </span>{ CND *cnd; SEM *mutex; RTIME time; } arg = { cnd, mutex, time };
00363         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT_UNTIL, &amp;arg).i[LOW];
00364 }
00365 
<a name="l00366"></a><a class="code" href="group__sem.html#a17">00366</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_wait_timed,(CND *cnd, SEM *mutex, RTIME delay))
00367 {
00368         <span class="keyword">struct </span>{ CND *cnd; SEM *mutex; RTIME delay; } arg = { cnd, mutex, delay };
00369         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT_TIMED, &amp;arg).i[LOW];
00370 }
00371 
00372 <span class="preprocessor">#ifdef __cplusplus</span>
00373 <span class="preprocessor"></span>}
00374 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00375 
00376 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00377 
00378 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_SEM_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:04 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
