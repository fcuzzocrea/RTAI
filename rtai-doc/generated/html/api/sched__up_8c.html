<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: sched_up.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/sched/rtai/sched_up.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Scheduling function for uni-processor. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>Paolo Mantegazza</dd></dl>
This file is part of the RTAI project.<p>
<dl compact><dt><b>Note:</b></dt><dd>Copyright (C) 1999-2003 Paolo Mantegazza &lt;<a href="mailto:mantegazza@aero.polimi.it">mantegazza@aero.polimi.it</a>&gt;</dd></dl>
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.<p>
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.<p>
You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
<p>

<p>
Include dependency graph for sched_up.c:<p><center><img src="sched__up_8c__incl.png" border="0" usemap="#sched_up.c_map" alt="Include dependency graph"></center>
<map name="sched_up.c_map">
<area href="rtai_8h-source.html" shape="rect" coords="25,544,65,563" alt="">
<area href="rtai__sched_8h-source.html" shape="rect" coords="113,570,195,588" alt="">
<area href="rtai__schedcore_8h-source.html" shape="rect" coords="245,616,354,635" alt="">
<area href="rtai__trace_8h-source.html" shape="rect" coords="115,639,193,658" alt="">
<area href="rtai__registry_8h.html" shape="rect" coords="254,752,345,771" alt="">
</map>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a48">rt_task_init</a> (RT_TASK *task, void(*rt_thread)(int), int data, int stack_size, int priority, int uses_fpu, void(*signal)(void))</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a49">rt_task_init_cpuid</a> (RT_TASK *task, void(*rt_thread)(int), int data, int stack_size, int priority, int uses_fpu, void(*signal)(void), unsigned int cpuid)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a52">rt_set_runnable_on_cpus</a> (RT_TASK *task, unsigned long runnable_on_cpus)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign CPUs to a task. </em> <a href="#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a53">rt_set_runnable_on_cpuid</a> (RT_TASK *task, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign CPUs to a task. </em> <a href="#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a57">rt_sched_lock</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the scheduling of tasks. </em> <a href="#a57"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a58">rt_sched_unlock</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the scheduling of tasks. </em> <a href="#a58"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a59">rt_task_delete</a> (RT_TASK *task)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a63">rt_set_periodic_mode</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set timer mode. </em> <a href="#a63"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a64">rt_set_oneshot_mode</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set timer mode. </em> <a href="#a64"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a66">start_rt_timer</a> (int period)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start timer. </em> <a href="#a66"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a68">start_rt_apic_timers</a> (struct apic_timer_setup_data *setup_mode, unsigned int rcvr_jiffies_cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start local apic timer. </em> <a href="#a68"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a69">stop_rt_timer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop timer. </em> <a href="#a69"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a71">rt_preempt_always</a> (int yes_no)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable hard preemption. </em> <a href="#a71"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a72">rt_preempt_always_cpuid</a> (int yes_no, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable hard preemption. </em> <a href="#a72"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a82">count2nano</a> (RTIME counts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert internal count units to nanoseconds. </em> <a href="#a82"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a83">nano2count</a> (RTIME ns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert nanoseconds to internal count units. </em> <a href="#a83"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a84">count2nano_cpuid</a> (RTIME counts, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert internal count units to nanoseconds. </em> <a href="#a84"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a85">nano2count_cpuid</a> (RTIME ns, unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert nanoseconds to internal count units. </em> <a href="#a85"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a86">rt_get_time</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a86"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a87">rt_get_time_cpuid</a> (unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a87"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a88">rt_get_time_ns</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a88"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a89">rt_get_time_ns_cpuid</a> (unsigned int cpuid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a89"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RTIME&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sched__up_8c.html#a90">rt_get_cpu_time_ns</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current time. </em> <a href="#a90"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a82" doxytag="sched_up.c::count2nano" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME count2nano </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>counts</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert internal count units to nanoseconds. 
<p>
<a class="anchor" name="count2nano"></a> <p>
This function converts the time of timercounts internal count units into nanoseconds. Remember that the count units are related to the time base being used (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>counts</em>&nbsp;</td><td>internal count units.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a84" doxytag="sched_up.c::count2nano_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME count2nano_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>counts</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert internal count units to nanoseconds. 
<p>
<a class="anchor" name="count2nano_cpuid"></a> <p>
This function converts the time of timercounts internal count units into nanoseconds. It is to be used with the MUP scheduler since with such a scheduler it is possible to have independent timers, i.e. periodic of different periods or a mixing of periodic and oneshot, so that it is impossible to establish which conversion units should be used in the case one asks for a conversion from any CPU for any other CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>counts</em>&nbsp;</td><td>internal count units.</td></tr>
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>Identifier of the CPU (FIXME).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a83" doxytag="sched_up.c::nano2count" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME nano2count </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ns</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert nanoseconds to internal count units. 
<p>
<a class="anchor" name="nano2count"></a> <p>
This function converts the time of nanosecs <em>nanoseconds</em> into internal counts units. Remember that the count units are related to the time base being used (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
The versions ending with_cpuid are to be used with the MUP scheduler since with such a scheduler it is possible to have independent timers, i.e. periodic of different periods or a mixing of periodic and oneshot, so that it is impossible to establish which conversion units should be used in the case one asks for a conversion from any CPU for any other CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ns</em>&nbsp;</td><td>Number of nanoseconds.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a85" doxytag="sched_up.c::nano2count_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME nano2count_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>ns</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert nanoseconds to internal count units. 
<p>
<a class="anchor" name="nano2count_cpuid"></a> <p>
This function converts the time of nanosecs <em>nanoseconds</em> into internal counts units. Remember that the count units are related to the time base being used (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
This function is to be used with the MUP scheduler since with such a scheduler it is possible to have independent timers, i.e. periodic of different periods or a mixing of periodic and oneshot, so that it is impossible to establish which conversion units should be used in the case one asks for a conversion from any CPU for any other CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ns</em>&nbsp;</td><td>Number of nanoseconds.</td></tr>
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>Identifier of the CPU (FIXME).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The given time in nanoseconds is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a90" doxytag="sched_up.c::rt_get_cpu_time_ns" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_cpu_time_ns </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_cpu_time_ns"></a> <p>
rt_get_cpu_time_ns always returns the CPU time in nanoseconds whatever timer is in use.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a86" doxytag="sched_up.c::rt_get_time" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time"></a> <p>
rt_get_time returns the time, in internal count units, since start_rt_timer was called. In periodic mode this number is in multiples of the periodic tick. In oneshot mode it is directly the TSC count for CPUs having a time stamp clock (TSC), while it is a (FIXME) on 8254 units for those not having it (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation).<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a87" doxytag="sched_up.c::rt_get_time_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cpuid</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time_cpuid"></a> <p>
rt_get_time_cpuid returns the time, in internal count units, since start_rt_timer was called. In periodic mode this number is in multiples of the periodic tick. In oneshot mode it is directly the TSC count for CPUs having a time stamp clock (TSC), while it is a (FIXME) on 8254 units for those not having it (see functions <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() and <a class="el" href="sched__lxrt_8c.html#rt_set_periodic_mode">rt_set_periodic_mode</a>() for an explanation). This version ending with _cpuid must be used with the MUP scheduler when there is the need to declare from which cpuid the time must be gotten (FIXME). In fact one can need to get the time of another CPU and timers can differ from CPU to CPU. (FIXME) All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>corresponds to the CPUI identifier.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a88" doxytag="sched_up.c::rt_get_time_ns" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time_ns </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time_ns"></a> <p>
rt_get_time_ns is the same as <a class="el" href="sched__lxrt_8c.html#rt_get_time">rt_get_time</a>() but the returned time is converted to nanoseconds.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a89" doxytag="sched_up.c::rt_get_time_ns_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME rt_get_time_ns_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cpuid</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current time. 
<p>
<a class="anchor" name="rt_get_time_ns_cpuid"></a> <p>
rt_get_time_ns is the same as rt_get_time but the returned time is converted to nanoseconds. The version ending with _cpuid must be used with the MUP scheduler when there is the need to declare from which cpuidthe time must be got. In fact one can need to get the time of another CPU and timers can differ from CPU to CPU. All these functions have the same behavior with UP and SMP schedulers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>corresponds to the CPUI identifier.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The current time in internal count units is returned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a71" doxytag="sched_up.c::rt_preempt_always" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_preempt_always </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>yes_no</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable hard preemption. 
<p>
<a class="anchor" name="rt_preempt_always"></a> <p>
In the oneshot mode the next timer expiration is programmed after a timer shot by choosing among the timed tasks the one with a priority higher than the task chosen to run as current, with the constraint of always assuring a correct Linux timing. In such a view there is no need to fire the timer immediately. In fact it can happen that the current task can be so fast to get suspended and rerun before the one that was devised to time the next shot when it was made running. In such a view <b>RTAI</b> schedulers try to shoot only when strictly needed. This minimizes the number of slow setups of the 8254 timer used with UP and 8254 based SMP schedulers. While such a policy minimizes the number of actual shots, greatly enhancing efficiency, it can be unsuitable when an application has to be guarded against undesired program loops or other unpredicted error causes. Calling these functions with a nonzero value assures that a timed high priority preempting task is always programmed to be fired while another task is currently running. The default is no immediate preemption in oneshot mode, i.e. firing of the next shot programmed only when strictly needed to satisfy tasks timings.<p>
<dl compact><dt><b>Note:</b></dt><dd>With UP and SMP schedulers there is always only a timing source so that cpu_idinrt_preempt_always_cpuid is not used. With the MUP scheduler you have an independent timer for each CPU, so rt_preempt_always applies to all the CPUs while rt_preempt_always_cpuid should be used when preemption is to be forced only on a specific CPU. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a72" doxytag="sched_up.c::rt_preempt_always_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_preempt_always_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>yes_no</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable hard preemption. 
<p>
<a class="anchor" name="rt_preempt_always_cpuid"></a> <p>
In the oneshot mode the next timer expiration is programmed after a timer shot by choosing among the timed tasks the one with a priority higher than the task chosen to run as current, with the constraint of always assuring a correct Linux timing. In such a view there is no need to fire the timer immediately. In fact it can happen that the current task can be so fast to get suspended and rerun before the one that was devised to time the next shot when it was made running. In such a view <b>RTAI</b> schedulers try to shoot only when strictly needed. This minimizes the number of slow setups of the 8254 timer used with UP and 8254 based SMP schedulers. While such a policy minimizes the number of actual shots, greatly enhancing efficiency, it can be unsuitable when an application has to be guarded against undesired program loops or other unpredicted error causes. Calling these functions with a nonzero value assures that a timed high priority preempting task is always programmed to be fired while another task is currently running. The default is no immediate preemption in oneshot mode, i.e. firing of the next shot programmed only when strictly needed to satisfy tasks timings.<p>
<dl compact><dt><b>Note:</b></dt><dd>With UP and SMP schedulers there is always only a timing source so that cpu_idinrt_preempt_always_cpuid is not used. With the MUP scheduler you have an independent timer for each CPU, so rt_preempt_always applies to all the CPUs while rt_preempt_always_cpuid should be used when preemption is to be forced only on a specific CPU. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a57" doxytag="sched_up.c::rt_sched_lock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_sched_lock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lock the scheduling of tasks. 
<p>
<a class="anchor" name="rt_sched_lock"></a> <p>
rt_sched_lock, lock on the CPU on which they are called, any scheduler activity, thus preventing a higher priority task to preempt a lower priority one. They can be nested, provided unlocks are paired to locks in reversed order. It can be used for synchronization access to data among tasks. Note however that under MP the lock is active only for the CPU on which it has been issued, so it cannot be used to avoid races with tasks that can run on any other available CPU. Interrupts are not affected by such calls. Any task that needs rescheduling while a scheduler lock is in placewill be only at the issuing of the last unlock<p>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx.</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_sched_unlock">rt_sched_unlock</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a58" doxytag="sched_up.c::rt_sched_unlock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_sched_unlock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock the scheduling of tasks. 
<p>
<a class="anchor" name="rt_sched_unlock"></a> <p>
rt_sched_unlock, unlock on the CPU on which they are called, any scheduler activity, thus preventing a higher priority task to preempt a lower priority one. They can be nested, provided unlocks are paired to locks in reversed order. It can be used for synchronization access to data among tasks. Note however that under MP the lock is active only for the CPU on which it has been issued, so it cannot be used to avoid races with tasks that can run on any other available CPU. Interrupts are not affected by such calls. Any task that needs rescheduling while a scheduler lock is in placewill be only at the issuing of the last unlock<p>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx.</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_sched_unlock">rt_sched_unlock</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a64" doxytag="sched_up.c::rt_set_oneshot_mode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_oneshot_mode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set timer mode. 
<p>
<a class="anchor" name="rt_set_oneshot_mode"></a> <p>
rt_set_periodic_mode sets the periodic mode for the timer. It consists of a fixed frequency timing of the tasks in multiple of the period set with a call to <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>(). The resolution is that of the 8254 (1193180 Hz) on a UP machine, or if the 8254 based SMP scheduler is being used. For the SMP scheduler timed by the local APIC timer and for the MUP scheduler the timer resolution is that of the local APIC timer frequency, generally the bus frequency divided 16. Any timing request not being an integer multiple of the set timer period is satisfied at the closest period tick. It is the default mode when no call is made to set the oneshot mode.<p>
<dl compact><dt><b>Note:</b></dt><dd>Stopping the timer by <a class="el" href="sched__lxrt_8c.html#stop_rt_timer">stop_rt_timer</a>() sets the timer back into its default (periodic) mode. Always call <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() before each <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>() if you want to be sure to have it oneshot on multiple insmod without rmmoding the RTAI scheduler in use. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a63" doxytag="sched_up.c::rt_set_periodic_mode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_periodic_mode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set timer mode. 
<p>
<a class="anchor" name="rt_set_periodic_mode"></a> <p>
rt_set_periodic_mode sets the periodic mode for the timer. It consists of a fixed frequency timing of the tasks in multiple of the period set with a call to <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>(). The resolution is that of the 8254 (1193180 Hz) on a UP machine, or if the 8254 based SMP scheduler is being used. For the SMP scheduler timed by the local APIC timer and for the MUP scheduler the timer resolution is that of the local APIC timer frequency, generally the bus frequency divided 16. Any timing request not being an integer multiple of the set timer period is satisfied at the closest period tick. It is the default mode when no call is made to set the oneshot mode.<p>
<dl compact><dt><b>Note:</b></dt><dd>Stopping the timer by <a class="el" href="sched__lxrt_8c.html#stop_rt_timer">stop_rt_timer</a>() sets the timer back into its default (periodic) mode. Always call <a class="el" href="sched__lxrt_8c.html#rt_set_oneshot_mode">rt_set_oneshot_mode</a>() before each <a class="el" href="sched__lxrt_8c.html#start_rt_timer">start_rt_timer</a>() if you want to be sure to have it oneshot on multiple insmod without rmmoding the RTAI scheduler in use. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="sched_up.c::rt_set_runnable_on_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_runnable_on_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assign CPUs to a task. 
<p>
<a class="anchor" name="rt_set_runnable_on_cpuid"></a> <p>
rt_set_runnable_on_cpuid select one or more CPUs which are allowed to run task <em>task</em>.<p>
rt_set_runnable_on_cpuid assigns a task to a single specific CPU. If no CPU, as selected by cpu_mask or cpuid, is available, both functions choose a possible CPU automatically, following the same rule as above.<p>
<dl compact><dt><b>Note:</b></dt><dd>This call has no effect on UniProcessor (UP) systems.</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_set_runnable_on_cpus">rt_set_runnable_on_cpus</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a52" doxytag="sched_up.c::rt_set_runnable_on_cpus" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_set_runnable_on_cpus </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>runnable_on_cpus</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assign CPUs to a task. 
<p>
<a class="anchor" name="rt_set_runnable_on_cpus"></a> <p>
rt_set_runnable_on_cpus selects one or more CPUs which are allowed to run task <em>task</em>. rt_set_runnable_on_cpus behaves differently for MUP and SMP schedulers. Under the SMP scheduler bit&lt;n&gt; of cpu_mask enables the task to run on CPU&lt;n&gt;. Under the MUP scheduler it selects the CPU with less running tasks among those allowed by cpu_mask. Recall that with MUP a task must be bounded to run on a single CPU. If no CPU, as selected by cpu_mask or cpuid, is available, both functions choose a possible CPU automatically, following the same rule as above.<p>
<dl compact><dt><b>Note:</b></dt><dd>This call has no effect on UniProcessor (UP) systems.</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_set_runnable_on_cpuid">rt_set_runnable_on_cpuid</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a59" doxytag="sched_up.c::rt_task_delete" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_delete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="anchor" name="rt_task_delete"></a> Delete a real time task.<p>
rt_task_delete deletes a real time task previously created by <a class="el" href="sched__lxrt_8c.html#rt_task_init">rt_task_init</a>() or <a class="el" href="sched__lxrt_8c.html#rt_task_init_cpuid">rt_task_init_cpuid</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is the pointer to the task structure. If task task was waiting on a queue, i.e. semaphore, mailbox, etc, it is removed from such a queue and messaging tasks pending on its message queue are unblocked with an error return.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task does not refer to a valid task. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a48" doxytag="sched_up.c::rt_task_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>rt_thread</em>)(int), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>stack_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>uses_fpu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>signal</em>)(void)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="anchor" name="rt_task_init"></a> Creates a new real time task.<p>
The newly created real time task is initially in a suspend state. It can be made active by calling: rt_task_make_periodic, rt_task_make_periodic_relative_ns, rt_task_resume.<p>
When used with the MUP scheduler rt_task_init automatically selects which CPU the task will run on, while with the SMP scheduler the task defaults to using any of the available CPUs. This assignment may be changed by calling rt_set_runnable_on_cpus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is a pointer to an RT_TASK type structure whose space must be provided by the application. It must be kept during the whole lifetime of the real time task.</td></tr>
    <tr><td valign=top><em>rt_thread</em>&nbsp;</td><td>is the entry point of the task function.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The parent task can pass a single integer value data to the new task being created. Recall that an appropriately type casting allows data to be a pointer to whatever data structure one would like to pass to the task, so you can indirectly pass whatever you want to the task.</td></tr>
    <tr><td valign=top><em>stack_size</em>&nbsp;</td><td>is the size of the stack to be used by the new task. In sizing it, recall to make room for any real time interrupt handler, as real time interrupts run on the stack of the task they interrupt. So try to avoid being too sparing.</td></tr>
    <tr><td valign=top><em>priority</em>&nbsp;</td><td>is the priority to be given to the task. The highest priority is 0, while the lowest is RT_SCHED_LOWEST_PRIORITY.</td></tr>
    <tr><td valign=top><em>uses_fpu</em>&nbsp;</td><td>is a flag. A nonzero value indicates that the task will use the floating point unit.</td></tr>
    <tr><td valign=top><em>signal</em>&nbsp;</td><td>is a function that is called, within the task environment and with interrupts disabled, when the task becomes the current running task after a context switch. Note however that signal is not called at the very first scheduling of the task. Such a function can be assigned and/or changed dynamically whenever needed (see function rt_task_signal_handler.)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task structure pointed by task is already in use;</li><li><b>ENOMEM</b>: stack_size bytes could not be allocated for the stack.</li></ul>
</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_task_init_cpuid">rt_task_init_cpuid</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a49" doxytag="sched_up.c::rt_task_init_cpuid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_task_init_cpuid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>rt_thread</em>)(int), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>stack_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>uses_fpu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>signal</em>)(void), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="anchor" name="rt_task_init_cpuid"></a> Creates a new real time task and assigns it to a single specific CPU.<p>
The newly created real time task is initially in a suspend state. It can be made active by calling: rt_task_make_periodic, rt_task_make_periodic_relative_ns, rt_task_resume.<p>
When used with the MUP scheduler rt_task_init automatically selects which CPU the task will run on, while with the SMP scheduler the task defaults to using any of the available CPUs. This assignment may be changed by calling rt_set_runnable_on_cpus or rt_set_runnable_on_cpuid. If cpuid is invalid rt_task_init_cpuid falls back to automatic CPU selection.<p>
Whatever scheduler is used on multiprocessor systems rt_task_init_cpuid allows to create a task and assign it to a single specific CPU cpuid from its very beginning, without any need to call rt_set_runnable_on_cpuid later on.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>is a pointer to an RT_TASK type structure whose space must be provided by the application. It must be kept during the whole lifetime of the real time task.</td></tr>
    <tr><td valign=top><em>rt_thread</em>&nbsp;</td><td>is the entry point of the task function.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The parent task can pass a single integer value data to the new task being created. Recall that an appropriately type casting allows data to be a pointer to whatever data structure one would like to pass to the task, so you can indirectly pass whatever you want to the task.</td></tr>
    <tr><td valign=top><em>stack_size</em>&nbsp;</td><td>is the size of the stack to be used by the new task. In sizing it recall to make room for any real time interrupt handler, as real time interrupts run on the stack of the task they interrupt. So try to avoid being too sparing.</td></tr>
    <tr><td valign=top><em>priority</em>&nbsp;</td><td>is the priority to be given to the task. The highest priority is 0, while the lowest is RT_SCHED_LOWEST_PRIORITY.</td></tr>
    <tr><td valign=top><em>uses_fpu</em>&nbsp;</td><td>is a flag. A nonzero value indicates that the task will use the floating point unit.</td></tr>
    <tr><td valign=top><em>signal</em>&nbsp;</td><td>is a function that is called, within the task environment and with interrupts disabled, when the task becomes the current running task after a context switch. Note however that signal is not called at the very first scheduling of the task. Such a function can be assigned and/or changed dynamically whenever needed (see function rt_task_signal_handler.)</td></tr>
    <tr><td valign=top><em>cpuid</em>&nbsp;</td><td>FIXME</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL</b>: task structure pointed by task is already in use;</li><li><b>ENOMEM</b>: stack_size bytes could not be allocated for the stack.</li></ul>
</dd></dl>
See also: <a class="el" href="sched__lxrt_8c.html#rt_task_init">rt_task_init</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a68" doxytag="sched_up.c::start_rt_apic_timers" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void start_rt_apic_timers </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct apic_timer_setup_data *&nbsp;</td>
          <td class="mdname" nowrap> <em>setup_mode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>rcvr_jiffies_cpuid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start local apic timer. 
<p>
<a class="anchor" name="start_rt_apic_timer"></a> <p>
start_rt_apic_timers starts local APIC timers according to what is found in <em>setup_data</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>setup_mode</em>&nbsp;</td><td>is a pointer to an array of structures apic_timer_setup_data, see function rt_setup_apic_timers (FIXME) in RTAI module functions described further on in this manual. </td></tr>
    <tr><td valign=top><em>rcvr_jiffies_cpuid</em>&nbsp;</td><td>is the CPU number whose time log has to be used to keep Linux timing and pacing in tune. This function is specific to the MUP scheduler. If it is called with either the UP or SMP scheduler it will use:<ul>
<li>a periodic timer if all local APIC timers are periodic with the same period;</li><li>a oneshot timer if all the local APIC timers are oneshot, or have different timing modes, are periodic with different periods. </li></ul>
</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a66" doxytag="sched_up.c::start_rt_timer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RTIME start_rt_timer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>period</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start timer. 
<p>
<a class="anchor" name="start_rt_timer"></a> <p>
start_rt_timer starts the timer with a period <em>period</em>. The period is in internal count units and is required only for the periodic mode. In the oneshot mode the period value is ignored. This functions uses the 8254 with the UP and the 8254 based SMP scheduler. Otherwise it uses a single local APIC with the APIC based SMP schedulers and an APIC for each CPU with the MUP scheduler. In the latter case all local APIC timers are paced in the same way, according to the timer mode set.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The period in internal count units. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a69" doxytag="sched_up.c::stop_rt_timer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void stop_rt_timer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stop timer. 
<p>
<a class="anchor" name="stop_rt_timer"></a> <p>
stop_rt_timer stops the timer. The timer mode is set to periodic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The period in internal count units. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:17 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
