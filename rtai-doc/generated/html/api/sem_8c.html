<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: sem.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/ipc/sem/sem.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Semaphore functions. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>Paolo Mantegazza</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Copyright (C) 1999-2003 Paolo Mantegazza &lt;<a href="mailto:mantegazza@aero.polimi.it">mantegazza@aero.polimi.it</a>&gt;</dd></dl>
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.<p>
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.<p>
You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
<p>

<p>
Include dependency graph for sem.c:<p><center><img src="sem_8c__incl.png" border="0" usemap="#sem.c_map" alt="Include dependency graph"></center>
<map name="sem.c_map">
<area href="rtai__schedcore_8h-source.html" shape="rect" coords="115,154,225,173" alt="">
<area href="rtai__sem_8h.html" shape="rect" coords="97,15,169,34" alt="">
<area href="rtai__rwl_8h-source.html" shape="rect" coords="66,85,130,103" alt="">
<area href="rtai__spl_8h-source.html" shape="rect" coords="205,85,269,103" alt="">
<area href="rtai__registry_8h.html" shape="rect" coords="299,154,390,173" alt="">
</map>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a2">rt_typed_sem_init</a> (SEM *sem, int value, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a specifically typed (counting, binary, resource) semaphore. </em> <a href="group__sem.html#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a3">rt_sem_init</a> (SEM *sem, int value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a counting semaphore. </em> <a href="group__sem.html#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a4">rt_sem_delete</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a semaphore. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a6">rt_sem_signal</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signaling a semaphore. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a7">rt_sem_broadcast</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signaling a semaphore. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a8">rt_sem_wait</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take a semaphore. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a9">rt_sem_wait_if</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take a semaphore, only if the calling task is not blocked. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a10">rt_sem_wait_until</a> (SEM *sem, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a11">rt_sem_wait_timed</a> (SEM *sem, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a12">rt_sem_wait_barrier</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on a semaphore barrier. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a13">rt_cond_signal</a> (CND *cnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a signal to a conditional variable. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a15">rt_cond_wait</a> (CND *cnd, SEM *mtx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a signal to a conditional variable. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a16">rt_cond_wait_until</a> (CND *cnd, SEM *mtx, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a17">rt_cond_wait_timed</a> (CND *cnd, SEM *mtx, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a18">rt_rwl_init</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a multi readers single writer lock. </em> <a href="group__sem.html#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a19">rt_rwl_delete</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destroys a multi readers single writer lock. </em> <a href="group__sem.html#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a20">rt_rwl_rdlock</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">acquires a multi readers single writer lock for reading. </em> <a href="group__sem.html#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a21">rt_rwl_rdlock_if</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock just for reading. </em> <a href="group__sem.html#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a22">rt_rwl_rdlock_until</a> (RWL *rwl, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock for reading within an absolute deadline time. </em> <a href="group__sem.html#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a23">rt_rwl_rdlock_timed</a> (RWL *rwl, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock for reading within a relative deadline time. </em> <a href="group__sem.html#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a24">rt_rwl_wrlock</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">acquires a multi readers single writer lock for wrtiting. </em> <a href="group__sem.html#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a25">rt_rwl_wrlock_if</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">acquires a multi readers single writer lock for writing. </em> <a href="group__sem.html#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a26">rt_rwl_wrlock_until</a> (RWL *rwl, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock for writing within an absolute deadline time. </em> <a href="group__sem.html#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a27">rt_rwl_wrlock_timed</a> (RWL *rwl, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock for writing within a relative deadline time. </em> <a href="group__sem.html#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a28">rt_rwl_unlock</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unlock an acquired multi readers single writer lock. </em> <a href="group__sem.html#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a29">rt_spl_init</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a spinlock. </em> <a href="group__sem.html#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a30">rt_spl_delete</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a spinlock. </em> <a href="group__sem.html#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a31">rt_spl_lock</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire a spinlock. </em> <a href="group__sem.html#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a32">rt_spl_lock_if</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire a spinlock without waiting. </em> <a href="group__sem.html#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a33">rt_spl_lock_timed</a> (SPL *spl, unsigned long ns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire a spinlock with timeout. </em> <a href="group__sem.html#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a34">rt_spl_unlock</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release an owned spinlock. </em> <a href="group__sem.html#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>SEM *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a35">_rt_typed_named_sem_init</a> (unsigned long sem_name, int value, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a specifically typed (counting, binary, resource) semaphore identified by a name. </em> <a href="group__sem.html#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html#a36">rt_named_sem_delete</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a semaphore initialized in named mode. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RWL *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a37">_rt_named_rwl_init</a> (unsigned long rwl_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a multi readers single writer lock identified by a name. </em> <a href="group__sem.html#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a38">rt_named_rwl_delete</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a multi readers single writer lock in named mode. </em> <a href="group__sem.html#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>SPL *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a39">_rt_named_spl_init</a> (unsigned long spl_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a spinlock identified by a name. </em> <a href="group__sem.html#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a40">rt_named_spl_delete</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a spinlock in named mode. </em> <a href="group__sem.html#a40"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a13" doxytag="sem.c::rt_cond_signal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_cond_signal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cnd</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for a signal to a conditional variable. 
<p>
<a class="anchor" name="rt_cond_signal"></a><p>
rt_cond_signal resumes one of the tasks that are waiting on the condition semaphore cnd. Nothing happens if no task is waiting on <em>cnd</em>, while it resumed the first queued task blocked on cnd, according to the queueing method set at rt_cond_init.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#a348">rt_cond_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="sem.c::rt_cond_wait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_cond_wait </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname" nowrap> <em>cnd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>mtx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for a signal to a conditional variable. 
<p>
<a class="anchor" name="rt_cond_wait"></a><p>
rt_cond_wait atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signaled. The task execution is suspended until the condition semaphore is signalled. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait reacquires mtx by calling rt_sem_wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#a348">rt_cond_init</a>().</td></tr>
    <tr><td valign=top><em>mtx</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on succes, SEM_ERR in case of error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="sem.c::rt_cond_wait_timed" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_cond_wait_timed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname" nowrap> <em>cnd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>mtx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_cond_wait_timed"></a><p>
rt_cond_wait_timed atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signalled. The task execution is suspended until the condition semaphore is either signaled or a timeout expires. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait_until reacquires mtx by calling rt_sem_wait and returns a value to indicate if it has been signalled pr timedout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#a348">rt_cond_init</a>().</td></tr>
    <tr><td valign=top><em>mtx</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign=top><em>delay</em>&nbsp;</td><td>is a realtive time values with respect to the current time, in timer count unit.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if it was signaled, SEM_TIMOUT if a timeout occured, SEM_ERR if the task has been resumed because of any other action (likely cnd was deleted). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="sem.c::rt_cond_wait_until" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_cond_wait_until </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname" nowrap> <em>cnd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>mtx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_cond_wait_until"></a><p>
rt_cond_wait_until atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signalled. The task execution is suspended until the condition semaphore is either signaled or a timeout expires. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait_until reacquires mtx by calling rt_sem_wait and returns a value to indicate if it has been signalled pr timedout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#a348">rt_cond_init</a>().</td></tr>
    <tr><td valign=top><em>mtx</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign=top><em>time</em>&nbsp;</td><td>is an absolute value to the current time, in timer count unit.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if it was signaled, SEM_TIMOUT if a timeout occured, SEM_ERR if the task has been resumed because of any other action (likely cnd was deleted). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="sem.c::rt_named_sem_delete" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_named_sem_delete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a semaphore initialized in named mode. 
<p>
<a class="anchor" name="rt_named_sem_delete"></a><p>
rt_named_sem_delete deletes a semaphore previously created with <a class="el" href="sem_8c.html#_rt_typed_named_sem_init">_rt_typed_named_sem_init</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure pointer returned by a corresponding call to _rt_typed_named_sem_init.</td></tr>
  </table>
</dl>
Any tasks blocked on this semaphore is returned in error and allowed to run when semaphore is destroyed. As it is done by all the named allocation functions delete calls have just the effect of decrementing a usage count till the last is done, as that is the one the really frees the object.<p>
<dl compact><dt><b>Returns:</b></dt><dd>an int &gt;=0 is returned upon success, SEM_ERR if it failed to delete the semafore, -EFAULT if the semaphore does not exist anymore. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="sem.c::rt_sem_broadcast" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_broadcast </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signaling a semaphore. 
<p>
<a class="anchor" name="rt_sem_broadcast"></a><p>
rt_sem_broadcast signals an event to a semaphore that unblocks all tasks waiting on it. It is used as a support for RTAI proper conditional variables but can be of help in many other instances. After the broadcast the semaphore counts is set to zero, thus all tasks waiting on it will blocked.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="sem.c::rt_sem_delete" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_delete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a semaphore. 
<p>
<a class="anchor" name="rt_sem_delete"></a><p>
rt_sem_delete deletes a semaphore previously created with <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the corresponding call to rt_sem_init.</td></tr>
  </table>
</dl>
Any tasks blocked on this semaphore is returned in error and allowed to run when semaphore is destroyed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. A negative value is returned on failure as described below:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count, so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="sem.c::rt_sem_signal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_signal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signaling a semaphore. 
<p>
<a class="anchor" name="rt_sem_signal"></a><p>
rt_sem_signal signals an event to a semaphore. It is typically called when the task leaves a critical region. The semaphore value is incremented and tested. If the value is not positive, the first task in semaphore's waiting queue is allowed to run. rt_sem_signal never blocks the caller task.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. A negative value is returned on failure as described below:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count, so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. See <a class="el" href="rtai__sem_8h.html#rt_sem_wait">rt_sem_wait</a>() notes for some curiosities. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="sem.c::rt_sem_wait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_wait </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Take a semaphore. 
<p>
<a class="anchor" name="rt_sem_wait"></a><p>
rt_sem_wait waits for a event to be signaled to a semaphore. It is typically called when a task enters a critical region. The semaphore value is decremented and tested. If it is still non-negative rt_sem_wait returns immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case rt_sem_wait returns if:<ul>
<li>The caller task is in the first place of the waiting queue and another task issues a <a class="el" href="rtai__sem_8h.html#rt_sem_signal">rt_sem_signal</a>() call;</li><li>An error occurs (e.g. the semaphore is destroyed);</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. A special value" as described below in case of a failure :<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count, so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF.<br>
 Just for curiosity: the original Dijkstra notation for rt_sem_wait was a "P" operation, and rt_sem_signal was a "V" operation. The name for P comes from the Dutch "prolagen", a combination of "proberen" (to probe) and "verlagen" (to decrement). Also from the word "passeren" (to pass).<br>
 The name for V comes from the Dutch "verhogen" (to increase) or "vrygeven" (to release). (Source: Daniel Tabak - Multiprocessors, Prentice Hall, 1990).<br>
 It should be also remarked that real time programming practitioners were using semaphores a long time before Dijkstra formalized P and V. "In Italian semaforo" means a traffic light, so that semaphores have an intuitive appeal and their use and meaning is easily understood. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="sem.c::rt_sem_wait_barrier" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_wait_barrier </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait on a semaphore barrier. 
<p>
<a class="anchor" name="rt_sem_wait_barrier"></a><p>
rt_sem_wait_barrier is a gang waiting in that a task issuing such a request will be blocked till a number of tasks equal to the semaphore count set at rt_sem_init is reached.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="sem.c::rt_sem_wait_if" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_wait_if </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Take a semaphore, only if the calling task is not blocked. 
<p>
<a class="anchor" name="rt_sem_wait_if"></a><p>
rt_sem_wait_if is a version of the semaphore wait operation is similar to <a class="el" href="rtai__sem_8h.html#rt_sem_wait">rt_sem_wait</a>() but it is never blocks the caller. If the semaphore is not free, rt_sem_wait_if returns immediately and the semaphore value remains unchanged.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. A special value as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="sem.c::rt_sem_wait_timed" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_wait_timed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_sem_wait_timed"></a><p>
rt_sem_wait_timed, like <a class="el" href="rtai__sem_8h.html#rt_sem_wait_until">rt_sem_wait_until</a>(), is a timed version of the standard semaphore wait call. The semaphore value is decremented and tested. If it is still non-negative these functions return immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case the function returns if:<ul>
<li>The caller task is in the first place of the waiting queue and an other task issues a <a class="el" href="rtai__sem_8h.html#rt_sem_signal">rt_sem_signal</a>() call;</li><li>a timeout occurs;</li><li>an error occurs (e.g. the semaphore is destroyed);</li></ul>
<p>
In case of a timeout, the semaphore value is incremented before return.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign=top><em>delay</em>&nbsp;</td><td>is an absolute value to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. A special value as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="sem.c::rt_sem_wait_until" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_wait_until </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_sem_wait_until"></a><p>
rt_sem_wait_until, like <a class="el" href="rtai__sem_8h.html#rt_sem_wait_timed">rt_sem_wait_timed</a>() is a timed version of the standard semaphore wait call. The semaphore value is decremented and tested. If it is still non-negative these functions return immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case the function returns if:<ul>
<li>The caller task is in the first place of the waiting queue and an other task issues a <a class="el" href="rtai__sem_8h.html#rt_sem_signal">rt_sem_signal</a> call();</li><li>a timeout occurs;</li><li>an error occurs (e.g. the semaphore is destroyed);</li></ul>
<p>
In case of a timeout, the semaphore value is incremented before return.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign=top><em>time</em>&nbsp;</td><td>is an absolute value to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. Aa special value" as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:36:14 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
