<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Remote procedure call functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Remote procedure call functions<br>
<small>
[<a class="el" href="group__sched.html">RTAI schedulers modules</a>]</small>
</h1>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="ipc_2msg_2msg_8c.html">msg.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Message handling functions. <br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RT_TASK *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__rpc.html#a0">rt_rpc</a> (RT_TASK *task, unsigned int to_do, unsigned int *result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RT_TASK *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__rpc.html#a1">rt_rpc_if</a> (RT_TASK *task, unsigned int to_do, unsigned int *result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call, only if the calling task is not blocked. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RT_TASK *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__rpc.html#a2">rt_rpc_until</a> (RT_TASK *task, unsigned int to_do, unsigned int *result, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call with timeout. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RT_TASK *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__rpc.html#a3">rt_rpc_timed</a> (RT_TASK *task, unsigned int to_do, unsigned int *result, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call with timeout. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__rpc.html#a4">rt_isrpc</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if sender waits for reply or not. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RT_TASK *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__rpc.html#a5">rt_return</a> (RT_TASK *task, unsigned int result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends (returns) the result back to the task that made the related remote procedure call. </em> <a href="#a5"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a4" doxytag="msg.c::rt_isrpc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_isrpc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if sender waits for reply or not. 
<p>
<a class="anchor" name="rt_isrpc"></a> <p>
After receiving a message, by calling rt_isrpc a task can figure out whether the sender task <em>task</em> is waiting for a reply or not. That can be needed in the case one needs a server task that must provide services both to sends (FIXME) and rt_rtcs. No answer is required if the message sent by a <em>rt_send</em> function or the sender called <a class="el" href="ipc_2msg_2msg_8c.html#rt_rpc_timed">rt_rpc_timed</a>() or <a class="el" href="ipc_2msg_2msg_8c.html#rt_rpc_until">rt_rpc_until</a>() but it is already timed out.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>pointer to a task structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>If the task waits for a reply, a nonzero value is returned. Otherwise 0 is returned.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>rt_isrpc does not perform any check on pointer task. rt_isrpc cannot figure out what RPC result the sender is waiting for.<br>
 <a class="el" href="ipc_2msg_2msg_8c.html#rt_return">rt_return</a>() is intelligent enough to not send an answer to a task which is not waiting for it. Therefore using rt_isrpc is not necessary and discouraged. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="msg.c::rt_return" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RT_TASK* rt_return </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends (returns) the result back to the task that made the related remote procedure call. 
<p>
<a class="anchor" name="rt_return"></a> <p>
rt_return sends the result result to the task <em>task</em>. If the task calling rt_rpc previously is not waiting the answer (i.e. killed or timed out) this return message is silently discarded.<p>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that is got the reply) is returned. If the reply message has not been sent, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The reply message was not delivered.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.</dd></dl>
See also: notes under <a class="el" href="ipc_2msg_2msg_8c.html#rt_rpc">rt_rpc</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="msg.c::rt_rpc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RT_TASK* rt_rpc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>to_do</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a remote procedure call. 
<p>
<a class="anchor" name="rt_rpc"></a> <p>
rt_rpc makes a Remote Procedure Call (RPC). rt_rpc is used for synchronous inter task messaging as it sends the message <em>msg</em> to the task <em>task</em> then it always block waiting until a return is received from the called task. So the caller task is always blocked and queued up (queuing may happen in priority order or on FIFO base. This is determined by the compile time option MSG_PRIORD). The receiver task may get the message with any rt_receive function. It can send an answer with <a class="el" href="ipc_2msg_2msg_8c.html#rt_return">rt_return</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td valign=top><em>msg</em>&nbsp;</td><td>message to send.</td></tr>
    <tr><td valign=top><em>reply</em>&nbsp;</td><td>points to a buffer provided by the caller were the returned result message, any 4 bytes integer, is to be place.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If the message has not been sent (e.g. the task <em>task</em> was killed before receiving the message) 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: the receiver task was killed before receiving the message.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: rt_receive_*, <a class="el" href="ipc_2msg_2msg_8c.html#rt_return">rt_return</a>(), <a class="el" href="ipc_2msg_2msg_8c.html#rt_isrpc">rt_isrpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br>
 The trio <a class="el" href="ipc_2msg_2msg_8c.html#rt_rpc">rt_rpc</a>(), <a class="el" href="ipc_2msg_2msg_8c.html#rt_receive">rt_receive</a>(), <a class="el" href="ipc_2msg_2msg_8c.html#rt_return">rt_return</a>() implement functions similar to its peers send-receive-replay found in QNX, except that in RTAI only four bytes messages contained in any integer can be exchanged. That's so because we never needed anything different. Note also that we prefer the idea of calling a function by using a message and then wait for a return value since it is believed to give a better idea of what is meant for synchronous message passing. For a truly QNX like way of inter task messaging use the support module found in directory lxrt-informed. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="msg.c::rt_rpc_if" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RT_TASK* rt_rpc_if </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>to_do</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a remote procedure call, only if the calling task is not blocked. 
<p>
<a class="anchor" name="rt_rpc_if"></a> <p>
rt_rpc_if tries to make a Remote Procedure Call (RPC). If the receiver task is ready to accept a message rt_rpc_if sends the message <em>msg</em> then it always block until a return is received. In this case the caller task is blocked and queued up (queuing may happen in priority order or on FIFO base. This is determined by the compile time option MSG_PRIORD). If the receiver is not ready rt_rpc_if returns immediately. The receiver task may get the message with any rt_receive function. It can send the answer with <a class="el" href="ipc_2msg_2msg_8c.html#rt_return">rt_return</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td valign=top><em>msg</em>&nbsp;</td><td>message to send.</td></tr>
    <tr><td valign=top><em>reply</em>&nbsp;</td><td>points to a buffer provided by the caller.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The task <em>task</em> was not ready to receive the message or it was killed before sending the reply.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: notes under <a class="el" href="ipc_2msg_2msg_8c.html#rt_rpc">rt_rpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="msg.c::rt_rpc_timed" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RT_TASK* rt_rpc_timed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>to_do</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a remote procedure call with timeout. 
<p>
<a class="anchor" name="rt_rpc_timed"></a> <p>
rt_rpc_timed makes a Remote Procedure Call. It sends the message <em>msg</em> to the task <em>task</em> then always waits until a return is received or a timeout occurs. So the caller task is always blocked and queued up (queuing may happen in priority order or on FIFO base. This is determined by the compile time option MSG_PRIORD). The receiver task may get the message with any <a class="el" href="ipc_2msg_2msg_8c.html#rt_receive">rt_receive</a>() function. It can send the answer with <a class="el" href="ipc_2msg_2msg_8c.html#rt_return">rt_return</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td valign=top><em>msg</em>&nbsp;</td><td>message to send.</td></tr>
    <tr><td valign=top><em>reply</em>&nbsp;</td><td>points to a buffer provided by the caller.</td></tr>
    <tr><td valign=top><em>delay</em>&nbsp;</td><td>is relative to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent or no answer arrived, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The message could not be sent or the answer did not arrived in time.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="ipc_2msg_2msg_8c.html#rt_receive">rt_receive</a>(), <a class="el" href="ipc_2msg_2msg_8c.html#rt_return">rt_return</a>(), <a class="el" href="ipc_2msg_2msg_8c.html#rt_isrpc">rt_isrpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br>
 See also the notes under <a class="el" href="ipc_2msg_2msg_8c.html#rt_rpc">rt_rpc</a>(). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="msg.c::rt_rpc_until" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RT_TASK* rt_rpc_until </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>to_do</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a remote procedure call with timeout. 
<p>
<a class="anchor" name="rt_rpc_until"></a> <p>
rt_rpc_until makes a Remote Procedure Call. It sends the message <em>msg</em> to the task <em>task</em> then always waits until a return is received or a timeout occurs. So the caller task is always blocked and queued up (queuing may happen in priority order or on FIFO base. This is determined by the compile time option MSG_PRIORD). The receiver task may get the message with any <a class="el" href="ipc_2msg_2msg_8c.html#rt_receive">rt_receive</a>() function. It can send the answer with <a class="el" href="ipc_2msg_2msg_8c.html#rt_return">rt_return</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td valign=top><em>msg</em>&nbsp;</td><td>message to send.</td></tr>
    <tr><td valign=top><em>reply</em>&nbsp;</td><td>points to a buffer provided by the caller.</td></tr>
    <tr><td valign=top><em>time</em>&nbsp;</td><td>is an absolute value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent or no answer arrived, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The message could not be sent or the answer did not arrived in time.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="ipc_2msg_2msg_8c.html#rt_receive">rt_receive</a>(), <a class="el" href="ipc_2msg_2msg_8c.html#rt_return">rt_return</a>(), <a class="el" href="ipc_2msg_2msg_8c.html#rt_isrpc">rt_isrpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br>
 See also the notes under <a class="el" href="ipc_2msg_2msg_8c.html#rt_rpc">rt_rpc</a>(). </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Jun 18 18:14:48 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
