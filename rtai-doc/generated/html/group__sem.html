<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Semaphore functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Semaphore functions<br>
<small>
[<a class="el" href="group__sched.html">RTAI schedulers modules</a>]</small>
</h1>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sem_8c.html">sem.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Semaphore functions. <br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a2">rt_typed_sem_init</a> (SEM *sem, int value, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a specifically typed (counting, binary, resource) semaphore. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a3">rt_sem_init</a> (SEM *sem, int value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a counting semaphore. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a4">rt_sem_delete</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a semaphore. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a6">rt_sem_signal</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signaling a semaphore. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a7">rt_sem_broadcast</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signaling a semaphore. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a8">rt_sem_wait</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take a semaphore. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a9">rt_sem_wait_if</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take a semaphore, only if the calling task is not blocked. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a10">rt_sem_wait_until</a> (SEM *sem, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a11">rt_sem_wait_timed</a> (SEM *sem, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a12">rt_sem_wait_barrier</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on a semaphore barrier. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a13">rt_cond_signal</a> (CND *cnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a signal to a conditional variable. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a15">rt_cond_wait</a> (CND *cnd, SEM *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a signal to a conditional variable. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a16">rt_cond_wait_until</a> (CND *cnd, SEM *mutex, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a17">rt_cond_wait_timed</a> (CND *cnd, SEM *mutex, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a18">rt_rwl_init</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a multi readers single writer lock. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a19">rt_rwl_delete</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destroys a multi readers single writer lock. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a20">rt_rwl_rdlock</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">acquires a multi readers single writer lock just for reading. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a21">rt_rwl_rdlock_if</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock just for reading. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a22">rt_rwl_rdlock_until</a> (RWL *rwl, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock for reading within an absolute deadline time. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sem.html#a23">rt_rwl_rdlock_timed</a> (RWL *rwl, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock for reading within a relative deadline time. </em> <a href="#a23"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a13" doxytag="rtai_sem.h::rt_cond_signal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_cond_signal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cnd</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for a signal to a conditional variable. 
<p>
<a class="anchor" name="rt_cond_signal"></a><p>
rt_cond_signal resumes one of the tasks that are waiting on the condition semaphore cnd. Nothing happens if no task is waiting on cnd, while it resumed the first queued task blocked on cnd, according to the queueing method set at rt_cond_init.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to rt_cond_init().</td></tr>
  </table>
</dl>
returns 0 always.     </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="rtai_sem.h::rt_cond_wait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_cond_wait </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname" nowrap> <em>cnd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>mtx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for a signal to a conditional variable. 
<p>
<a class="anchor" name="rt_cond_wait"></a><p>
rt_cond_wait atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signaled. The task execution is suspended until the condition semaphore is signalled. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait reacquires mtx by calling rt_sem_wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to rt_cond_init().</td></tr>
    <tr><td valign=top><em>mtx</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on succes, SEM_ERR in case of error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="rtai_sem.h::rt_cond_wait_timed" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_cond_wait_timed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname" nowrap> <em>cnd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>mtx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_cond_wait_timed"></a><p>
rt_cond_wait_timed atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signalled. The task execution is suspended until the condition semaphore is either signaled or a timeout expires. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait_until reacquires mtx by calling rt_sem_wait and returns a value to indicate if it has been signalled pr timedout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to rt_cnd_init().</td></tr>
    <tr><td valign=top><em>mtx</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign=top><em>delay</em>&nbsp;</td><td>is a realtive time values with respect to the current time, in timer count unit.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if it was signaled, SEM_TIMOUT if a timeout occured, SEM_ERR if the task has been resumed because of any other action (likely cnd was deleted). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="rtai_sem.h::rt_cond_wait_until" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_cond_wait_until </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname" nowrap> <em>cnd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>mtx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_cond_wait_until"></a><p>
rt_cond_wait_until atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signalled. The task execution is suspended until the condition semaphore is either signaled or a timeout expires. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait_until reacquires mtx by calling rt_sem_wait and returns a value to indicate if it has been signalled pr timedout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to rt_cnd_init().</td></tr>
    <tr><td valign=top><em>mtx</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign=top><em>time</em>&nbsp;</td><td>is an absolute value to the current time, in timer count unit.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if it was signaled, SEM_TIMOUT if a timeout occured, SEM_ERR if the task has been resumed because of any other action (likely cnd was deleted). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="sem.c::rt_rwl_delete" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_rwl_delete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
destroys a multi readers single writer lock. 
<p>
<a class="anchor" name="rt_rwl_delete"></a><p>
rt_rwl_init destroys a multi readers single writer lock .<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if OK, SEM_ERR if anything went wrong. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="sem.c::rt_rwl_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_rwl_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a multi readers single writer lock. 
<p>
<a class="anchor" name="rt_rwl_init"></a><p>
rt_rwl_init initializes a multi readers single writer lock .<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
A multi readers single writer lock (RWL) is a synchronization mechanism that allows to have simultaneous read only access to an object, while only one task can have write access. A data set which is searched more frequently than it is changed can be usefuly controlled by using an rwl.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 if always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="sem.c::rt_rwl_rdlock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_rwl_rdlock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
acquires a multi readers single writer lock just for reading. 
<p>
<a class="anchor" name="rt_rwl_rdlock"></a><p>
rt_rwl_rdlock acquires a multi readers single writer lock  just for reading. The calling task will block only if there is a writer already or a task attempting to acquire write acces.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if OK, SEM_ERR if anything went wrong after being blocked. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="sem.c::rt_rwl_rdlock_if" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_rwl_rdlock_if </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
try to acquire a multi readers single writer lock just for reading. 
<p>
<a class="anchor" name="rt_rwl_rdlock_if"></a><p>
rt_rwl_rdlock tries to acquire a multi readers single writer lock  just for reading immediately, i.e. without blocking if a writer owns or is attempting to own the lock already.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the lock was acquired, -1 if the lock was already owned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="sem.c::rt_rwl_rdlock_timed" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_rwl_rdlock_timed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname" nowrap> <em>rwl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
try to acquire a multi readers single writer lock for reading within a relative deadline time. 
<p>
<a class="anchor" name="rt_rwl_rdlock_timed"></a><p>
rt_rwl_rdlock tries to acquire a multi readers single writer lock  just for reading, timing out if the lock has not been acquired within an assigned deadline.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
is the time delay within which the lock must be acquired, in internal count units.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the lock was acquired, SEM_TIMOUT if the deadline expired without acquiring the lock, SEM_ERR in case something went wrong. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="sem.c::rt_rwl_rdlock_until" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_rwl_rdlock_until </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname" nowrap> <em>rwl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
try to acquire a multi readers single writer lock for reading within an absolute deadline time. 
<p>
<a class="anchor" name="rt_rwl_rdlock_until"></a><p>
rt_rwl_rdlock tries to acquire a multi readers single writer lock  just for reading, timing out if the lock has not been acquired within an assigned deadline.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
is the time deadline, in internal count units.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the lock was acquired, SEM_TIMOUT if the deadline expired without acquiring the lock, SEM_ERR in case something went wrong. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="rtai_sem.h::rt_sem_broadcast" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_broadcast </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signaling a semaphore. 
<p>
<a class="anchor" name="rt_sem_broadcast"></a><p>
rt_sem_broadcast signals an event to a semaphore that unblocks all tasks waiting on it. It is used as a support for RTAI proper conditional variables but can be of help in many other instances. After the broadcast the semaphore counts is set to zero, thus all tasks waiting on it will blocked.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="rtai_sem.h::rt_sem_delete" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_delete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a semaphore. 
<p>
<a class="anchor" name="rt_sem_delete"></a><p>
rt_sem_delete deletes a semaphore previously created with <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the corresponding call to rt_sem_init.</td></tr>
  </table>
</dl>
Any tasks blocked on this semaphore is returned in error and allowed to run when semaphore is destroyed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. A negative value is returned on failure as described below:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count, so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="sem.c::rt_sem_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_sem_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a counting semaphore. 
<p>
<a class="anchor" name="rt_sem_init"></a><p>
rt_sem_init initializes a counting fifo queueing semaphore <em>sem</em>.<p>
A semaphore can be used for communication and synchronization among real time tasks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>must point to an allocated <em>SEM</em> structure.</td></tr>
    <tr><td valign=top><em>value</em>&nbsp;</td><td>is the initial value of the semaphore.</td></tr>
  </table>
</dl>
Positive values of the semaphore variable show how many tasks can do a <a class="el" href="rtai__sem_8h.html#rt_sem_wait">rt_sem_wait</a>() call without blocking. Negative value of a semaphore shows how many tasks are blocked on the semaphore queue, waiting to be awaken by calls to <a class="el" href="rtai__sem_8h.html#rt_sem_signal">rt_sem_signal</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>RTAI counting semaphores assume that their counter will never exceed 0xFFFF, such a number being used to signal returns in error. Thus also the initial count value cannot be greater than 0xFFFF. This is an old legacy function. RTAI 24.1.xx has also <a class="el" href="sem_8c.html#rt_typed_sem_init">rt_typed_sem_init</a>(), allowing to choose among counting, binary and resource semaphores. Resource semaphores have priority inherithance. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="rtai_sem.h::rt_sem_signal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_signal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signaling a semaphore. 
<p>
<a class="anchor" name="rt_sem_signal"></a><p>
rt_sem_signal signals an event to a semaphore. It is typically called when the task leaves a critical region. The semaphore value is incremented and tested. If the value is not positive, the first task in semaphore's waiting queue is allowed to run. rt_sem_signal never blocks the caller task.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. A negative value is returned on failure as described below:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count, so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. See <a class="el" href="rtai__sem_8h.html#rt_sem_wait">rt_sem_wait</a>() notes for some curiosities. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="rtai_sem.h::rt_sem_wait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_wait </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Take a semaphore. 
<p>
<a class="anchor" name="rt_sem_wait"></a><p>
rt_sem_wait waits for a event to be signaled to a semaphore. It is typically called when a task enters a critical region. The semaphore value is decremented and tested. If it is still non-negative rt_sem_wait returns immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case rt_sem_wait returns if:<ul>
<li>The caller task is in the first place of the waiting queue and another task issues a <a class="el" href="rtai__sem_8h.html#rt_sem_signal">rt_sem_signal</a>() call;</li><li>An error occurs (e.g. the semaphore is destroyed);</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. A special value" as described below in case of a failure :<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count, so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF.<br>
 Just for curiosity: the original Dijkstra notation for rt_sem_wait was a "P" operation, and rt_sem_signal was a "V" operation. The name for P comes from the Dutch "prolagen", a combination of "proberen" (to probe) and "verlagen" (to decrement). Also from the word "passeren" (to pass).<br>
 The name for V comes from the Dutch "verhogen" (to increase) or "vrygeven" (to release). (Source: Daniel Tabak - Multiprocessors, Prentice Hall, 1990).<br>
 It should be also remarked that real time programming practitioners were using semaphores a long time before Dijkstra formalized P and V. "In Italian semaforo" means a traffic light, so that semaphores have an intuitive appeal and their use and meaning is easily understood. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="rtai_sem.h::rt_sem_wait_barrier" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_wait_barrier </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait on a semaphore barrier. 
<p>
<a class="anchor" name="rt_sem_wait_barrier"></a><p>
rt_sem_wait_barrier is a gang waiting in that a task issuing such a request will be blocked till a number of tasks equal to the semaphore count set at rt_sem_init is reached.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="rtai_sem.h::rt_sem_wait_if" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_wait_if </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Take a semaphore, only if the calling task is not blocked. 
<p>
<a class="anchor" name="rt_sem_wait_if"></a><p>
rt_sem_wait_if is a version of the semaphore wait operation is similar to <a class="el" href="rtai__sem_8h.html#rt_sem_wait">rt_sem_wait</a>() but it is never blocks the caller. If the semaphore is not free, rt_sem_wait_if returns immediately and the semaphore value remains unchanged.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. A special value as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="rtai_sem.h::rt_sem_wait_timed" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_wait_timed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_sem_wait_timed"></a><p>
rt_sem_wait_timed, like <a class="el" href="rtai__sem_8h.html#rt_sem_wait_until">rt_sem_wait_until</a>(), is a timed version of the standard semaphore wait call. The semaphore value is decremented and tested. If it is still non-negative these functions return immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case the function returns if:<ul>
<li>The caller task is in the first place of the waiting queue and an other task issues a <a class="el" href="rtai__sem_8h.html#rt_sem_signal">rt_sem_signal</a>() call;</li><li>a timeout occurs;</li><li>an error occurs (e.g. the semaphore is destroyed);</li></ul>
<p>
In case of a timeout, the semaphore value is incremented before return.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign=top><em>delay</em>&nbsp;</td><td>is an absolute value to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. A special value as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="rtai_sem.h::rt_sem_wait_until" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_sem_wait_until </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_sem_wait_until"></a><p>
rt_sem_wait_until, like <a class="el" href="rtai__sem_8h.html#rt_sem_wait_timed">rt_sem_wait_timed</a>() is a timed version of the standard semaphore wait call. The semaphore value is decremented and tested. If it is still non-negative these functions return immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case the function returns if:<ul>
<li>The caller task is in the first place of the waiting queue and an other task issues a <a class="el" href="rtai__sem_8h.html#rt_sem_signal">rt_sem_signal</a> call();</li><li>a timeout occurs;</li><li>an error occurs (e.g. the semaphore is destroyed);</li></ul>
<p>
In case of a timeout, the semaphore value is incremented before return.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="sem_8c.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign=top><em>time</em>&nbsp;</td><td>is an absolute value to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. Aa special value" as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="sem.c::rt_typed_sem_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_typed_sem_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a specifically typed (counting, binary, resource) semaphore. 
<p>
<a class="anchor" name="rt_typed_sem_init"></a><p>
rt_typed_sem_init initializes a semaphore <em>sem</em> of type <em>type</em>. A semaphore can be used for communication and synchronization among real time tasks. Negative value of a semaphore shows how many tasks are blocked on the semaphore queue, waiting to be awaken by calls to rt_sem_signal.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>sem</em>&nbsp;</td><td>must point to an allocated SEM structure.</td></tr>
    <tr><td valign=top><em>value</em>&nbsp;</td><td>is the initial value of the semaphore, always set to 1 for a resource semaphore.</td></tr>
    <tr><td valign=top><em>type</em>&nbsp;</td><td>is the semaphore type and queuing policy. It can be an OR a semaphore kind: CNT_SEM for counting semaphores, BIN_SEM for binary semaphores, RES_SEM for resource semaphores; and queuing policy: FIFO_Q, PRIO_Q for a fifo and priority queueing respectively. Resource semaphores will enforce a PRIO_Q policy anyhow.</td></tr>
  </table>
</dl>
Counting semaphores can register up to 0xFFFE events. Binary semaphores do not count signalled events, their count will never exceed 1 whatever number of events is signaled to them. Resource semaphores are special binary semaphores suitable for managing resources. The task that acquires a resource semaphore becomes its owner, also called resource owner, since it is the only one capable of manipulating the resource the semaphore is protecting. The owner has its priority increased to that of any task blocking on a wait to the semaphore. Such a feature, called priority inheritance, ensures that a high priority task is never slaved to a lower priority one, thus allowing to avoid any deadlock due to priority inversion. Resource semaphores can be recursed, i.e. their task owner is not blocked by nested waits placed on an owned resource. The owner must insure that it will signal the semaphore, in reversed order, as many times as he waited on it. Note that that full priority inheritance is supported both for resource semaphores and inter task messages, for a singly owned resource. Instead it becomes an adaptive priority ceiling when a task owns multiple resources, including messages sent to him. In such a case in fact its priority is returned to its base one only when all such resources are released and no message is waiting for being received. This is a compromise design choice aimed at avoiding extensive searches for the new priority to be inherited across multiply owned resources and blocked tasks sending messages to him. Such a solution will be implemented only if it proves necessary. Note also that, to avoid <em>deadlocks</em>, a task owning a resource semaphore cannot be suspended. Any <a class="el" href="rtai__lxrt_8h.html#rt_task_suspend">rt_task_suspend</a>() posed on it is just registered. An owner task will go into suspend state only when it releases all the owned resources.<p>
<dl compact><dt><b>Note:</b></dt><dd>RTAI counting semaphores assume that their counter will never exceed 0xFFFF, such a number being used to signal returns in error. Thus also the initial count value cannot be greater than 0xFFFF. To be used only with RTAI24.x.xx (FIXME). </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Jun 18 22:38:09 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
