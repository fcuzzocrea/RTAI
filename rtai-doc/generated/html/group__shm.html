<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Unified RTAI real-time memory management.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Unified RTAI real-time memory management.</h1>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="rtai__nam2num_8h.html">rtai_nam2num.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion between characters strings and unsigned long identifiers. <br><br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="rtai__scb_8h.html">rtai_scb.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SCB stand for Shared (memory) Circular Buffer. <br><br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="rtai__shm_8h.html">rtai_shm.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface of the <a class="el" href="group__shm.html">RTAI SHM module</a>. <br><br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align=right valign=top>file &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="shm_8c.html">shm.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the <a class="el" href="group__shm.html">RTAI SHM module</a>. <br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a52">rtai_kmalloc</a>(name, size)&nbsp;&nbsp;&nbsp;rt_shm_alloc(name, size, USE_VMALLOC)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. </em> <a href="#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a53">rtai_kfree</a>(name)&nbsp;&nbsp;&nbsp;rt_shm_free(name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. </em> <a href="#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a57">rtai_malloc</a>(name, size)&nbsp;&nbsp;&nbsp;_rt_shm_alloc(0, name, size, USE_VMALLOC, 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. </em> <a href="#a57"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a58">rt_shm_alloc_adr</a>(start_address, name, size, suprt)&nbsp;&nbsp;&nbsp;_rt_shm_alloc(start_address, name, size, suprt, 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. </em> <a href="#a58"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a60">rtai_malloc_adr</a>(start_address, name, size)&nbsp;&nbsp;&nbsp;_rt_shm_alloc(start_address, name, size, USE_VMALLOC, 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. </em> <a href="#a60"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a61">rtai_free</a>(name, adr)&nbsp;&nbsp;&nbsp;rt_shm_free(name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. </em> <a href="#a61"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a62">rt_heap_close</a>(name, adr)&nbsp;&nbsp;&nbsp;rt_shm_free(name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a real time group heap being shared inter-intra kernel modules and Linux processes. </em> <a href="#a62"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a72">rt_global_heap_open</a>()&nbsp;&nbsp;&nbsp;rt_heap_open(GLOBAL_HEAP_ID, 0, 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the global real time heap to be shared inter-intra kernel modules and Linux processes. </em> <a href="#a72"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a73">rt_global_heap_close</a>()&nbsp;&nbsp;&nbsp;rt_heap_close(GLOBAL_HEAP_ID, 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the global real time heap being shared inter-intra kernel modules and Linux processes. </em> <a href="#a73"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a8">rt_shm_free</a> (unsigned long name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a9">rt_halloc</a> (int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of a group real time heap in kernel/user space. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a10">rt_hfree</a> (void *addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of a group real time heap. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a11">rt_named_halloc</a> (unsigned long name, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of a group real time heap in kernel/user space. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a12">rt_named_hfree</a> (void *addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of a group real time heap. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a13">rt_malloc_new</a> (int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of the global real time heap in kernel/user space. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a14">rt_free_new</a> (void *addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of the global real time heap. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a15">rt_named_malloc</a> (unsigned long name, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of the global real time heap in kernel/user space. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a16">rt_named_free</a> (void *addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a named chunk of the global real time heap. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a20">rt_shm_alloc</a> (unsigned long name, int size, int suprt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__shm.html#a39">rt_heap_open</a> (unsigned long name, int size, int suprt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open/create a named group real time heap to be shared inter-intra kernel modules and Linux processes. </em> <a href="#a39"></a><em><br><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a73" doxytag="rtai_shm.h::rt_global_heap_close" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rt_global_heap_close</td>
          <td class="md" valign="top">(&nbsp;</td>
&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_heap_close(GLOBAL_HEAP_ID, 0)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close the global real time heap being shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_global_heap_close is used to close the global real time heap.<p>
Closing a global heap in user space has just the effect of deregistering its use and unmapping the related memory from a process address space. In kernel tasks just the deregistration is performed. The global real time heap is destroyed just a the rmmoding of the shared memory module. </p>
    </td>
  </tr>
</table>
<a class="anchor" name="a72" doxytag="rtai_shm.h::rt_global_heap_open" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rt_global_heap_open</td>
          <td class="md" valign="top">(&nbsp;</td>
&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_heap_open(GLOBAL_HEAP_ID, 0, 0)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open the global real time heap to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_global_heap_open is used to open the global real time heap.<p>
The global heap is created by the shared memory module and its opening is needed in user space to map it to the process address space. In kernel space opening the global heap in a task is not required but should be done anyhow, both for symmetry and to register its usage. </p>
    </td>
  </tr>
</table>
<a class="anchor" name="a62" doxytag="rtai_shm.h::rt_heap_close" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rt_heap_close</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>adr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_shm_free(name)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a real time group heap being shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_heap_close is used to close a previously opened real time group heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is the unsigned long identifier used to identify the hep.</td></tr>
  </table>
</dl>
Analogously to what done by any allocation function this group real time heap closing call have just the effect of decrementing a usage count, unmapping any user space heap being closed, till the last is done, as that is the one the really closes the group heap, freeing any allocated memory.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the size of the succesfully freed heap, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a58" doxytag="rtai_shm.h::rt_shm_alloc_adr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rt_shm_alloc_adr</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">start_address,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>name,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>suprt&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_rt_shm_alloc(start_address, name, size, suprt, 0)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. 
<p>
rt_shm_alloc_adr is used to allocate in user space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>start_address</em>&nbsp;</td><td>is a user desired address where the allocated memory should be mapped in user space;</td></tr>
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>is the amount of required shared memory.</td></tr>
    <tr><td valign=top><em>suprt</em>&nbsp;</td><td>is the kernel allocation method to be used, it can be:<ul>
<li>USE_VMALLOC, use vmalloc;</li><li>USE_GFP_KERNEL, use kmalloc with GFP_KERNEL;</li><li>USE_GFP_ATOMIC, use kmalloc with GFP_ATOMIC;</li><li>USE_GFP_DMA, use kmalloc with GFP_DMA.</li></ul>
</td></tr>
  </table>
</dl>
Since <code>name</code> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd>the functions <a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
It must be remarked that only the very first call does a real allocation, any subsequent call to allocate with the same name from anywhere will just increase the usage count and map the area to user space, or return the related pointer to the already allocated space in kernel space. The function returns a pointer to the allocated memory, appropriately mapped to the memory space in use. So if one is really sure that the named shared memory has been allocated already parameters size and suprt are not used and can be assigned any value.<p>
<dl compact><dt><b>Note:</b></dt><dd>If the same process calls rtai_malloc_adr and <a class="el" href="group__shm.html#a57">rtai_malloc()</a> twice in the same process it get a zero return value on the second call.</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a61" doxytag="rtai_shm.h::rtai_free" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rtai_free</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>adr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_shm_free(name)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. 
<p>
rtai_free is used to free a shared memory chunk from user space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is the unsigned long identifier used when the memory was allocated;</td></tr>
  </table>
</dl>
rtai_free is a legacy helper macro, the real job is carried out by a call to rt_shm_free with the same name. This function should not be used in newly developed applications. See rt_shm_alloc_adr for more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the size of the succesfully freed memory, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="rtai_shm.h::rtai_kfree" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rtai_kfree</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_shm_free(name)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. 
<p>
rtai_kfree is used to free a shared memory chunk from kernel space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is the unsigned long identifier used when the memory was allocated;</td></tr>
  </table>
</dl>
rtai_kfree is a legacy helper macro, the real job is carried out by a call to rt_shm_free with the same name. This function should not be used in newly developed applications. See rt_shm_free for more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the size of the succesfully freed memory, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a52" doxytag="rtai_shm.h::rtai_kmalloc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rtai_kmalloc</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_shm_alloc(name, size, USE_VMALLOC)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rtai_kalloc is used to allocate shared memory from kernel space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
  </table>
</dl>
rtai_kmalloc is a legacy helper macro, the real job is carried out by a call to <a class="el" href="group__shm.html#a20">rt_shm_alloc()</a> with the same name, size and with vmalloc support. This function should not be used in newly developed applications. See rt_shm_alloc for more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a57" doxytag="rtai_shm.h::rtai_malloc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rtai_malloc</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_rt_shm_alloc(0, name, size, USE_VMALLOC, 0)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rtai_malloc is used to allocate shared memory from user space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
  </table>
</dl>
rtai_malloc is a legacy helper macro, the real job is carried out by a call to <a class="el" href="group__shm.html#a20">rt_shm_alloc()</a> with the same name, size and with vmalloc support. This function should not be used in newly developed applications. See rt_shm_alloc fro more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a60" doxytag="rtai_shm.h::rtai_malloc_adr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define rtai_malloc_adr</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">start_address,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>name,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_rt_shm_alloc(start_address, name, size, USE_VMALLOC, 0)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rtai_malloc_adr is used to allocate shared memory from user space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>start_address</em>&nbsp;</td><td>size is the amount of required shared memory.</td></tr>
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
  </table>
</dl>
rtai_malloc_adr is a legacy helper macro, the real job is carried out by a call to <a class="el" href="group__shm.html#a58">rt_shm_alloc_adr()</a> with the same name, size and with vmalloc support. This function should not be used in newly developed applications. See rt_shm_alloc_adr for more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a14" doxytag="rtai_shm.h::rt_free_new" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_free_new </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>addr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a chunk of the global real time heap. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_free is used to free a previously allocated chunck of the global real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>addr</em>&nbsp;</td><td>is the address of the memory to be freed. </td></tr>
  </table>
</dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="rtai_shm.h::rt_halloc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void * rt_halloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of a group real time heap in kernel/user space. 
<p>
Since it is not named there is no chance to retrieve and share it elsewhere.<p><b>For internal use only.</b></p>
<p>
rt_halloc is used to allocate a non sharable piece of a group real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>size</em>&nbsp;</td><td>is the size of the requested memory in bytes;</td></tr>
  </table>
</dl>
A process/task must have opened the real time group heap to use and can use just one real time group heap. Be careful and avoid opening more than one group real time heap per process/task. If more than one is opened then just the last will used.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the pointer to the allocated memory, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="shm.c::rt_heap_open" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* rt_heap_open </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>suprt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open/create a named group real time heap to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_heap_open is used to allocate open/create a shared real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
    <tr><td valign=top><em>suprt</em>&nbsp;</td><td>is the kernel allocation method to be used, it can be:<ul>
<li>USE_VMALLOC, use vmalloc;</li><li>USE_GFP_KERNEL, use kmalloc with GFP_KERNEL;</li><li>USE_GFP_ATOMIC, use kmalloc with GFP_ATOMIC;</li><li>USE_GFP_DMA, use kmalloc with GFP_DMA.</li></ul>
</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
It must be remarked that only the very first open does a real allocation, any subsequent one with the same name from anywhere will just map the area to the user space, or return the related pointer to the already allocated memory in kernel space. In any case the functions return a pointer to the allocated memory, appropriately mapped to the memory space in use. Be careful and avoid opening more than one group heap per process/task, if more than one is opened then just the last will used.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="rtai_shm.h::rt_hfree" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_hfree </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>adr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a chunk of a group real time heap. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_hfree is used to free a previously allocated chunck of a group real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>adr</em>&nbsp;</td><td>is the address of the memory to be freed. </td></tr>
  </table>
</dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="rtai_shm.h::rt_malloc_new" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void * rt_malloc_new </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of the global real time heap in kernel/user space. 
<p>
Since it is not named there is no chance of retrieving and sharing it elsewhere.<p><b>For internal use only.</b></p>
<p>
rt_malloc is used to allocate a non sharable piece of the global real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>size</em>&nbsp;</td><td>is the size of the requested memory in bytes;</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the pointer to the allocated memory, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="rtai_shm.h::rt_named_free" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_named_free </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>adr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a named chunk of the global real time heap. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_named_free is used to free a previously allocated chunk of the global real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>adr</em>&nbsp;</td><td>is the address of the memory to be freed.</td></tr>
  </table>
</dl>
Analogously to what done by all the named allocation functions the freeing calls of named memory chunks have just the effect of decrementing its usage count, any shared piece of the global heap being freed only when the last is done, as that is the one the really frees any allocated memory. So one must be carefull not to use rt_free on a named global heap chunk, since it will force its unconditional immediate freeing. </p>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="rtai_shm.h::rt_named_halloc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void * rt_named_halloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of a group real time heap in kernel/user space. 
<p>
Since it is named it can be retrieved and shared everywhere among the group peers, i.e all processes/tasks that have opened the same group heap.<p><b>For internal use only.</b></p>
<p>
rt_named_halloc is used to allocate a sharable piece of a group real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
A process/task must have opened the real time group heap to use and can use just one real time group heap. Be careful and avoid opening more than one group real time heap per process/task. If more than one is opened then just the last will used. It must be remarked that only the very first call does a real allocation, any subsequent call with the same name will just increase the usage count and receive the appropriate pointer to the already allocated memory having the same name.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="rtai_shm.h::rt_named_hfree" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rt_named_hfree </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>adr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a chunk of a group real time heap. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_named_hfree is used to free a previously allocated chunk of the global real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>adr</em>&nbsp;</td><td>is the address of the memory to be freed.</td></tr>
  </table>
</dl>
Analogously to what done by all the named allocation functions the freeing calls of named memory chunks have just the effect of decrementing a usage count, any shared piece of the global heap being freed only when the last is done, as that is the one the really frees any allocated memory. So one must be carefull not to use rt_hfree on a named global heap chunk, since it will force its unconditional immediate freeing. </p>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="rtai_shm.h::rt_named_malloc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void * rt_named_malloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of the global real time heap in kernel/user space. 
<p>
Since it is named it can be retrieved and shared everywhere.<p><b>For internal use only.</b></p>
<p>
rt_named_malloc is used to allocate a sharable piece of the global real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
It must be remarked that only the very first call does a real allocation, any subsequent call to allocate with the same name will just increase the usage count and return the appropriate pointer to the already allocated memory having the same name. So if one is really sure that the named chunk has been allocated already the size parameter is not used and can be assigned any value.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="shm.c::rt_shm_alloc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* rt_shm_alloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>suprt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_shm_alloc is used to allocate shared memory.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
    <tr><td valign=top><em>suprt</em>&nbsp;</td><td>is the kernel allocation method to be used, it can be:<ul>
<li>USE_VMALLOC, use vmalloc;</li><li>USE_GFP_KERNEL, use kmalloc with GFP_KERNEL;</li><li>USE_GFP_ATOMIC, use kmalloc with GFP_ATOMIC;</li><li>USE_GFP_DMA, use kmalloc with GFP_DMA.</li></ul>
</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
It must be remarked that only the very first call does a real allocation, any following call to allocate with the same name from anywhere will just increase the usage count and maps the area to the user space, or return the related pointer to the already allocated space in kernel space. In any case the functions return a pointer to the allocated memory, appropriately mapped to the memory space in use. So if one is really sure that the named shared memory has been allocated already parameters size and suprt are not used and can be assigned any value.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="rtai_shm.h::rt_shm_free" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int rt_shm_free </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_shm_free is used to free a previously allocated shared memory.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>is the unsigned long identifier used when the memory was allocated;</td></tr>
  </table>
</dl>
Analogously to what done by all the named allocation functions the freeing calls have just the effect of decrementing a usage count, unmapping any user space shared memory being freed, till the last is done, as that is the one the really frees any allocated memory.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the size of the succesfully freed memory, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Jun 18 18:14:48 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
