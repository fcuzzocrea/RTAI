<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_lxrt.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">rtai-core</a>&nbsp;/&nbsp;<a class="el" href="dir_000019.html">include</a></div>
<h1>rtai_lxrt.h</h1><a href="rtai__lxrt_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00066 <span class="preprocessor">#ifndef _RTAI_LXRT_H</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_LXRT_H</span>
00068 <span class="preprocessor"></span>
00069 <span class="preprocessor">#include &lt;rtai_sched.h&gt;</span>
00070 <span class="preprocessor">#include &lt;<a class="code" href="rtai__nam2num_8h.html">rtai_nam2num.h</a>&gt;</span>
00071 
00072 <span class="comment">// scheduler</span>
00073 <span class="preprocessor">#define YIELD                            0</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#define SUSPEND                          1</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#define RESUME                           2</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_PERIODIC                    3</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#define WAIT_PERIOD                      4</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#define SLEEP                            5</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#define SLEEP_UNTIL                      6</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#define START_TIMER                      7</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#define STOP_TIMER                       8</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME                         9</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#define COUNT2NANO                      10</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#define NANO2COUNT                      11</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#define BUSY_SLEEP                      12</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#define SET_PERIODIC_MODE               13</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#define SET_ONESHOT_MODE                14</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#define SIGNAL_HANDLER                  15</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#define TASK_USE_FPU                    16</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#define LINUX_USE_FPU                   17</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define PREEMPT_ALWAYS_GEN              18</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_NS                     19</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#define GET_CPU_TIME_NS                 20</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#define SET_RUNNABLE_ON_CPUS            21 </span>
00095 <span class="preprocessor"></span><span class="preprocessor">#define SET_RUNNABLE_ON_CPUID           22       </span>
00096 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIMER_CPU                   23       </span>
00097 <span class="preprocessor"></span><span class="preprocessor">#define START_RT_APIC_TIMERS            24</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#define PREEMPT_ALWAYS_CPUID            25</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#define COUNT2NANO_CPUID                26</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#define NANO2COUNT_CPUID                27</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_CPUID                  28</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_NS_CPUID               29</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_PERIODIC_NS                30</span>
00104 <span class="preprocessor"></span><span class="preprocessor">#define SET_SCHED_POLICY                31</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#define SET_RESUME_END                  32</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#define SPV_RMS                         33</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#define WAKEUP_SLEEPING                 34</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#define CHANGE_TASK_PRIO                35</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#define SET_RESUME_TIME                 36</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#define SET_PERIOD                      37</span>
00111 <span class="preprocessor"></span><span class="preprocessor">#define HARD_TIMER_RUNNING              38</span>
00112 <span class="preprocessor"></span>
00113 <span class="comment">// semaphores</span>
00114 <span class="preprocessor">#define TYPED_SEM_INIT                  39</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#define SEM_DELETE                      40</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SEM_INIT                  41</span>
00117 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SEM_DELETE                42</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#define SEM_SIGNAL                      43</span>
00119 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT                        44</span>
00120 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_IF                     45</span>
00121 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_UNTIL                  46</span>
00122 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_TIMED                  47</span>
00123 <span class="preprocessor"></span><span class="preprocessor">#define SEM_BROADCAST                   48</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_BARRIER                49</span>
00125 <span class="preprocessor"></span><span class="preprocessor">#define SEM_COUNT                       50</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT                       51</span>
00127 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT_UNTIL                 52</span>
00128 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT_TIMED                 53</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#define RWL_INIT                        54</span>
00130 <span class="preprocessor"></span><span class="preprocessor">#define RWL_DELETE                      55</span>
00131 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_RWL_INIT                  56</span>
00132 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_RWL_DELETE                57</span>
00133 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK                      58</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_IF                   59</span>
00135 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_UNTIL                60</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_TIMED                61</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK                      62      </span>
00138 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_IF                   63</span>
00139 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_UNTIL                64</span>
00140 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_TIMED                65</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#define RWL_UNLOCK                      66</span>
00142 <span class="preprocessor"></span><span class="preprocessor">#define SPL_INIT                        67</span>
00143 <span class="preprocessor"></span><span class="preprocessor">#define SPL_DELETE                      68</span>
00144 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SPL_INIT                  69</span>
00145 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SPL_DELETE                70</span>
00146 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK                        71      </span>
00147 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK_IF                     72</span>
00148 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK_TIMED                  73</span>
00149 <span class="preprocessor"></span><span class="preprocessor">#define SPL_UNLOCK                      74</span>
00150 <span class="preprocessor"></span>
00151 <span class="comment">// mail boxes</span>
00152 <span class="preprocessor">#define TYPED_MBX_INIT                  75</span>
00153 <span class="preprocessor"></span><span class="preprocessor">#define MBX_DELETE                      76</span>
00154 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MBX_INIT                  77</span>
00155 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MBX_DELETE                78</span>
00156 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND                        79</span>
00157 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_WP                     80</span>
00158 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_IF                     81</span>
00159 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_UNTIL                  82</span>
00160 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_TIMED                  83</span>
00161 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE                     84</span>
00162 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_WP                  85</span>
00163 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_IF                  86</span>
00164 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_UNTIL               87</span>
00165 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_TIMED               88</span>
00166 <span class="preprocessor"></span><span class="preprocessor">#define MBX_EVDRP                       89</span>
00167 <span class="preprocessor"></span><span class="preprocessor">#define MBX_OVRWR_SEND                  90</span>
00168 <span class="preprocessor"></span>
00169 <span class="comment">// short intertask messages</span>
00170 <span class="preprocessor">#define SENDMSG                         91</span>
00171 <span class="preprocessor"></span><span class="preprocessor">#define SEND_IF                         92</span>
00172 <span class="preprocessor"></span><span class="preprocessor">#define SEND_UNTIL                      93</span>
00173 <span class="preprocessor"></span><span class="preprocessor">#define SEND_TIMED                      94</span>
00174 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEMSG                      95</span>
00175 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_IF                      96</span>
00176 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_UNTIL                   97</span>
00177 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_TIMED                   98</span>
00178 <span class="preprocessor"></span><span class="preprocessor">#define RPCMSG                          99</span>
00179 <span class="preprocessor"></span><span class="preprocessor">#define RPC_IF                         100</span>
00180 <span class="preprocessor"></span><span class="preprocessor">#define RPC_UNTIL                      101</span>
00181 <span class="preprocessor"></span><span class="preprocessor">#define RPC_TIMED                      102</span>
00182 <span class="preprocessor"></span><span class="preprocessor">#define EVDRP                          103</span>
00183 <span class="preprocessor"></span><span class="preprocessor">#define ISRPC                          104</span>
00184 <span class="preprocessor"></span><span class="preprocessor">#define RETURNMSG                      105</span>
00185 <span class="preprocessor"></span>
00186 <span class="comment">// extended intertask messages</span>
00187 <span class="preprocessor">#define RPCX                           106</span>
00188 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_IF                        107</span>
00189 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_UNTIL                     108</span>
00190 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_TIMED                     109</span>
00191 <span class="preprocessor"></span><span class="preprocessor">#define SENDX                          110</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_IF                       111</span>
00193 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_UNTIL                    112</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_TIMED                    113</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#define RETURNX                        114</span>
00196 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX                       115</span>
00197 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_IF                    116</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_UNTIL                 117</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_TIMED                 118</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#define EVDRPX                         119</span>
00201 <span class="preprocessor"></span>
00202 <span class="comment">// proxies</span>
00203 <span class="preprocessor">#define PROXY_ATTACH                   120</span>
00204 <span class="preprocessor"></span><span class="preprocessor">#define PROXY_DETACH                   121</span>
00205 <span class="preprocessor"></span><span class="preprocessor">#define PROXY_TRIGGER                  122</span>
00206 <span class="preprocessor"></span>
00207 
00208 <span class="comment">// synchronous user space specific intertask messages and related proxies</span>
00209 <span class="preprocessor">#define RT_SEND                        123</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#define RT_RECEIVE                     124</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#define RT_CRECEIVE                    125</span>
00212 <span class="preprocessor"></span><span class="preprocessor">#define RT_REPLY                       126</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#define RT_PROXY_ATTACH                127</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#define RT_PROXY_DETACH                128</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#define RT_TRIGGER                     129</span>
00216 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_ATTACH                 130</span>
00217 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_DETACH                 131</span>
00218 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_LOCATE                 132</span>
00219 <span class="preprocessor"></span>
00220 <span class="comment">// bits</span>
00221 <span class="preprocessor">#define BITS_INIT                      133      </span>
00222 <span class="preprocessor"></span><span class="preprocessor">#define BITS_DELETE                    134</span>
00223 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_BITS_INIT                135</span>
00224 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_BITS_DELETE              136</span>
00225 <span class="preprocessor"></span><span class="preprocessor">#define BITS_GET                       137</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#define BITS_RESET                     138</span>
00227 <span class="preprocessor"></span><span class="preprocessor">#define BITS_SIGNAL                    139</span>
00228 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT                      140</span>
00229 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_IF                   141              </span>
00230 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_UNTIL                142</span>
00231 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_TIMED                143</span>
00232 <span class="preprocessor"></span>
00233 <span class="comment">// typed mail boxes</span>
00234 <span class="preprocessor">#define TBX_INIT                       144</span>
00235 <span class="preprocessor"></span><span class="preprocessor">#define TBX_DELETE                     145</span>
00236 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TBX_INIT                 146</span>
00237 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TBX_DELETE               147</span>
00238 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND                       148</span>
00239 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_IF                    149</span>
00240 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_UNTIL                 150</span>
00241 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_TIMED                 151</span>
00242 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE                    152</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_IF                 153</span>
00244 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_UNTIL              154</span>
00245 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_TIMED              155</span>
00246 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST                  156</span>
00247 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_IF               157</span>
00248 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_UNTIL            158</span>
00249 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_TIMED            159</span>
00250 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT                     160</span>
00251 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_IF                  161</span>
00252 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_UNTIL               162</span>
00253 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_TIMED               163</span>
00254 <span class="preprocessor"></span>
00255 <span class="comment">// pqueue</span>
00256 <span class="preprocessor">#define MQ_OPEN                        164</span>
00257 <span class="preprocessor"></span><span class="preprocessor">#define MQ_RECEIVE                     165</span>
00258 <span class="preprocessor"></span><span class="preprocessor">#define MQ_SEND                        166</span>
00259 <span class="preprocessor"></span><span class="preprocessor">#define MQ_CLOSE                       167</span>
00260 <span class="preprocessor"></span><span class="preprocessor">#define MQ_GETATTR                     168</span>
00261 <span class="preprocessor"></span><span class="preprocessor">#define MQ_SETATTR                     169</span>
00262 <span class="preprocessor"></span><span class="preprocessor">#define MQ_NOTIFY                      170</span>
00263 <span class="preprocessor"></span><span class="preprocessor">#define MQ_UNLINK                      171</span>
00264 <span class="preprocessor"></span><span class="preprocessor">#define MQ_TIMEDRECEIVE                172</span>
00265 <span class="preprocessor"></span><span class="preprocessor">#define MQ_TIMEDSEND                   173</span>
00266 <span class="preprocessor"></span>
00267 <span class="comment">// named tasks init/delete</span>
00268 <span class="preprocessor">#define NAMED_TASK_INIT                174</span>
00269 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TASK_INIT_CPUID          175</span>
00270 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TASK_DELETE              176</span>
00271 <span class="preprocessor"></span>
00272 <span class="comment">// registry</span>
00273 <span class="preprocessor">#define GET_ADR                        177</span>
00274 <span class="preprocessor"></span><span class="preprocessor">#define GET_NAME                       178</span>
00275 <span class="preprocessor"></span>
00276 <span class="comment">// netrpc</span>
00277 <span class="preprocessor">#define NETRPC                         179</span>
00278 <span class="preprocessor"></span><span class="preprocessor">#define SEND_REQ_REL_PORT              180</span>
00279 <span class="preprocessor"></span><span class="preprocessor">#define DDN2NL                         181</span>
00280 <span class="preprocessor"></span><span class="preprocessor">#define SET_THIS_NODE                  182</span>
00281 <span class="preprocessor"></span><span class="preprocessor">#define FIND_ASGN_STUB                 183</span>
00282 <span class="preprocessor"></span><span class="preprocessor">#define REL_STUB                       184      </span>
00283 <span class="preprocessor"></span><span class="preprocessor">#define WAITING_RETURN                 185</span>
00284 <span class="preprocessor"></span>
00285 <span class="comment">// a semaphore extension</span>
00286 <span class="preprocessor">#define COND_SIGNAL                    186</span>
00287 <span class="preprocessor"></span>
00288 <span class="comment">// new shm</span>
00289 <span class="preprocessor">#define SHM_ALLOC                      187</span>
00290 <span class="preprocessor"></span><span class="preprocessor">#define SHM_FREE                       188</span>
00291 <span class="preprocessor"></span><span class="preprocessor">#define SHM_SIZE                       189</span>
00292 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_SET                       190</span>
00293 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_ALLOC                     191</span>
00294 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_FREE                      192</span>
00295 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_NAMED_ALLOC               193</span>
00296 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_NAMED_FREE                194</span>
00297 <span class="preprocessor"></span><span class="preprocessor">#define MALLOC                         195</span>
00298 <span class="preprocessor"></span><span class="preprocessor">#define FREE                           196</span>
00299 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MALLOC                   197</span>
00300 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_FREE                     198</span>
00301 <span class="preprocessor"></span>
00302 <span class="preprocessor">#define MAX_LXRT_FUN                   200</span>
00303 <span class="preprocessor"></span>
00304 <span class="comment">// not recovered yet </span>
00305 <span class="comment">// Qblk's </span>
00306 <span class="preprocessor">#define RT_INITTICKQUEUE                69</span>
00307 <span class="preprocessor"></span><span class="preprocessor">#define RT_RELEASETICKQUEUE             70</span>
00308 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNALLOC                    71</span>
00309 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNFREE                     72</span>
00310 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNINIT                     73</span>
00311 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKWAIT                     74</span>
00312 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKREPEAT                   75</span>
00313 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKSOON                     76</span>
00314 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKDEQUEUE                  77</span>
00315 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKCANCEL                   78</span>
00316 <span class="preprocessor"></span><span class="preprocessor">#define RT_QSYNC                        79</span>
00317 <span class="preprocessor"></span><span class="preprocessor">#define RT_QRECEIVE                     80</span>
00318 <span class="preprocessor"></span><span class="preprocessor">#define RT_QLOOP                        81</span>
00319 <span class="preprocessor"></span><span class="preprocessor">#define RT_QSTEP                        82</span>
00320 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKBEFORE                   83</span>
00321 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKAFTER                    84</span>
00322 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKUNHOOK                   85</span>
00323 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKRELEASE                  86</span>
00324 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKCOMPLETE                 87</span>
00325 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKFLUSH                   88</span>
00326 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKATHEAD                   89</span>
00327 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKATTAIL                   90</span>
00328 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKINIT                    91</span>
00329 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKRELEASE                 92</span>
00330 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKSCHEDULE                 93</span>
00331 <span class="preprocessor"></span><span class="preprocessor">#define RT_GETTICKQUEUEHOOK             94</span>
00332 <span class="preprocessor"></span><span class="comment">// Testing</span>
00333 <span class="preprocessor">#define RT_BOOM                         95</span>
00334 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_MALLOC                     96</span>
00335 <span class="preprocessor"></span><span class="preprocessor">#define RT_FREE                         97</span>
00336 <span class="preprocessor"></span><span class="preprocessor">#define RT_MMGR_STATS                   98</span>
00337 <span class="preprocessor"></span><span class="preprocessor">#define RT_STOMP                        99</span>
00338 <span class="preprocessor"></span><span class="comment">// VC</span>
00339 <span class="preprocessor">#define RT_VC_ATTACH                    100</span>
00340 <span class="preprocessor"></span><span class="preprocessor">#define RT_VC_RELEASE                   101</span>
00341 <span class="preprocessor"></span><span class="preprocessor">#define RT_VC_RESERVE                   102</span>
00342 <span class="preprocessor"></span><span class="comment">// Linux Signal Support</span>
00343 <span class="preprocessor">#define RT_GET_LINUX_SIGNAL             103</span>
00344 <span class="preprocessor"></span><span class="preprocessor">#define RT_GET_ERRNO                    104</span>
00345 <span class="preprocessor"></span><span class="preprocessor">#define RT_SET_LINUX_SIGNAL_HANDLER     105</span>
00346 <span class="preprocessor"></span><span class="comment">// end of not recovered yet</span>
00347 
00348 <span class="preprocessor">#define LXRT_GET_ADR            1000</span>
00349 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_GET_NAME           1001</span>
00350 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_TASK_INIT          1002</span>
00351 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_TASK_DELETE        1003</span>
00352 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SEM_INIT           1004</span>
00353 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SEM_DELETE         1005</span>
00354 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_MBX_INIT           1006</span>
00355 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_MBX_DELETE         1007</span>
00356 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_SOFT_RT            1008</span>
00357 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_HARD_RT            1009</span>
00358 <span class="preprocessor"></span><span class="preprocessor">#define PRINT_TO_SCREEN         1010</span>
00359 <span class="preprocessor"></span><span class="preprocessor">#define NONROOT_HRT             1011</span>
00360 <span class="preprocessor"></span><span class="preprocessor">#define RT_BUDDY                1012</span>
00361 <span class="preprocessor"></span><span class="preprocessor">#define HRT_USE_FPU             1013</span>
00362 <span class="preprocessor"></span><span class="preprocessor">#define USP_SIGHDL              1014</span>
00363 <span class="preprocessor"></span><span class="preprocessor">#define GET_USP_FLAGS           1015</span>
00364 <span class="preprocessor"></span><span class="preprocessor">#define SET_USP_FLAGS           1016</span>
00365 <span class="preprocessor"></span><span class="preprocessor">#define GET_USP_FLG_MSK         1017</span>
00366 <span class="preprocessor"></span><span class="preprocessor">#define SET_USP_FLG_MSK         1018</span>
00367 <span class="preprocessor"></span><span class="preprocessor">#define IS_HARD                 1019</span>
00368 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_FORK               1020</span>
00369 <span class="preprocessor"></span><span class="preprocessor">#define ALLOC_REGISTER          1021</span>
00370 <span class="preprocessor"></span><span class="preprocessor">#define DELETE_DEREGISTER       1022</span>
00371 <span class="preprocessor"></span><span class="preprocessor">#define FORCE_TASK_SOFT         1023</span>
00372 <span class="preprocessor"></span><span class="preprocessor">#define PRINTK                  1024</span>
00373 <span class="preprocessor"></span><span class="preprocessor">#define GET_EXECTIME            1025</span>
00374 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIMEORIG            1026</span>
00375 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_RWL_INIT           1027</span>
00376 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_RWL_DELETE         1028</span>
00377 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SPL_INIT           1029</span>
00378 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SPL_DELETE         1030</span>
00379 <span class="preprocessor"></span>
00380 <span class="preprocessor">#define FORCE_SOFT 0x80000000</span>
00381 <span class="preprocessor"></span>
00382 <span class="preprocessor">#ifdef __KERNEL__</span>
00383 <span class="preprocessor"></span>
00384 <span class="preprocessor">#include &lt;asm/rtai_lxrt.h&gt;</span>
00385 
00386 <span class="comment">/*</span>
00387 <span class="comment">     Encoding of system call argument</span>
00388 <span class="comment">            31                                    0  </span>
00389 <span class="comment">soft SRQ    .... |||| |||| |||| .... .... .... ....  0 - 4095 max</span>
00390 <span class="comment">int  NARG   .... .... .... .... |||| |||| |||| ||||  </span>
00391 <span class="comment">arg  INDX   |||| .... .... .... .... .... .... ....</span>
00392 <span class="comment">*/</span>
00393 
00394 <span class="comment">/*</span>
00395 <span class="comment">These USP (unsigned long long) type fields allow to read and write up to 2 arguments.  </span>
00396 <span class="comment">                                               </span>
00397 <span class="comment">RW marker .... .... .... .... .... .... .... ..|| .... .... .... .... .... .... .... ...|</span>
00398 <span class="comment"></span>
00399 <span class="comment">HIGH unsigned long encodes writes</span>
00400 <span class="comment">W ARG1 BF .... .... .... .... .... ...| |||| ||..</span>
00401 <span class="comment">W ARG1 SZ .... .... .... .... |||| |||. .... ....</span>
00402 <span class="comment">W ARG2 BF .... .... .||| |||| .... .... .... ....</span>
00403 <span class="comment">W ARG2 SZ ..|| |||| |... .... .... .... .... ....</span>
00404 <span class="comment">W 1st  LL .|.. .... .... .... .... .... .... ....</span>
00405 <span class="comment">W 2nd  LL |... .... .... .... .... .... .... ....</span>
00406 <span class="comment"></span>
00407 <span class="comment">LOW unsigned long encodes reads</span>
00408 <span class="comment">R ARG1 BF .... .... .... .... .... ...| |||| ||..</span>
00409 <span class="comment">R ARG1 SZ .... .... .... .... |||| |||. .... ....</span>
00410 <span class="comment">R ARG2 BF .... .... .||| |||| .... .... .... ....</span>
00411 <span class="comment">R ARG2 SZ ..|| |||| |... .... .... .... .... ....</span>
00412 <span class="comment">R 1st  LL .|.. .... .... .... .... .... .... ....</span>
00413 <span class="comment">R 2nd  LL |... .... .... .... .... .... .... ....</span>
00414 <span class="comment"></span>
00415 <span class="comment">LOW unsigned long encodes also</span>
00416 <span class="comment">RT Switch .... .... .... .... .... .... .... ...|</span>
00417 <span class="comment"></span>
00418 <span class="comment">and </span>
00419 <span class="comment">Always 0  .... .... .... .... .... .... .... ..|.</span>
00420 <span class="comment"></span>
00421 <span class="comment">If SZ is zero sizeof(int) is copied by default, if LL bit is set sizeof(long long) is copied.</span>
00422 <span class="comment">*/</span>
00423 
00424 <span class="comment">// These are for setting appropriate bits in any function entry structure, OR</span>
00425 <span class="comment">// them in fun entry type to obtain the desired encoding</span>
00426 
00427 <span class="comment">// for writes</span>
00428 <span class="preprocessor">#define UW1(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9))) &lt;&lt; 32) | 0x300000001LL)</span>
00429 <span class="preprocessor"></span><span class="preprocessor">#define UW2(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23))) &lt;&lt; 32) | 0x300000001LL)</span>
00430 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ1LL      (0x4000000300000001LL)</span>
00431 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ2LL      (0x8000000300000001LL)</span>
00432 <span class="preprocessor"></span>
00433 <span class="comment">// for reads</span>
00434 <span class="preprocessor">#define UR1(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9) | 0x300000001LL)</span>
00435 <span class="preprocessor"></span><span class="preprocessor">#define UR2(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23) | 0x300000001LL)</span>
00436 <span class="preprocessor"></span><span class="preprocessor">#define URSZ1LL      (0x340000001LL)</span>
00437 <span class="preprocessor"></span><span class="preprocessor">#define URSZ2LL      (0x380000001LL)</span>
00438 <span class="preprocessor"></span>
00439 <span class="comment">// and these are for deciding what to do in lxrt.c</span>
00440 <span class="preprocessor">#define NEED_TO_RW(x)   (((unsigned long *)&amp;(x))[HIGH])</span>
00441 <span class="preprocessor"></span>
00442 <span class="preprocessor">#define NEED_TO_R(x)    (((unsigned long *)&amp;(x))[LOW]  &amp; 0x0000FFFC)</span>
00443 <span class="preprocessor"></span><span class="preprocessor">#define NEED_TO_W(x)    (((unsigned long *)&amp;(x))[HIGH] &amp; 0x0000FFFC)</span>
00444 <span class="preprocessor"></span>
00445 <span class="preprocessor">#define NEED_TO_R2ND(x) (((unsigned long *)&amp;(x))[LOW]  &amp; 0x3FFF0000)</span>
00446 <span class="preprocessor"></span><span class="preprocessor">#define NEED_TO_W2ND(x) (((unsigned long *)&amp;(x))[HIGH] &amp; 0x3FFF0000)</span>
00447 <span class="preprocessor"></span>
00448 <span class="preprocessor">#define USP_RBF1(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt;  2) &amp; 0x7F)</span>
00449 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ1(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt;  9) &amp; 0x7F)</span>
00450 <span class="preprocessor"></span><span class="preprocessor">#define USP_RBF2(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt; 16) &amp; 0x7F)</span>
00451 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ2(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt; 23) &amp; 0x7F)</span>
00452 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ1LL(x)   (((unsigned long *)&amp;(x))[LOW] &amp; 0x40000000)</span>
00453 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ2LL(x)   (((unsigned long *)&amp;(x))[LOW] &amp; 0x80000000)</span>
00454 <span class="preprocessor"></span>
00455 <span class="preprocessor">#define USP_WBF1(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt;  2) &amp; 0x7F)</span>
00456 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ1(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt;  9) &amp; 0x7F)</span>
00457 <span class="preprocessor"></span><span class="preprocessor">#define USP_WBF2(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt; 16) &amp; 0x7F)</span>
00458 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ2(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt; 23) &amp; 0x7F)</span>
00459 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ1LL(x)   (((unsigned long *)&amp;(x))[HIGH] &amp; 0x40000000)</span>
00460 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ2LL(x)   (((unsigned long *)&amp;(x))[HIGH] &amp; 0x80000000)</span>
00461 <span class="preprocessor"></span>
00462 <span class="preprocessor">#define SRQ(x)   (((x) &gt;&gt; 16) &amp; 0xFFF)</span>
00463 <span class="preprocessor"></span><span class="preprocessor">#define NARG(x)  ((x) &amp; 0xFFFF)</span>
00464 <span class="preprocessor"></span><span class="preprocessor">#define INDX(x)  (((x) &gt;&gt; 28) &amp; 0xF)</span>
00465 <span class="preprocessor"></span>
00466 <span class="keyword">struct </span>rt_fun_entry {
00467     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> type;
00468     <span class="keywordtype">void</span> *fun;
00469 };
00470 
00471 <span class="keyword">struct </span>rt_native_fun_entry {
00472     <span class="keyword">struct </span>rt_fun_entry fun;
00473     <span class="keywordtype">int</span> index;
00474 };
00475 
00476 <span class="keyword">extern</span> <span class="keyword">struct </span>rt_fun_entry rt_fun_lxrt[];
00477 
00478 <span class="preprocessor">#ifdef __cplusplus</span>
00479 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00480 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00481 
00482 <span class="preprocessor">#if CONFIG_RTAI_INTERNAL_LXRT_SUPPORT</span>
00483 <span class="preprocessor"></span> 
00484 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>rt_task_struct *pid2rttask(pid_t pid)
00485 {
00486         <span class="keywordflow">return</span> ((<span class="keywordtype">unsigned</span> long)pid) &gt; PID_MAX ? (<span class="keyword">struct </span>rt_task_struct *)pid : find_task_by_pid(pid)-&gt;this_rt_task[0];
00487 }
00488 
00489 <span class="keyword">static</span> <span class="keyword">inline</span> pid_t rttask2pid(<span class="keyword">struct</span> rt_task_struct * task)
00490 {
00491     <span class="keywordflow">return</span> task-&gt;lnxtsk ? task-&gt;lnxtsk-&gt;pid : (int) task;
00492 }
00493 
00494 <span class="preprocessor">#else </span><span class="comment">/* !CONFIG_RTAI_INTERNAL_LXRT_SUPPORT */</span>
00495 
00496 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>rt_task_struct *pid2rttask(pid_t pid)
00497 {
00498     <span class="keywordflow">return</span> 0;
00499 }
00500 
00501 <span class="comment">// The following might look strange but it must be so to work with</span>
00502 <span class="comment">// buddies also.</span>
00503 <span class="keyword">static</span> <span class="keyword">inline</span> pid_t rttask2pid(<span class="keyword">struct</span> rt_task_struct * task)
00504 {
00505     <span class="keywordflow">return</span> (int) task;
00506 }
00507 
00508 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_INTERNAL_LXRT_SUPPORT */</span>
00509 
00510 <span class="keywordtype">int</span> set_rtai_callback(<span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span>));
00511 
00512 <span class="keywordtype">void</span> remove_rtai_callback(<span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span>));
00513 
00514 <span class="keywordtype">void</span> linux_process_termination(<span class="keywordtype">void</span>);
00515 
00516 RT_TASK *rt_lxrt_whoami(<span class="keywordtype">void</span>);
00517 
00518 <span class="keywordtype">void</span> exec_func(<span class="keywordtype">void</span> (*func)(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> evn),
00519                <span class="keywordtype">void</span> *data,
00520                <span class="keywordtype">int</span> evn);
00521 
00522 <span class="keywordtype">int</span>  set_rt_fun_ext_index(<span class="keyword">struct</span> rt_fun_entry *fun,
00523                           <span class="keywordtype">int</span> idx);
00524 
00525 <span class="keywordtype">void</span> reset_rt_fun_ext_index(<span class="keyword">struct</span> rt_fun_entry *fun,
00526                             <span class="keywordtype">int</span> idx);
00527 
00528 <span class="preprocessor">#ifdef __cplusplus</span>
00529 <span class="preprocessor"></span>}
00530 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00531 
00532 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00533 
00534 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00535 <span class="preprocessor">#include &lt;sched.h&gt;</span>
00536 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00537 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00538 <span class="preprocessor">#include &lt;string.h&gt;</span>
00539 <span class="preprocessor">#include &lt;asm/rtai_lxrt.h&gt;</span>
00540 
00541 <span class="comment">/* including linux/module.h in user space does not work with SMP enabled kernel</span>
00542 <span class="comment">   we hence paste here the two definitions needed for rt_lxrt_loaded.</span>
00543 <span class="comment">*/</span>
00544 
00545 <span class="preprocessor">#define QM_INFO         5</span>
00546 <span class="preprocessor"></span>
00547 <span class="keyword">struct </span>module_info
00548 {
00549         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr;
00550         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size;
00551         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00552         <span class="keywordtype">long</span> usecount;
00553 };
00554 
00555 
00556 <span class="keyword">struct </span>apic_timer_setup_data;
00557 
00558 <span class="preprocessor">#define rt_grow_and_lock_stack(incr) \</span>
00559 <span class="preprocessor">        do { \</span>
00560 <span class="preprocessor">                char buf[incr]; \</span>
00561 <span class="preprocessor">                memset(buf, 0, incr); \</span>
00562 <span class="preprocessor">                mlockall(MCL_CURRENT | MCL_FUTURE); \</span>
00563 <span class="preprocessor">        } while (0)</span>
00564 <span class="preprocessor"></span>
00565 <span class="preprocessor">#define BIDX   0 // rt_fun_ext[0]</span>
00566 <span class="preprocessor"></span><span class="preprocessor">#define SIZARG sizeof(arg)</span>
00567 <span class="preprocessor"></span>
00568 <span class="preprocessor">#ifdef __cplusplus</span>
00569 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00570 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00571 
<a name="l00578"></a><a class="code" href="group__lxrt.html#ga0">00578</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_lxrt_loaded,(<span class="keywordtype">void</span>))
00579 {
00580     <span class="keywordtype">int</span> query_module(<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
00581                      <span class="keywordtype">int</span> which,
00582                      <span class="keywordtype">void</span> *buf,
00583                      size_t szbuf,
00584                      size_t *ret);
00585     <span class="keyword">struct </span>module_info modInfo;
00586     size_t retSize;
00587 
00588     <span class="keywordflow">return</span> query_module(<span class="stringliteral">"rtai_lxrt"</span>, QM_INFO, &amp;modInfo, 
00589                         <span class="keyword">sizeof</span>(modInfo), &amp;retSize);
00590 }
00591 
<a name="l00599"></a><a class="code" href="group__lxrt.html#ga1">00599</a> RTAI_PROTO(<span class="keywordtype">void</span> *,rt_get_adr,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name))
00600 {
00601         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name; } arg = { name };
00602         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_GET_ADR, &amp;arg).v[LOW];
00603 } 
00604 
<a name="l00613"></a><a class="code" href="group__lxrt.html#ga2">00613</a> RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_name,(<span class="keywordtype">void</span> *adr))
00614 {
00615         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *adr; } arg = { adr };
00616         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_GET_NAME, &amp;arg).i[LOW];
00617 }
00618 
00619 RTAI_PROTO(RT_TASK *,rt_task_init_schmod,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> max_msg_size, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> cpus_allowed))
00620 {
00621         <span class="keyword">struct </span>sched_param mysched;
00622         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, priority, stack_size, max_msg_size, cpus_allowed; } arg = { name, priority, stack_size, max_msg_size, cpus_allowed };
00623 
00624         mysched.sched_priority = sched_get_priority_max(policy) - priority;
00625         <span class="keywordflow">if</span> (mysched.sched_priority &lt; 1 ) {
00626                 mysched.sched_priority = 1;
00627         }
00628         <span class="keywordflow">if</span> (sched_setscheduler(0, policy, &amp;mysched) &lt; 0) {
00629                 <span class="keywordflow">return</span> 0;
00630         }
00631 
00632         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, LXRT_TASK_INIT, &amp;arg).v[LOW];
00633 }
00634 
00635 
<a name="l00689"></a><a class="code" href="group__lxrt.html#ga4">00689</a> RTAI_PROTO(RT_TASK *,rt_task_init,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> max_msg_size))
00690 {
00691         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, priority, stack_size, max_msg_size, cpus_allowed; } arg = { name, priority, stack_size, max_msg_size, 0xFF };
00692         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, LXRT_TASK_INIT, &amp;arg).v[LOW];
00693 }
00694 
00695 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_sched_policy,(RT_TASK *task, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> rr_quantum_ns))
00696 {
00697         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> policy; <span class="keywordtype">int</span> rr_quantum_ns; } arg = { task, policy, rr_quantum_ns };
00698         rtai_lxrt(BIDX, SIZARG, SET_SCHED_POLICY, &amp;arg);
00699 }
00700 
00701 RTAI_PROTO(<span class="keywordtype">int</span>,rt_change_prio,(RT_TASK *task, <span class="keywordtype">int</span> priority))
00702 {
00703         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> priority; } arg = { task, priority };
00704         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, CHANGE_TASK_PRIO, &amp;arg).i[LOW];
00705 }
00706 
<a name="l00719"></a><a class="code" href="group__lxrt.html#ga7">00719</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_make_soft_real_time,(<span class="keywordtype">void</span>))
00720 {
00721         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00722         rtai_lxrt(BIDX, SIZARG, MAKE_SOFT_RT, &amp;arg);
00723 }
00724 
00725 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_delete,(RT_TASK *task))
00726 {
00727         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00728         <a class="code" href="group__lxrt.html#ga7">rt_make_soft_real_time</a>();
00729         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_TASK_DELETE, &amp;arg).i[LOW];
00730 }
00731 
00732 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_yield,(<span class="keywordtype">void</span>))
00733 {
00734         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00735         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, YIELD, &amp;arg).i[LOW];
00736 }
00737 
00738 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_suspend,(RT_TASK *task))
00739 {
00740         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00741         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SUSPEND, &amp;arg).i[LOW];
00742 }
00743 
00744 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_resume,(RT_TASK *task))
00745 {
00746         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00747         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RESUME, &amp;arg).i[LOW];
00748 }
00749 
00750 RTAI_PROTO(<span class="keywordtype">int</span>, rt_task_make_periodic,(RT_TASK *task, RTIME start_time, RTIME period))
00751 {
00752         <span class="keyword">struct </span>{ RT_TASK *task; RTIME start_time, period; } arg = { task, start_time, period };
00753         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MAKE_PERIODIC, &amp;arg).i[LOW];
00754 }
00755 
00756 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_make_periodic_relative_ns,(RT_TASK *task, RTIME start_delay, RTIME period))
00757 {
00758         <span class="keyword">struct </span>{ RT_TASK *task; RTIME start_time, period; } arg = { task, start_delay, period };
00759         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MAKE_PERIODIC_NS, &amp;arg).i[LOW];
00760 }
00761 
00762 RTAI_PROTO(<span class="keywordtype">void</span>,rt_task_wait_period,(<span class="keywordtype">void</span>))
00763 {
00764         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00765         rtai_lxrt(BIDX, SIZARG, WAIT_PERIOD, &amp;arg);
00766 }
00767 
00768 RTAI_PROTO(<span class="keywordtype">void</span>,rt_sleep,(RTIME delay))
00769 {
00770         <span class="keyword">struct </span>{ RTIME delay; } arg = { delay };
00771         rtai_lxrt(BIDX, SIZARG, SLEEP, &amp;arg);
00772 }
00773 
00774 RTAI_PROTO(<span class="keywordtype">void</span>,rt_sleep_until,(RTIME time))
00775 {
00776         <span class="keyword">struct </span>{ RTIME time; } arg = { time };
00777         rtai_lxrt(BIDX, SIZARG, SLEEP_UNTIL, &amp;arg);
00778 }
00779 
00780 RTAI_PROTO(<span class="keywordtype">int</span>,rt_is_hard_timer_running,(<span class="keywordtype">void</span>))
00781 {
00782         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00783         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, HARD_TIMER_RUNNING, &amp;arg).i[LOW];
00784 }
00785 
00786 RTAI_PROTO(RTIME, start_rt_timer,(<span class="keywordtype">int</span> period))
00787 {
00788         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> period; } arg = { period };
00789         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, START_TIMER, &amp;arg).rt;
00790 }
00791 
00792 RTAI_PROTO(<span class="keywordtype">void</span>, stop_rt_timer,(<span class="keywordtype">void</span>))
00793 {
00794         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00795         rtai_lxrt(BIDX, SIZARG, STOP_TIMER, &amp;arg);
00796 }
00797 
00798 RTAI_PROTO(RTIME,rt_get_time,(<span class="keywordtype">void</span>))
00799 {
00800         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00801         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME, &amp;arg).rt;
00802 }
00803 
00804 RTAI_PROTO(RTIME,count2nano,(RTIME count))
00805 {
00806         <span class="keyword">struct </span>{ RTIME count; } arg = { count };
00807         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COUNT2NANO, &amp;arg).rt;
00808 }
00809 
00810 RTAI_PROTO(RTIME,nano2count,(RTIME nanos))
00811 {
00812         <span class="keyword">struct </span>{ RTIME nanos; } arg = { nanos };
00813         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NANO2COUNT, &amp;arg).rt;
00814 }
00815 
00816 RTAI_PROTO(<span class="keywordtype">void</span>,rt_busy_sleep,(<span class="keywordtype">int</span> ns))
00817 {
00818         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> ns; } arg = { ns };
00819         rtai_lxrt(BIDX, SIZARG, BUSY_SLEEP, &amp;arg);
00820 }
00821 
00822 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_periodic_mode,(<span class="keywordtype">void</span>))
00823 {
00824         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00825         rtai_lxrt(BIDX, SIZARG, SET_PERIODIC_MODE, &amp;arg);
00826 }
00827 
00828 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_oneshot_mode,(<span class="keywordtype">void</span>))
00829 {
00830         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00831         rtai_lxrt(BIDX, SIZARG, SET_ONESHOT_MODE, &amp;arg);
00832 }
00833 
00834 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_signal_handler,(RT_TASK *task, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>)))
00835 {
00836         <span class="keyword">struct </span>{ RT_TASK *task; void (*handler)(void); } arg = { task, handler };
00837         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SIGNAL_HANDLER, &amp;arg).i[LOW];
00838 }
00839 
00840 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_use_fpu,(RT_TASK *task, <span class="keywordtype">int</span> use_fpu_flag))
00841 {
00842         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> use_fpu_flag; } arg = { task, use_fpu_flag };
00843         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, RT_BUDDY, &amp;arg).v[LOW] != task) {
00844                 <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, TASK_USE_FPU, &amp;arg).i[LOW];
00845         } <span class="keywordflow">else</span> {
00846 <span class="comment">// note that it would be enough to do whatever FP op here to have it OK. But</span>
00847 <span class="comment">// that is scary if it is done when already in hard real time, and we do not</span>
00848 <span class="comment">// want to force users to call this before making it hard.</span>
00849                 rtai_lxrt(BIDX, SIZARG, HRT_USE_FPU, &amp;arg);
00850                 <span class="keywordflow">return</span> 0;
00851         }
00852 }
00853 
00854 RTAI_PROTO(<span class="keywordtype">int</span>,rt_buddy_task_use_fpu,(RT_TASK *task, <span class="keywordtype">int</span> use_fpu_flag))
00855 {
00856         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> use_fpu_flag; } arg = { task, use_fpu_flag };
00857         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, TASK_USE_FPU, &amp;arg).i[LOW];
00858 }
00859 
00860 RTAI_PROTO(<span class="keywordtype">int</span>,rt_linux_use_fpu,(<span class="keywordtype">int</span> use_fpu_flag))
00861 {
00862         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> use_fpu_flag; } arg = { use_fpu_flag };
00863         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LINUX_USE_FPU, &amp;arg).i[LOW];
00864 }
00865 
00866 RTAI_PROTO(<span class="keywordtype">void</span>,rt_preempt_always,(<span class="keywordtype">int</span> yes_no))
00867 {
00868         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> yes_no; } arg = { yes_no };
00869         rtai_lxrt(BIDX, SIZARG, PREEMPT_ALWAYS_GEN, &amp;arg);
00870 }
00871 
00872 RTAI_PROTO(RTIME,rt_get_time_ns,(<span class="keywordtype">void</span>))
00873 {
00874         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00875         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_NS, &amp;arg).rt;
00876 }
00877 
00878 RTAI_PROTO(RTIME,rt_get_cpu_time_ns,(<span class="keywordtype">void</span>))
00879 {
00880         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00881         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_CPU_TIME_NS, &amp;arg).rt;
00882 }
00883 
00884 <span class="preprocessor">#define rt_named_task_init(task_name, thread, data, stack_size, prio, uses_fpu, signal) \</span>
00885 <span class="preprocessor">        rt_task_init(nam2num(task_name), thread, data, stack_size, prio, uses_fpu, signal)</span>
00886 <span class="preprocessor"></span>
00887 <span class="preprocessor">#define rt_named_task_init_cpuid(task_name, thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu) \</span>
00888 <span class="preprocessor">        rt_task_init_cpuid(nam2num(task_name), thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu)</span>
00889 <span class="preprocessor"></span>
00890 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_runnable_on_cpus,(RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpu_mask))
00891 {
00892         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpu_mask; } arg = { task, cpu_mask };
00893         rtai_lxrt(BIDX, SIZARG, SET_RUNNABLE_ON_CPUS, &amp;arg);
00894 }
00895 
00896 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_runnable_on_cpuid,(RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00897 {
00898         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { task, cpuid };
00899         rtai_lxrt(BIDX, SIZARG, SET_RUNNABLE_ON_CPUID, &amp;arg);
00900 }
00901 
00902 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_timer_cpu,(<span class="keywordtype">void</span>))
00903 {
00904         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00905         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIMER_CPU, &amp;arg).i[LOW];
00906 }
00907 
00908 RTAI_PROTO(<span class="keywordtype">void</span>,start_rt_apic_timers,(<span class="keyword">struct</span> apic_timer_setup_data *setup_mode, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rcvr_jiffies_cpuid))
00909 {
00910         <span class="keyword">struct </span>{ <span class="keyword">struct </span>apic_timer_setup_data *setup_mode; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rcvr_jiffies_cpuid; } arg = { setup_mode, rcvr_jiffies_cpuid };
00911         rtai_lxrt(BIDX, SIZARG, START_RT_APIC_TIMERS, &amp;arg);
00912 }
00913 
00914 RTAI_PROTO(<span class="keywordtype">void</span>,rt_preempt_always_cpuid,(<span class="keywordtype">int</span> yes_no, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00915 {
00916         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> yes_no; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { yes_no, cpuid };
00917         rtai_lxrt(BIDX, SIZARG, PREEMPT_ALWAYS_CPUID, &amp;arg);
00918 }
00919 
00920 RTAI_PROTO(RTIME,count2nano_cpuid,(RTIME count, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00921 {
00922         <span class="keyword">struct </span>{ RTIME count; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { count, cpuid };
00923         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COUNT2NANO_CPUID, &amp;arg).rt;
00924 }
00925 
00926 RTAI_PROTO(RTIME,nano2count_cpuid,(RTIME nanos, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00927 {
00928         <span class="keyword">struct </span>{ RTIME nanos; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { nanos, cpuid };
00929         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NANO2COUNT_CPUID, &amp;arg).rt;
00930 }
00931 
00932 RTAI_PROTO(RTIME,rt_get_time_cpuid,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00933 {
00934         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
00935         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_CPUID, &amp;arg).rt;
00936 }
00937 
00938 RTAI_PROTO(RTIME,rt_get_time_ns_cpuid,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
00939 {
00940         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
00941         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_NS_CPUID, &amp;arg).rt;
00942 }
00943 
00944 RTAI_PROTO(<span class="keywordtype">void</span>,rt_boom,(<span class="keywordtype">void</span>))
00945 {
00946         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00947         rtai_lxrt(BIDX, SIZARG, RT_BOOM, &amp;arg);
00948 }
00949 
00950 RTAI_PROTO(<span class="keywordtype">void</span>,rt_mmgr_stats,(<span class="keywordtype">void</span>))
00951 {
00952         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00953         rtai_lxrt(BIDX, SIZARG, RT_MMGR_STATS, &amp;arg);
00954 }
00955 
00956 RTAI_PROTO(<span class="keywordtype">void</span>,rt_stomp,(<span class="keywordtype">void</span>) )
00957 {
00958         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00959         rtai_lxrt(BIDX, SIZARG, RT_STOMP, &amp;arg);
00960 }
00961 
00962 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_linux_signal,(RT_TASK *task))
00963 {
00964     <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00965     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_GET_LINUX_SIGNAL, &amp;arg).i[LOW];
00966 }
00967 
00968 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_errno,(RT_TASK *task))
00969 {
00970     <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00971     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_GET_ERRNO, &amp;arg).i[LOW];
00972 }
00973 
00974 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_linux_signal_handler,(RT_TASK *task, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">int</span> sig)))
00975 {
00976     <span class="keyword">struct </span>{ RT_TASK *task; void (*handler)(<span class="keywordtype">int</span> sig); } arg = { task, handler };
00977     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_SET_LINUX_SIGNAL_HANDLER, &amp;arg).i[LOW];
00978 }
00979 
00980 RTAI_PROTO(<span class="keywordtype">int</span>, rt_lxrt_fork,(<span class="keywordtype">int</span> is_a_clone))
00981 {
00982     <span class="keyword">struct </span>{ <span class="keywordtype">int</span> is_a_clone; } arg = { is_a_clone };
00983     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_FORK, &amp;arg).i[LOW];
00984 }
00985 
00986 RTAI_PROTO(<span class="keywordtype">int</span>,rtai_print_to_screen,(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...))
00987 {
00988         <span class="keywordtype">char</span> display[256];
00989         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *display; <span class="keywordtype">int</span> nch; } arg = { display, 0 };
00990         va_list args;
00991 
00992         va_start(args, format);
00993         arg.nch = vsprintf(display, format, args);
00994         va_end(args);
00995         rtai_lxrt(BIDX, SIZARG, PRINT_TO_SCREEN, &amp;arg);
00996         <span class="keywordflow">return</span> arg.nch;
00997 }
00998 
00999 RTAI_PROTO(<span class="keywordtype">int</span>,rt_printk,(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...))
01000 {
01001         <span class="keywordtype">char</span> display[256];
01002         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *display; <span class="keywordtype">int</span> nch; } arg = { display, 0 };
01003         va_list args;
01004 
01005         va_start(args, format);
01006         arg.nch = vsprintf(display, format, args);
01007         va_end(args);
01008         rtai_lxrt(BIDX, SIZARG, PRINTK, &amp;arg);
01009         <span class="keywordflow">return</span> arg.nch;
01010 }
01011 
01012 RTAI_PROTO(<span class="keywordtype">int</span>,rt_usp_signal_handler,(<span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>)))
01013 {
01014         <span class="keyword">struct </span>{ void (*handler)(void); } arg = { handler };
01015         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, USP_SIGHDL, &amp;arg).i[0];
01016 }
01017 
01018 RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_usp_flags,(RT_TASK *rt_task))
01019 {
01020         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
01021         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_USP_FLAGS, &amp;arg).i[LOW];
01022 }
01023 
01024 RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_usp_flags_mask,(RT_TASK *rt_task))
01025 {
01026         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
01027         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_USP_FLG_MSK, &amp;arg).i[LOW];
01028 }
01029 
01030 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_usp_flags,(RT_TASK *rt_task, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags))
01031 {
01032         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags; } arg = { rt_task, flags };
01033         rtai_lxrt(BIDX, SIZARG, SET_USP_FLAGS, &amp;arg);
01034 }
01035 
01036 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_usp_flags_mask,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags_mask))
01037 {
01038         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags_mask; } arg = { flags_mask };
01039         rtai_lxrt(BIDX, SIZARG, SET_USP_FLG_MSK, &amp;arg);
01040 }
01041 
01042 RTAI_PROTO(RT_TASK *,rt_force_task_soft,(<span class="keywordtype">int</span> pid))
01043 {
01044         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> pid; } arg = { pid };
01045         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, FORCE_TASK_SOFT, &amp;arg).v[LOW];
01046 }
01047 
01048 RTAI_PROTO(RT_TASK *,rt_agent,(<span class="keywordtype">void</span>))
01049 {
01050         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01051         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, RT_BUDDY, &amp;arg).v[LOW];
01052 }
01053 
01054 <span class="preprocessor">#define rt_buddy() rt_agent()</span>
01055 <span class="preprocessor"></span>
<a name="l01078"></a><a class="code" href="group__lxrt.html#ga58">01078</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_make_hard_real_time,(<span class="keywordtype">void</span>))
01079 {
01080         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01081         rtai_lxrt(BIDX, SIZARG, MAKE_HARD_RT, &amp;arg);
01082 }
01083 
<a name="l01092"></a><a class="code" href="group__lxrt.html#ga59">01092</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_allow_nonroot_hrt,(<span class="keywordtype">void</span>))
01093 {
01094         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01095         rtai_lxrt(BIDX, SIZARG, NONROOT_HRT, &amp;arg);
01096 }
01097 
01098 RTAI_PROTO(<span class="keywordtype">int</span>,rt_is_hard_real_time,(RT_TASK *rt_task))
01099 {
01100         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
01101         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IS_HARD, &amp;arg).i[LOW];
01102 }
01103 
01104 <span class="preprocessor">#define rt_is_soft_real_time(rt_task) (!rt_is_hard_real_time((rt_task)))</span>
01105 <span class="preprocessor"></span>
01106 RTAI_PROTO(<span class="keywordtype">void</span>,rt_task_set_resume_end_times,(RTIME resume, RTIME end))
01107 {
01108         <span class="keyword">struct </span>{ RTIME resume, end; } arg = { resume, end };
01109         rtai_lxrt(BIDX, SIZARG, SET_RESUME_END, &amp;arg);
01110 }
01111 
01112 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_resume_time,(RT_TASK *rt_task, RTIME new_resume_time))
01113 {
01114         <span class="keyword">struct </span>{ RT_TASK *rt_task; RTIME new_resume_time; } arg = { rt_task, new_resume_time };
01115         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SET_RESUME_TIME, &amp;arg).i[LOW];
01116 }
01117 
01118 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_period,(RT_TASK *rt_task, RTIME new_period))
01119 {
01120         <span class="keyword">struct </span>{ RT_TASK *rt_task; RTIME new_period; } arg = { rt_task, new_period };
01121         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SET_PERIOD, &amp;arg).i[LOW];
01122 }
01123 
01124 RTAI_PROTO(<span class="keywordtype">void</span>,rt_spv_RMS,(<span class="keywordtype">int</span> cpuid))
01125 {
01126         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
01127         rtai_lxrt(BIDX, SIZARG, SPV_RMS, &amp;arg);
01128 }
01129 
01130 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_wakeup_sleeping,(RT_TASK *task))
01131 {
01132         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
01133         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, WAKEUP_SLEEPING, &amp;arg).i[LOW];
01134 }
01135 
01136 RTAI_PROTO(<span class="keywordtype">void</span>,rt_get_exectime,(RT_TASK *task, RTIME *exectime))
01137 {
01138         RTIME lexectime[] = { 0LL, 0LL, 0LL };
01139         <span class="keyword">struct </span>{ RT_TASK *task; RTIME *lexectime; } arg = { task, lexectime };
01140         rtai_lxrt(BIDX, SIZARG, GET_EXECTIME, &amp;arg);
01141         memcpy(exectime, lexectime, <span class="keyword">sizeof</span>(lexectime));
01142 }
01143 
01144 RTAI_PROTO(<span class="keywordtype">void</span>,rt_gettimeorig,(RTIME time_orig[]))
01145 {
01146         <span class="keyword">struct </span>{ RTIME *time_orig; } arg = { time_orig };
01147         rtai_lxrt(BIDX, SIZARG, GET_TIMEORIG, &amp;arg);
01148 }
01149 
01150 <span class="preprocessor">#ifdef __cplusplus</span>
01151 <span class="preprocessor"></span>}
01152 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
01153 
01154 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
01155 
01158 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_LXRT_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jan 20 15:55:46 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
