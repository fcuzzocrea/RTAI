<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_msg.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/rtai_msg.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 2002 POSEIDON CONTROLS INC &lt;pcloutier@poseidoncontrols.com&gt;</span>
00003 <span class="comment"> *                    Paolo Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00006 <span class="comment"> * modify it under the terms of the GNU General Public License as</span>
00007 <span class="comment"> * published by the Free Software Foundation; either version 2 of the</span>
00008 <span class="comment"> * License, or (at your option) any later version.</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00011 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00013 <span class="comment"> * GNU General Public License for more details.</span>
00014 <span class="comment"> *</span>
00015 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00016 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00017 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00018 <span class="comment"> */</span>
00019 
00020 <span class="preprocessor">#ifndef _RTAI_MSG_H</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_MSG_H</span>
00022 <span class="preprocessor"></span>
00023 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00024 
00025 <span class="preprocessor">#ifdef CONFIG_RTAI_MSG_BUILTIN</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#define MSG_INIT_MODULE     msg_init_module</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define MSG_CLEANUP_MODULE  msg_cleanup_module</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#define MSG_INIT_MODULE     init_module</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#define MSG_CLEANUP_MODULE  cleanup_module</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#define MSG_ERR ((RT_TASK *)0xFfff)</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#define MAX_NAME_LENGTH  32</span>
00036 <span class="preprocessor"></span>
00037 <span class="keyword">struct </span>rt_task_struct;
00038 <span class="keyword">struct </span>QueueBlock;
00039 <span class="keyword">struct </span>QueueHook;
00040 
00041 <span class="preprocessor">#ifdef __KERNEL__</span>
00042 <span class="preprocessor"></span>
00043 <span class="keyword">typedef</span> <span class="keyword">struct </span>t_msgcb { <span class="comment">/* Message control block structure. */</span>
00044     <span class="keywordtype">int</span>  cmd;
00045     <span class="keywordtype">void</span> *sbuf;
00046     size_t sbytes;
00047     <span class="keywordtype">void</span> *rbuf;
00048     size_t rbytes;
00049 } MSGCB;
00050 
00051 <span class="preprocessor">#define PROXY_MIN_STACK_SIZE 2048</span>
00052 <span class="preprocessor"></span>
00053 <span class="keyword">struct </span>proxy_t {
00054 
00055     <span class="keyword">struct </span>rt_task_struct *receiver;
00056     <span class="keywordtype">int</span> nmsgs,
00057         nbytes;
00058     <span class="keywordtype">char</span> *msg;
00059 };
00060 
00061 <span class="preprocessor">#define SYNCMSG          0</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#define PROXY           -1</span>
00063 <span class="preprocessor"></span>
00064 <span class="preprocessor">#ifdef __cplusplus</span>
00065 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00066 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00067 
00068 <span class="keywordtype">int</span> MSG_INIT_MODULE(<span class="keywordtype">void</span>);
00069 
00070 <span class="keywordtype">void</span> MSG_CLEANUP_MODULE(<span class="keywordtype">void</span>);
00071 
00072 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#a0">rt_send</a>(<span class="keyword">struct</span> rt_task_struct *task,
00073                                <span class="keywordtype">unsigned</span> msg);
00074 
00075 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#a1">rt_send_if</a>(<span class="keyword">struct</span> rt_task_struct *task,
00076                                   <span class="keywordtype">unsigned</span> msg);
00077 
00078 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#a2">rt_send_until</a>(<span class="keyword">struct</span> rt_task_struct *task,
00079                                      <span class="keywordtype">unsigned</span> msg,
00080                                      RTIME time);
00081     
00082 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#a3">rt_send_timed</a>(<span class="keyword">struct</span> rt_task_struct *task,
00083                                      <span class="keywordtype">unsigned</span> msg,
00084                                      RTIME delay);
00085 
00086 <span class="keyword">struct </span>rt_task_struct *rt_evdrp(<span class="keyword">struct</span> rt_task_struct *task,
00087                                 <span class="keywordtype">unsigned</span> *msg);
00088 
00089 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#a4">rt_receive</a>(<span class="keyword">struct</span> rt_task_struct *task,
00090                                   <span class="keywordtype">unsigned</span> *msg);
00091 
00092 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#a5">rt_receive_if</a>(<span class="keyword">struct</span> rt_task_struct *task,
00093                                      <span class="keywordtype">unsigned</span> *msg);
00094 
00095 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#a6">rt_receive_until</a>(<span class="keyword">struct</span> rt_task_struct *task,
00096                                         <span class="keywordtype">unsigned</span> *msg,
00097                                         RTIME time);
00098 
00099 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#a7">rt_receive_timed</a>(<span class="keyword">struct</span> rt_task_struct *task,
00100                                         <span class="keywordtype">unsigned</span> *msg,
00101                                         RTIME delay);
00102 
00103 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#a0">rt_rpc</a>(<span class="keyword">struct</span> rt_task_struct *task,
00104                               <span class="keywordtype">unsigned</span> to_do,
00105                               <span class="keywordtype">unsigned</span> *result);
00106 
00107 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#a1">rt_rpc_if</a>(<span class="keyword">struct</span> rt_task_struct *task,
00108                                  <span class="keywordtype">unsigned</span> to_do,
00109                                  <span class="keywordtype">unsigned</span> *result);
00110 
00111 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#a2">rt_rpc_until</a>(<span class="keyword">struct</span> rt_task_struct *task,
00112                                     <span class="keywordtype">unsigned</span> to_do,
00113                                     <span class="keywordtype">unsigned</span> *result,
00114                                     RTIME time);
00115 
00116 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#a3">rt_rpc_timed</a>(<span class="keyword">struct</span> rt_task_struct *task,
00117                                     <span class="keywordtype">unsigned</span> to_do,
00118                                     <span class="keywordtype">unsigned</span> *result,
00119                                     RTIME delay);
00120 
00121 <span class="keywordtype">int</span> <a class="code" href="group__rpc.html#a4">rt_isrpc</a>(<span class="keyword">struct</span> rt_task_struct *task);
00122 
00123 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#a5">rt_return</a>(<span class="keyword">struct</span> rt_task_struct *task,
00124                                  <span class="keywordtype">unsigned</span> result);
00125 
00126 <span class="keyword">struct </span>rt_task_struct *rt_rpcx(<span class="keyword">struct</span> rt_task_struct *task,
00127                                <span class="keywordtype">void</span> *smsg,
00128                                <span class="keywordtype">void</span> *rmsg,
00129                                <span class="keywordtype">int</span> ssize,
00130                                <span class="keywordtype">int</span> rsize);
00131 
00132 <span class="keyword">struct </span>rt_task_struct *rt_rpcx_if(<span class="keyword">struct</span> rt_task_struct *task,
00133                                   <span class="keywordtype">void</span> *smsg,
00134                                   <span class="keywordtype">void</span> *rmsg,
00135                                   <span class="keywordtype">int</span> ssize,
00136                                   <span class="keywordtype">int</span> rsize);
00137 
00138 <span class="keyword">struct </span>rt_task_struct *rt_rpcx_until(<span class="keyword">struct</span> rt_task_struct *task,
00139                                      <span class="keywordtype">void</span> *smsg,
00140                                      <span class="keywordtype">void</span> *rmsg,
00141                                      <span class="keywordtype">int</span> ssize,
00142                                      <span class="keywordtype">int</span> rsize,
00143                                      RTIME time);
00144 
00145 <span class="keyword">struct </span>rt_task_struct *rt_rpcx_timed(<span class="keyword">struct</span> rt_task_struct *task,
00146                                      <span class="keywordtype">void</span> *smsg,
00147                                      <span class="keywordtype">void</span> *rmsg,
00148                                      <span class="keywordtype">int</span> ssize,
00149                                      <span class="keywordtype">int</span> rsize,
00150                                      RTIME delay);
00151 
00152 <span class="keyword">struct </span>rt_task_struct *rt_sendx(<span class="keyword">struct</span> rt_task_struct *task,
00153                                 <span class="keywordtype">void</span> *msg,
00154                                 <span class="keywordtype">int</span> size);
00155 
00156 <span class="keyword">struct </span>rt_task_struct *rt_sendx_if(<span class="keyword">struct</span> rt_task_struct *task,
00157                                    <span class="keywordtype">void</span> *msg,
00158                                    <span class="keywordtype">int</span> size);
00159 
00160 <span class="keyword">struct </span>rt_task_struct *rt_sendx_until(<span class="keyword">struct</span> rt_task_struct *task,
00161                                       <span class="keywordtype">void</span> *msg,
00162                                       <span class="keywordtype">int</span> size,
00163                                       RTIME time);
00164 
00165 <span class="keyword">struct </span>rt_task_struct *rt_sendx_timed(<span class="keyword">struct</span> rt_task_struct *task,
00166                                       <span class="keywordtype">void</span> *msg,
00167                                       <span class="keywordtype">int</span> size,
00168                                       RTIME delay);
00169 
00170 <span class="keyword">struct </span>rt_task_struct *rt_returnx(<span class="keyword">struct</span> rt_task_struct *task,
00171                                   <span class="keywordtype">void</span> *msg,
00172                                   <span class="keywordtype">int</span> size);
00173 
00174 <span class="preprocessor">#define rt_isrpcx(task) rt_isrpc(task)</span>
00175 <span class="preprocessor"></span>
00176 <span class="keyword">struct </span>rt_task_struct *rt_evdrpx(<span class="keyword">struct</span> rt_task_struct *task,
00177                                  <span class="keywordtype">void</span> *msg,
00178                                  <span class="keywordtype">int</span> size,
00179                                  <span class="keywordtype">int</span> *len);
00180 
00181 <span class="keyword">struct </span>rt_task_struct *rt_receivex(<span class="keyword">struct</span> rt_task_struct *task,
00182                                    <span class="keywordtype">void</span> *msg,
00183                                    <span class="keywordtype">int</span> size,
00184                                    <span class="keywordtype">int</span> *len);
00185 
00186 <span class="keyword">struct </span>rt_task_struct *rt_receivex_if(<span class="keyword">struct</span> rt_task_struct *task,
00187                                       <span class="keywordtype">void</span> *msg,
00188                                       <span class="keywordtype">int</span> size,
00189                                       <span class="keywordtype">int</span> *len);
00190 
00191 <span class="keyword">struct </span>rt_task_struct *rt_receivex_until(<span class="keyword">struct</span> rt_task_struct *task,
00192                                          <span class="keywordtype">void</span> *msg,
00193                                          <span class="keywordtype">int</span> size,
00194                                          <span class="keywordtype">int</span> *len,
00195                                          RTIME time);
00196 
00197 <span class="keyword">struct </span>rt_task_struct *rt_receivex_timed(<span class="keyword">struct</span> rt_task_struct *task,
00198                                          <span class="keywordtype">void</span> *msg,
00199                                          <span class="keywordtype">int</span> size,
00200                                          <span class="keywordtype">int</span> *len,
00201                                          RTIME delay);
00202 
00203 <span class="keyword">struct </span>rt_task_struct *__rt_proxy_attach(<span class="keywordtype">void</span> (*func)(<span class="keywordtype">int</span>),
00204                                          <span class="keyword">struct</span> rt_task_struct *task,
00205                                          <span class="keywordtype">void</span> *msg,
00206                                          <span class="keywordtype">int</span> nbytes,
00207                                          <span class="keywordtype">int</span> priority);
00208 
00209 <span class="keyword">struct </span>rt_task_struct *rt_proxy_attach(<span class="keyword">struct</span> rt_task_struct *task,
00210                                        <span class="keywordtype">void</span> *msg,
00211                                        <span class="keywordtype">int</span> nbytes,
00212                                        <span class="keywordtype">int</span> priority);
00213 
00214 <span class="keywordtype">int</span> rt_proxy_detach(<span class="keyword">struct</span> rt_task_struct *proxy);
00215 
00216 <span class="keyword">struct </span>rt_task_struct *rt_trigger(<span class="keyword">struct</span> rt_task_struct *proxy);
00217 
00218 <span class="preprocessor">#define exist(name)  rt_get_adr(nam2num(name))</span>
00219 <span class="preprocessor"></span>
00220 <span class="keywordtype">int</span> rt_Send(pid_t pid,
00221             <span class="keywordtype">void</span> *smsg,
00222             <span class="keywordtype">void</span> *rmsg,
00223             size_t ssize,
00224             size_t rsize);
00225 
00226 pid_t rt_Receive(pid_t pid,
00227                  <span class="keywordtype">void</span> *msg,
00228                  size_t maxsize,
00229                  size_t *msglen);
00230 
00231 pid_t rt_Creceive(pid_t pid,
00232                   <span class="keywordtype">void</span> *msg,
00233                   size_t maxsize,
00234                   size_t *msglen,
00235                   RTIME delay);
00236 
00237 <span class="keywordtype">int</span> rt_Reply(pid_t pid,
00238              <span class="keywordtype">void</span> *msg,
00239              size_t size);
00240 
00241 pid_t rt_Proxy_attach(pid_t pid,
00242                       <span class="keywordtype">void</span> *msg,
00243                       <span class="keywordtype">int</span> nbytes,
00244                       <span class="keywordtype">int</span> priority);
00245 
00246 <span class="keywordtype">int</span> rt_Proxy_detach(pid_t pid);
00247 
00248 pid_t rt_Trigger(pid_t pid);
00249 
00250 pid_t rt_Name_attach(<span class="keyword">const</span> <span class="keywordtype">char</span> *name);
00251 
00252 pid_t rt_Name_locate(<span class="keyword">const</span> <span class="keywordtype">char</span> *host,
00253                      <span class="keyword">const</span> <span class="keywordtype">char</span> *name);
00254 
00255 <span class="keywordtype">int</span> rt_Name_detach(pid_t pid);
00256 
00257 <span class="preprocessor">#ifdef __cplusplus</span>
00258 <span class="preprocessor"></span>}
00259 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00260 
00261 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00262 
00263 <span class="preprocessor">#include &lt;<a class="code" href="rtai__lxrt_8h.html">rtai_lxrt.h</a>&gt;</span>
00264 
00265 <span class="preprocessor">#ifdef __cplusplus</span>
00266 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00267 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00268 
00269 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_send,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> msg))
00270 {
00271         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> msg; } arg = { task, msg };
00272         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SENDMSG, &amp;arg).v[LOW];
00273 }
00274 
00275 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_send_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> msg))
00276 {
00277         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> msg; } arg = { task, msg };
00278         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SEND_IF, &amp;arg).v[LOW];
00279 }
00280 
00281 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_send_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> msg, RTIME time))
00282 {
00283         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> msg; RTIME time; } arg = { task, msg, time };
00284         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SEND_UNTIL, &amp;arg).v[LOW];
00285 }
00286 
00287 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_send_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> msg, RTIME delay))
00288 {
00289         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> msg; RTIME delay; } arg = { task, msg, delay };
00290         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SEND_TIMED, &amp;arg).v[LOW];
00291 }
00292 
00293 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_evdrp,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> *msg))
00294 {
00295         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> *msg; } arg = { task, msg };
00296         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, EVDRP, &amp;arg).v[LOW];
00297 }
00298 
00299 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receive,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> *msg))
00300 {
00301         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> *msg; } arg = { task, msg };
00302         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVEMSG, &amp;arg).v[LOW];
00303 }
00304 
00305 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receive_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> *msg))
00306 {
00307         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> *msg; } arg = { task, msg };
00308         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVE_IF, &amp;arg).v[LOW];
00309 }
00310 
00311 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receive_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> *msg, RTIME time))
00312 {
00313         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> *msg; RTIME time; } arg = { task, msg, time };
00314         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVE_UNTIL, &amp;arg).v[LOW];
00315 }
00316 
00317 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receive_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> *msg, RTIME delay))
00318 {
00319         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> *msg; RTIME delay; } arg = { task, msg, delay };
00320         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVE_TIMED, &amp;arg).v[LOW];
00321 }
00322 
00323 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpc,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> to_do, <span class="keywordtype">unsigned</span> *result))
00324 {
00325         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> to_do; <span class="keywordtype">unsigned</span> *result; } arg = { task, to_do, result };
00326         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPCMSG, &amp;arg).v[LOW];
00327 }
00328 
00329 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpc_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> to_do, <span class="keywordtype">unsigned</span> *result))
00330 {
00331         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> to_do; <span class="keywordtype">unsigned</span> *result; } arg = { task, to_do, result };
00332         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPC_IF, &amp;arg).v[LOW];
00333 }
00334 
00335 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpc_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> to_do, <span class="keywordtype">unsigned</span> *result, RTIME time))
00336 {
00337         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> to_do; <span class="keywordtype">unsigned</span> *result; RTIME time; } arg = { task, to_do, result, time };
00338         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPC_UNTIL, &amp;arg).v[LOW];
00339 }
00340 
00341 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpc_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> to_do, <span class="keywordtype">unsigned</span> *result, RTIME delay))
00342 {
00343         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> to_do; <span class="keywordtype">unsigned</span> *result; RTIME delay; } arg = { task, to_do, result, delay };
00344         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPC_TIMED, &amp;arg).v[LOW];
00345 }
00346 
00347 RTAI_PROTO(<span class="keywordtype">int</span>, rt_isrpc,(<span class="keyword">struct</span> rt_task_struct *task))
00348 {
00349         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; } arg = { task };
00350         <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)rtai_lxrt(BIDX, SIZARG, ISRPC, &amp;arg).i[LOW];
00351 }
00352 
00353 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_return,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> result))
00354 {
00355         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> result; } arg = { task, result };
00356         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RETURNMSG, &amp;arg).v[LOW];
00357 }
00358 
00359 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpcx,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize))
00360 {
00361         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; } arg = { task, smsg, rmsg, ssize, rsize };
00362         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPCX, &amp;arg).v[LOW];
00363 }
00364 
00365 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpcx_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize))
00366 {
00367         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; } arg = { task, smsg, rmsg, ssize, rsize };
00368         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPCX_IF, &amp;arg).v[LOW];
00369 }
00370 
00371 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpcx_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME time))
00372 {
00373         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; RTIME time; } arg = { task, smsg, rmsg, ssize, rsize, time };
00374         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPCX_UNTIL, &amp;arg).v[LOW];
00375 }
00376 
00377 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpcx_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME delay))
00378 {
00379         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; RTIME delay; } arg = { task, smsg, rmsg, ssize, rsize, delay };
00380         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPCX_TIMED, &amp;arg).v[LOW];
00381 }
00382 
00383 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_sendx,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size))
00384 {
00385         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
00386         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SENDX, &amp;arg).v[LOW];
00387 }
00388 
00389 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_sendx_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size))
00390 {
00391         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
00392         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SENDX_IF, &amp;arg).v[LOW];
00393 }
00394 
00395 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_sendx_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME time))
00396 {
00397         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME time; } arg = { task, msg, size, time };
00398         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SENDX_UNTIL, &amp;arg).v[LOW];
00399 }
00400 
00401 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_sendx_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME delay))
00402 {
00403         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME delay; } arg = { task, msg, size, delay };
00404         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SENDX_TIMED, &amp;arg).v[LOW];
00405 }
00406 
00407 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_returnx,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size))
00408 {
00409         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
00410         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RETURNX, &amp;arg).v[LOW];
00411 }
00412 
00413 <span class="preprocessor">#define rt_isrpcx(task)  rt_isrpc(task)</span>
00414 <span class="preprocessor"></span>
00415 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_evdrpx,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len))
00416 {
00417         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size, *len; } arg = { task, msg, size, len };
00418         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, EVDRPX, &amp;arg).v[LOW];
00419 }
00420 
00421 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receivex,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len))
00422 {
00423         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size, *len; } arg = { task, msg, size, len };
00424         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVEX, &amp;arg).v[LOW];
00425 }
00426 
00427 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receivex_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len))
00428 {
00429         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size, *len; } arg = { task, msg, size, len };
00430         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVEX_IF, &amp;arg).v[LOW];
00431 }
00432 
00433 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receivex_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME time))
00434 {
00435         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size, *len; RTIME time; } arg = { task, msg, size, len, time };
00436         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVEX_UNTIL, &amp;arg).v[LOW];
00437 }
00438 
00439 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receivex_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME delay))
00440 {
00441         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size, *len; RTIME delay; } arg = { task, msg, size, len, delay };
00442         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVEX_TIMED, &amp;arg).v[LOW];
00443 }
00444 
00445 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_proxy_attach,(<span class="keyword">struct</span> rt_task_struct *proxy, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> nbytes, <span class="keywordtype">int</span> priority))
00446 {
00447         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *proxy; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> nbytes, priority;} arg = { proxy, msg, nbytes, priority };
00448         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *) rtai_lxrt(BIDX, SIZARG, PROXY_ATTACH, &amp;arg).v[LOW];
00449 }
00450 
00451 RTAI_PROTO(<span class="keywordtype">int</span>, rt_proxy_detach,(<span class="keyword">struct</span> rt_task_struct *proxy))
00452 {
00453         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *proxy; } arg = { proxy };
00454         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, PROXY_DETACH, &amp;arg).i[LOW];
00455 }
00456 
00457 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_trigger,(<span class="keyword">struct</span> rt_task_struct *proxy))
00458 {
00459         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *proxy; } arg = { proxy };
00460         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *) rtai_lxrt(BIDX, SIZARG, PROXY_TRIGGER, &amp;arg).v[LOW];
00461 }
00462 
00463 RTAI_PROTO(<span class="keywordtype">int</span>, rt_Send,(pid_t pid, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, size_t ssize, size_t rsize ))
00464 {
00465         <span class="keyword">struct </span>{ pid_t pid; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; size_t ssize, rsize;} arg = { pid, smsg, rmsg, ssize, rsize };
00466         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_SEND, &amp;arg).i[LOW];
00467 }
00468 
00469 RTAI_PROTO(pid_t, rt_Receive,(pid_t pid, <span class="keywordtype">void</span> *msg, size_t maxsize, size_t *msglen))
00470 {
00471         <span class="keyword">struct </span>{ pid_t pid; <span class="keywordtype">void</span> *msg; size_t maxsize, *msglen;}
00472         arg = { pid, msg, maxsize, msglen };
00473         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_RECEIVE, &amp;arg).i[LOW];
00474 }
00475 
00476 RTAI_PROTO(pid_t, rt_Creceive,(pid_t pid, <span class="keywordtype">void</span> *msg, size_t maxsize, size_t *msglen, RTIME delay))
00477 {
00478         <span class="keyword">struct </span>{ pid_t pid; <span class="keywordtype">void</span> *msg; size_t maxsize, *msglen; RTIME delay;} arg = { pid, msg, maxsize, msglen, delay };
00479         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_CRECEIVE, &amp;arg).i[LOW];
00480 }
00481 
00482 RTAI_PROTO(pid_t, rt_Reply,(pid_t pid, <span class="keywordtype">void</span> *msg, size_t size))
00483 {
00484         <span class="keyword">struct </span>{ pid_t pid; <span class="keywordtype">void</span> *msg; size_t size;} arg = { pid, msg, size };
00485         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_REPLY, &amp;arg).i[LOW];
00486 }
00487 
00488 RTAI_PROTO(pid_t, rt_Proxy_attach,(pid_t pid, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> nbytes, <span class="keywordtype">int</span> priority))
00489 {
00490         <span class="keyword">struct </span>{ pid_t pid; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> nbytes, priority;} arg = { pid, msg, nbytes, priority };
00491         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_PROXY_ATTACH, &amp;arg).i[LOW];
00492 }
00493 
00494 RTAI_PROTO(pid_t, rt_Proxy_detach,(pid_t pid))
00495 {
00496         <span class="keyword">struct </span>{ pid_t pid; } arg = { pid };
00497         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_PROXY_DETACH, &amp;arg).i[LOW];
00498 }
00499 
00500 RTAI_PROTO(pid_t, rt_Trigger,(pid_t pid))
00501 {
00502         <span class="keyword">struct </span>{ pid_t pid; } arg = { pid };
00503         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_TRIGGER, &amp;arg).i[LOW];
00504 }
00505 
00506 RTAI_PROTO(pid_t, rt_Alias_attach,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name))
00507 {
00508         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *name; } arg = { name};
00509         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_NAME_ATTACH, &amp;arg).i[LOW];
00510 }
00511 
00512 RTAI_PROTO(pid_t, rt_Name_locate,(<span class="keyword">const</span> <span class="keywordtype">char</span> *host, <span class="keyword">const</span> <span class="keywordtype">char</span> *name))
00513 {
00514         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *host, *name; } arg = { host, name };
00515         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_NAME_LOCATE, &amp;arg).i[LOW];
00516 }
00517 
00518 RTAI_PROTO(<span class="keywordtype">int</span>, rt_Name_detach,(pid_t pid))
00519 {
00520         <span class="keyword">struct </span>{ pid_t pid; } arg = { pid };
00521         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_NAME_DETACH, &amp;arg).i[LOW];
00522 }
00523 
00524 RTAI_PROTO(<span class="keywordtype">int</span>, rt_InitTickQueue,(<span class="keywordtype">void</span>))
00525 {
00526         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00527         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_INITTICKQUEUE, &amp;arg).i[LOW];
00528 }
00529 
00530 RTAI_PROTO(<span class="keywordtype">void</span>, rt_ReleaseTickQueue,(<span class="keywordtype">void</span>))
00531 {
00532         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00533         rtai_lxrt(BIDX, SIZARG, RT_RELEASETICKQUEUE, &amp;arg);
00534 }
00535 
00536 RTAI_PROTO(<span class="keywordtype">unsigned</span>, rt_qDynAlloc,(<span class="keywordtype">unsigned</span> n))
00537 {
00538         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> n; } arg = { n };
00539         <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span>) rtai_lxrt(BIDX, SIZARG, RT_QDYNALLOC, &amp;arg).i[LOW];
00540 } 
00541 
00542 RTAI_PROTO(<span class="keywordtype">unsigned</span>, rt_qDynFree,(<span class="keywordtype">int</span> n))
00543 {
00544         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> n; } arg = { n };
00545         <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span>) rtai_lxrt(BIDX, SIZARG, RT_QDYNFREE, &amp;arg).i[LOW];
00546 }
00547 
00548 RTAI_PROTO(<span class="keyword">struct</span> QueueBlock *,rt_qDynInit,(<span class="keyword">struct</span> QueueBlock **q, <span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span> *, <span class="keywordtype">int</span>), <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> evn ))
00549 {
00550         <span class="keyword">struct </span>QueueBlock *r;
00551 
00552         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock **q; void (*fun)(<span class="keywordtype">void</span> *, <span class="keywordtype">int</span>), *data; <span class="keywordtype">int</span> evn; } arg = { 0, fun, data, evn };
00553         r  = (<span class="keyword">struct </span>QueueBlock *) rtai_lxrt(BIDX, SIZARG, RT_QDYNINIT, &amp;arg).v[LOW];
00554         <span class="keywordflow">if</span> (q) *q = r;
00555         <span class="keywordflow">return</span> r;
00556 }
00557 
00558 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkWait,(<span class="keyword">struct</span> QueueBlock *q, RTIME t))
00559 {
00560         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; RTIME t; } arg = { q, t } ;
00561         rtai_lxrt(BIDX, SIZARG, RT_QBLKWAIT, &amp;arg);
00562 }
00563 
00564 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkRepeat,(<span class="keyword">struct</span> QueueBlock *q, RTIME t))
00565 {
00566         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; RTIME t; } arg = { q, t } ;
00567         rtai_lxrt(BIDX, SIZARG, RT_QBLKREPEAT, &amp;arg);
00568 }
00569 
00570 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkSoon,(<span class="keyword">struct</span> QueueBlock *q))
00571 {
00572         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00573         rtai_lxrt(BIDX, SIZARG, RT_QBLKSOON, &amp;arg);
00574 }
00575 
00576 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkDequeue,(<span class="keyword">struct</span> QueueBlock *q))
00577 {
00578         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00579         rtai_lxrt(BIDX, SIZARG, RT_QBLKDEQUEUE, &amp;arg);
00580 }
00581 
00582 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkCancel,(<span class="keyword">struct</span> QueueBlock *q))
00583 {
00584         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00585         rtai_lxrt(BIDX, SIZARG, RT_QBLKCANCEL, &amp;arg);
00586 }
00587 
00588 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkBefore,(<span class="keyword">struct</span> QueueBlock *cur, <span class="keyword">struct</span> QueueBlock *nxt))
00589 {
00590         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *cur, *nxt; } arg = { cur, nxt };
00591         rtai_lxrt(BIDX, SIZARG, RT_QBLKBEFORE, &amp;arg);
00592 }
00593 
00594 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkAfter,(<span class="keyword">struct</span> QueueBlock *cur, <span class="keyword">struct</span> QueueBlock *prv))
00595 {
00596         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *cur, *prv; } arg = { cur, prv };
00597         rtai_lxrt(BIDX, SIZARG, RT_QBLKAFTER, &amp;arg);
00598 }
00599 
00600 RTAI_PROTO(<span class="keyword">struct</span> QueueBlock *,rt_qBlkUnhook,(<span class="keyword">struct</span> QueueBlock *q))
00601 {
00602         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00603         <span class="keywordflow">return</span> (<span class="keyword">struct </span>QueueBlock *) rtai_lxrt(BIDX, SIZARG, RT_QBLKUNHOOK, &amp;arg).v[LOW];
00604 }
00605 
00606 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkRelease,(<span class="keyword">struct</span> QueueBlock *q))
00607 {
00608         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00609         rtai_lxrt(BIDX, SIZARG, RT_QBLKRELEASE, &amp;arg);
00610 }
00611 
00612 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkComplete,(<span class="keyword">struct</span> QueueBlock *q))
00613 {
00614         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00615         rtai_lxrt(BIDX, SIZARG, RT_QBLKCOMPLETE, &amp;arg);
00616 }
00617 
00618 RTAI_PROTO(<span class="keywordtype">int</span>, rt_qSync,(<span class="keywordtype">void</span>))
00619 {
00620         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00621         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_QSYNC, &amp;arg).i[LOW];
00622 }
00623 
00624 RTAI_PROTO(pid_t, rt_qReceive,(pid_t target, <span class="keywordtype">void</span> *buf, size_t maxlen, size_t *msglen))
00625 {
00626         <span class="keyword">struct </span>{pid_t target; <span class="keywordtype">void</span> *buf; size_t maxlen, *msglen; } arg = { target, buf, maxlen, msglen };
00627         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_QRECEIVE, &amp;arg).i[LOW];
00628 }
00629 
00630 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qLoop,(<span class="keywordtype">void</span>))
00631 {
00632         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00633         rtai_lxrt(BIDX, SIZARG, RT_QLOOP, &amp;arg);
00634 }
00635 
00636 RTAI_PROTO(RTIME, rt_qStep,(<span class="keywordtype">void</span>))
00637 {
00638         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00639         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_QSTEP, &amp;arg).rt;
00640 }
00641 
00642 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qHookFlush,(<span class="keyword">struct</span> QueueHook *h))
00643 {
00644         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueHook *h; } arg = { h };
00645         rtai_lxrt(BIDX, SIZARG, RT_QHOOKFLUSH, &amp;arg);
00646 }
00647 
00648 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkAtHead,(<span class="keyword">struct</span> QueueBlock *q, <span class="keyword">struct</span> QueueHook *h))
00649 {
00650         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; <span class="keyword">struct </span>QueueHook *h; } arg = { q, h };
00651         rtai_lxrt(BIDX, SIZARG, RT_QBLKATHEAD, &amp;arg);
00652 }
00653 
00654 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkAtTail,(<span class="keyword">struct</span> QueueBlock *q, <span class="keyword">struct</span> QueueHook *h))
00655 {
00656         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; <span class="keyword">struct </span>QueueHook *h; } arg = { q, h };
00657         rtai_lxrt(BIDX, SIZARG, RT_QBLKATTAIL, &amp;arg);
00658 }
00659 
00660 RTAI_PROTO(<span class="keyword">struct</span> QueueHook *,rt_qHookInit,(<span class="keyword">struct</span> QueueHook **h, <span class="keywordtype">void</span> (*c)(<span class="keywordtype">void</span> *, <span class="keyword">struct</span> QueueBlock *), <span class="keywordtype">void</span> *a))
00661 {
00662         <span class="keyword">struct </span>QueueHook *r;
00663         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueHook **h; void (*c)(<span class="keywordtype">void</span> *, <span class="keyword">struct </span>QueueBlock *), *a;} arg = { 0, c, a };
00664         r = (<span class="keyword">struct </span>QueueHook *) rtai_lxrt(BIDX, SIZARG, RT_QHOOKINIT, &amp;arg).v[LOW];
00665         <span class="keywordflow">if</span> (h) *h = r;
00666         <span class="keywordflow">return</span> r;
00667 }
00668 
00669 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qHookRelease,(<span class="keyword">struct</span> QueueHook *h))
00670 {
00671         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueHook *h; } arg = { h };
00672         rtai_lxrt(BIDX, SIZARG, RT_QHOOKRELEASE, &amp;arg);
00673 }
00674 
00675 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkSchedule,(<span class="keyword">struct</span> QueueBlock *q, RTIME t))
00676 {
00677         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; RTIME t; } arg = { q, t } ;
00678         rtai_lxrt(BIDX, SIZARG, RT_QBLKSCHEDULE, &amp;arg);
00679 }
00680 
00681 RTAI_PROTO(<span class="keyword">struct</span> QueueHook *,rt_GetTickQueueHook,(<span class="keywordtype">void</span>))
00682 {
00683         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00684         <span class="keywordflow">return</span> (<span class="keyword">struct </span>QueueHook *) rtai_lxrt(BIDX, SIZARG, RT_GETTICKQUEUEHOOK, &amp;arg).v[LOW];
00685 }
00686 
00687 RTAI_PROTO(pid_t, rt_vc_reserve,( <span class="keywordtype">void</span> ))
00688 {
00689         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00690         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_VC_RESERVE, &amp;arg).i[LOW];
00691 }
00692 
00693 RTAI_PROTO(<span class="keywordtype">int</span>, rt_vc_attach,(pid_t pid))
00694 {
00695         <span class="keyword">struct </span>{ pid_t pid; } arg = { pid };
00696         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_VC_ATTACH, &amp;arg).i[LOW];
00697 }
00698 
00699 RTAI_PROTO(<span class="keywordtype">int</span>, rt_vc_release,(pid_t pid))
00700 {
00701         <span class="keyword">struct </span>{ pid_t pid; } arg = { pid };
00702         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_VC_RELEASE, &amp;arg).i[LOW];
00703 }
00704 
00705 <span class="preprocessor">#ifdef __cplusplus</span>
00706 <span class="preprocessor"></span>}
00707 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00708 
00709 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00710 
00711 <span class="preprocessor">#if !defined(__KERNEL__) || defined(__cplusplus)</span>
00712 <span class="preprocessor"></span>
00713 <span class="keyword">typedef</span> <span class="keyword">struct </span>t_msgcb {
00714     <span class="keywordtype">int</span> opaque;
00715 } MSGCB;
00716 
00717 <span class="preprocessor">#endif </span><span class="comment">/* !__KERNEL__ || __cplusplus */</span>
00718 
00719 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_MSG_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:31:25 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
