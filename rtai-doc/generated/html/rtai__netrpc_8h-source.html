<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_netrpc.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">rtai-core</a>&nbsp;/&nbsp;<a class="el" href="dir_000019.html">include</a></div>
<h1>rtai_netrpc.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 1999-2003 Paolo Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00005 <span class="comment"> * modify it under the terms of the GNU General Public License as</span>
00006 <span class="comment"> * published by the Free Software Foundation; either version 2 of the</span>
00007 <span class="comment"> * License, or (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> * GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00016 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00017 <span class="comment"> */</span>
00018 
00019 <span class="preprocessor">#ifndef _RTAI_NETRPC_H</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_NETRPC_H</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include &lt;rtai_config.h&gt;</span>
00023 
00024 <span class="preprocessor">#ifdef CONFIG_RTAI_INTERNAL_LXRT_SUPPORT</span>
00025 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include &lt;<a class="code" href="rtai__registry_8h.html">rtai_registry.h</a>&gt;</span>
00027 <span class="preprocessor">#include &lt;<a class="code" href="rtai__lxrt_8h.html">rtai_lxrt.h</a>&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="rtai__sem_8h.html">rtai_sem.h</a>&gt;</span>
00029 <span class="preprocessor">#include &lt;<a class="code" href="rtai__mbx_8h.html">rtai_mbx.h</a>&gt;</span>
00030 <span class="preprocessor">#include &lt;rtai_msg.h&gt;</span>
00031 
00032 <span class="preprocessor">#define MAX_STUBS     16  // _M_U_S_T___B_E___P_O_W_E_R___O_F___2_</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define MAX_SOCKS     16</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define MAX_MSG_SIZE  1500</span>
00035 <span class="preprocessor"></span>
00036 <span class="preprocessor">#define NET_RPC_EXT  0</span>
00037 <span class="preprocessor"></span>
00038 <span class="comment">// for writes</span>
00039 <span class="preprocessor">#define UW1(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9))) &lt;&lt; 32) | 0x300000001LL)</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define UW2(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23))) &lt;&lt; 32) | 0x300000001LL)</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ1LL      (0x4000000300000001LL)</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ2LL      (0x8000000300000001LL)</span>
00043 <span class="preprocessor"></span>
00044 <span class="comment">// for reads</span>
00045 <span class="preprocessor">#define UR1(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9) | 0x300000001LL)</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define UR2(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23) | 0x300000001LL)</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#define URSZ1LL      (0x340000001LL)</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#define URSZ2LL      (0x380000001LL)</span>
00049 <span class="preprocessor"></span>
00050 <span class="preprocessor">#define SIZARG sizeof(arg)</span>
00051 <span class="preprocessor"></span>
00052 <span class="preprocessor">#define PACKPORT(port, ext, fun, timed) (((port) &lt;&lt; 18) | ((timed) &lt;&lt; 13) | ((ext) &lt;&lt; 8) | (fun))</span>
00053 <span class="preprocessor"></span>
00054 <span class="preprocessor">#define PORT(i)   ((i) &gt;&gt; 18)</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#define FUN(i)    ((i) &amp; 0xFF)</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#define EXT(i)    (((i) &gt;&gt; 8) &amp; 0x1F)</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#define TIMED(i)  (((i) &gt;&gt; 13) &amp; 0x1F)</span>
00058 <span class="preprocessor"></span>
00059 <span class="comment">/* </span>
00060 <span class="comment"> * SYNC_NET_RPC is hard wired here, no need to have it elsewhere. It must </span>
00061 <span class="comment"> * have all the bits allowed to the "fun" field, in PACKPORT above, set.</span>
00062 <span class="comment"> */</span>
00063 <span class="preprocessor">#define SYNC_NET_RPC  0xFF  // hard wired here, no need to have it elsewhere</span>
00064 <span class="preprocessor"></span>
00065 <span class="preprocessor">#define PRT_REQ  1</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#define PRT_SRV  2</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#define PRT_RTR  3</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#define PRT_RCV  4</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#define RPC_REQ  5</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#define RPC_SRV  6</span>
00071 <span class="preprocessor"></span><span class="preprocessor">#define RPC_RTR  7</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#define RPC_RCV  8</span>
00073 <span class="preprocessor"></span>
00074 <span class="preprocessor">#define OWNER(node, task) \</span>
00075 <span class="preprocessor">        ((((unsigned long long)(node)) &lt;&lt; 32) | (unsigned long)(task))</span>
00076 <span class="preprocessor"></span>
00077 <span class="preprocessor">#ifdef __KERNEL__</span>
00078 <span class="preprocessor"></span>
00079 <span class="preprocessor">#include &lt;rtai_sched.h&gt;</span>
00080 
00081 <span class="preprocessor">#ifdef CONFIG_RTAI_NETRPC_BUILTIN</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#define NETRPC_INIT_MODULE     netrpc_init_module</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#define NETRPC_CLEANUP_MODULE  netrpc_cleanup_module</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#else  </span><span class="comment">/* !CONFIG_RTAI_NETRPC_BUILTIN */</span>
00085 <span class="preprocessor">#define NETRPC_INIT_MODULE     init_module</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#define NETRPC_CLEANUP_MODULE  cleanup_module</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_NETRPC_BUILTIN */</span>
00088 
00089 <span class="preprocessor">#ifdef __cplusplus</span>
00090 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00091 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00092 
00093 <span class="keywordtype">int</span> netrpc_init_module(<span class="keywordtype">void</span>);
00094 
00095 <span class="keywordtype">void</span> netrpc_cleanup_module(<span class="keywordtype">void</span>);
00096 
00097 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> rt_net_rpc(<span class="keywordtype">int</span> fun_ext_timed,
00098                               <span class="keywordtype">long</span> <span class="keywordtype">long</span> type,
00099                               <span class="keywordtype">void</span> *args,
00100                               <span class="keywordtype">int</span> argsize);
00101 
00102 <span class="keywordtype">int</span> rt_send_req_rel_port(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node,
00103                          <span class="keywordtype">int</span> port,
00104                          <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">id</span>,
00105                          MBX *mbx,
00106                          <span class="keywordtype">int</span> hard);
00107 
00108 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ddn2nl(<span class="keyword">const</span> <span class="keywordtype">char</span> *ddn);
00109 
00110 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rt_set_this_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *ddn,
00111                                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node,
00112                                <span class="keywordtype">int</span> hard);
00113 
00114 RT_TASK *rt_find_asgn_stub(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner,
00115                            <span class="keywordtype">int</span> asgn);
00116 
00117 <span class="keywordtype">int</span> rt_rel_stub(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner);
00118 
00119 <span class="keywordtype">int</span> rt_waiting_return(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node,
00120                       <span class="keywordtype">int</span> port);
00121 
00122 <span class="keywordtype">int</span> rt_get_net_rpc_ret(MBX *mbx,
00123                        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *retval,
00124                        <span class="keywordtype">void</span> *msg1,
00125                        <span class="keywordtype">int</span> *msglen1,
00126                        <span class="keywordtype">void</span> *msg2,
00127                        <span class="keywordtype">int</span> *msglen2,
00128                        RTIME timeout,
00129                        <span class="keywordtype">int</span> type);
00130 
00131 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_sync_net_rpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00132 {
00133         <span class="keywordflow">if</span> (node) {
00134                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00135                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(abs(port), NET_RPC_EXT, SYNC_NET_RPC, 0), 0LL, &amp;arg, SIZARG);
00136         }
00137         <span class="keywordflow">return</span> 1;
00138 } 
00139 
00140 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> *RT_get_adr(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *sname)
00141 {
00142         <span class="keywordflow">if</span> (node) {
00143                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sname) };
00144                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, GET_ADR, 0), 0LL, &amp;arg, SIZARG);
00145         }
00146         <span class="keywordflow">return</span> <a class="code" href="group__lxrt.html#ga1">rt_get_adr</a>(<a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sname));
00147 } 
00148 
00149 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_named_task_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *task_name, <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>), <span class="keywordtype">int</span> data, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> prio, <span class="keywordtype">int</span> uses_fpu, <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>))
00150 {
00151         <span class="keywordflow">if</span> (node) {
00152                 <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *task_name; void (*thread)(int); <span class="keywordtype">int</span> data; <span class="keywordtype">int</span> stack_size; <span class="keywordtype">int</span> prio; <span class="keywordtype">int</span> uses_fpu; void(*signal)(void); <span class="keywordtype">int</span> namelen; } arg = { task_name, thread, data, stack_size, prio, uses_fpu, signal, strlen(task_name) };
00153                 <span class="keywordflow">return</span> (RT_TASK *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_TASK_INIT, 0), UR1(1, 8), &amp;arg, SIZARG);
00154         }
00155         <span class="keywordflow">return</span> rt_named_task_init(task_name, thread, data, stack_size, prio, uses_fpu, signal);
00156 }
00157 
00158 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_named_task_init_cpuid(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *task_name, <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>), <span class="keywordtype">int</span> data, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> prio, <span class="keywordtype">int</span> uses_fpu, <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>), <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> run_on_cpu)
00159 {
00160         <span class="keywordflow">if</span> (node) {
00161                 <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *task_name; void (*thread)(int); <span class="keywordtype">int</span> data; <span class="keywordtype">int</span> stack_size; <span class="keywordtype">int</span> prio; <span class="keywordtype">int</span> uses_fpu; void(*signal)(void); <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> run_on_cpu; <span class="keywordtype">int</span> namelen; } arg = { task_name, thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu, strlen(task_name) };
00162                 <span class="keywordflow">return</span> (RT_TASK *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_TASK_INIT_CPUID, 0), UR1(1, 9), &amp;arg, SIZARG);
00163         }
00164         <span class="keywordflow">return</span> rt_named_task_init_cpuid(task_name, thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu);
00165 }
00166 
00167 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_named_task_delete(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00168 {
00169         <span class="keywordflow">if</span> (node) {
00170                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00171                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_TASK_DELETE, 0), 0LL, &amp;arg, SIZARG);
00172         }
00173         <span class="keywordflow">return</span> rt_named_task_delete(task);
00174 }
00175 
00176 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_time_ns(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00177 {
00178         <span class="keywordflow">if</span> (node) {
00179                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00180                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, GET_TIME_NS, 0), 0LL, &amp;arg, SIZARG);
00181         }
00182         <span class="keywordflow">return</span> <a class="code" href="group__timer.html#ga11">rt_get_time_ns</a>();
00183 }
00184 
00185 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_time_ns_cpuid(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keywordtype">int</span> cpuid)
00186 {
00187         <span class="keywordflow">if</span> (node) {
00188                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
00189                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, GET_TIME_NS_CPUID, 0), 0LL, &amp;arg, SIZARG);
00190         }
00191         <span class="keywordflow">return</span> <a class="code" href="group__timer.html#ga12">rt_get_time_ns_cpuid</a>(cpuid);
00192 }
00193 
00194 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_cpu_time_ns(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00195 {
00196         <span class="keywordflow">if</span> (node) {
00197                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00198                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, GET_CPU_TIME_NS, 0), 0LL, &amp;arg, SIZARG);
00199         }
00200         <span class="keywordflow">return</span> <a class="code" href="group__timer.html#ga13">rt_get_cpu_time_ns</a>();
00201 }
00202 
00203 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_task_suspend(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00204 {
00205         <span class="keywordflow">if</span> (node) {
00206                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00207                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SUSPEND, 0), 0LL, &amp;arg, SIZARG);
00208         }
00209         <span class="keywordflow">return</span> <a class="code" href="common_8c.html#a10">rt_task_suspend</a>(task);
00210 }
00211 
00212 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_task_resume(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00213 {
00214         <span class="keywordflow">if</span> (node) {
00215                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00216                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RESUME, 0), 0LL, &amp;arg, SIZARG);
00217         }
00218         <span class="keywordflow">return</span> <a class="code" href="common_8c.html#a11">rt_task_resume</a>(task);
00219 }
00220 
00221 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_sleep(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RTIME delay)
00222 {
00223         <span class="keywordflow">if</span> (node) {
00224                 <span class="keyword">struct </span>{ RTIME delay; } arg = { delay };
00225                 rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SLEEP, 1), 0LL, &amp;arg, SIZARG);
00226                 <span class="keywordflow">return</span>;
00227         }
00228         <a class="code" href="common_8c.html#a25">rt_sleep</a>(<a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00229 } 
00230 
00231 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_sleep_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RTIME time)
00232 {
00233         <span class="keywordflow">if</span> (node) {
00234                 <span class="keyword">struct </span>{ RTIME time; } arg = { time };
00235                 rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SLEEP_UNTIL, 1), 0LL, &amp;arg, SIZARG);
00236                 <span class="keywordflow">return</span>;
00237         }
00238         <a class="code" href="common_8c.html#a26">rt_sleep_until</a>(<a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00239 } 
00240 
00241 <span class="preprocessor">#if CONFIG_RTAI_SEM</span>
00242 <span class="preprocessor"></span>
00243 <span class="keyword">static</span> <span class="keyword">inline</span> SEM *RT_typed_named_sem_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *sem_name, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type)
00244 {
00245         <span class="keywordflow">if</span> (node) {
00246                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sem_name; <span class="keywordtype">int</span> value; <span class="keywordtype">int</span> type; <span class="keywordtype">int</span> namelen; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sem_name), value, type };
00247                 <span class="keywordflow">return</span> (SEM *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_SEM_INIT, 0), 0LL, &amp;arg, SIZARG);
00248         }
00249         <span class="keywordflow">return</span> rt_typed_named_sem_init(sem_name, value, type);
00250 }
00251 
00252 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_named_sem_delete(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00253 {
00254         <span class="keywordflow">if</span> (node) {
00255                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00256                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_SEM_DELETE, 0), 0LL, &amp;arg, SIZARG);
00257         }
00258         <span class="keywordflow">return</span> rt_named_sem_delete(sem);
00259 }
00260 
00261 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_signal(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00262 {
00263         <span class="keywordflow">if</span> (node) {
00264                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00265                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_SIGNAL, 0), 0LL, &amp;arg, SIZARG);
00266         }
00267         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga6">rt_sem_signal</a>(sem);
00268 } 
00269 
00270 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_broadcast(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00271 {
00272         <span class="keywordflow">if</span> (node) {
00273                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00274                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_BROADCAST, 0), 0LL, &amp;arg, SIZARG);
00275         }
00276         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga7">rt_sem_broadcast</a>(sem);
00277 } 
00278 
00279 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00280 {
00281         <span class="keywordflow">if</span> (node) {
00282                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00283                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_WAIT, 0), 0LL, &amp;arg, SIZARG);
00284         }
00285         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga8">rt_sem_wait</a>(sem);
00286 } 
00287 
00288 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00289 {
00290         <span class="keywordflow">if</span> (node) {
00291                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00292                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_WAIT_IF, 0), 0LL, &amp;arg, SIZARG);
00293         }
00294         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga9">rt_sem_wait_if</a>(sem);
00295 } 
00296 
00297 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem, RTIME time)
00298 {
00299         <span class="keywordflow">if</span> (node) {
00300                 <span class="keyword">struct </span>{ SEM *sem; RTIME time; } arg = { sem, time };
00301                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_WAIT_UNTIL, 2), 0LL, &amp;arg, SIZARG);
00302         }
00303         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga10">rt_sem_wait_until</a>(sem, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00304 } 
00305 
00306 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem, RTIME delay)
00307 {
00308         <span class="keywordflow">if</span> (node) {
00309                 <span class="keyword">struct </span>{ SEM *sem; RTIME delay; } arg = { sem, delay };
00310                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEM_WAIT_TIMED, 2), 0LL, &amp;arg, SIZARG);
00311         }
00312         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga11">rt_sem_wait_timed</a>(sem, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00313 } 
00314 
00315 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_SEM */</span>
00316 
00317 <span class="preprocessor">#if CONFIG_RTAI_MSG</span>
00318 <span class="preprocessor"></span>
00319 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg)
00320 {
00321         <span class="keywordflow">if</span> (node) {
00322                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; } arg = { task, msg };
00323                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SENDMSG, 0), 0LL, &amp;arg, SIZARG);
00324         }
00325         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga0">rt_send</a>(task, msg);
00326 }
00327 
00328 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg)
00329 {
00330         <span class="keywordflow">if</span> (node) {
00331                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; } arg = { task, msg };
00332                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEND_IF, 0), 0LL, &amp;arg, SIZARG);
00333         }
00334         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga1">rt_send_if</a>(task, msg);
00335 }
00336 
00337 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, RTIME time)
00338 {
00339         <span class="keywordflow">if</span> (node) {
00340                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; RTIME time; } arg = { task, msg, time };
00341                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEND_UNTIL, 3), 0LL, &amp;arg, SIZARG);
00342         }
00343         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga2">rt_send_until</a>(task, msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00344 }
00345 
00346 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, RTIME delay)
00347 {
00348         <span class="keywordflow">if</span> (node) {
00349                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; RTIME delay; } arg = { task, msg, delay };
00350                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SEND_TIMED, 3), 0LL, &amp;arg, SIZARG);
00351         }
00352         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga3">rt_send_timed</a>(task, msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00353 }
00354 
00355 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00356 {
00357         <span class="keywordflow">if</span> (!task || !node) {
00358                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga4">rt_receive</a>(task, msg);
00359         }
00360         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga4">rt_receive</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00361 }
00362 
00363 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00364 {
00365         <span class="keywordflow">if</span> (!task || !node) {
00366                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga5">rt_receive_if</a>(task, msg);
00367         }
00368         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga5">rt_receive_if</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00369 }
00370 
00371 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg, RTIME time)
00372 {
00373         <span class="keywordflow">if</span> (!task || !node) {
00374                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga6">rt_receive_until</a>(task, msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00375         }
00376         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga6">rt_receive_until</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(time)) ? task : 0;
00377 }
00378 
00379 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg, RTIME delay)
00380 {
00381         <span class="keywordflow">if</span> (!task || !node) {
00382                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga7">rt_receive_timed</a>(task, msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00383         }
00384         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga7">rt_receive_timed</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay)) ? task : 0;
00385 }
00386 
00387 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret)
00388 {
00389         <span class="keywordflow">if</span> (node) {
00390                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; } arg = { task, msg, ret };
00391                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPCMSG, 0), UW1(3, 0), &amp;arg, SIZARG);
00392         }
00393         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga0">rt_rpc</a>(task, msg, ret);
00394 }
00395 
00396 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret)
00397 {
00398         <span class="keywordflow">if</span> (node) {
00399                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; } arg = { task, msg };
00400                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPC_IF, 0), UW1(3, 0), &amp;arg, SIZARG);
00401         }
00402         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga1">rt_rpc_if</a>(task, msg, ret);
00403 }
00404 
00405 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret, RTIME time)
00406 {
00407         <span class="keywordflow">if</span> (node) {
00408                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; RTIME time; } arg = { task, msg, ret, time };
00409                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPC_UNTIL, 4), UW1(3, 0), &amp;arg, SIZARG);
00410         }
00411         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga2">rt_rpc_until</a>(task, msg, ret, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00412 }
00413 
00414 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret, RTIME delay)
00415 {
00416         <span class="keywordflow">if</span> (node) {
00417                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; RTIME delay; } arg = { task, msg, ret, delay };
00418                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPC_TIMED, 4), UW1(3, 0), &amp;arg, SIZARG);
00419         }
00420         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga3">rt_rpc_timed</a>(task, msg, ret, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00421 }
00422 
00423 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_isrpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00424 {
00425         <span class="keywordflow">if</span> (node) {
00426                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00427                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, ISRPC, 0), 0LL, &amp;arg, SIZARG);
00428         }
00429         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga4">rt_isrpc</a>(task);
00430 }
00431 
00432 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_return(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result)
00433 {
00434         <span class="keywordflow">if</span> (!task || !node) {
00435                 <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga5">rt_return</a>(task, result);
00436         }
00437         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga5">rt_return</a>(rt_find_asgn_stub(OWNER(node, task), 1), result) ? task : 0;
00438 }
00439 
00440 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_evdrp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00441 {
00442         <span class="keywordflow">if</span> (!task || !node) {
00443                 <span class="keywordflow">return</span> rt_evdrp(task, msg);
00444         }
00445         <span class="keywordflow">return</span> rt_evdrp(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00446 }
00447 
00448 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize)
00449 {
00450         <span class="keywordflow">if</span> (node) {
00451                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; } arg = { task, smsg, rmsg, ssize, rsize };
00452                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPCX, 0), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG);
00453         }
00454         <span class="keywordflow">return</span> rt_rpcx(task, smsg, rmsg, ssize, rsize);
00455 }
00456 
00457 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize)
00458 {
00459         <span class="keywordflow">if</span> (node) {
00460                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; } arg = { task, smsg, rmsg, ssize, rsize };
00461                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPCX_IF, 0), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG);
00462         }
00463         <span class="keywordflow">return</span> rt_rpcx_if(task, smsg, rmsg, ssize, rsize);
00464 }
00465 
00466 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME time)
00467 {
00468         <span class="keywordflow">if</span> (node) {
00469                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; RTIME time; } arg = { task, smsg, rmsg, ssize, rsize, time };
00470                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPCX_UNTIL, 6), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG);
00471         }
00472         <span class="keywordflow">return</span> rt_rpcx_until(task, smsg, rmsg, ssize, rsize, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00473 }
00474 
00475 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME delay)
00476 {
00477         <span class="keywordflow">if</span> (node) {
00478                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; RTIME delay; } arg = { task, smsg, rmsg, ssize, rsize, delay };
00479                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, RPCX_TIMED, 6), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG);
00480         }
00481         <span class="keywordflow">return</span> rt_rpcx_timed(task, smsg, rmsg, ssize, rsize, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00482 }
00483 
00484 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
00485 {
00486         <span class="keywordflow">if</span> (node) {
00487                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
00488                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SENDX, 0), UR1(2, 3), &amp;arg, SIZARG);
00489         }
00490         <span class="keywordflow">return</span> rt_sendx(task, msg, size);
00491 }
00492 
00493 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
00494 {
00495         <span class="keywordflow">if</span> (node) {
00496                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
00497                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SENDX_IF, 0), UR1(2, 3), &amp;arg, SIZARG);
00498         }
00499         <span class="keywordflow">return</span> rt_sendx_if(task, msg, size);
00500 }
00501 
00502 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME time)
00503 {
00504         <span class="keywordflow">if</span> (node) {
00505                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME time; } arg = { task, msg, size, time };
00506                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SENDX_UNTIL, 4), UR1(2, 3), &amp;arg, SIZARG);
00507         }
00508         <span class="keywordflow">return</span> rt_sendx_until(task, msg, size, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00509 }
00510 
00511 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME delay)
00512 {
00513         <span class="keywordflow">if</span> (node) {
00514                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME delay; } arg = { task, msg, size, delay };
00515                 <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, SENDX_TIMED, 4), UR1(2, 3), &amp;arg, SIZARG);
00516         }
00517         <span class="keywordflow">return</span> rt_sendx_timed(task, msg, size, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00518 }
00519 
00520 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_returnx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
00521 {
00522         <span class="keywordflow">if</span> (!task || !node) {
00523                 <span class="keywordflow">return</span> rt_returnx(task, msg, size);
00524         }
00525         <span class="keywordflow">return</span> rt_returnx(rt_find_asgn_stub(OWNER(node, task), 1), msg, size) ? task : 0;
00526 }
00527 
00528 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_evdrpx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
00529 {
00530         <span class="keywordflow">if</span> (!task || !node) {
00531                 <span class="keywordflow">return</span> rt_evdrpx(task, msg, size, len);
00532         }
00533         <span class="keywordflow">return</span> rt_evdrpx(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
00534 }
00535 
00536 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
00537 {
00538         <span class="keywordflow">if</span> (!task || !node) {
00539                 <span class="keywordflow">return</span> rt_receivex(task, msg, size, len);
00540         }
00541         <span class="keywordflow">return</span> rt_receivex(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
00542 }
00543 
00544 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
00545 {
00546         <span class="keywordflow">if</span> (!task || !node) {
00547                 <span class="keywordflow">return</span> rt_receivex_if(task, msg, size, len);
00548         }
00549         <span class="keywordflow">return</span> rt_receivex_if(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
00550 }
00551 
00552 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME time)
00553 {
00554         <span class="keywordflow">if</span> (!task || !node) {
00555                 <span class="keywordflow">return</span> rt_receivex_until(task, msg, size, len, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00556         }
00557         <span class="keywordflow">return</span> rt_receivex_until(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len, <a class="code" href="group__timer.html#ga6">nano2count</a>(time)) ? task : 0;
00558 }
00559 
00560 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME delay)
00561 {
00562         <span class="keywordflow">if</span> (!task || !node) {
00563                 <span class="keywordflow">return</span> rt_receivex_timed(task, msg, size, len, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00564         }
00565         <span class="keywordflow">return</span> rt_receivex_timed(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay)) ? task : 0;
00566 }
00567 
00568 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_MSG */</span>
00569 
00570 <span class="preprocessor">#if CONFIG_RTAI_MBX</span>
00571 <span class="preprocessor"></span>
00572 <span class="keyword">static</span> <span class="keyword">inline</span> MBX *RT_typed_named_mbx_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *mbx_name, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> qtype)
00573 {
00574         <span class="keywordflow">if</span> (node) {
00575                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mbx_name; <span class="keywordtype">int</span> size; <span class="keywordtype">int</span> qype; <span class="keywordtype">int</span> namelen; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(mbx_name), size, qtype };
00576                 <span class="keywordflow">return</span> (MBX *)(<span class="keywordtype">unsigned</span> long)rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_MBX_INIT, 0), 0LL, &amp;arg, SIZARG);
00577         }
00578         <span class="keywordflow">return</span> rt_typed_named_mbx_init(mbx_name, size, qtype);
00579 }
00580 
00581 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_named_mbx_delete(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx)
00582 {
00583         <span class="keywordflow">if</span> (node) {
00584                 <span class="keyword">struct </span>{ MBX *mbx; } arg = { mbx };
00585                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, NAMED_MBX_DELETE, 0), 0LL, &amp;arg, SIZARG);
00586         }
00587         <span class="keywordflow">return</span> rt_named_mbx_delete(mbx);
00588 }
00589 
00590 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00591 {
00592         <span class="keywordflow">if</span> (node) {
00593                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00594                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_SEND, 0), UR1(2, 3), &amp;arg, SIZARG);
00595         }
00596         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga13">rt_mbx_send</a>(mbx, msg, msg_size);
00597 } 
00598 
00599 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_wp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00600 {
00601         <span class="keywordflow">if</span> (node) {
00602                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00603                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_SEND_WP, 0), UR1(2, 3), &amp;arg, SIZARG);
00604         }
00605         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga14">rt_mbx_send_wp</a>(mbx, msg, msg_size);
00606 } 
00607 
00608 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00609 {
00610         <span class="keywordflow">if</span> (node) {
00611                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00612                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_SEND_IF, 0), UR1(2, 3), &amp;arg, SIZARG);
00613         }
00614         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga15">rt_mbx_send_if</a>(mbx, msg, msg_size);
00615 } 
00616 
00617 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_ovrwr_send(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00618 {
00619         <span class="keywordflow">if</span> (node) {
00620                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00621                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_OVRWR_SEND, 0), UR1(2, 3), &amp;arg, SIZARG);
00622         }
00623         <span class="keywordflow">return</span> rt_mbx_ovrwr_send(mbx, msg, msg_size);
00624 } 
00625 
00626 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time)
00627 {
00628         <span class="keywordflow">if</span> (node) {
00629                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { mbx, msg, msg_size, time };
00630                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_SEND_UNTIL, 4), UR1(2, 3), &amp;arg, SIZARG);
00631         }
00632         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga16">rt_mbx_send_until</a>(mbx, msg, msg_size, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00633 } 
00634 
00635 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay)
00636 {
00637         <span class="keywordflow">if</span> (node) {
00638                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { mbx, msg, msg_size, delay };
00639                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_SEND_TIMED, 4), UR1(2, 3), &amp;arg, SIZARG);
00640         }
00641         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga17">rt_mbx_send_timed</a>(mbx, msg, msg_size, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00642 } 
00643 
00644 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_evdrp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00645 {
00646         <span class="keywordflow">if</span> (node) {
00647                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00648                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_EVDRP, 0), UW1(2, 3), &amp;arg, SIZARG);
00649         }
00650         <span class="keywordflow">return</span> rt_mbx_evdrp(mbx, msg, msg_size);
00651 } 
00652 
00653 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00654 {
00655         <span class="keywordflow">if</span> (node) {
00656                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00657                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE, 0), UW1(2, 3), &amp;arg, SIZARG);
00658         }
00659         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga18">rt_mbx_receive</a>(mbx, msg, msg_size);
00660 } 
00661 
00662 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_wp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00663 {
00664         <span class="keywordflow">if</span> (node) {
00665                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00666                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_WP, 0), UW1(2, 3), &amp;arg, SIZARG);
00667         }
00668         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga19">rt_mbx_receive_wp</a>(mbx, msg, msg_size);
00669 } 
00670 
00671 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
00672 {
00673         <span class="keywordflow">if</span> (node) {
00674                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
00675                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_IF, 0), UW1(2, 3), &amp;arg, SIZARG);
00676         }
00677         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga20">rt_mbx_receive_if</a>(mbx, msg, msg_size);
00678 } 
00679 
00680 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time)
00681 {
00682         <span class="keywordflow">if</span> (node) {
00683                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { mbx, msg, msg_size, time };
00684                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_UNTIL, 4), UW1(2, 3), &amp;arg, SIZARG);
00685         }
00686         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga21">rt_mbx_receive_until</a>(mbx, msg, msg_size, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00687 } 
00688 
00689 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay)
00690 {
00691         <span class="keywordflow">if</span> (node) {
00692                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { mbx, msg, msg_size, delay };
00693                 <span class="keywordflow">return</span> rt_net_rpc(PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_TIMED, 4), UW1(2, 3), &amp;arg, SIZARG);
00694         }
00695         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga22">rt_mbx_receive_timed</a>(mbx, msg, msg_size, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00696 } 
00697 
00698 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_MBX */</span>
00699 
00700 <span class="preprocessor">#ifdef __cplusplus</span>
00701 <span class="preprocessor"></span>}
00702 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00703 
00704 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00705 
00706 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00707 
00708 <span class="preprocessor">#define NET_RPC_IDX  0</span>
00709 <span class="preprocessor"></span>
00710 <span class="preprocessor">#define SIZARGS sizeof(args)</span>
00711 <span class="preprocessor"></span>
00712 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_send_req_rel_port(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">id</span>, MBX *mbx, <span class="keywordtype">int</span> hard)
00713 {
00714         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, port; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> id; MBX *mbx; <span class="keywordtype">int</span> hard; } args = { node, port, id, mbx, hard };
00715         <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, SEND_REQ_REL_PORT, &amp;args).i[LOW];
00716 } 
00717 
00718 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ddn2nl(<span class="keyword">const</span> <span class="keywordtype">char</span> *ddn)
00719 {
00720         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *ddn; } args = { ddn };
00721         <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, DDN2NL, &amp;args).i[LOW];
00722 } 
00723 
00724 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rt_set_this_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *ddn, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> hard)
00725 {
00726         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *ddn; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node; <span class="keywordtype">int</span> hard; } args = { ddn, node, hard };
00727         <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, SET_THIS_NODE, &amp;args).i[LOW];
00728 } 
00729 
00730 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *rt_find_asgn_stub(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner, <span class="keywordtype">int</span> asgn)
00731 {
00732         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner; <span class="keywordtype">int</span> asgn; } args = { owner, asgn };
00733         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, FIND_ASGN_STUB, &amp;args).v[LOW];
00734 } 
00735 
00736 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_rel_stub(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner)
00737 {
00738         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> owner; } args = { owner };
00739         <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, REL_STUB, &amp;args).i[LOW];
00740 } 
00741 
00742 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_waiting_return(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00743 {
00744         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node; <span class="keywordtype">int</span> port; } args = { node, port };
00745         <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, WAITING_RETURN, &amp;args).i[LOW];
00746 } 
00747 
00748 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_sync_net_rpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00749 {
00750         <span class="keywordflow">if</span> (node) {
00751                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00752                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(abs(port), NET_RPC_EXT, SYNC_NET_RPC, 0), 0LL, &amp;arg, SIZARG };
00753                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00754         } 
00755         <span class="keywordflow">return</span> 1;
00756 } 
00757 
00758 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> *RT_get_adr(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *sname)
00759 {
00760         <span class="keywordflow">if</span> (node) {
00761                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sname) };
00762                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, GET_ADR, 0), 0LL, &amp;arg, SIZARG };
00763                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00764         } 
00765         <span class="keywordflow">return</span> <a class="code" href="group__lxrt.html#ga1">rt_get_adr</a>(<a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sname));
00766 } 
00767 
00768 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_time_ns(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00769 {
00770         <span class="keywordflow">if</span> (node) {
00771                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00772                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, GET_TIME_NS, 0), 0LL, &amp;arg, SIZARG };
00773                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).rt;
00774         }
00775         <span class="keywordflow">return</span> <a class="code" href="group__timer.html#ga11">rt_get_time_ns</a>();
00776 } 
00777 
00778 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_time_ns_cpuid(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keywordtype">int</span> cpuid)
00779 {
00780         <span class="keywordflow">if</span> (node) {
00781                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
00782                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, GET_TIME_NS_CPUID, 0), 0LL, &amp;arg, SIZARG };
00783                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).rt;
00784         }
00785         <span class="keywordflow">return</span> <a class="code" href="group__timer.html#ga12">rt_get_time_ns_cpuid</a>(cpuid);
00786 } 
00787 
00788 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME RT_get_cpu_time_ns(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port)
00789 {
00790         <span class="keywordflow">if</span> (node) {
00791                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
00792                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, GET_CPU_TIME_NS, 0), 0LL, &amp;arg, SIZARG };
00793                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).rt;
00794         }
00795         <span class="keywordflow">return</span> <a class="code" href="group__timer.html#ga13">rt_get_cpu_time_ns</a>();
00796 } 
00797 
00798 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_task_suspend(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00799 {
00800         <span class="keywordflow">if</span> (node) {
00801                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00802                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SUSPEND, 0), 0LL, &amp;arg, SIZARG };
00803                 rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args);
00804                 <span class="keywordflow">return</span>;
00805         }
00806         <a class="code" href="common_8c.html#a10">rt_task_suspend</a>(task);
00807 } 
00808 
00809 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_task_resume(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
00810 {
00811         <span class="keywordflow">if</span> (node) {
00812                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00813                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RESUME, 0), 0LL, &amp;arg, SIZARG };
00814                 rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args);
00815                 <span class="keywordflow">return</span>;
00816         }
00817         <a class="code" href="common_8c.html#a11">rt_task_resume</a>(task);
00818 } 
00819 
00820 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_sleep(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RTIME delay)
00821 {
00822         <span class="keywordflow">if</span> (node) {
00823                 <span class="keyword">struct </span>{ RTIME delay; } arg = { delay };
00824                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SLEEP, 1), 0LL, &amp;arg, SIZARG };
00825                 rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args);
00826                 <span class="keywordflow">return</span>;
00827         }
00828         <a class="code" href="common_8c.html#a25">rt_sleep</a>(<a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00829 } 
00830 
00831 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> RT_sleep_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RTIME time)
00832 {
00833         <span class="keywordflow">if</span> (node) {
00834                 <span class="keyword">struct </span>{ RTIME time; } arg = { time };
00835                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SLEEP_UNTIL, 1), 0LL, &amp;arg, SIZARG };
00836                 rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args);
00837                 <span class="keywordflow">return</span>;
00838         }
00839         <a class="code" href="common_8c.html#a25">rt_sleep</a>(<a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00840 } 
00841 
00842 <span class="preprocessor">#if CONFIG_RTAI_SEM</span>
00843 <span class="preprocessor"></span>
00844 <span class="keyword">static</span> <span class="keyword">inline</span> SEM *RT_typed_named_sem_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *sem_name, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type)
00845 {
00846         <span class="keywordflow">if</span> (node) {
00847                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sem_name; <span class="keywordtype">int</span> value; <span class="keywordtype">int</span> type; <span class="keywordtype">int</span> namelen; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sem_name), value, type };
00848                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, NAMED_SEM_INIT, 0), 0LL, &amp;arg, SIZARG };
00849                 <span class="keywordflow">return</span> (SEM *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00850         }
00851         <span class="keywordflow">return</span> rt_typed_named_sem_init(sem_name, value, type);
00852 }
00853 
00854 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_named_sem_delete(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00855 {
00856         <span class="keywordflow">if</span> (node) {
00857                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00858                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, NAMED_SEM_DELETE, 0), 0LL, &amp;arg, SIZARG };
00859                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00860         }
00861         <span class="keywordflow">return</span> rt_named_sem_delete(sem);
00862 }
00863 
00864 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_signal(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00865 {
00866         <span class="keywordflow">if</span> (node) {
00867                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00868                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_SIGNAL, 0), 0LL, &amp;arg, SIZARG };
00869                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00870         } 
00871         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga6">rt_sem_signal</a>(sem);
00872 } 
00873 
00874 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_broadcast(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00875 {
00876         <span class="keywordflow">if</span> (node) {
00877                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00878                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_BROADCAST, 0), 0LL, &amp;arg, SIZARG };
00879                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00880         }
00881         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga7">rt_sem_broadcast</a>(sem);
00882 } 
00883 
00884 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00885 {
00886         <span class="keywordflow">if</span> (node) {
00887                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00888                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_WAIT, 0), 0LL, &amp;arg, SIZARG };
00889                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00890         } 
00891         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga8">rt_sem_wait</a>(sem);
00892 } 
00893 
00894 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem)
00895 {
00896         <span class="keywordflow">if</span> (node) {
00897                 <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00898                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_WAIT_IF, 0), 0LL, &amp;arg, SIZARG };
00899                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00900         }
00901         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga9">rt_sem_wait_if</a>(sem);
00902 } 
00903 
00904 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem, RTIME time)
00905 {
00906         <span class="keywordflow">if</span> (node) {
00907                 <span class="keyword">struct </span>{ SEM *sem; RTIME time; } arg = { sem, time };
00908                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_WAIT_UNTIL, 2), 0LL, &amp;arg, SIZARG };
00909                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00910         }
00911         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga10">rt_sem_wait_until</a>(sem, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00912 } 
00913 
00914 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_sem_wait_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, SEM *sem, RTIME delay)
00915 {
00916         <span class="keywordflow">if</span> (node) {
00917                 <span class="keyword">struct </span>{ SEM *sem; RTIME delay; } arg = { sem, delay };
00918                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEM_WAIT_TIMED, 2), 0LL, &amp;arg, SIZARG };
00919                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
00920         } 
00921         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga11">rt_sem_wait_timed</a>(sem, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00922 } 
00923 
00924 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_SEM */</span>
00925 
00926 <span class="preprocessor">#if CONFIG_RTAI_MSG</span>
00927 <span class="preprocessor"></span>
00928 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg)
00929 {
00930         <span class="keywordflow">if</span> (node) {
00931                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; } arg = { task, msg };
00932                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SENDMSG, 0), 0LL, &amp;arg, SIZARG };
00933                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00934         } 
00935         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga0">rt_send</a>(task, msg);
00936 } 
00937 
00938 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg)
00939 {
00940         <span class="keywordflow">if</span> (node) {
00941                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; } arg = { task, msg };
00942                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEND_IF, 0), 0LL, &amp;arg, SIZARG };
00943                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00944         } 
00945         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga1">rt_send_if</a>(task, msg);
00946 } 
00947 
00948 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, RTIME time)
00949 {
00950         <span class="keywordflow">if</span> (node) {
00951                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; RTIME time; } arg = { task, msg, time };
00952                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEND_UNTIL, 3), 0LL, &amp;arg, SIZARG };
00953                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00954         } 
00955         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga2">rt_send_until</a>(task, msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00956 } 
00957 
00958 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_send_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, RTIME delay)
00959 {
00960         <span class="keywordflow">if</span> (node) {
00961                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; RTIME delay; } arg = { task, msg, delay };
00962                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SEND_TIMED, 3), 0LL, &amp;arg, SIZARG };
00963                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
00964         } 
00965         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga3">rt_send_timed</a>(task, msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
00966 } 
00967 
00968 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_evdrp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00969 {
00970         <span class="keywordflow">if</span> (!task || !node) {
00971                 <span class="keywordflow">return</span> rt_evdrp(task, msg);
00972         } 
00973         <span class="keywordflow">return</span> rt_evdrp(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00974 } 
00975 
00976 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00977 {
00978         <span class="keywordflow">if</span> (!task || !node) {
00979                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga4">rt_receive</a>(task, msg);
00980         } 
00981         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga4">rt_receive</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00982 } 
00983 
00984 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg)
00985 {
00986         <span class="keywordflow">if</span> (!task || !node) {
00987                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga5">rt_receive_if</a>(task, msg);
00988         } 
00989         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga5">rt_receive_if</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg) ? task : 0;
00990 } 
00991 
00992 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg, RTIME time)
00993 {
00994         <span class="keywordflow">if</span> (!task || !node) {
00995                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga6">rt_receive_until</a>(task, msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
00996         } 
00997         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga6">rt_receive_until</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(time)) ? task : 0;
00998 } 
00999 
01000 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receive_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg, RTIME delay)
01001 {
01002         <span class="keywordflow">if</span> (!task || !node) {
01003                 <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga7">rt_receive_timed</a>(task, msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
01004         } 
01005         <span class="keywordflow">return</span> <a class="code" href="group__msg.html#ga7">rt_receive_timed</a>(rt_find_asgn_stub(OWNER(node, task), 1), msg, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay)) ? task : 0;
01006 } 
01007 
01008 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret)
01009 {
01010         <span class="keywordflow">if</span> (node) {
01011                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; } arg = { task, msg, ret };
01012                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPCMSG, 0), UW1(3, 0), &amp;arg, SIZARG };
01013                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01014         }
01015         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga0">rt_rpc</a>(task, msg, ret);
01016 } 
01017 
01018 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret)
01019 {
01020         <span class="keywordflow">if</span> (node) {
01021                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; } arg = { task, msg, ret };
01022                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPC_IF, 0), UW1(3, 0), &amp;arg, SIZARG };
01023                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01024         }
01025         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga1">rt_rpc_if</a>(task, msg, ret);
01026 } 
01027 
01028 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret, RTIME time)
01029 {
01030         <span class="keywordflow">if</span> (node) {
01031                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; RTIME time; } arg = { task, msg, ret, time };
01032                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPC_UNTIL, 4), UW1(3, 0), &amp;arg, SIZARG };
01033                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01034         }
01035         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga2">rt_rpc_until</a>(task, msg, ret, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
01036 } 
01037 
01038 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpc_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret, RTIME delay)
01039 {
01040         <span class="keywordflow">if</span> (node) {
01041                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msg; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ret; RTIME delay; } arg = { task, msg, ret, delay };
01042                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPC_TIMED, 4), UW1(3, 0), &amp;arg, SIZARG };
01043                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01044         }
01045         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga3">rt_rpc_timed</a>(task, msg, ret, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
01046 } 
01047 
01048 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_isrpc(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task)
01049 {
01050         <span class="keywordflow">if</span> (node) {
01051                 <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
01052                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, ISRPC, 0), 0LL, &amp;arg, SIZARG };
01053                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01054         } 
01055         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga4">rt_isrpc</a>(task);
01056 } 
01057 
01058 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_return(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result)
01059 {
01060 
01061         <span class="keywordflow">if</span> (!task || !node) {
01062                 <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga5">rt_return</a>(task, result);
01063         } 
01064         <span class="keywordflow">return</span> <a class="code" href="group__rpc.html#ga5">rt_return</a>(rt_find_asgn_stub(OWNER(node, task), 1), result) ? task : 0;
01065 } 
01066 
01067 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize)
01068 {
01069         <span class="keywordflow">if</span> (node) {
01070                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg, *rmsg; <span class="keywordtype">int</span> ssize, rsize; } arg = { task, smsg, rmsg, ssize, rsize };
01071                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPCX, 0), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG };
01072                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01073         }
01074         <span class="keywordflow">return</span> rt_rpcx(task, smsg, rmsg, ssize, rsize);
01075 } 
01076 
01077 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize)
01078 {
01079         <span class="keywordflow">if</span> (node) {
01080                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg, *rmsg; <span class="keywordtype">int</span> ssize, rsize; } arg = { task, smsg, rmsg, ssize, rsize };
01081                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPCX_IF, 0), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG };
01082                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01083         }
01084         <span class="keywordflow">return</span> rt_rpcx_if(task, smsg, rmsg, ssize, rsize);
01085 } 
01086 
01087 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME time)
01088 {
01089         <span class="keywordflow">if</span> (node) {
01090                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg, *rmsg; <span class="keywordtype">int</span> ssize, rsize; RTIME time; } arg = { task, smsg, rmsg, ssize, rsize, time };
01091                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPCX_UNTIL, 6), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG };
01092                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01093         }
01094         <span class="keywordflow">return</span> rt_rpcx_until(task, smsg, rmsg, ssize, rsize, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
01095 } 
01096 
01097 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_rpcx_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME delay)
01098 {
01099         <span class="keywordflow">if</span> (node) {
01100                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *smsg, *rmsg; <span class="keywordtype">int</span> ssize, rsize; RTIME delay; } arg = { task, smsg, rmsg, ssize, rsize, delay };
01101                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, RPCX_TIMED, 6), UR1(2, 4) | UW1(3, 5), &amp;arg, SIZARG };
01102                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01103         }
01104         <span class="keywordflow">return</span> rt_rpcx_timed(task, smsg, rmsg, ssize, rsize, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
01105 } 
01106 
01107 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
01108 {
01109         <span class="keywordflow">if</span> (node) {
01110                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
01111                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SENDX, 0), UR1(2, 3), &amp;arg, SIZARG };
01112                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01113         }
01114         <span class="keywordflow">return</span> rt_sendx(task, msg, size);
01115 } 
01116 
01117 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
01118 {
01119         <span class="keywordflow">if</span> (node) {
01120                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
01121                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SENDX_IF, 0), UR1(2, 3), &amp;arg, SIZARG };
01122                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01123         }
01124         <span class="keywordflow">return</span> rt_sendx_if(task, msg, size);
01125 } 
01126 
01127 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME time)
01128 {
01129         <span class="keywordflow">if</span> (node) {
01130                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME time; } arg = { task, msg, size, time };
01131                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SENDX_UNTIL, 4), UR1(2, 3), &amp;arg, SIZARG };
01132                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01133         }
01134         <span class="keywordflow">return</span> rt_sendx_until(task, msg, size, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
01135 } 
01136 
01137 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_sendx_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME delay)
01138 {
01139         <span class="keywordflow">if</span> (node) {
01140                 <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME delay; } arg = { task, msg, size, delay };
01141                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, SENDX_TIMED, 4), UR1(2, 3), &amp;arg, SIZARG };
01142                 <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01143         }
01144         <span class="keywordflow">return</span> rt_sendx_timed(task, msg, size, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
01145 } 
01146 
01147 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_returnx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size)
01148 {
01149 
01150         <span class="keywordflow">if</span> (!task || !node) {
01151                 <span class="keywordflow">return</span> rt_returnx(task, msg, size);
01152         } 
01153         <span class="keywordflow">return</span> rt_returnx(rt_find_asgn_stub(OWNER(node, task), 1), msg, size) ? task : 0;
01154 } 
01155 
01156 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_evdrpx(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
01157 {
01158         <span class="keywordflow">if</span> (!task || !node) {
01159                 <span class="keywordflow">return</span> rt_evdrpx(task, msg, size, len);
01160         } 
01161         <span class="keywordflow">return</span> rt_evdrpx(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
01162 } 
01163 
01164 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
01165 {
01166         <span class="keywordflow">if</span> (!task || !node) {
01167                 <span class="keywordflow">return</span> rt_receivex(task, msg, size, len);
01168         } 
01169         <span class="keywordflow">return</span> rt_receivex(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
01170 } 
01171 
01172 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len)
01173 {
01174         <span class="keywordflow">if</span> (!task || !node) {
01175                 <span class="keywordflow">return</span> rt_receivex_if(task, msg, size, len);
01176         } 
01177         <span class="keywordflow">return</span> rt_receivex_if(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len) ? task : 0;
01178 } 
01179 
01180 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME time)
01181 {
01182         <span class="keywordflow">if</span> (!task || !node) {
01183                 <span class="keywordflow">return</span> rt_receivex_until(task, msg, size, len, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
01184         } 
01185         <span class="keywordflow">return</span> rt_receivex_until(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len, <a class="code" href="group__timer.html#ga6">nano2count</a>(time)) ? task : 0;
01186 } 
01187 
01188 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TASK *RT_receivex_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, RT_TASK *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME delay)
01189 {
01190         <span class="keywordflow">if</span> (!task || !node) {
01191                 <span class="keywordflow">return</span> rt_receivex_timed(task, msg, size, len, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
01192         } 
01193         <span class="keywordflow">return</span> rt_receivex_timed(rt_find_asgn_stub(OWNER(node, task), 1), msg, size, len, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay)) ? task : 0;
01194 } 
01195 
01196 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_MSG */</span>
01197 
01198 <span class="preprocessor">#if CONFIG_RTAI_MBX</span>
01199 <span class="preprocessor"></span>
01200 <span class="keyword">static</span> <span class="keyword">inline</span> MBX *RT_typed_named_mbx_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, <span class="keyword">const</span> <span class="keywordtype">char</span> *mbx_name, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> qtype)
01201 {
01202         <span class="keywordflow">if</span> (node) {
01203                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mbx_name; <span class="keywordtype">int</span> size; <span class="keywordtype">int</span> qype; <span class="keywordtype">int</span> namelen; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(mbx_name), size, qtype, strlen(mbx_name) };
01204                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, NAMED_MBX_INIT, 0), 0LL, &amp;arg, SIZARG };
01205                 <span class="keywordflow">return</span> (MBX *)rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).v[LOW];
01206         }
01207         <span class="keywordflow">return</span> (MBX *)rt_typed_named_mbx_init(mbx_name, size, qtype);
01208 }
01209 
01210 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_named_mbx_delete(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx)
01211 {
01212         <span class="keywordflow">if</span> (node) {
01213                 <span class="keyword">struct </span>{ MBX *mbx; } arg = { mbx };
01214                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, NAMED_MBX_DELETE, 0), 0LL, &amp;arg, SIZARG };
01215                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01216         }
01217         <span class="keywordflow">return</span> rt_named_mbx_delete(mbx);
01218 }
01219 
01220 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01221 {
01222         <span class="keywordflow">if</span> (node) {
01223                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01224                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_SEND, 0), UR1(2, 3), &amp;arg, SIZARG };
01225                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01226         } 
01227         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga13">rt_mbx_send</a>(mbx, msg, msg_size);
01228 } 
01229 
01230 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_wp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01231 {
01232         <span class="keywordflow">if</span> (node) {
01233                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01234                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_SEND_WP, 0), UR1(2, 3), &amp;arg, SIZARG };
01235                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01236         } 
01237         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga14">rt_mbx_send_wp</a>(mbx, msg, msg_size);
01238 } 
01239 
01240 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01241 {
01242         <span class="keywordflow">if</span> (node) {
01243                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01244                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_SEND_IF, 0), UR1(2, 3), &amp;arg, SIZARG };
01245                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01246         } 
01247         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga15">rt_mbx_send_if</a>(mbx, msg, msg_size);
01248 } 
01249 
01250 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_ovrwr_send(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01251 {
01252         <span class="keywordflow">if</span> (node) {
01253                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01254                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_OVRWR_SEND, 0), UR1(2, 3), &amp;arg, SIZARG };
01255                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01256         } 
01257         <span class="keywordflow">return</span> rt_mbx_ovrwr_send(mbx, msg, msg_size);
01258 } 
01259 
01260 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time)
01261 {
01262         <span class="keywordflow">if</span> (node) {
01263                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { mbx, msg, msg_size, time };
01264                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_SEND_UNTIL, 4), UR1(2, 3), &amp;arg, SIZARG };
01265                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01266         } 
01267         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga16">rt_mbx_send_until</a>(mbx, msg, msg_size, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
01268 } 
01269 
01270 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_send_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay)
01271 {
01272         <span class="keywordflow">if</span> (node) {
01273                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { mbx, msg, msg_size, delay };
01274                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_SEND_TIMED, 4), UR1(2, 3), &amp;arg, SIZARG };
01275                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01276         } 
01277         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga16">rt_mbx_send_until</a>(mbx, msg, msg_size, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
01278 } 
01279 
01280 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_evdrp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01281 {
01282         <span class="keywordflow">if</span> (node) {
01283                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01284                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_EVDRP, 0), UW1(2, 3), &amp;arg, SIZARG };
01285                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01286         } 
01287         <span class="keywordflow">return</span> rt_mbx_evdrp(mbx, msg, msg_size);
01288 } 
01289 
01290 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01291 {
01292         <span class="keywordflow">if</span> (node) {
01293                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01294                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE, 0), UW1(2, 3), &amp;arg, SIZARG };
01295                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01296         } 
01297         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga18">rt_mbx_receive</a>(mbx, msg, msg_size);
01298 } 
01299 
01300 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_wp(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01301 {
01302         <span class="keywordflow">if</span> (node) {
01303                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01304                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_WP, 0), UW1(2, 3), &amp;arg, SIZARG };
01305                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01306         } 
01307         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga19">rt_mbx_receive_wp</a>(mbx, msg, msg_size);
01308 } 
01309 
01310 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_if(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size)
01311 {
01312         <span class="keywordflow">if</span> (node) {
01313                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { mbx, msg, msg_size };
01314                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_IF, 0), UW1(2, 3), &amp;arg, SIZARG };
01315                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01316         } 
01317         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga20">rt_mbx_receive_if</a>(mbx, msg, msg_size);
01318 } 
01319 
01320 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_until(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time)
01321 {
01322         <span class="keywordflow">if</span> (node) {
01323                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { mbx, msg, msg_size, time };
01324                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_UNTIL, 4), UW1(2, 3), &amp;arg, SIZARG };
01325                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01326         }
01327         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga21">rt_mbx_receive_until</a>(mbx, msg, msg_size, <a class="code" href="group__timer.html#ga6">nano2count</a>(time));
01328 } 
01329 
01330 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> RT_mbx_receive_timed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> node, <span class="keywordtype">int</span> port, MBX *mbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay)
01331 {
01332         <span class="keywordflow">if</span> (node) {
01333                 <span class="keyword">struct </span>{ MBX *mbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { mbx, msg, msg_size, delay };
01334                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fun; <span class="keywordtype">long</span> <span class="keywordtype">long</span> type; <span class="keywordtype">void</span> *args; <span class="keywordtype">int</span> argsize; } args = { PACKPORT(port, NET_RPC_EXT, MBX_RECEIVE_TIMED, 4), UW1(2, 3), &amp;arg, SIZARG };
01335                 <span class="keywordflow">return</span> rtai_lxrt(NET_RPC_IDX, SIZARGS, NETRPC, &amp;args).i[LOW];
01336         }
01337         <span class="keywordflow">return</span> <a class="code" href="group__mbx.html#ga22">rt_mbx_receive_timed</a>(mbx, msg, msg_size, <a class="code" href="group__timer.html#ga6">nano2count</a>(delay));
01338 } 
01339 
01340 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_get_net_rpc_ret(MBX *mbx, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *retval, <span class="keywordtype">void</span> *msg1, <span class="keywordtype">int</span> *msglen1, <span class="keywordtype">void</span> *msg2, <span class="keywordtype">int</span> *msglen2, RTIME timeout, <span class="keywordtype">int</span> type)
01341 {
01342         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> wsize, w2size; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> retval; } reply;
01343         <span class="keywordtype">int</span> ret;
01344 
01345         <span class="keywordflow">switch</span> (type) {
01346                 <span class="keywordflow">case</span> MBX_RECEIVE:
01347                         ret = <a class="code" href="group__mbx.html#ga18">rt_mbx_receive</a>(mbx, &amp;reply, <span class="keyword">sizeof</span>(reply));
01348                         <span class="keywordflow">break</span>;
01349                 <span class="keywordflow">case</span> MBX_RECEIVE_WP:
01350                         ret = <a class="code" href="group__mbx.html#ga19">rt_mbx_receive_wp</a>(mbx, &amp;reply, <span class="keyword">sizeof</span>(reply));
01351                         <span class="keywordflow">break</span>;
01352                 <span class="keywordflow">case</span> MBX_RECEIVE_IF:
01353                         ret = <a class="code" href="group__mbx.html#ga20">rt_mbx_receive_if</a>(mbx, &amp;reply, <span class="keyword">sizeof</span>(reply));
01354                         <span class="keywordflow">break</span>;
01355                 <span class="keywordflow">case</span> MBX_RECEIVE_UNTIL:
01356                         ret = <a class="code" href="group__mbx.html#ga21">rt_mbx_receive_until</a>(mbx, &amp;reply, <span class="keyword">sizeof</span>(reply), timeout);
01357                         <span class="keywordflow">break</span>;
01358                 <span class="keywordflow">case</span> MBX_RECEIVE_TIMED:
01359                         ret = <a class="code" href="group__mbx.html#ga22">rt_mbx_receive_timed</a>(mbx, &amp;reply, <span class="keyword">sizeof</span>(reply), timeout);
01360                 <span class="keywordflow">default</span>:
01361                         ret = -1;
01362         }
01363         <span class="keywordflow">if</span> (!ret) {
01364                 *retval = reply.retval;
01365                 <span class="keywordflow">if</span> (reply.wsize) {
01366                         <span class="keywordflow">if</span> (*msglen1 &gt; reply.wsize) {
01367                                 *msglen1 = reply.wsize;
01368                         }
01369                         <a class="code" href="group__mbx.html#ga18">rt_mbx_receive</a>(mbx, msg1, *msglen1);
01370                 } <span class="keywordflow">else</span> {
01371                         *msglen1 = 0;
01372                 }
01373                 <span class="keywordflow">if</span> (reply.w2size) {
01374                         <span class="keywordflow">if</span> (*msglen2 &gt; reply.w2size) {
01375                                 *msglen2 = reply.w2size;
01376                         }
01377                         <a class="code" href="group__mbx.html#ga18">rt_mbx_receive</a>(mbx, msg2, *msglen2);
01378                 } <span class="keywordflow">else</span> {
01379                         *msglen2 = 0;
01380                 }
01381                 <span class="keywordflow">return</span> 0;
01382         }
01383         <span class="keywordflow">return</span> ret;
01384 }
01385 
01386 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_MBX */</span>
01387 
01388 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
01389 
01390 <span class="comment">/*</span>
01391 <span class="comment"> * A set of compatibility defines for APIs that can be interpreted in various</span>
01392 <span class="comment"> * ways but do the same the same things always.</span>
01393 <span class="comment"> */</span>
01394 
01395 <span class="preprocessor">#define RT_isrpcx(task)  RT_isrpc(task)</span>
01396 <span class="preprocessor"></span>
01397 <span class="preprocessor">#define RT_waiting_return            rt_waiting_return</span>
01398 <span class="preprocessor"></span>
01399 <span class="preprocessor">#define RT_sync_net_rpc              rt_sync_net_rpc</span>
01400 <span class="preprocessor"></span>
01401 <span class="preprocessor">#define RT_request_port              rt_request_port</span>
01402 <span class="preprocessor"></span>
01403 <span class="preprocessor">#define RT_request_port_id           rt_request_port_id</span>
01404 <span class="preprocessor"></span>
01405 <span class="preprocessor">#define RT_request_port_mbx          rt_request_port_mbx</span>
01406 <span class="preprocessor"></span>
01407 <span class="preprocessor">#define RT_request_port_id_mbx       rt_request_port_id_mbx</span>
01408 <span class="preprocessor"></span>
01409 <span class="preprocessor">#define RT_request_soft_port         rt_request_soft_port</span>
01410 <span class="preprocessor"></span>
01411 <span class="preprocessor">#define RT_request_soft_port_id      rt_request_soft_port_id</span>
01412 <span class="preprocessor"></span>
01413 <span class="preprocessor">#define RT_request_soft_port_mbx     rt_request_soft_port_mbx</span>
01414 <span class="preprocessor"></span>
01415 <span class="preprocessor">#define RT_request_soft_port_id_mbx  rt_request_soft_port_id_mbx</span>
01416 <span class="preprocessor"></span>
01417 <span class="preprocessor">#define RT_request_hard_port         rt_request_hard_port</span>
01418 <span class="preprocessor"></span>
01419 <span class="preprocessor">#define RT_request_hard_port_id      rt_request_hard_port_id</span>
01420 <span class="preprocessor"></span>
01421 <span class="preprocessor">#define RT_request_hard_port_mbx     rt_request_hard_port_mbx</span>
01422 <span class="preprocessor"></span>
01423 <span class="preprocessor">#define RT_request_hard_port_id_mbx  rt_request_hard_port_id_mbx</span>
01424 <span class="preprocessor"></span>
01425 <span class="preprocessor">#define RT_release_port              rt_release_port</span>
01426 <span class="preprocessor"></span>
01427 <span class="preprocessor">#define rt_request_port              rt_request_soft_port </span>
01428 <span class="preprocessor"></span>
01429 <span class="preprocessor">#define rt_request_port_id           rt_request_soft_port_id</span>
01430 <span class="preprocessor"></span>
01431 <span class="preprocessor">#define rt_request_port_mbx          rt_request_soft_port_mbx</span>
01432 <span class="preprocessor"></span>
01433 <span class="preprocessor">#define rt_request_port_id_mbx       rt_request_soft_port_id_mbx</span>
01434 <span class="preprocessor"></span>
01435 <span class="comment">/*</span>
01436 <span class="comment"> * End of compatibility defines.</span>
01437 <span class="comment"> */</span>
01438 
01439 <span class="preprocessor">#define rt_request_soft_port(node) \</span>
01440 <span class="preprocessor">        rt_send_req_rel_port(node, 0, 0, 0, 0)</span>
01441 <span class="preprocessor"></span>
01442 <span class="preprocessor">#define rt_request_soft_port_id(node, id) \</span>
01443 <span class="preprocessor">        rt_send_req_rel_port(node, 0, id, 0, 0)</span>
01444 <span class="preprocessor"></span>
01445 <span class="preprocessor">#define rt_request_soft_port_mbx(node, mbx) \</span>
01446 <span class="preprocessor">        rt_send_req_rel_port(node, 0, 0, mbx, 0)</span>
01447 <span class="preprocessor"></span>
01448 <span class="preprocessor">#define rt_request_soft_port_id_mbx(node, id, mbx) \</span>
01449 <span class="preprocessor">        rt_send_req_rel_port(node, 0, id, mbx, 0)</span>
01450 <span class="preprocessor"></span>
01451 <span class="preprocessor">#define rt_request_hard_port(node) \</span>
01452 <span class="preprocessor">        rt_send_req_rel_port(node, 0, 0, 0, 1)</span>
01453 <span class="preprocessor"></span>
01454 <span class="preprocessor">#define rt_request_hard_port_id(node, id) \</span>
01455 <span class="preprocessor">        rt_send_req_rel_port(node, 0, id, 0, 1)</span>
01456 <span class="preprocessor"></span>
01457 <span class="preprocessor">#define rt_request_hard_port_mbx(node, mbx) \</span>
01458 <span class="preprocessor">        rt_send_req_rel_port(node, 0, 0, mbx, 1)</span>
01459 <span class="preprocessor"></span>
01460 <span class="preprocessor">#define rt_request_hard_port_id_mbx(node, id, mbx) \</span>
01461 <span class="preprocessor">        rt_send_req_rel_port(node, 0, id, mbx, 1)</span>
01462 <span class="preprocessor"></span>
01463 <span class="preprocessor">#define rt_release_port(node, port) \</span>
01464 <span class="preprocessor">        rt_send_req_rel_port(node, port, 0, 0, 0) </span>
01465 <span class="preprocessor"></span>
01466 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_INTERNAL_LXRT_SUPPORT */</span>
01467 
01468 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_NETRPC_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jan 20 15:55:46 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
