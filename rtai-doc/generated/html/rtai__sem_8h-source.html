<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_sem.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/rtai_sem.h</h1><a href="rtai__sem_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00024 <span class="preprocessor">#ifndef _RTAI_SEM_H</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_SEM_H</span>
00026 <span class="preprocessor"></span>
00027 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="rtai__nam2num_8h.html">rtai_nam2num.h</a>&gt;</span>
00029 
00030 <span class="preprocessor">#define RT_SEM_MAGIC 0xaabcdeff</span>
00031 <span class="preprocessor"></span>
00032 <span class="preprocessor">#define SEM_TIMOUT (0xFffe)</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#define SEM_ERR (0xFfff)</span>
00035 <span class="preprocessor"></span>
00036 <span class="preprocessor">#if defined(__KERNEL__) &amp;&amp; !defined(__cplusplus)</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#include &lt;rtai_sched.h&gt;</span>
00039 
00040 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore {
00041     <span class="keyword">struct </span>rt_queue queue; <span class="comment">/* &lt;= Must be first in struct. */</span>
00042     <span class="keywordtype">int</span> magic;
00043     <span class="keywordtype">int</span> type;
00044     <span class="keywordtype">int</span> count;
00045     <span class="keyword">struct </span>rt_task_struct *owndby;
00046     <span class="keywordtype">int</span> qtype;
00047 } SEM;
00048 
00049 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ || __cplusplus */</span>
00050 
00051 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore {
00052     <span class="keywordtype">int</span> opaque;
00053 } SEM;
00054 
00055 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ &amp;&amp; !__cplusplus */</span>
00056 
00057 <span class="keyword">typedef</span> SEM CND;
00058 
00059 <span class="preprocessor">#ifdef __KERNEL__</span>
00060 <span class="preprocessor"></span>
00061 <span class="preprocessor">#include &lt;linux/errno.h&gt;</span>
00062 
00063 <span class="preprocessor">#ifdef CONFIG_RTAI_SEM_BUILTIN</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#define SEM_INIT_MODULE     sem_init_module</span>
00065 <span class="preprocessor"></span><span class="preprocessor">#define SEM_CLEANUP_MODULE  sem_cleanup_module</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#else  </span><span class="comment">/* !CONFIG_RTAI_SEM_BUILTIN */</span>
00067 <span class="preprocessor">#define SEM_INIT_MODULE     init_module</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#define SEM_CLEANUP_MODULE  cleanup_module</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_SEM_BUILTIN */</span>
00070 
00071 <span class="keyword">typedef</span> SEM psem_t;
00072 
00073 <span class="keyword">typedef</span> SEM pmutex_t;
00074 
00075 <span class="preprocessor">#ifdef __cplusplus</span>
00076 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00077 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00078 
00079 <span class="keywordtype">int</span> SEM_INIT_MODULE(<span class="keywordtype">void</span>);
00080 
00081 <span class="keywordtype">void</span> SEM_CLEANUP_MODULE(<span class="keywordtype">void</span>);
00082 
00083 <span class="keywordtype">void</span> <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(SEM *sem,
00084                        <span class="keywordtype">int</span> value,
00085                        <span class="keywordtype">int</span> type);
00086 
00087 SEM *_rt_typed_named_sem_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sem_name,
00088                              <span class="keywordtype">int</span> value,
00089                              <span class="keywordtype">int</span> type);
00090 <span class="keyword">static</span> <span class="keyword">inline</span> SEM *rt_typed_named_sem_init(<span class="keyword">const</span> <span class="keywordtype">char</span> *sem_name, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type)
00091 {       
00092         <span class="keywordflow">return</span> _rt_typed_named_sem_init(<a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(sem_name), value, type);
00093 }
00094 
00095 <span class="keywordtype">void</span> <a class="code" href="group__lxrt.html#a349">rt_sem_init</a>(SEM *sem,
00096                  <span class="keywordtype">int</span> value);
00097 
00098 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(SEM *sem);
00099 
00100 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(SEM *sem);
00101 
00102 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a7">rt_sem_broadcast</a>(SEM *sem);
00103 
00104 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(SEM *sem);
00105 
00106 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(SEM *sem);
00107 
00108 <span class="keywordtype">int</span> rt_cntsem_wait_if_and_lock(SEM *sem);
00109 
00110 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(SEM *sem,
00111                       RTIME time);
00112 
00113 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a11">rt_sem_wait_timed</a>(SEM *sem,
00114                       RTIME delay);
00115 
00116 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a12">rt_sem_wait_barrier</a>(SEM *sem);
00117 
00118 <span class="keywordtype">int</span> rt_sem_count(SEM *sem);
00119 
00120 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a13">rt_cond_signal</a>(CND *cnd);
00121 
00122 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a15">rt_cond_wait</a>(CND *cnd,
00123                  SEM *mtx);
00124 
00125 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a16">rt_cond_wait_until</a>(CND *cnd,
00126                        SEM *mtx,
00127                        RTIME time);
00128 
00129 <span class="keywordtype">int</span> <a class="code" href="sem_8c.html#a17">rt_cond_wait_timed</a>(CND *cnd,
00130                        SEM *mtx,
00131                        RTIME delay);
00132 
00133 <span class="preprocessor">#define rt_named_sem_init(sem_name, value)  rt_typed_named_sem_init(sem_name, value, CNT_SEM)</span>
00134 <span class="preprocessor"></span>
00135 <span class="keywordtype">int</span> rt_named_sem_delete(SEM *sem);
00136 
00137 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_init(psem_t *sem, <span class="keywordtype">int</span> pshared, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value)
00138 {
00139         <span class="keywordflow">if</span> (value &lt; SEM_TIMOUT) {
00140                 <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(sem, value, pshared | PRIO_Q);
00141                 <span class="keywordflow">return</span> 0;
00142         }
00143         <span class="keywordflow">return</span> -EINVAL;
00144 }
00145 
00146 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_destroy(psem_t *sem)
00147 {
00148         <span class="keywordflow">if</span> (<a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem) &gt;= 0) {
00149                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00150                 <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(sem);
00151         }
00152         <span class="keywordflow">return</span> -EBUSY;
00153 }
00154 
00155 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_wait(psem_t *sem) {
00156     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(sem) &lt; SEM_TIMOUT ? 0 : -1;
00157 }
00158 
00159 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_timedwait(psem_t *sem, <span class="keyword">struct</span> timespec *abstime) {
00160     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(sem, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -1;
00161 }
00162 
00163 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_trywait(psem_t *sem) {
00164     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem) &gt; 0 ? 0 : -EAGAIN;
00165 }
00166 
00167 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_post(psem_t *sem) {
00168     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00169 }
00170 
00171 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_psem_getvalue(psem_t *sem, <span class="keywordtype">int</span> *sval)
00172 {
00173         <span class="keywordflow">if</span> ((*sval = <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(sem)) &gt; 0) {
00174                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(sem);
00175         }
00176         <span class="keywordflow">return</span> 0;
00177 }
00178 
00179 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_init(pmutex_t *mutex, <span class="keywordtype">void</span> *mutexattr)
00180 {
00181         <a class="code" href="group__sem.html#a2">rt_typed_sem_init</a>(mutex, 1, RES_SEM);
00182         <span class="keywordflow">return</span> 0;
00183 }
00184 
00185 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_destroy(pmutex_t *mutex)
00186 {
00187         <span class="keywordflow">if</span> (<a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(mutex) &gt; 0) {
00188                 <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(mutex);
00189                 <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a4">rt_sem_delete</a>(mutex);
00190         }
00191         <span class="keywordflow">return</span> -EBUSY;
00192 }
00193 
00194 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_lock(pmutex_t *mutex) {
00195     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a8">rt_sem_wait</a>(mutex) &lt; SEM_TIMOUT ? 0 : -EINVAL;
00196 }
00197 
00198 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_trylock(pmutex_t *mutex) {
00199     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a9">rt_sem_wait_if</a>(mutex) &gt; 0 ? 0 : -EBUSY;
00200 }
00201 
00202 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_timedlock(pmutex_t *sem, <span class="keyword">struct</span> timespec *abstime) {
00203     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a10">rt_sem_wait_until</a>(sem, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -1;
00204 }
00205 
00206 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_pmutex_unlock(pmutex_t *mutex) {
00207     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a6">rt_sem_signal</a>(mutex);
00208 }
00209 
00210 <span class="preprocessor">#define rt_mutex_init(mtx)             rt_typed_sem_init(mtx, 1, RES_SEM)</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_delete(mtx)           rt_sem_delete(mtx)</span>
00212 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_destroy(mtx)          rt_sem_delete(mtx)</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_trylock(mtx)          rt_sem_wait_if(mtx)</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_lock(mtx)             rt_sem_wait(mtx)</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_timedlock(mtx, time)  rt_sem_wait_until(mtx, time)</span>
00216 <span class="preprocessor"></span><span class="preprocessor">#define rt_mutex_unlock(mtx)           rt_sem_signal(mtx)</span>
00217 <span class="preprocessor"></span>
00218 <span class="preprocessor">#define rt_cond_init(cnd)                  rt_typed_sem_init(cnd, 0, BIN_SEM | PRIO_Q)</span>
00219 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_delete(cnd)                rt_sem_delete(cnd)</span>
00220 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_destroy(cnd)               rt_sem_delete(cnd)</span>
00221 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_broadcast(cnd)             rt_sem_broadcast(cnd)</span>
00222 <span class="preprocessor"></span>
00223 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_cond_timedwait(CND *cnd, SEM *mtx, RTIME time) {
00224     <span class="keywordflow">return</span> <a class="code" href="sem_8c.html#a16">rt_cond_wait_until</a>(cnd, mtx, time) &lt; SEM_TIMOUT ? 0 : -1;
00225 }
00226 
00227 <span class="preprocessor">#ifdef __cplusplus</span>
00228 <span class="preprocessor"></span>}
00229 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00230 
00231 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00232 
00233 <span class="preprocessor">#include &lt;<a class="code" href="rtai__lxrt_8h.html">rtai_lxrt.h</a>&gt;</span>
00234 
00235 <span class="preprocessor">#ifdef __cplusplus</span>
00236 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00237 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00238 
00239 RTAI_PROTO(SEM *, rt_typed_sem_init,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type))
00240 {
00241         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { name, value, type };
00242         <span class="keywordflow">return</span> (SEM *)rtai_lxrt(BIDX, SIZARG, LXRT_SEM_INIT, &amp;arg).v[LOW];
00243 }
00244 
<a name="l00262"></a><a class="code" href="group__lxrt.html#a349">00262</a> <span class="preprocessor">#define rt_sem_init(name, value) rt_typed_sem_init(name, value, CNT_SEM)</span>
00263 <span class="preprocessor"></span>
00264 <span class="preprocessor">#define rt_named_sem_init(sem_name, value) \</span>
00265 <span class="preprocessor">        rt_typed_named_sem_init(sem_name, value, CNT_SEM)</span>
00266 <span class="preprocessor"></span>
<a name="l00267"></a><a class="code" href="group__sem.html#a4">00267</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_delete,(SEM *sem))
00268 {
00269         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00270         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_SEM_DELETE, &amp;arg).i[LOW];
00271 }
00272 
00273 RTAI_PROTO(SEM *, rt_typed_named_sem_init,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type))
00274 {
00275         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name; <span class="keywordtype">int</span> value, type; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(name), value, type };
00276         <span class="keywordflow">return</span> (SEM *)rtai_lxrt(BIDX, SIZARG, NAMED_SEM_INIT, &amp;arg).v[LOW];
00277 }
00278 
00279 RTAI_PROTO(<span class="keywordtype">int</span>, rt_named_sem_delete,(SEM *sem))
00280 {
00281         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00282         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NAMED_SEM_DELETE, &amp;arg).i[LOW];
00283 }
00284 
<a name="l00285"></a><a class="code" href="group__sem.html#a6">00285</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_signal,(SEM *sem))
00286 {
00287         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00288         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_SIGNAL, &amp;arg).i[LOW];
00289 }
00290 
<a name="l00291"></a><a class="code" href="group__sem.html#a7">00291</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_broadcast,(SEM *sem))
00292 {
00293         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00294         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_BROADCAST, &amp;arg).i[LOW];
00295 }
00296 
<a name="l00297"></a><a class="code" href="group__sem.html#a8">00297</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait,(SEM *sem))
00298 {
00299         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00300         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT, &amp;arg).i[LOW];
00301 }
00302 
<a name="l00303"></a><a class="code" href="group__sem.html#a9">00303</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_if,(SEM *sem))
00304 {
00305         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00306         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_IF, &amp;arg).i[LOW];
00307 }
00308 
<a name="l00309"></a><a class="code" href="group__sem.html#a10">00309</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_until,(SEM *sem, RTIME time))
00310 {
00311         <span class="keyword">struct </span>{ SEM *sem; RTIME time; } arg = { sem, time };
00312         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_UNTIL, &amp;arg).i[LOW];
00313 }
00314 
<a name="l00315"></a><a class="code" href="group__sem.html#a11">00315</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_timed,(SEM *sem, RTIME delay))
00316 {
00317         <span class="keyword">struct </span>{ SEM *sem; RTIME delay; } arg = { sem, delay };
00318         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_TIMED, &amp;arg).i[LOW];
00319 }
00320 
<a name="l00321"></a><a class="code" href="group__sem.html#a12">00321</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_wait_barrier,(SEM *sem))
00322 {
00323         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00324         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_BARRIER, &amp;arg).i[LOW];
00325 }
00326 
00327 RTAI_PROTO(<span class="keywordtype">int</span>, rt_sem_count,(SEM *sem))
00328 {
00329         <span class="keyword">struct </span>{ SEM *sem; } arg = { sem };
00330         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_COUNT, &amp;arg).i[LOW];
00331 }
00332 
<a name="l00348"></a><a class="code" href="group__lxrt.html#a350">00348</a> <span class="preprocessor">#define rt_cond_init(name)                 rt_typed_sem_init(name, 0, BIN_SEM)</span>
00349 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_delete(cnd)                rt_sem_delete(cnd)</span>
00350 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_destroy(cnd)               rt_sem_delete(cnd)</span>
00351 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_broadcast(cnd)             rt_sem_broadcast(cnd)</span>
00352 <span class="preprocessor"></span><span class="preprocessor">#define rt_cond_timedwait(cnd, mtx, time)  rt_cond_wait_until(cnd, mtx, time)</span>
00353 <span class="preprocessor"></span>
<a name="l00354"></a><a class="code" href="group__sem.html#a13">00354</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_signal,(CND *cnd))
00355 {
00356         <span class="keyword">struct </span>{ CND *cnd; } arg = { cnd };
00357         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_SIGNAL, &amp;arg).i[LOW];
00358 }
00359 
<a name="l00360"></a><a class="code" href="group__sem.html#a15">00360</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_wait,(CND *cnd, SEM  *mutex))
00361 {
00362         <span class="keyword">struct </span>{ CND *cnd; SEM *mutex; } arg = { cnd, mutex };
00363         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT, &amp;arg).i[LOW];
00364 }
00365 
<a name="l00366"></a><a class="code" href="group__sem.html#a16">00366</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_wait_until,(CND *cnd, SEM *mutex, RTIME time))
00367 {
00368         <span class="keyword">struct </span>{ CND *cnd; SEM *mutex; RTIME time; } arg = { cnd, mutex, time };
00369         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT_UNTIL, &amp;arg).i[LOW];
00370 }
00371 
<a name="l00372"></a><a class="code" href="group__sem.html#a17">00372</a> RTAI_PROTO(<span class="keywordtype">int</span>, rt_cond_wait_timed,(CND *cnd, SEM *mutex, RTIME delay))
00373 {
00374         <span class="keyword">struct </span>{ CND *cnd; SEM *mutex; RTIME delay; } arg = { cnd, mutex, delay };
00375         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT_TIMED, &amp;arg).i[LOW];
00376 }
00377 
00378 <span class="preprocessor">#ifdef __cplusplus</span>
00379 <span class="preprocessor"></span>}
00380 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00381 
00382 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00383 
00384 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_SEM_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Jun 20 20:09:33 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
