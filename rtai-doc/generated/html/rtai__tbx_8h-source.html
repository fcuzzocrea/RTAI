<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: rtai-core/include/rtai_tbx.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>rtai-core/include/rtai_tbx.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 2001  G.M. Bertani &lt;gmbertani@yahoo.it&gt;</span>
00003 <span class="comment"> * Copyright (C) 2002  P. Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00004 <span class="comment"> *                       (LXRT extensions).</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00007 <span class="comment"> * modify it under the terms of the GNU General Public License as</span>
00008 <span class="comment"> * published by the Free Software Foundation; either version 2 of the</span>
00009 <span class="comment"> * License, or (at your option) any later version.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00012 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00013 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00014 <span class="comment"> * GNU General Public License for more details.</span>
00015 <span class="comment"> *</span>
00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00017 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00018 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="preprocessor">#ifndef _RTAI_TBX_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_TBX_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00025 
00026 <span class="comment">/* TYPED MAILBOXES */</span>
00027 
00028 <span class="preprocessor">#define RT_TBX_MAGIC 0x6e93ad4b</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#define TYPE_NONE      0x00</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_NORMAL    0x01</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_BROADCAST 0x02</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_URGENT    0x04</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#ifdef __KERNEL__</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#ifdef CONFIG_RTAI_TBX_BUILTIN</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define TBX_INIT_MODULE     tbx_init_module</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define TBX_CLEANUP_MODULE  tbx_cleanup_module</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#else  </span><span class="comment">/* !CONFIG_RTAI_TBX_BUILTIN */</span>
00041 <span class="preprocessor">#define TBX_INIT_MODULE     init_module</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define TBX_CLEANUP_MODULE  cleanup_module</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_TBX_BUILTIN */</span>
00044 
00045 <span class="keyword">struct </span>rt_typed_mailbox;
00046 
00047 <span class="preprocessor">#ifndef __cplusplus</span>
00048 <span class="preprocessor"></span>
00049 <span class="preprocessor">#include &lt;<a class="code" href="rtai__sem_8h.html">rtai_sem.h</a>&gt;</span>
00050 
00051 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_typed_mailbox {
00052 
00053     <span class="keywordtype">int</span> magic;
00054     <span class="keywordtype">int</span> waiting_nr;   <span class="comment">/* number of tasks waiting for a broadcast */</span>
00055     SEM sndsmx, rcvsmx;
00056     SEM bcbsmx;       <span class="comment">/* binary sem needed to wakeup the sleeping tasks </span>
00057 <span class="comment">                      when the broadcasting of a message is terminated */</span>
00058     RT_TASK *waiting_task;
00059     <span class="keywordtype">char</span> *bufadr;     <span class="comment">/* mailbox buffer */</span>
00060     <span class="keywordtype">char</span> *bcbadr;     <span class="comment">/* broadcasting buffer */</span>
00061     <span class="keywordtype">int</span> size;         <span class="comment">/* mailbox size */</span>
00062     <span class="keywordtype">int</span> fbyte;        <span class="comment">/* circular buffer read pointer */</span>
00063     <span class="keywordtype">int</span> avbs;         <span class="comment">/* bytes occupied */</span>
00064     <span class="keywordtype">int</span> frbs;         <span class="comment">/* bytes free */</span>
00065     spinlock_t buflock;
00066 
00067 } TBX;
00068 
00069 <span class="preprocessor">#else </span><span class="comment">/* __cplusplus */</span>
00070 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00071 <span class="preprocessor">#endif </span><span class="comment">/* !__cplusplus */</span>
00072 
00073 <span class="keywordtype">int</span> TBX_INIT_MODULE(<span class="keywordtype">void</span>);
00074 
00075 <span class="keywordtype">void</span> TBX_CLEANUP_MODULE(<span class="keywordtype">void</span>);
00076 
00077 <span class="comment">/*</span>
00078 <span class="comment"> * send_wp and receive_wp are not implemented because </span>
00079 <span class="comment"> * the packed message must be sent/received atomically</span>
00080 <span class="comment"> */</span> 
00081 
00082 <span class="keywordtype">int</span> rt_tbx_init(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00083                 <span class="keywordtype">int</span> size,
00084                 <span class="keywordtype">int</span> flags);
00085 
00086 <span class="keywordtype">int</span> rt_tbx_delete(<span class="keyword">struct</span> rt_typed_mailbox *tbx);
00087 
00088 <span class="keywordtype">int</span> rt_tbx_send(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00089                 <span class="keywordtype">void</span> *msg,
00090                 <span class="keywordtype">int</span> msg_size);
00091 
00092 <span class="keywordtype">int</span> rt_tbx_send_if(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00093                    <span class="keywordtype">void</span> *msg,
00094                    <span class="keywordtype">int</span> msg_size);
00095 
00096 <span class="keywordtype">int</span> rt_tbx_send_until(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00097                       <span class="keywordtype">void</span> *msg,
00098                       <span class="keywordtype">int</span> msg_size,
00099                       RTIME time);
00100 
00101 <span class="keywordtype">int</span> rt_tbx_send_timed(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00102                       <span class="keywordtype">void</span> *msg,
00103                       <span class="keywordtype">int</span> msg_size,
00104                       RTIME delay);
00105 
00106 <span class="keywordtype">int</span> rt_tbx_receive(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00107                    <span class="keywordtype">void</span> *msg,
00108                    <span class="keywordtype">int</span> msg_size);
00109 
00110 <span class="keywordtype">int</span> rt_tbx_receive_if(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00111                       <span class="keywordtype">void</span> *msg,
00112                       <span class="keywordtype">int</span> msg_size);
00113 
00114 <span class="keywordtype">int</span> rt_tbx_receive_until(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00115                          <span class="keywordtype">void</span> *msg,
00116                          <span class="keywordtype">int</span> msg_size,
00117                          RTIME time);
00118 
00119 <span class="keywordtype">int</span> rt_tbx_receive_timed(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00120                          <span class="keywordtype">void</span> *msg,
00121                          <span class="keywordtype">int</span> msg_size,
00122                          RTIME delay);
00123 
00124 <span class="keywordtype">int</span> rt_tbx_broadcast(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00125                      <span class="keywordtype">void</span> *msg,
00126                      <span class="keywordtype">int</span> msg_size);
00127 
00128 <span class="keywordtype">int</span> rt_tbx_broadcast_if(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00129                         <span class="keywordtype">void</span> *msg,
00130                         <span class="keywordtype">int</span> msg_size);
00131 
00132 <span class="keywordtype">int</span> rt_tbx_broadcast_until(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00133                            <span class="keywordtype">void</span> *msg,
00134                            <span class="keywordtype">int</span> msg_size,
00135                            RTIME time);
00136 
00137 <span class="keywordtype">int</span> rt_tbx_broadcast_timed(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00138                            <span class="keywordtype">void</span> *msg,
00139                            <span class="keywordtype">int</span> msg_size,
00140                            RTIME delay);
00141 
00142 <span class="keywordtype">int</span> rt_tbx_urgent(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00143                   <span class="keywordtype">void</span> *msg,
00144                   <span class="keywordtype">int</span> msg_size);
00145 
00146 <span class="keywordtype">int</span> rt_tbx_urgent_if(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00147                      <span class="keywordtype">void</span> *msg,
00148                      <span class="keywordtype">int</span> msg_size);
00149 
00150 <span class="keywordtype">int</span> rt_tbx_urgent_until(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00151                         <span class="keywordtype">void</span> *msg,
00152                         <span class="keywordtype">int</span> msg_size,
00153                         RTIME time);
00154 
00155 <span class="keywordtype">int</span> rt_tbx_urgent_timed(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00156                         <span class="keywordtype">void</span> *msg,
00157                         <span class="keywordtype">int</span> msg_size,
00158                         RTIME delay);
00159 
00160 <span class="preprocessor">#ifdef __cplusplus</span>
00161 <span class="preprocessor"></span>}
00162 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00163 
00164 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00165 
00166 <span class="preprocessor">#include &lt;<a class="code" href="rtai__lxrt_8h.html">rtai_lxrt.h</a>&gt;</span>
00167 
00168 <span class="preprocessor">#define TBXIDX 0</span>
00169 <span class="preprocessor"></span>
00170 <span class="preprocessor">#ifdef __cplusplus</span>
00171 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00172 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00173 
00174 RTAI_PROTO(<span class="keyword">struct</span> rt_typed_mailbox *, rt_tbx_init,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> flags))
00175 {
00176         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name; <span class="keywordtype">int</span> size; <span class="keywordtype">int</span> flags; } arg = { name, size, flags };
00177         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_typed_mailbox *)rtai_lxrt(TBXIDX, SIZARG, TBX_INIT, &amp;arg).v[LOW];
00178 }
00179 
00180 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_delete,(<span class="keyword">struct</span> rt_typed_mailbox *tbx))
00181 {
00182         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; } arg = { tbx };
00183         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_DELETE, &amp;arg).i[LOW];
00184 }
00185 
00186 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_send,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00187 {
00188         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00189         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_SEND, &amp;arg).i[LOW];
00190 }
00191 
00192 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_send_if,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00193 {
00194         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00195         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_SEND_IF, &amp;arg).i[LOW];
00196 }
00197 
00198 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_send_until,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time))
00199 {
00200         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { tbx, msg, msg_size, time };
00201         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_SEND_UNTIL, &amp;arg).i[LOW];
00202 }
00203 
00204 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_send_timed,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay))
00205 {
00206         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { tbx, msg, msg_size, delay };
00207         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_SEND_TIMED, &amp;arg).i[LOW];
00208 }
00209 
00210 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_receive,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00211 {
00212         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00213         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_RECEIVE, &amp;arg).i[LOW];
00214 }
00215 
00216 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_receive_if,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00217 {
00218         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00219         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_RECEIVE_IF, &amp;arg).i[LOW];
00220 }
00221 
00222 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_receive_until,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time))
00223 {
00224         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { tbx, msg, msg_size, time };
00225         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_RECEIVE_UNTIL, &amp;arg).i[LOW];
00226 }
00227 
00228 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_receive_timed,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay))
00229 {
00230         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { tbx, msg, msg_size, delay };
00231         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_RECEIVE_TIMED, &amp;arg).i[LOW];
00232 }
00233 
00234 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_broadcast,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00235 {
00236         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00237         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_BROADCAST, &amp;arg).i[LOW];
00238 }
00239 
00240 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_broadcast_if,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00241 {
00242         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00243         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_BROADCAST_IF, &amp;arg).i[LOW];
00244 }
00245 
00246 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_broadcast_until,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time))
00247 {
00248         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { tbx, msg, msg_size, time };
00249         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_BROADCAST_UNTIL, &amp;arg).i[LOW];
00250 }
00251 
00252 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_broadcast_timed,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay))
00253 {
00254         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { tbx, msg, msg_size, delay };
00255         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_BROADCAST_TIMED, &amp;arg).i[LOW];
00256 }
00257 
00258 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_urgent,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00259 {
00260         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00261         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_URGENT, &amp;arg).i[LOW];
00262 }
00263 
00264 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_urgent_if,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00265 {
00266         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00267         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_URGENT_IF, &amp;arg).i[LOW];
00268 }
00269 
00270 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_urgent_until,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time))
00271 {
00272         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { tbx, msg, msg_size, time };
00273         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_URGENT_UNTIL, &amp;arg).i[LOW];
00274 }
00275 
00276 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_urgent_timed,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay))
00277 {
00278         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { tbx, msg, msg_size, delay };
00279         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_URGENT_TIMED, &amp;arg).i[LOW];
00280 }
00281 
00282 <span class="preprocessor">#ifdef __cplusplus</span>
00283 <span class="preprocessor"></span>}
00284 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00285 
00286 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00287 
00288 <span class="preprocessor">#if !defined(__KERNEL__) || defined(__cplusplus)</span>
00289 <span class="preprocessor"></span>
00290 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_typed_mailbox {
00291     <span class="keywordtype">int</span> opaque;
00292 } TBX;
00293 
00294 <span class="preprocessor">#endif </span><span class="comment">/* !__KERNEL__ || __cplusplus */</span>
00295 
00296 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_TBX_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jul 24 19:31:26 2004 for RTAI API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
