<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>1.2. Porting traditional RTOS-based applications to GNU/Linux</title>
<link rel="stylesheet" href="../css/rtai.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="The XENOMAI project Implementing a RTOS emulation framework
      on GNU/Linux">
<link rel="up" href="whitepaper.html" title="1. White paper">
<link rel="previous" href="introduction.html" title="1.1. Introduction">
<link rel="next" href="common-framework.html" title="1.3. A common emulation framework">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">1.2. Porting traditional RTOS-based applications to GNU/Linux</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="introduction.html"><img src="../pictures/prev.gif" alt="Prev"></a> </td>
<th width="60%" align="center">1. White paper</th>
<td width="20%" align="right"> <a accesskey="n" href="common-framework.html"><img src="../pictures/next.gif" alt="Next"></a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="porting-rtos"></a>1.2. Porting traditional RTOS-based applications to GNU/Linux</h3></div></div>
<div></div>
</div>
<p>The idea of using GNU/Linux </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../pictures/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p> Ceci est une
      petite note sur GNU/Linux</p></td></tr>
</table></div>
<p> as an embedded system
      with real-time capabilities is not novel. The reader can refer
      to Jerry Epplin's article in the October 97 issue of Embedded
      Systems Programming for a discussion about GNU/Linux potential
      in the embedded field [2].</p>
<p>Throughout this document, we will use the expression
      <span class="emphasis"><em>source RTOS</em></span> to indicate the traditional
      real-time operating from which the application is to be ported,
      and<span class="emphasis"><em>target OS</em></span>to indicate GNU/Linux or any
      other free operating system to which the application could be
      ported.</p>
<div class="sect3" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="highlevel-code"></a>1.2.1. <span class="level3">Limited high-level code modification</span></h4></div></div>
<div></div>
</div>
<p>Keeping the initial design and implementation of a hard
	real-time application when attempting to port it to another
	architecture is obviously of the greatest
	interest. Reliability and performance may have been obtained
	after a long, complex and costly engineering process one does
	not want to compromise. Consequently, the best situation is to
	have the closest possible equivalence between the source and
	destination RTOS programming interfaces, as far as both the
	syntax and the semantics are concerned.</p>
<p>For instance, if the application needs dynamic memory
	allocation with success guarantee for its real-time threads
	(which is different from a real-time guarantee), porting it to
	a GNU/Linux hard real-time extension (such as RTAI or RTLinux)
	raises the following issues:

	</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Linux kernel's
	      <span class="emphasis"><em>kmalloc()/kfree()</em></span> services should
	      ne be called on behalf of a real-time thread, since
	      these services are not reentrant.  Consequently, the
	      needed memory has to be pre-allocated statically or
	      during the application startup, on behalf of the Linux
	      kernel context.</p></li>
<li><p>A dynamic allocator callable from a real-time
	      context is provided by RTAI
	      (i.e. <span class="emphasis"><em>rt_mem_mgr</em></span>), but its services
	      are based on an algorithm
	      <span class="emphasis"><em>anticipating</em></span>the memory starvations
	      using an asynchronous pre-allocation technique, but
	      <span class="emphasis"><em>not guaranteeing</em></span>that no failure
	      could occur. To give a reasonable guarantee of success
	      in allocating memory blocks, i.e. to be sure that valid
	      memory will always be returned to the real-time thread
	      as soon as it is available from the Linux kernel, the
	      calling thread should be put in a wait state until the
	      memory it has requested is available.</p></li>
</ul></div>
<p>

	</p>
<p>In both cases, it may be necessary to adapt the memory
	management strategy according to these constraints, which
	could be quite difficult and error-prone task.</p>
<p>Another example can be taken from the support of a
	priority inheritance protocol [3] by the mutual exclusion
	services. These services allow concurrent threads to protect
	themselves from race conditions that could occur into critical
	sections of code. The purpose of this discussion is not to
	argue whether relying on priority inheritance for resolving
	priority inversion problems is a major design flaw or a
	necessary safety belt for a real-time application, but only to
	emphasize that any cases, if this feature is used in the
	source RTOS, but not available from the target OS, the
	resource management strategy must be reevaluated for the
	application, since priority inversion risks will
	exists.</p>
</div>
<div class="sect3" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="rtos-compat"></a>1.2.2. RTOS behavioral compatibility</h4></div></div>
<div></div>
</div>
<p>During the past years, major embedded RTOS, such as
	VRTX, VxWorks, pSOS+ and a few others, have implemented a
	real-time kernel behavior which has become a de facto
	standard, notably for thread scheduling, inter-thread
	synchronization, and asynchronous event management. To
	illustrate this, let us talk about a specific concern in the
	interrupt service management.</p>
<p>A well-known behavior of such RTOS is to lock the
	rescheduling procedure until the outer interrupt service
	routine (or ISR) - called first upon possibly nested
	interrupts - has exited, after which a global rescheduling is
	finally stated. This way, an interrupt service routine
	can always assume that no synchronous thread activity may run
	until it has exited. Moreover, all changes impacting the
	scheduling order of threads, due to actions taken by any
	number of nested ISRs (e.g. signaling a synchronization object
	on which one or more threads are pending) are considered once
	and conjunctively, instead of disjunctively.</p>
<p>For instance, if a suspended thread is first resumed by
	an ISR, then forcibly suspended later by another part of the
	same ISR, the outcome will be that the thread will not run,
	and remain suspended after the ISR has exited. In the other
	hand, if the RTOS sees ISRs as non-specific code that can be
	preempted by threads, the considered thread will be given the
	opportunity to execute immediately after it is resumed, until
	it is suspended anew. Obviously, the respective resulting
	situations won't be identical.</p>
</div>
<div class="sect3" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="reevalutation"></a>1.2.3. Reevaluation of the real-time constraints</h4></div></div>
<div></div>
</div>
<p>Making GNU/Linux a hard real-time system is currently
	achieved by using a co-kernel approach which takes control of
	the hardware interrupt management, and allows running
	real-time tasks seamlessly aside of the hosting GNU/Linux
	system [4]. The 'regular' Linux kernel is eventually seen as a
	low-priority, background of the small real-time executive. The
	<a href="http://www.rtai.org" target="_top">RTAI</a> and <a href="http://www.rtlinux.org" target="_top">RTLinux</a>projects are
	representative of this technical path. However, this approach
	has a major drawback when it comes to port complex
	applications from a foreign software platform: since the
	real-time tasks run outside the Linux kernel control, the
	GNU/Linux programming model cannot be preserved when porting
	these applications. The result is an increased complexity in
	redesigning and debugging the ported code.</p>
<p>In some cases, choosing a traditional RTOS to run an
	embedded application has been initially dictated by the memory
	constraints imposed by the target hardware, instead of actual
	real-time constraints imposed by the application itself. Since
	embedded devices tend to exhibit ever increasing memory and
	processing horsepower, it seems judicious to reevaluate the
	need for real-time guarantee when considering the porting
	effort to GNU/Linux on a new target hardware. This way, the
	best underlying software architecture can be selected. In this
	respect, the following, the following criteria need to be
	considered:

	</p>
<div class="itemizedlist"><ul type="disc">
<li>
<p><span class="emphasis"><em>Determinism and
	      criticality.</em></span></p>
<p>What is the worst
	      case interrupt and dispatch latencies needed
	      ?</p>
<p>Does a missed deadline lead to a
	      catastrophic failure ?</p>
</li>
<li>
<p><span class="emphasis"><em>Programming model</em></span></p>
<p>What is the overall application complexity,
	      provided taht the highest the complexity, the greatest
	      the need for powerful debugging aid and monitoring
	      tools.</p>
</li>
<li>
<p>Is there a need need for low-level hardware
	      control ? </p>
<p>Is the real-time activity
	      coupled to non real-time services, such as GUI or
	      databases, requiring sophisticated communications with
	      the non real-time world ?</p>
</li>
</ul></div>
<p>
	</p>
</div>
<div class="sect3" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="existing-solutions"></a>1.2.4. Some existing solutions</h4></div></div>
<div></div>
</div>
<p>In order to get whether hard or soft real-time support,
	several GNU/Linux-based solutions exist [5][6]. It is not the
	purpose of this paper to present them all exhaustively. We
	will only consider a two fold approach based on free software
	solutions which is likely to be suited for many porting
	taskings, depending on the actual real-time constraints
	imposed by the application.</p>
<div class="sect4" lang="en">
<div class="titlepage">
<div><div><h5 class="title">
<a name="partial-rewriting"></a>1.2.4.1. Partial rewriting using a real-time GNU/Linux
	  extension</h5></div></div>
<div></div>
</div>
<p>
<span class="emphasis"><em>Real-time enabling GNU/Linux using
	  RTAI.</em></span>Strictly speaking Linux/RTAI [7] is not a
	  real-time operating system but rather a real-time Linux
	  kernel extension, which allows running real-time tasks
	  seamlessly aside of the hosting GNU/Linux system. The RTAI
	  co-kernel is hooked to the hosting GNU/Linux through an
	  hardware abstraction layer (HAL) which redirects external
	  events to it, thus ensuring low interrupt latencies. RTAI
	  provides a fixed-priority driver scheduler to run concurrent
	  real-time activities loaded from dynamic kernel
	  modules. Globally-scoped scheduling decisions are made by
	  the co-kernel which always considers the host Linux kernel
	  as its lowest-priority thread of activity. In other words,
	  RTAI considers the Linux kernel as a background task that
	  should run when no real-time activity occurs, a kind of idle
	  task for common RTOS. RTAI provides a wealth of other useful
	  services, including counting semaphores, POSIX 1003.1-1996
	  facilities such as pthreads, mutexes and condition
	  variables, also adding remote procedure call facility,
	  mailboxes, and precision timers.</p>
<p>Moreover, RTAI provides a mean to execute hard
	  real-time tasks in user-space context, but still outside the
	  Linux kernel control, which is best described as running
	  'user-space kernel modules'. This feature, namely LXRT, is a
	  major step toward a simpler migration path from traditional
	  RTOS, since programming errors occuring within real-time
	  tasks don't jeopardize the overall GNU/Linux system sanity,
	  at the expense of a few microseconds more latency.</p>
<p>
<span class="emphasis"><em>Ad hoc serices emulation.</em></span>A first
	  approach consists in emulating each real-time facility
	  needed by the application using a combination of the RTAI
	  services. An ad hoc wrapping interface has to be written to
	  support the needed function calls. The benefit of the
	  wrapping approach lies in the limited modifications made to
	  the original code. However, some RTAI behaviors may not be
	  compliant with the source operating system's. For the very
	  same reason, conflicts between the emulated and native RTAI
	  services may occur in some way.</p>
<p>
<span class="emphasis"><em>Complete port to RTAI.</em></span>A second
	  approach consists in fully porting the application natively
	  to RTAI. In such a case, RTAI facilities are globally
	  substituted from the facilities from the source RTOS. This
	  solution brings improved consistency at the expense of a
	  possible large-scale rewriting of the application, due to
	  some fundamental behavioral differences that may exist
	  between the traditional RTOS and RTAI.</p>
</div>
<div class="sect4" lang="en">
<div class="titlepage">
<div><div><h5 class="title">
<a name="uspace-emul"></a>1.2.4.2. Unconstrained user-space emulations</h5></div></div>
<div></div>
</div>
<p>A few traditional RTOS emulators exists in the free
	  software world. There are generally designed on top of the
	  GNU/Linux POSIX 1003.1-1996 layer, and allow to emulate the
	  source RTOS API in a user-space execution context, under the
	  control of the Linux kernel.</p>
<p>One of the most proeminent effort in this area is the
	  Legacy2linux project [8]. This project, sponsored by
	  Montavista Software, aims at providing [<span class="citation">&quot;a series
	  of Linux-resident emulators for various legacy RTOS
	  kernels.&quot;</span>]Just like Xenomai, [<span class="citation">these
	  emulators are designed to ease the task of porting legacy
	  RTOS code to an embedded Linux environment&quot;.</span>]Two
	  emulators are currenlty available from this project,
	  respectively mimicking the APIs of WindRiver's pSOS+ and
	  VxWorks real-time operating systems.</p>
<p>The benefits of this approach is mainly to keep the
	  development process in the GNU/Linux user-space environment,
	  instead of moving to a rather 'hostile' kernel/supervisor
	  mode context. This way, the rich set of existing tools such
	  as debuggers, code profilers, and monitors usable in this
	  context are immediatly available to the application
	  developer. Moreover, the standard GNU/Linux programming
	  model is preserved, allowing the application to use the full
	  set of of facilities existing in the user space (e.g. full
	  POSIX support, including inter-process communication). Last
	  but not least, programming errors occuring in this context
	  don't jeopardize the overall GNU/Linux system stability,
	  unlike what can happen if a bug is encountered on behalf of
	  a hard real-time RTAI task which could cause serious damages
	  to the running Linux kernel.
	  </p>
<p>However, we can see at least three problems in using
	  these emulators, depending on the application constraints:
	  </p>
<div class="itemizedlist"><ul type="disc">
<li><p>First, the emulated API they provide is usually
		incomplete for an easy port from the source RTOS. In
		other words, only a limited syntactic compatibility is
		available.</p></li>
<li><p>Second, the exact behavior of the source RTOS is
		not reproduced for all the functional areas. In other
		words, the semantic compatibility might not be
		guaranteed.</p></li>
<li><p>These emulators don't share any common code base
		for implementing the fundamental real-time behaviors,
		even so both pSOS+ and VxWorks share most of them. The
		resulting situation leads to redundant implementation
		efforts, without any benefit one can see in code
		mutualization.</p></li>
<li><p>And finally, even combined to existing Linux
		kernel patches providing fixed-priority scheduling
		(Montavista's RTSched) and fine-grain kernel
		preemption (Ingo Molnar's Linux kernel patches for
		improved preemptability), these emulators cannot
		deliver hard real-time performance.</p></li>
</ul></div>
<p>
	</p>
</div>
</div>
</div>
<hr>
<p class="copyright">© 2004 RTAI Project</p>
<a href="http://validator.w3.org/check/referer" title="Markup validation for this page"><img src="../pictures/w3_xhtml11.png" alt="Standard-compliant XHTML" width="80" height="15"></a><a href="http://jigsaw.w3.org/css-validator/check/referer" title="Style Sheet validation for this page"><img src="../pictures/w3_css2.png" alt="Standard-compliant CSS 2" width="80" height="15"></a><div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="introduction.html"><img src="../pictures/prev.gif" alt="Prev"></a> </td>
<td width="20%" align="center"><a accesskey="u" href="whitepaper.html"><img src="../pictures/up.gif" alt="Up"></a></td>
<td width="40%" align="right"> <a accesskey="n" href="common-framework.html"><img src="../pictures/next.gif" alt="Next"></a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">1.1. Introduction </td>
<td width="20%" align="center"><a accesskey="h" href="index.html"><img src="../pictures/home.gif" alt="Home"></a></td>
<td width="40%" align="right" valign="top"> 1.3. A common emulation framework</td>
</tr>
</table>
</div>
</body>
</html>
