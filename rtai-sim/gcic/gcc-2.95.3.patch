diff -Naur gcc-2.95.3/gcc/Makefile.in gcc-gcic/gcc/Makefile.in
--- gcc-2.95.3/gcc/Makefile.in	Thu Jan 25 15:02:58 2001
+++ gcc-gcic/gcc/Makefile.in	Sat Aug  3 14:17:40 2002
@@ -552,7 +552,7 @@
 # If you change this line, you probably also need to change the definition
 # of HOST_CFLAGS in build-make to match.
 ALL_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS) $(XCFLAGS) \
-	@DEFS@
+	@DEFS@ -DGCIC=1 -DGCIC_C=1 -DYYTOKENTYPE
 
 # Likewise.
 ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)
@@ -665,7 +665,7 @@
 
 # Language-specific object files for C and Objective C.
 C_AND_OBJC_OBJS = c-lex.o c-pragma.o c-decl.o c-typeck.o c-convert.o \
-  c-aux-info.o c-common.o c-iterate.o @extra_c_objs@
+  c-aux-info.o c-common.o c-iterate.o gcic.o @extra_c_objs@
 
 # Language-specific object files for C.
 C_OBJS = c-parse.o c-lang.o $(C_AND_OBJC_OBJS)
@@ -1332,6 +1332,10 @@
 	  -e "/^ifc$$/d" -e "/^end ifc$$/d" \
 	  $(srcdir)/c-parse.in >>tmp-c-parse.y
 	$(srcdir)/move-if-change tmp-c-parse.y $(srcdir)/c-parse.y
+
+gcic.o : $(srcdir)/gcic.c $(CONFIG_H) $(TREE_H) c-lex.h \
+    $(srcdir)/c-parse.h tree.h c-tree.h input.h flags.h system.h toplev.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c $(srcdir)/gcic.c
 
 $(srcdir)/c-gperf.h: c-parse.gperf
 	gperf -L C -F ', 0, 0' -p -j1 -i 1 -g -o -t -G -N is_reserved_word \
diff -Naur gcc-2.95.3/gcc/c-decl.c gcc-gcic/gcc/c-decl.c
--- gcc-2.95.3/gcc/c-decl.c	Thu Jan 25 15:02:59 2001
+++ gcc-gcic/gcc/c-decl.c	Sat Aug  3 14:17:40 2002
@@ -27,6 +27,12 @@
 /* ??? not all decl nodes are given the most useful possible
    line numbers.  For example, the CONST_DECLs for enum values.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    Added Sim-specific processing to finish_decl(),
+    grokdeclarator(), start_function(), finish_function().  */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 #include "system.h"
 #include "tree.h"
@@ -50,6 +56,11 @@
   BITFIELD,			/* Likewise but with specified width */
   TYPENAME};			/* Typename (inside cast or sizeof)  */
 
+#ifdef GCIC_C
+extern int flag_gcic_mode;
+extern void remember_body_fall_through PROTO((tree));
+#endif /* GCIC_C */
+
 #ifndef CHAR_TYPE_SIZE
 #define CHAR_TYPE_SIZE BITS_PER_UNIT
 #endif
@@ -5128,6 +5139,7 @@
 	  || (typedef_decl && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))
 	C_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;
       pop_obstacks ();
+
       return decl;
     }
 
@@ -6446,7 +6458,15 @@
 			       TYPE_ARG_TYPES (TREE_TYPE (decl1)));
     }
 
+#ifdef GCIC_C
+  /* Do not emit the following warning while instrumenting -- it is
+     caused by the -Wreturn-type flag passed to the compilation
+     driver, and will be emitted during the actual compilation
+     pass. */
+  if (!flag_gcic_mode && warn_about_return_type)
+#else /* !GCIC_C */
   if (warn_about_return_type)
+#endif /* GCIC_C */
     warning ("return-type defaults to `int'");
 
   /* Save the parm names or decls from this function's declarator
@@ -7271,6 +7291,15 @@
 
   current_function_returns_null |= can_reach_end;
 
+#ifdef GCIC_C
+  /* Do not emit the following warnings while instrumenting -- they
+     are caused by the -Wreturn-type flag passed to the compilation
+     driver, and will be emitted during the actual compilation
+     pass. */
+  if (!flag_gcic_mode)
+      {
+#endif /* GCIC_C */
+
   if (warn_missing_noreturn
       && !TREE_THIS_VOLATILE (fndecl)
       && !current_function_returns_null
@@ -7289,6 +7318,11 @@
   else if (extra_warnings
 	   && current_function_returns_value && current_function_returns_null)
     warning ("this function may return with or without a value");
+#ifdef GCIC_C
+      }
+  else if (can_reach_end)
+	   remember_body_fall_through(fndecl);
+#endif /* GCIC_C */
 
   /* If requested, warn about function definitions where the function will
      return a value (usually of some struct or union type) which itself will
diff -Naur gcc-2.95.3/gcc/c-lang.c gcc-gcic/gcc/c-lang.c
--- gcc-2.95.3/gcc/c-lang.c	Thu Sep 30 13:23:56 1999
+++ gcc-gcic/gcc/c-lang.c	Sat Aug  3 14:17:40 2002
@@ -18,6 +18,10 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    Changed lang_init() and finish_file() routines.  */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
 
 #include "config.h"
 #include "system.h"
@@ -28,6 +32,13 @@
 #include "toplev.h"
 #include "output.h"
 
+#ifdef GCIC_C
+extern void generate_gcic_code PROTO((void));
+extern void reset_token_stack PROTO((void));
+extern int flag_gcic_mode;
+extern int lex_offset;
+#endif /* GCIC_C */
+
 #if USE_CPPLIB
 #include "cpplib.h"
 extern char *yy_cur;
@@ -64,6 +75,13 @@
      and put it in input_filename.  */
 #if !USE_CPPLIB
   ungetc (check_newline (), finput);
+#ifdef GCIC_C
+  if (flag_gcic_mode)
+      {
+      lex_offset--; /* FIXME: should use UNGETC() from c-lex.c instead */
+      reset_token_stack();
+      }
+#endif /* GCIC_C */
 #else
   check_newline ();
   yy_cur--;
@@ -170,6 +188,12 @@
 #if !defined(ASM_OUTPUT_CONSTRUCTOR) || !defined(ASM_OUTPUT_DESTRUCTOR)
   tree void_list_node = build_tree_list (NULL_TREE, void_type_node);
 #endif
+
+#ifdef GCIC_C
+  if (flag_gcic_mode)
+      generate_gcic_code();
+#endif /* GCIC_C */
+
 #ifndef ASM_OUTPUT_CONSTRUCTOR
   if (static_ctors)
     {
diff -Naur gcc-2.95.3/gcc/c-lex.c gcc-gcic/gcc/c-lex.c
--- gcc-2.95.3/gcc/c-lex.c	Sat Mar 20 20:21:23 1999
+++ gcc-gcic/gcc/c-lex.c	Sat Aug  3 14:17:40 2002
@@ -18,6 +18,12 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   All changes are aimed at tracking the input text position in
+   the original source file for a subsequent use by the patch engine.  */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 #include "system.h"
 
@@ -65,6 +71,9 @@
 #define YYDEBUG 1
 
 #if USE_CPPLIB
+#ifdef GCIC_C
+#error "cannot build GCIC instrumenter with CPPLIB"
+#endif /* GCIC_C */
 extern unsigned char *yy_cur, *yy_lim;
 
 extern int yy_get_token ();
@@ -72,8 +81,20 @@
 #define GETC() (yy_cur < yy_lim ? *yy_cur++ : yy_get_token ())
 #define UNGETC(c) ((c) == EOF ? 0 : yy_cur--)
 #else
+#ifdef GCIC_C
+extern int lex_offset;
+extern int lex_token_offset;
+extern int lex_identifier_offset;
+extern int real_yylex_nestcount;
+extern int yy_offset;
+extern int input_char_num;
+extern int flag_gcic_mode;
+#define GETC() (lex_offset++, input_char_num++, getc (finput))
+#define UNGETC(c) (lex_offset--, input_char_num--, ungetc (c, finput))
+#else /* !GCIC_C */
 #define GETC() getc (finput)
 #define UNGETC(c) ungetc (c, finput)
+#endif /* GCIC_C */
 #endif
 
 /* the declaration found for the last IDENTIFIER token read in.
@@ -739,6 +760,13 @@
 	= (char *) permalloc (TREE_STRING_LENGTH (yylval.ttype) + 1);
       strcpy (input_filename, TREE_STRING_POINTER (yylval.ttype));
       lineno = l;
+#ifdef GCIC_C
+      /* Restart counting from a stable base just in case the current
+	 file is to be compiled more than once with different
+	 conditional blocks being parsed. This trick was suggested by
+	 Vincent Bodson <vincent.bodson@art.alcatel.fr> */
+      input_char_num = l;
+#endif /* GCIC_C */
 
       /* Each change of file name
 	 reinitializes whether we are now in a system header.  */
@@ -1213,6 +1241,11 @@
   int wide_flag = 0;
   int objc_flag = 0;
 
+#ifdef GCIC_C
+  real_yylex_nestcount++;
+lex_again:
+#endif /* GCIC_C */
+
 #if !USE_CPPLIB
   if (nextchar >= 0)
     c = nextchar, nextchar = -1;
@@ -1248,6 +1281,18 @@
   token_buffer[0] = c;
   token_buffer[1] = 0;
 
+#ifdef GCIC_C
+  if (real_yylex_nestcount == 1)
+      {
+      /* Keep pointing to the heading token; i did not want to change
+	 yylex() prototype to keep the impact on the original code as
+	 minor as possible.  Therefore, i use an ugly global nesting
+	 count to prevent overwriting lex_token_offset while
+	 recursing. */
+      lex_token_offset = lex_offset - 1;
+      }
+#endif /* GCIC_C */
+
 /*  yylloc.first_line = lineno; */
 
   switch (c)
@@ -1354,12 +1399,45 @@
 	    if (doing_objc_thang && value == OBJECTNAME)
 	      {
 		lastiddecl = lookup_name(yylval.ttype);
+#ifdef GCIC_C
+		lex_identifier_offset = lex_token_offset;
+#endif /* GCIC_C */
 
 		if (lastiddecl == NULL_TREE
 		    || TREE_CODE (lastiddecl) != TYPE_DECL)
 		  value = IDENTIFIER;
 	      }
 
+#ifdef GCIC_C
+	    /* Some compilers allow inline assembler code to be given
+	       within braces -- just eat this code at lexer's level
+	       without passing it back to the parser. */
+	    if (flag_gcic_mode && value == ASM_KEYWORD)
+		{
+		int next_c = GETC();
+
+		while (next_c == ' ') /* LF appears as blank  */
+		    next_c = GETC();
+
+		if (next_c == '{')
+		    {
+		    int braces = 1;
+
+		    while ((next_c = GETC()) != EOF)
+			{
+			if (next_c == '{')
+			    braces++;
+			else if (next_c == '}' && --braces <= 0)
+			    break;
+			}
+
+		    goto lex_again;
+		    }
+		else
+		    UNGETC(next_c);
+		}
+#endif /* GCIC_C */
+
 	    /* Even if we decided to recognize asm, still perhaps warn.  */
 	    if (pedantic
 		&& (value == ASM_KEYWORD || value == TYPEOF
@@ -1380,6 +1458,9 @@
 
           yylval.ttype = get_identifier (token_buffer);
 	  lastiddecl = lookup_name (yylval.ttype);
+#ifdef GCIC_C
+	  lex_identifier_offset = lex_token_offset;
+#endif /* GCIC_C */
 
 	  if (lastiddecl != 0 && TREE_CODE (lastiddecl) == TYPE_DECL)
 	    value = TYPENAME;
@@ -1517,7 +1598,25 @@
 			  {
 			    *p++ = c;
 			    *p = 0;
+#ifdef GCIC_C
+			    value = ELLIPSIS;
+			    if (real_yylex_nestcount == 1)
+				{
+				/* This code is specifically designed
+				   to work with the
+				   old_style_parm_decls clause from
+				   the parser (i.e. ...datadecls
+				   ELLIPSIS). It forces the opening
+				   brace to be the next token to be
+				   read in as expected by
+				   SIM_ENTER_FUNC() */
+				position_after_white_space();
+				lex_token_offset = lex_offset;
+				}
+			    goto done;
+#else /* !GCIC_C */
 			    return ELLIPSIS;
+#endif /* GCIC_C */
 			  }
 			error ("parse error at `..'");
 		      }
@@ -2330,6 +2429,21 @@
 
 done:
 /*  yylloc.last_line = lineno; */
+
+#ifdef GCIC_C
+  if (!--real_yylex_nestcount)
+      {
+      yy_offset = lex_token_offset;
+
+      if (flag_gcic_mode)
+	  {
+	  if (value == ';')
+	      insert_gcic_stack_marker(yy_offset);
+	  else
+	      feed_gcic_token_stack(value,yy_offset);
+	  }
+      }
+#endif /* GCIC_C */
 
   return value;
 }
diff -Naur gcc-2.95.3/gcc/c-parse.h gcc-gcic/gcc/c-parse.h
--- gcc-2.95.3/gcc/c-parse.h	Fri Mar 16 15:13:48 2001
+++ gcc-gcic/gcc/c-parse.h	Sat Aug  3 14:38:25 2002
@@ -1,64 +1,74 @@
+#ifndef BISON_C_PARSE_H
+# define BISON_C_PARSE_H
+
+#ifndef YYSTYPE
 typedef union {long itype; tree ttype; enum tree_code code;
-	char *filename; int lineno; int ends_in_label; } YYSTYPE;
-#define	IDENTIFIER	258
-#define	TYPENAME	259
-#define	SCSPEC	260
-#define	TYPESPEC	261
-#define	TYPE_QUAL	262
-#define	CONSTANT	263
-#define	STRING	264
-#define	ELLIPSIS	265
-#define	SIZEOF	266
-#define	ENUM	267
-#define	STRUCT	268
-#define	UNION	269
-#define	IF	270
-#define	ELSE	271
-#define	WHILE	272
-#define	DO	273
-#define	FOR	274
-#define	SWITCH	275
-#define	CASE	276
-#define	DEFAULT	277
-#define	BREAK	278
-#define	CONTINUE	279
-#define	RETURN	280
-#define	GOTO	281
-#define	ASM_KEYWORD	282
-#define	TYPEOF	283
-#define	ALIGNOF	284
-#define	ATTRIBUTE	285
-#define	EXTENSION	286
-#define	LABEL	287
-#define	REALPART	288
-#define	IMAGPART	289
-#define	ASSIGN	290
-#define	OROR	291
-#define	ANDAND	292
-#define	EQCOMPARE	293
-#define	ARITHCOMPARE	294
-#define	LSHIFT	295
-#define	RSHIFT	296
-#define	UNARY	297
-#define	PLUSPLUS	298
-#define	MINUSMINUS	299
-#define	HYPERUNARY	300
-#define	POINTSAT	301
-#define	INTERFACE	302
-#define	IMPLEMENTATION	303
-#define	END	304
-#define	SELECTOR	305
-#define	DEFS	306
-#define	ENCODE	307
-#define	CLASSNAME	308
-#define	PUBLIC	309
-#define	PRIVATE	310
-#define	PROTECTED	311
-#define	PROTOCOL	312
-#define	OBJECTNAME	313
-#define	CLASS	314
-#define	ALIAS	315
-#define	OBJC_STRING	316
+	char *filename; int lineno; int ends_in_label; } yystype;
+# define YYSTYPE yystype
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+# define	IDENTIFIER	257
+# define	TYPENAME	258
+# define	SCSPEC	259
+# define	TYPESPEC	260
+# define	TYPE_QUAL	261
+# define	CONSTANT	262
+# define	STRING	263
+# define	ELLIPSIS	264
+# define	SIZEOF	265
+# define	ENUM	266
+# define	STRUCT	267
+# define	UNION	268
+# define	IF	269
+# define	ELSE	270
+# define	WHILE	271
+# define	DO	272
+# define	FOR	273
+# define	SWITCH	274
+# define	CASE	275
+# define	DEFAULT	276
+# define	BREAK	277
+# define	CONTINUE	278
+# define	RETURN	279
+# define	GOTO	280
+# define	ASM_KEYWORD	281
+# define	TYPEOF	282
+# define	ALIGNOF	283
+# define	ATTRIBUTE	284
+# define	EXTENSION	285
+# define	LABEL	286
+# define	REALPART	287
+# define	IMAGPART	288
+# define	EMPTY	289
+# define	ASSIGN	290
+# define	OROR	291
+# define	ANDAND	292
+# define	EQCOMPARE	293
+# define	ARITHCOMPARE	294
+# define	LSHIFT	295
+# define	RSHIFT	296
+# define	UNARY	297
+# define	PLUSPLUS	298
+# define	MINUSMINUS	299
+# define	HYPERUNARY	300
+# define	POINTSAT	301
+# define	INTERFACE	302
+# define	IMPLEMENTATION	303
+# define	END	304
+# define	SELECTOR	305
+# define	DEFS	306
+# define	ENCODE	307
+# define	CLASSNAME	308
+# define	PUBLIC	309
+# define	PRIVATE	310
+# define	PROTECTED	311
+# define	PROTOCOL	312
+# define	OBJECTNAME	313
+# define	CLASS	314
+# define	ALIAS	315
+# define	OBJC_STRING	316
 
 
 extern YYSTYPE yylval;
+
+#endif /* not BISON_C_PARSE_H */
diff -Naur gcc-2.95.3/gcc/c-parse.in gcc-gcic/gcc/c-parse.in
--- gcc-2.95.3/gcc/c-parse.in	Tue Apr 27 00:35:50 1999
+++ gcc-gcic/gcc/c-parse.in	Sat Aug  3 14:39:09 2002
@@ -27,8 +27,15 @@
 /* To whomever it may concern: I have heard that such a thing was once
    written by AT&T, but I have never seen it.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    All changes are aimed at feeding the instrumentation engine
+    (in ck/ck.c) with information it will subsequently use to determine
+    the required code modifications in the original source.  */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 ifobjc
-%expect 66
+%expect 72
 end ifobjc
 ifc
 %expect 51
@@ -137,6 +144,7 @@
 %token BREAK CONTINUE RETURN GOTO ASM_KEYWORD TYPEOF ALIGNOF
 %token ATTRIBUTE EXTENSION LABEL
 %token REALPART IMAGPART
+%token EMPTY /* GCIC-specific */
 
 /* Add precedence rules to solve dangling else s/r conflict */
 %nonassoc IF
@@ -211,6 +219,9 @@
 
 %type <filename> save_filename
 %type <lineno> save_lineno
+/* GCIC-specific */
+%type <itype> label
+%type <ttype> .gcic.case.expr
 
 ifobjc
 /* the Objective-C nonterminals */
@@ -265,6 +276,124 @@
 
 #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)
 extern void yyprint			PROTO ((FILE *, int, YYSTYPE));
+
+ifc
+
+extern int flag_gcic_mode;
+extern int yy_offset;
+extern int yy_preemption_lock;
+extern int lex_offset;
+extern int lex_identifier_offset;
+
+extern void remember_body_start PROTO((int));
+extern void remember_body_end PROTO((int));
+extern void remember_stmt_bounds PROTO((int, int, int));
+extern void analyze_return_stmt PROTO((tree));
+extern void remember_handles_exceptions PROTO((void));
+extern void remember_compound_start PROTO((int));
+extern void remember_compound_end PROTO((int));
+extern void substitute_call_wrapper PROTO((tree,int));
+
+static int *yy_offstack,
+            yy_offmax,
+            yy_offsp,
+            yy_returnstmt,
+            yy_lookahead;
+
+static void gcic_push_offset (int offset)
+
+{
+    if (yy_offmax <= yy_offsp)
+	{
+	yy_offmax += 16;
+
+	if (!yy_offstack)
+	    yy_offstack = (int *)xmalloc(yy_offmax * sizeof(int));
+	else
+	    yy_offstack = (int *)xrealloc(yy_offstack,yy_offmax * sizeof(int));
+	}
+
+    yy_offstack[yy_offsp++] = offset;
+}
+
+static int gcic_pop_offset ()
+
+{ return yy_offstack[--yy_offsp]; }
+
+static int gcic_invalidate_offset ()
+
+{ yy_offstack[yy_offsp - 1] = -1; }
+
+static void gcic_push_yyoffset ()
+
+{
+    if (yy_lookahead)
+	{
+	gcic_push_offset(lex_offset);
+	yy_lookahead = 0;
+	}
+    else
+	gcic_push_offset(yy_offset);
+}
+
+#define GCIC_ENTER_FUNC() { if (flag_gcic_mode) \
+		                 remember_body_start(yy_offset); }
+#define GCIC_EXIT_FUNC()  { if (flag_gcic_mode) \
+		                 remember_body_end(yy_offset); }
+
+#define GCIC_BEGIN_STMT() { if (flag_gcic_mode) \
+                                 gcic_push_yyoffset(); }
+#define GCIC_MARK_STMT()  { if (flag_gcic_mode) { \
+		                 remember_stmt_bounds(gcic_pop_offset(), \
+				                      yy_offset, \
+				                      yy_returnstmt); \
+		                 yy_returnstmt = 0; } }
+#define GCIC_FLUSH_STMT()      { if (flag_gcic_mode) \
+                                      (void)gcic_pop_offset(); }
+#define GCIC_START_COMPOUND()  { if (flag_gcic_mode) \
+                                      remember_compound_start(yy_offset); }
+#define GCIC_END_COMPOUND()    { if (flag_gcic_mode) \
+                                      remember_compound_end(yy_offset); }
+#define GCIC_MARK_RETURN(t)    { if (flag_gcic_mode) { \
+                                      yy_returnstmt++; \
+                                      if (t) analyze_return_stmt(t); } }
+#define GCIC_PUSH_YYOFFSET()   { if (flag_gcic_mode) \
+                                      gcic_push_yyoffset(); }
+#define GCIC_PUSH_OFFSET(off)   { if (flag_gcic_mode) \
+                                       gcic_push_offset(off); }
+#define GCIC_POP_OFFSET()    (flag_gcic_mode ? gcic_pop_offset() : -1)
+
+#define GCIC_FAKE_LOOKAHEAD()  yy_lookahead = 1
+
+#define GCIC_LOCK_PREEMPTION() { if (flag_gcic_mode) \
+                                      yy_preemption_lock++; }
+#define GCIC_UNLOCK_PREEMPTION() { if (flag_gcic_mode) \
+                                        yy_preemption_lock--; }
+
+#define GCIC_SUBST_WRAP(t,off)   { if (flag_gcic_mode) \
+                                        substitute_call_wrapper(t,off); }
+end ifc
+
+ifobjc
+
+#define GCIC_ENTER_FUNC()
+#define GCIC_EXIT_FUNC()
+#define GCIC_BEGIN_STMT()
+#define GCIC_MARK_STMT()
+#define GCIC_FLUSH_STMT()
+#define GCIC_START_COMPOUND()
+#define GCIC_END_COMPOUND()
+#define GCIC_MARK_RETURN(t)
+#define GCIC_PUSH_YYOFFSET()
+#define GCIC_PUSH_OFFSET(off)
+#define GCIC_POP_OFFSET()
+#define GCIC_FAKE_LOOKAHEAD()
+#define GCIC_LOCK_PREEMPTION()
+#define GCIC_UNLOCK_PREEMPTION()
+#define GCIC_SUBST_WRAP(t,off)
+
+end ifobjc
+
 %}
 
 %%
@@ -307,7 +436,8 @@
 		  else
 		    error ("argument of `asm' is not a constant string"); }
 	| extension extdef
-		{ pedantic = $<itype>1; }
+		{ pedantic = $<itype>1;
+		GCIC_UNLOCK_PREEMPTION();  }
 	;
 
 datadef:
@@ -349,9 +479,11 @@
 		    YYERROR1;
 		  reinit_parse_for_function (); }
 	  old_style_parm_decls
-		{ store_parm_decls (); }
+		{ store_parm_decls (); GCIC_ENTER_FUNC(); }
 	  compstmt_or_error
-		{ finish_function (0); 
+		{  /* must be fired prior to finish_function() */
+                  GCIC_EXIT_FUNC();
+		  finish_function (0); 
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
@@ -367,9 +499,11 @@
 		    YYERROR1;
 		  reinit_parse_for_function (); }
 	  old_style_parm_decls
-		{ store_parm_decls (); }
+		{ store_parm_decls (); GCIC_ENTER_FUNC(); }
 	  compstmt_or_error
-		{ finish_function (0); 
+		{ /* must be fired prior to finish_function() */
+		  GCIC_EXIT_FUNC();
+		  finish_function (0); 
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
@@ -385,9 +519,11 @@
 		    YYERROR1;
 		  reinit_parse_for_function (); }
 	  old_style_parm_decls
-		{ store_parm_decls (); }
+		{ store_parm_decls (); GCIC_ENTER_FUNC(); }
 	  compstmt_or_error
-		{ finish_function (0); 
+		{ /* must be fired prior to finish_function() */
+		  GCIC_EXIT_FUNC();
+		  finish_function (0); 
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
@@ -448,7 +584,8 @@
 	/* __extension__ turns off -pedantic for following primary.  */
 	| extension cast_expr	  %prec UNARY
 		{ $$ = $2;
-		  pedantic = $<itype>1; }
+		  pedantic = $<itype>1;
+		  GCIC_UNLOCK_PREEMPTION(); }
 	| unop cast_expr  %prec UNARY
 		{ $$ = build_unary_op ($1, $2, 0);
 		  overflow_warning ($$); }
@@ -838,8 +975,9 @@
 		  else
 		    $$ = $3;
 		}
-	| primary '(' exprlist ')'   %prec '.'
-		{ $$ = build_function_call ($1, $3); }
+	| primary { GCIC_PUSH_OFFSET(lex_identifier_offset); } '(' exprlist ')'   %prec '.'
+		{ GCIC_SUBST_WRAP($1,GCIC_POP_OFFSET());
+		$$ = build_function_call ($1, $4); }
 	| primary '[' expr ']'   %prec '.'
 		{ $$ = build_array_ref ($1, $3); }
 	| primary '.' identifier
@@ -922,7 +1060,7 @@
    They are used for old-style parm decls.  */
 lineno_datadecl:
 	  save_filename save_lineno datadecl
-		{ }
+		{ GCIC_FLUSH_STMT(); }
 	;
 
 datadecls:
@@ -960,7 +1098,7 @@
    where statement labels are allowed.  */
 lineno_decl:
 	  save_filename save_lineno decl
-		{ }
+		{ GCIC_FLUSH_STMT(); }
 	;
 
 decls:
@@ -1015,7 +1153,8 @@
 	| declmods ';'
 		{ pedwarn ("empty declaration"); }
 	| extension decl
-		{ pedantic = $<itype>1; }
+		{ pedantic = $<itype>1;
+		  GCIC_UNLOCK_PREEMPTION(); }
 	;
 
 /* Declspecs which contain at least one type specifier or typedef name.
@@ -1134,12 +1273,16 @@
         | non_empty_protocolrefs
                 { $$ = get_object_reference ($1); }
 end ifobjc
-	| TYPEOF '(' expr ')'
+	| typeof '(' expr ')'
 		{ $$ = TREE_TYPE ($3); }
-	| TYPEOF '(' typename ')'
+	| typeof '(' typename ')'
 		{ $$ = groktypename ($3); }
 	;
 
+typeof:
+	TYPEOF { skip_evaluation++; }
+	;
+
 /* A typespec that is a reserved word, or a type qualifier.  */
 
 typespecqual_reserved: TYPESPEC
@@ -1333,7 +1476,7 @@
 		    }
 		  reinit_parse_for_function (); }
 	   old_style_parm_decls
-		{ store_parm_decls (); }
+		{ store_parm_decls (); GCIC_ENTER_FUNC(); }
 /* This used to use compstmt_or_error.
    That caused a bug with input `f(g) int g {}',
    where the use of YYERROR1 above caused an error
@@ -1341,7 +1484,8 @@
    There followed a repeated execution of that same rule,
    which called YYERROR1 again, and so on.  */
 	  compstmt
-		{ finish_function (1);
+		{ GCIC_EXIT_FUNC();
+		  finish_function (1);
 		  pop_c_function_context (); }
 	;
 
@@ -1356,7 +1500,7 @@
 		    }
 		  reinit_parse_for_function (); }
 	  old_style_parm_decls
-		{ store_parm_decls (); }
+		{ store_parm_decls (); GCIC_ENTER_FUNC(); }
 /* This used to use compstmt_or_error.
    That caused a bug with input `f(g) int g {}',
    where the use of YYERROR1 above caused an error
@@ -1364,7 +1508,8 @@
    There followed a repeated execution of that same rule,
    which called YYERROR1 again, and so on.  */
 	  compstmt
-		{ finish_function (1);
+		{ GCIC_EXIT_FUNC();
+		  finish_function (1);
 		  pop_c_function_context (); }
 	;
 
@@ -1614,7 +1759,8 @@
 		{ $$ = NULL_TREE; }
 	| extension component_decl
 		{ $$ = $2;
-		  pedantic = $<itype>1; }
+		  pedantic = $<itype>1;
+		  GCIC_UNLOCK_PREEMPTION(); }
 	;
 
 components:
@@ -1625,14 +1771,17 @@
 
 component_declarator:
 	  save_filename save_lineno declarator maybe_attribute
-		{ $$ = grokfield ($1, $2, $3, current_declspecs, NULL_TREE);
+		{ GCIC_FLUSH_STMT();
+		  $$ = grokfield ($1, $2, $3, current_declspecs, NULL_TREE);
 		  decl_attributes ($$, $4, prefix_attributes); }
 	| save_filename save_lineno
 	  declarator ':' expr_no_commas maybe_attribute
-		{ $$ = grokfield ($1, $2, $3, current_declspecs, $5);
+		{ GCIC_FLUSH_STMT();
+		  $$ = grokfield ($1, $2, $3, current_declspecs, $5);
 		  decl_attributes ($$, $6, prefix_attributes); }
 	| save_filename save_lineno ':' expr_no_commas maybe_attribute
-		{ $$ = grokfield ($1, $2, NULL_TREE, current_declspecs, $4);
+		{ GCIC_FLUSH_STMT();
+		  $$ = grokfield ($1, $2, NULL_TREE, current_declspecs, $4);
 		  decl_attributes ($$, $5, prefix_attributes); }
 	;
 
@@ -1788,10 +1937,13 @@
 	| error compstmt
 	;
 
-compstmt_start: '{' { compstmt_count++; }
+compstmt_start: '{' { compstmt_count++;
+                      GCIC_START_COMPOUND(); }
+              ;
 
 compstmt: compstmt_start '}'
-		{ $$ = convert (void_type_node, integer_zero_node); }
+		{ $$ = convert (void_type_node, integer_zero_node);
+		  GCIC_END_COMPOUND(); }
 	| compstmt_start pushlevel maybe_label_decls decls xstmts '}'
 		{ emit_line_note (input_filename, lineno);
 		  expand_end_bindings (getdecls (), 1, 0);
@@ -1799,7 +1951,8 @@
 		  if (yychar == CONSTANT || yychar == STRING)
 		    pop_momentary_nofree ();
 		  else
-		    pop_momentary (); }
+		    pop_momentary ();
+		  GCIC_END_COMPOUND(); }
 	| compstmt_start pushlevel maybe_label_decls error '}'
 		{ emit_line_note (input_filename, lineno);
 		  expand_end_bindings (getdecls (), kept_level_p (), 0);
@@ -1807,7 +1960,8 @@
 		  if (yychar == CONSTANT || yychar == STRING)
 		    pop_momentary_nofree ();
 		  else
-		    pop_momentary (); }
+		    pop_momentary ();
+		  GCIC_END_COMPOUND(); }
 	| compstmt_start pushlevel maybe_label_decls stmts '}'
 		{ emit_line_note (input_filename, lineno);
 		  expand_end_bindings (getdecls (), kept_level_p (), 0);
@@ -1815,7 +1969,8 @@
 		  if (yychar == CONSTANT || yychar == STRING)
 		    pop_momentary_nofree ();
 		  else
-		    pop_momentary (); }
+		    pop_momentary ();
+		  GCIC_END_COMPOUND(); }
 	;
 
 /* Value is number of statements counted as of the closeparen.  */
@@ -1849,29 +2004,47 @@
 		  /* See comment in `while' alternative, above.  */
 		  emit_nop ();
 		  expand_start_loop_continue_elsewhere (1);
-		  position_after_white_space (); }
+		  position_after_white_space ();
+		  GCIC_FAKE_LOOKAHEAD(); }
 	  lineno_labeled_stmt WHILE
 		{ expand_loop_continue_here (); }
 	;
 
+ifc
+.gcic.invalidate.preemption:
+	  /* empty */
+		{ if (flag_gcic_mode)
+                      gcic_invalidate_offset(); }
+	;
+end ifc
+
+ifobjc
+.gcic.invalidate.preemption:
+	  /* empty */
+	;
+
+end ifobjc
+
 save_filename:
 		{ $$ = input_filename; }
 	;
 
 save_lineno:
-		{ $$ = lineno; }
+		{ $$ = lineno;
+		  GCIC_BEGIN_STMT(); }
 	;
 
 lineno_labeled_stmt:
-	  save_filename save_lineno stmt
-		{ }
+	  save_filename save_lineno stmt { GCIC_MARK_STMT(); }
 /*	| save_filename save_lineno error
 		{ }
 */
-	| save_filename save_lineno label lineno_labeled_stmt
-		{ }
+	| save_filename save_lineno xlabel lineno_labeled_stmt { GCIC_FLUSH_STMT(); }
 	;
 
+xlabel: label { if ($1) GCIC_FAKE_LOOKAHEAD(); }
+      ;
+
 lineno_stmt_or_label:
 	  save_filename save_lineno stmt_or_label
 		{ $$ = $3; }
@@ -1879,14 +2052,14 @@
 
 stmt_or_label:
 	  stmt
-		{ $$ = 0; }
+		{ $$ = 0; GCIC_MARK_STMT(); }
 	| label
-		{ $$ = 1; }
+		{ $$ = 1; GCIC_FLUSH_STMT(); }
 	;
 
 /* Parse a single real statement, not including any labels.  */
 stmt:
-	  compstmt
+	  compstmt .gcic.invalidate.preemption
 		{ stmt_count++; }
         | all_iter_stmt 
 	| expr ';'
@@ -1946,7 +2119,8 @@
 		  emit_line_note (input_filename, lineno);
 		  expand_exit_loop_if_false (NULL_PTR,
 					     truthvalue_conversion ($4));
-		  position_after_white_space (); }
+		  position_after_white_space ();
+		  GCIC_FAKE_LOOKAHEAD(); }
 	  lineno_labeled_stmt
 		{ expand_end_loop (); }
 	| do_stmt_start
@@ -1991,7 +2165,8 @@
 		  push_momentary ();
 		  $<lineno>7 = lineno;
 		  $<filename>8 = input_filename;
-		  position_after_white_space (); }
+		  position_after_white_space ();
+		  GCIC_FAKE_LOOKAHEAD(); }
 	  lineno_labeled_stmt
 		{ /* Emit the increment expression, with a line number.  */
 		  emit_line_note ($<filename>8, $<lineno>7);
@@ -2017,12 +2192,12 @@
 		    pop_momentary_nofree ();
 		  else
 		    pop_momentary (); }
-	| BREAK ';'
+	| .gcic.invalidate.preemption BREAK ';'
 		{ stmt_count++;
 		  emit_line_note ($<filename>-1, $<lineno>0);
 		  if ( ! expand_exit_something ())
 		    error ("break statement not within loop or switch"); }
-	| CONTINUE ';'
+	| .gcic.invalidate.preemption CONTINUE ';'
 		{ stmt_count++;
 		  emit_line_note ($<filename>-1, $<lineno>0);
 		  if (! expand_continue_loop (NULL_PTR))
@@ -2030,11 +2205,13 @@
 	| RETURN ';'
 		{ stmt_count++;
 		  emit_line_note ($<filename>-1, $<lineno>0);
-		  c_expand_return (NULL_TREE); }
+		  c_expand_return (NULL_TREE);
+		  GCIC_MARK_RETURN(NULL_TREE); }
 	| RETURN expr ';'
 		{ stmt_count++;
 		  emit_line_note ($<filename>-1, $<lineno>0);
-		  c_expand_return ($2); }
+		  c_expand_return ($2);
+		  GCIC_MARK_RETURN($2); }
 	| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'
 		{ stmt_count++;
 		  emit_line_note ($<filename>-1, $<lineno>0);
@@ -2113,12 +2290,14 @@
 		$<itype>$ = 1;
 		iterator_for_loop_start ($3);
 	      }
+	    GCIC_FAKE_LOOKAHEAD();
 	  }
 	  lineno_labeled_stmt
 	  {
 	    if ($<itype>5)
 	      iterator_for_loop_end ($3);
 	  }
+          ;
 
 /*  This really should allow any kind of declaration,
     for generality.  Fix it before turning it back on.
@@ -2149,7 +2328,11 @@
    ANSI C accepts labels only before statements, but we allow them
    also at the end of a compound statement.  */
 
-label:	  CASE expr_no_commas ':'
+.gcic.case.expr: expr_no_commas .gcic.invalidate.preemption
+         { $$ = $1; }
+         ;
+
+label:	  CASE .gcic.case.expr ':'
 		{ register tree value = check_case_value ($2);
 		  register tree label
 		    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);
@@ -2179,8 +2362,9 @@
 		      else if (success == 5)
 			error ("case label within scope of cleanup or variable array");
 		    }
-		  position_after_white_space (); }
-	| CASE expr_no_commas ELLIPSIS expr_no_commas ':'
+		  position_after_white_space ();
+		  $$ = 1; }
+	| CASE .gcic.case.expr ELLIPSIS .gcic.case.expr ':'
 		{ register tree value1 = check_case_value ($2);
 		  register tree value2 = check_case_value ($4);
 		  register tree label
@@ -2210,8 +2394,9 @@
 		      else if (success == 5)
 			error ("case label within scope of cleanup or variable array");
 		    }
-		  position_after_white_space (); }
-	| DEFAULT ':'
+		  position_after_white_space ();
+		  $$ = 1; }
+	| .gcic.invalidate.preemption DEFAULT ':'
 		{
 		  tree duplicate;
 		  register tree label
@@ -2225,7 +2410,8 @@
 		      error ("multiple default labels in one switch");
 		      error_with_decl (duplicate, "this is the first default label");
 		    }
-		  position_after_white_space (); }
+		  position_after_white_space (); 
+		  $$ = 1; }
 	| identifier ':' maybe_attribute
 		{ tree label = define_label (input_filename, lineno, $1);
 		  stmt_count++;
@@ -2235,7 +2421,8 @@
 		      expand_label (label);
 		      decl_attributes (label, $3, NULL_TREE);
 		    }
-		  position_after_white_space (); }
+		  position_after_white_space ();
+		  $$ = ($3 != NULL_TREE); }
 	;
 
 /* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */
@@ -2427,7 +2614,8 @@
 extension:
 	EXTENSION
 		{ $<itype>$ = pedantic;
-		  pedantic = 0; }
+		  pedantic = 0;
+		  GCIC_LOCK_PREEMPTION(); }
 	;
 
 ifobjc
@@ -2465,12 +2653,14 @@
 		{
 		  objc_declare_class ($2);
 		}
+         ;
 
 aliasdecl:
 	  ALIAS identifier identifier ';'
 		{
 		  objc_declare_alias ($2, $3);
 		}
+         ;
 
 classdef:
 	  INTERFACE identifier protocolrefs '{'
diff -Naur gcc-2.95.3/gcc/c-pragma.c gcc-gcic/gcc/c-pragma.c
--- gcc-2.95.3/gcc/c-pragma.c	Mon Jun 21 07:12:17 1999
+++ gcc-gcic/gcc/c-pragma.c	Sat Aug  3 14:17:40 2002
@@ -18,6 +18,11 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   Changed handle_pragma_token() routine. */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 #include "system.h"
 #include "rtl.h"
@@ -31,6 +36,10 @@
 
 #ifdef HANDLE_GENERIC_PRAGMAS
 
+#ifdef GCIC_C
+extern int flag_gcic_mode;
+#endif /* GCIC_C */
+
 #ifdef HANDLE_PRAGMA_PACK
 /* When structure field packing is in effect, this variable is the
    number of bits to use as the maximum alignment.  When packing is not
@@ -255,7 +264,15 @@
 	  break;
 
 	case ps_done:
+#ifdef GCIC_C
+	      /* Always return success if parsing in GCIC mode. The
+		 parsed code may be submitted to a compiler accepting
+		 some exotic pragma dialect. */
+	      if (flag_gcic_mode)
+		  ret_val = 1;
+#else
 	  /* The pragma was not recognised.  */
+#endif /* GCIC_C */
 	  break;
 	  
 #ifdef HANDLE_PRAGMA_PACK	  
diff -Naur gcc-2.95.3/gcc/c-typeck.c gcc-gcic/gcc/c-typeck.c
--- gcc-2.95.3/gcc/c-typeck.c	Thu Jan 25 15:03:00 2001
+++ gcc-gcic/gcc/c-typeck.c	Sat Aug  3 14:17:40 2002
@@ -29,6 +29,11 @@
    and to process initializations in declarations (since they work
    like a strange sort of assignment).  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   Changed build_function_call() routine. */
+ 
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 #include "system.h"
 #include "tree.h"
@@ -78,6 +83,11 @@
 /* Do `exp = require_complete_type (exp);' to make sure exp
    does not have an incomplete type.  (That includes void types.)  */
 
+#ifdef GCIC_C
+extern int flag_gcic_mode;
+extern void remember_handles_exceptions PROTO((void));
+#endif /* GCIC_C */
+
 tree
 require_complete_type (value)
      tree value;
@@ -1541,6 +1551,15 @@
     {
       name = DECL_NAME (function);
       assembler_name = DECL_ASSEMBLER_NAME (function);
+
+#ifdef GCIC_C
+  if (flag_gcic_mode &&
+      ((IDENTIFIER_LENGTH(name) == 6 &&
+	!strcmp(IDENTIFIER_POINTER(name),"setjmp")) ||
+       (IDENTIFIER_LENGTH(name) == 10 &&
+	!strcmp(IDENTIFIER_POINTER(name),"getcontext"))))
+      remember_handles_exceptions();
+#endif /* GCIC_C */
 
       /* Differs from default_conversion by not setting TREE_ADDRESSABLE
 	 (because calling an inline function does not mean the function
diff -Naur gcc-2.95.3/gcc/cccp.c gcc-gcic/gcc/cccp.c
--- gcc-2.95.3/gcc/cccp.c	Thu Jan 25 15:03:00 2001
+++ gcc-gcic/gcc/cccp.c	Sat Aug  3 14:17:40 2002
@@ -19,6 +19,13 @@
 Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA. */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   Fixed a limitation in do_line() which used to cause bad #line extra-flags
+   (such as 'in system header' and so on) to be emitted for a reprocessed
+   file (i.e. a previous CPP output used as input to CPP). */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 
 #include "system.h"
@@ -6891,6 +6898,11 @@
 	error ("invalid format `#line' directive");
 	return 0;
       }
+
+#ifdef GCIC
+      if (file_change == leave_file)
+	  ip->system_header_p = 0;
+#endif /* GCIC */
 
       bp++;
       SKIP_WHITE_SPACE (bp);
diff -Naur gcc-2.95.3/gcc/configure gcc-gcic/gcc/configure
--- gcc-2.95.3/gcc/configure	Fri Mar 16 15:13:48 2001
+++ gcc-gcic/gcc/configure	Sat Aug  3 14:17:40 2002
@@ -1311,7 +1311,7 @@
 fi
 
 # Find some useful tools
-for ac_prog in gawk mawk nawk awk
+for ac_prog in mawk gawk nawk awk
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
@@ -6115,7 +6115,7 @@
 int main() {
 
 /* Ultrix mips cc rejects this.  */
-typedef int charset[2]; const charset x;
+typedef int charset[2]; const charset x = {0,0};
 /* SunOS 4.1.1 cc rejects this.  */
 char const *const *ccp;
 char **p;
@@ -6190,7 +6190,7 @@
 #include "confdefs.h"
 
 int main() {
-} $ac_kw foo() {
+} int $ac_kw foo() {
 ; return 0; }
 EOF
 if { (eval echo configure:6197: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
@@ -6296,7 +6296,7 @@
 #include "confdefs.h"
 #include <alloca.h>
 int main() {
-char *p = alloca(2 * sizeof(int));
+void *p = alloca(2 * sizeof(int));
 ; return 0; }
 EOF
 if { (eval echo configure:6303: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
@@ -6649,12 +6649,15 @@
 #include <sys/types.h>
 #include <fcntl.h>
 #include <sys/mman.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
 
 /* This mess was copied from the GNU getpagesize.h.  */
 #ifndef HAVE_GETPAGESIZE
-# ifdef HAVE_UNISTD_H
-#  include <unistd.h>
-# endif
 
 /* Assume that all systems that can run configure have sys/param.h.  */
 # ifndef HAVE_SYS_PARAM_H
@@ -6709,7 +6712,7 @@
 	/*
 	 * First, make a file with some known garbage in it.
 	 */
-	data = malloc(pagesize);
+	data = (char*)malloc(pagesize);
 	if (!data)
 		exit(1);
 	for (i = 0; i < pagesize; ++i)
@@ -6730,7 +6733,7 @@
 	fd = open("conftestmmap", O_RDWR);
 	if (fd < 0)
 		exit(1);
-	data2 = malloc(2 * pagesize);
+	data2 = (char*)malloc(2 * pagesize);
 	if (!data2)
 		exit(1);
 	data2 += (pagesize - ((int) data2 & (pagesize - 1))) & (pagesize - 1);
@@ -6748,7 +6751,7 @@
 	 */
 	for (i = 0; i < pagesize; ++i)
 		*(data2 + i) = *(data2 + i) + 1;
-	data3 = malloc(pagesize);
+	data3 = (char*)malloc(pagesize);
 	if (!data3)
 		exit(1);
 	if (read(fd, data3, pagesize) != pagesize)
@@ -6762,7 +6765,7 @@
 }
 
 EOF
-if { (eval echo configure:6766: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6769: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_mmap_fixed_mapped=yes
 else
@@ -6790,17 +6793,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:6794: checking for $ac_hdr" >&5
+echo "configure:6797: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6799 "configure"
+#line 6802 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:6804: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:6807: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -6830,12 +6833,12 @@
 strdup __argz_count __argz_stringify __argz_next
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:6834: checking for $ac_func" >&5
+echo "configure:6837: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6839 "configure"
+#line 6842 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -6858,7 +6861,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:6862: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6865: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -6887,12 +6890,12 @@
      for ac_func in stpcpy
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:6891: checking for $ac_func" >&5
+echo "configure:6894: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6896 "configure"
+#line 6899 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -6915,7 +6918,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:6919: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6922: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -6949,19 +6952,19 @@
 
    if test $ac_cv_header_locale_h = yes; then
     echo $ac_n "checking for LC_MESSAGES""... $ac_c" 1>&6
-echo "configure:6953: checking for LC_MESSAGES" >&5
+echo "configure:6956: checking for LC_MESSAGES" >&5
 if eval "test \"`echo '$''{'am_cv_val_LC_MESSAGES'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6958 "configure"
+#line 6961 "configure"
 #include "confdefs.h"
 #include <locale.h>
 int main() {
 return LC_MESSAGES
 ; return 0; }
 EOF
-if { (eval echo configure:6965: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6968: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   am_cv_val_LC_MESSAGES=yes
 else
@@ -6982,7 +6985,7 @@
     fi
   fi
    echo $ac_n "checking whether NLS is requested""... $ac_c" 1>&6
-echo "configure:6986: checking whether NLS is requested" >&5
+echo "configure:6989: checking whether NLS is requested" >&5
         # Check whether --enable-nls or --disable-nls was given.
 if test "${enable_nls+set}" = set; then
   enableval="$enable_nls"
@@ -7002,7 +7005,7 @@
 EOF
 
       echo $ac_n "checking whether included gettext is requested""... $ac_c" 1>&6
-echo "configure:7006: checking whether included gettext is requested" >&5
+echo "configure:7009: checking whether included gettext is requested" >&5
       # Check whether --with-included-gettext or --without-included-gettext was given.
 if test "${with_included_gettext+set}" = set; then
   withval="$with_included_gettext"
@@ -7021,17 +7024,17 @@
 
 	ac_safe=`echo "libintl.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for libintl.h""... $ac_c" 1>&6
-echo "configure:7025: checking for libintl.h" >&5
+echo "configure:7028: checking for libintl.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7030 "configure"
+#line 7033 "configure"
 #include "confdefs.h"
 #include <libintl.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:7035: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:7038: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -7048,19 +7051,19 @@
 if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   echo $ac_n "checking for gettext in libc""... $ac_c" 1>&6
-echo "configure:7052: checking for gettext in libc" >&5
+echo "configure:7055: checking for gettext in libc" >&5
 if eval "test \"`echo '$''{'gt_cv_func_gettext_libc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7057 "configure"
+#line 7060 "configure"
 #include "confdefs.h"
 #include <libintl.h>
 int main() {
 return (int) gettext ("")
 ; return 0; }
 EOF
-if { (eval echo configure:7064: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7067: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   gt_cv_func_gettext_libc=yes
 else
@@ -7076,7 +7079,7 @@
 
 	   if test "$gt_cv_func_gettext_libc" != "yes"; then
 	     echo $ac_n "checking for bindtextdomain in -lintl""... $ac_c" 1>&6
-echo "configure:7080: checking for bindtextdomain in -lintl" >&5
+echo "configure:7083: checking for bindtextdomain in -lintl" >&5
 ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7084,7 +7087,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lintl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7088 "configure"
+#line 7091 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -7095,7 +7098,7 @@
 bindtextdomain()
 ; return 0; }
 EOF
-if { (eval echo configure:7099: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7102: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7111,12 +7114,12 @@
 if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   echo $ac_n "checking for gettext in libintl""... $ac_c" 1>&6
-echo "configure:7115: checking for gettext in libintl" >&5
+echo "configure:7118: checking for gettext in libintl" >&5
 if eval "test \"`echo '$''{'gt_cv_func_gettext_libintl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo $ac_n "checking for gettext in -lintl""... $ac_c" 1>&6
-echo "configure:7120: checking for gettext in -lintl" >&5
+echo "configure:7123: checking for gettext in -lintl" >&5
 ac_lib_var=`echo intl'_'gettext | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7124,7 +7127,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lintl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7128 "configure"
+#line 7131 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -7135,7 +7138,7 @@
 gettext()
 ; return 0; }
 EOF
-if { (eval echo configure:7139: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7142: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7174,7 +7177,7 @@
 	      # Extract the first word of "msgfmt", so it can be a program name with args.
 set dummy msgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7178: checking for $ac_word" >&5
+echo "configure:7181: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7208,12 +7211,12 @@
 		for ac_func in dcgettext
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:7212: checking for $ac_func" >&5
+echo "configure:7215: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7217 "configure"
+#line 7220 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -7236,7 +7239,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:7240: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7243: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -7263,7 +7266,7 @@
 		# Extract the first word of "gmsgfmt", so it can be a program name with args.
 set dummy gmsgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7267: checking for $ac_word" >&5
+echo "configure:7270: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7299,7 +7302,7 @@
 		# Extract the first word of "xgettext", so it can be a program name with args.
 set dummy xgettext; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7303: checking for $ac_word" >&5
+echo "configure:7306: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7331,7 +7334,7 @@
 fi
 
 		cat > conftest.$ac_ext <<EOF
-#line 7335 "configure"
+#line 7338 "configure"
 #include "confdefs.h"
 
 int main() {
@@ -7339,7 +7342,7 @@
 			       return _nl_msg_cat_cntr
 ; return 0; }
 EOF
-if { (eval echo configure:7343: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7346: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   CATOBJEXT=.gmo
 		   DATADIRNAME=share
@@ -7362,7 +7365,7 @@
 
         if test "$CATOBJEXT" = "NONE"; then
 	  echo $ac_n "checking whether catgets can be used""... $ac_c" 1>&6
-echo "configure:7366: checking whether catgets can be used" >&5
+echo "configure:7369: checking whether catgets can be used" >&5
 	  # Check whether --with-catgets or --without-catgets was given.
 if test "${with_catgets+set}" = set; then
   withval="$with_catgets"
@@ -7375,7 +7378,7 @@
 
 	  if test "$nls_cv_use_catgets" = "yes"; then
 	    	    echo $ac_n "checking for main in -li""... $ac_c" 1>&6
-echo "configure:7379: checking for main in -li" >&5
+echo "configure:7382: checking for main in -li" >&5
 ac_lib_var=`echo i'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7383,14 +7386,14 @@
   ac_save_LIBS="$LIBS"
 LIBS="-li  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7387 "configure"
+#line 7390 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:7394: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7397: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7418,12 +7421,12 @@
 fi
 
 	    echo $ac_n "checking for catgets""... $ac_c" 1>&6
-echo "configure:7422: checking for catgets" >&5
+echo "configure:7425: checking for catgets" >&5
 if eval "test \"`echo '$''{'ac_cv_func_catgets'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7427 "configure"
+#line 7430 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char catgets(); below.  */
@@ -7446,7 +7449,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:7450: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7453: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_catgets=yes"
 else
@@ -7468,7 +7471,7 @@
 	       # Extract the first word of "gencat", so it can be a program name with args.
 set dummy gencat; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7472: checking for $ac_word" >&5
+echo "configure:7475: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GENCAT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7504,7 +7507,7 @@
 		 # Extract the first word of "gmsgfmt", so it can be a program name with args.
 set dummy gmsgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7508: checking for $ac_word" >&5
+echo "configure:7511: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7541,7 +7544,7 @@
 		   # Extract the first word of "msgfmt", so it can be a program name with args.
 set dummy msgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7545: checking for $ac_word" >&5
+echo "configure:7548: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7576,7 +7579,7 @@
 		 # Extract the first word of "xgettext", so it can be a program name with args.
 set dummy xgettext; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7580: checking for $ac_word" >&5
+echo "configure:7583: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7634,7 +7637,7 @@
         # Extract the first word of "msgfmt", so it can be a program name with args.
 set dummy msgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7638: checking for $ac_word" >&5
+echo "configure:7641: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7668,7 +7671,7 @@
         # Extract the first word of "gmsgfmt", so it can be a program name with args.
 set dummy gmsgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7672: checking for $ac_word" >&5
+echo "configure:7675: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7704,7 +7707,7 @@
         # Extract the first word of "xgettext", so it can be a program name with args.
 set dummy xgettext; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7708: checking for $ac_word" >&5
+echo "configure:7711: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7797,7 +7800,7 @@
        LINGUAS=
      else
        echo $ac_n "checking for catalogs to be installed""... $ac_c" 1>&6
-echo "configure:7801: checking for catalogs to be installed" >&5
+echo "configure:7804: checking for catalogs to be installed" >&5
        NEW_LINGUAS=
        for lang in ${LINGUAS=$ALL_LINGUAS}; do
          case "$ALL_LINGUAS" in
@@ -7825,17 +7828,17 @@
    if test "$CATOBJEXT" = ".cat"; then
      ac_safe=`echo "linux/version.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for linux/version.h""... $ac_c" 1>&6
-echo "configure:7829: checking for linux/version.h" >&5
+echo "configure:7832: checking for linux/version.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7834 "configure"
+#line 7837 "configure"
 #include "confdefs.h"
 #include <linux/version.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:7839: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:7842: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -8069,7 +8072,7 @@
 
 # Figure out what assembler alignment features are present.
 echo $ac_n "checking assembler alignment features""... $ac_c" 1>&6
-echo "configure:8073: checking assembler alignment features" >&5
+echo "configure:8076: checking assembler alignment features" >&5
 gcc_cv_as=
 gcc_cv_as_alignment_features=
 gcc_cv_as_gas_srcdir=`echo $srcdir | sed -e 's,/gcc$,,'`/gas
@@ -8190,7 +8193,7 @@
 echo "$ac_t""$gcc_cv_as_alignment_features" 1>&6
 
 echo $ac_n "checking assembler subsection support""... $ac_c" 1>&6
-echo "configure:8194: checking assembler subsection support" >&5
+echo "configure:8197: checking assembler subsection support" >&5
 gcc_cv_as_subsections=
 if test x$gcc_cv_as != x; then
 	# Check if we have .subsection
@@ -8230,7 +8233,7 @@
 echo "$ac_t""$gcc_cv_as_subsections" 1>&6
 
 echo $ac_n "checking assembler instructions""... $ac_c" 1>&6
-echo "configure:8234: checking assembler instructions" >&5
+echo "configure:8237: checking assembler instructions" >&5
 gcc_cv_as_instructions=
 if test x$gcc_cv_as != x; then
 	set "filds fists" "filds mem; fists mem"
diff -Naur gcc-2.95.3/gcc/cp/Makefile.in gcc-gcic/gcc/cp/Makefile.in
--- gcc-2.95.3/gcc/cp/Makefile.in	Sun Jul 25 23:27:38 1999
+++ gcc-gcic/gcc/cp/Makefile.in	Sat Aug  3 14:17:40 2002
@@ -147,7 +147,7 @@
 INTERNAL_CFLAGS = $(CROSS) -DIN_GCC @extra_c_flags@
 
 # This is the variable actually used when we compile.
-ALL_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS) $(XCFLAGS)
+ALL_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS) $(XCFLAGS) -DGCIC_CPLUS=1 -DGCIC=1 -DYYTOKENTYPE
 
 # Likewise.
 ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)
@@ -161,7 +161,7 @@
 # How to link with both our special library facilities
 # and the system's installed libraries.
 LIBS = $(SUBDIR_OBSTACK) $(SUBDIR_USE_ALLOCA) $(SUBDIR_MALLOC) \
-  $(INTLLIBS) $(CLIB)
+  $(INTLLIBS) $(CLIB) ../../libiberty/libiberty.a
 
 # Specify the directories to be searched for header files.
 # Both . and srcdir are used, in that order,
@@ -188,7 +188,7 @@
 CXX_OBJS = call.o decl.o errfn.o expr.o pt.o sig.o typeck2.o \
  class.o decl2.o error.o lex.o parse.o ptree.o rtti.o spew.o typeck.o cvt.o \
  except.o friend.o init.o method.o search.o semantics.o tree.o xref.o \
- repo.o @extra_cxx_objs@
+ repo.o @extra_cxx_objs@ gcic.o
 
 # Language-independent object files.
 OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o
@@ -240,6 +240,10 @@
 #	$(srcdir)/../move-if-change y.tab.h $(PARSE_H)
 #	cp $(PARSE_C) y.tab.c
 #	touch stamp-parse
+
+gcic.o : $(srcdir)/../gcic.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h \
+	$(srcdir)/../toplev.h
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) $(srcdir)/../gcic.c
 
 # We used to try to protect people from having to rerun gperf.  But,
 # the C front-end already requires this if c-parse.gperf is changed,
diff -Naur gcc-2.95.3/gcc/cp/cp-tree.def gcc-gcic/gcc/cp/cp-tree.def
--- gcc-2.95.3/gcc/cp/cp-tree.def	Mon May 17 18:07:30 1999
+++ gcc-gcic/gcc/cp/cp-tree.def	Sat Aug  3 14:17:40 2002
@@ -21,7 +21,11 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    Changed DEFAULT_ARG tree code.  */
  
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 /* Reference to the contents of an offset
    (a value whose type is an OFFSET_TYPE).
    Operand 0 is the object within which the offset is taken.
@@ -169,8 +173,13 @@
    This is not an alias, but is later expanded into multiple aliases.  */
 DEFTREECODE (USING_DECL, "using_decl", 'd', 0)
 
+#ifdef GCIC
+/* An un-parsed default argument.  Looks like a LEXLOC_NODE.  */
+DEFTREECODE (DEFAULT_ARG, "default_arg", 'c', 3)
+#else /* !GCIC */
 /* An un-parsed default argument.  Looks like an IDENTIFIER_NODE.  */
 DEFTREECODE (DEFAULT_ARG, "default_arg", 'c', 2)
+#endif /* GCIC */
 
 /* A template-id, like foo<int>.  The first operand is the template.
    The second is the TREE_LIST or TREE_VEC of explicitly specified
diff -Naur gcc-2.95.3/gcc/cp/cp-tree.h gcc-gcic/gcc/cp/cp-tree.h
--- gcc-2.95.3/gcc/cp/cp-tree.h	Thu Apr 20 07:13:25 2000
+++ gcc-gcic/gcc/cp/cp-tree.h	Sat Aug  3 14:17:40 2002
@@ -19,6 +19,13 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    Changed DEFARG_ and ANON_AGGRNAME_P macros.
+    Changed pending_inline struct.
+    Added CP_TYPE_NETSHARED_P and CP_TYPE_DATAPORT_P predicates. */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #ifndef _CP_TREE_H
 #define _CP_TREE_H
 
@@ -2062,10 +2069,17 @@
 #define UPT_TEMPLATE(NODE)      TREE_PURPOSE(TYPE_VALUES(NODE))
 #define UPT_PARMS(NODE)         TREE_VALUE(TYPE_VALUES(NODE))
 
-/* An un-parsed default argument looks like an identifier.  */
 #define DEFARG_NODE_CHECK(t)	TREE_CHECK(t, DEFAULT_ARG) 
+#ifdef GCIC_CPLUS
+/* An un-parsed default argument looks like a lexloc node.  */
+#define DEFARG_LENGTH(NODE)	(DEFARG_NODE_CHECK(NODE)->lexloc.length)
+#define DEFARG_POINTER(NODE)	(DEFARG_NODE_CHECK(NODE)->lexloc.pointer)
+#define DEFARG_OFFSET(NODE)	(DEFARG_NODE_CHECK(NODE)->lexloc.offset)
+#else /* !GCIC_CPLUS */
+/* An un-parsed default argument looks like an identifier.  */
 #define DEFARG_LENGTH(NODE)	(DEFARG_NODE_CHECK(NODE)->identifier.length)
 #define DEFARG_POINTER(NODE)	(DEFARG_NODE_CHECK(NODE)->identifier.pointer)
+#endif /* GCIC_CPLUS */
 
 #define builtin_function(NAME, TYPE, CODE, LIBNAME) \
   define_function (NAME, TYPE, CODE, (void (*) PROTO((tree)))pushdecl, LIBNAME)
@@ -2521,6 +2535,9 @@
   tree fndecl;			/* FUNCTION_DECL that brought us here */
   int token;			/* token we were scanning */
   int token_value;		/* value of token we were scanning (YYSTYPE) */
+#ifdef GCIC
+  int lex_offset;
+#endif
 
   char *buf;			/* pointer to character stream */
   int len;			/* length of stream */
@@ -3328,7 +3345,11 @@
 extern tree finish_parenthesized_expr           PROTO((tree));
 extern tree begin_stmt_expr                     PROTO((void));
 extern tree finish_stmt_expr                    PROTO((tree, tree));
+#ifdef GCIC_CPLUS
+extern tree finish_call_expr                    PROTO((tree, tree, int, int, int));
+#else /* !GCIC_CPLUS */
 extern tree finish_call_expr                    PROTO((tree, tree, int));
+#endif /* GCIC_CPLUS */
 extern tree finish_increment_expr               PROTO((tree, enum tree_code));
 extern tree finish_this_expr                    PROTO((void));
 extern tree finish_object_call_expr             PROTO((tree, tree, tree));
diff -Naur gcc-2.95.3/gcc/cp/decl.c gcc-gcic/gcc/cp/decl.c
--- gcc-2.95.3/gcc/cp/decl.c	Sat Jun 10 02:06:42 2000
+++ gcc-gcic/gcc/cp/decl.c	Sat Aug  3 14:17:40 2002
@@ -27,6 +27,12 @@
 /* ??? not all decl nodes are given the most useful possible
    line numbers.  For example, the CONST_DECLs for enum values.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    Added Sim-specific processing to shadow_tag(), cp_finish_decl()
+    grokdeclarator(), start_function(), finish_function().  */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+ 
 #include "config.h"
 #include "system.h"
 #include "tree.h"
@@ -69,6 +75,10 @@
 struct obstack decl_obstack;
 static struct stack_level *decl_stack;
 
+#ifdef GCIC_CPLUS
+extern void remember_body_fall_through PROTO((tree));
+#endif /* GCIC_CPLUS */
+
 #ifndef CHAR_TYPE_SIZE
 #define CHAR_TYPE_SIZE BITS_PER_UNIT
 #endif
@@ -14599,6 +14609,14 @@
 	  || DECL_NAME (DECL_RESULT (fndecl)) != NULL_TREE)
 	current_function_returns_null = 0;
 
+#ifdef GCIC_CPLUS
+	/* Do not emit the following warnings while instrumenting --
+	   they are caused by the -Wreturn-type flag passed to the
+	   compilation driver, and will be emitted during the actual
+	   compilation pass. */
+	if (!flag_gcic_mode)
+	    {
+#endif /* GCIC_CPLUS */
       if (TREE_THIS_VOLATILE (fndecl) && current_function_returns_null)
 	cp_warning ("`noreturn' function `%D' does return", fndecl);
       else if ((warn_return_type || pedantic)
@@ -14614,7 +14632,19 @@
       else if (extra_warnings
 	       && current_function_returns_value && current_function_returns_null)
 	warning ("this function may return with or without a value");
-    }
+#ifdef GCIC_CPLUS
+	    }
+      else if (can_reach_end || DECL_CONSTRUCTOR_P(fndecl))
+	       remember_body_fall_through(fndecl);
+#endif /* GCIC_CPLUS */
+    }
+#ifdef GCIC_CPLUS
+      /* Because we cannot analyze a template function control flow
+	 during its declaration, assume that it always falls through
+	 end. */
+      else if (flag_gcic_mode)
+	       remember_body_fall_through(fndecl);
+#endif /* GCIC_CPLUS */
 
   --function_depth;
 
diff -Naur gcc-2.95.3/gcc/cp/decl2.c gcc-gcic/gcc/cp/decl2.c
--- gcc-2.95.3/gcc/cp/decl2.c	Sat Jun 10 02:06:44 2000
+++ gcc-gcic/gcc/cp/decl2.c	Sat Aug  3 14:17:41 2002
@@ -27,6 +27,11 @@
 /* ??? not all decl nodes are given the most useful possible
    line numbers.  For example, the CONST_DECLs for enum values.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    Added hook in finish_file().  */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 #include "system.h"
 #include "tree.h"
@@ -50,6 +55,10 @@
 extern cpp_reader  parse_in;
 #endif
 
+#ifdef GCIC_CPLUS
+extern void generate_gcic_code PROTO((void));
+#endif /* GCIC_CPLUS */
+
 /* This structure contains information about the initializations
    and/or destructions required for a particular priority level.  */
 typedef struct priority_info_s {
@@ -3678,6 +3687,11 @@
     return;
 
   start_time = get_run_time ();
+
+#ifdef GCIC_CPLUS
+  if (flag_gcic_mode)
+      generate_gcic_code();
+#endif /* GCIC_CPLUS */
 
   /* Otherwise, GDB can get confused, because in only knows
      about source for LINENO-1 lines.  */
diff -Naur gcc-2.95.3/gcc/cp/init.c gcc-gcic/gcc/cp/init.c
--- gcc-2.95.3/gcc/cp/init.c	Sat Jun 10 02:06:44 2000
+++ gcc-gcic/gcc/cp/init.c	Sat Aug  3 14:17:41 2002
@@ -21,6 +21,11 @@
 
 /* High-level class interface.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    Added ck_build_offset_ref() helper routine.  */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 #include "system.h"
 #include "tree.h"
diff -Naur gcc-2.95.3/gcc/cp/input.c gcc-gcic/gcc/cp/input.c
--- gcc-2.95.3/gcc/cp/input.c	Mon Feb  1 08:01:50 1999
+++ gcc-gcic/gcc/cp/input.c	Sat Aug  3 14:17:41 2002
@@ -29,6 +29,12 @@
    lex.c for very minor efficiency gains (primarily in function
    inlining).  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    Changed sub_getch() routine.
+    Added ungetc() routine. */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "system.h"
 
 extern FILE *finput;
@@ -61,6 +67,12 @@
 #define GETC() getc (finput)
 #endif
 
+#ifdef GCIC_CPLUS
+extern int lex_offset;
+extern int input_char_num;
+#define UNGETC(c) ungetc (c,finput)
+#endif /* GCIC_CPLUS */
+
 extern void feed_input PROTO((char *, int));
 extern void put_input PROTO((int));
 extern void put_back PROTO((int));
@@ -168,8 +180,32 @@
 	  end_input ();
 	  return getch ();
 	}
+#ifdef GCIC_CPLUS
+      if ((unsigned char)input->str[input->offset] == 0xff)
+	  {
+	  /* Adjust current file offset */
+	  int disp = (int)input->str[++input->offset];
+	  input->offset++;
+
+	  if (!disp)
+	      return ' ';
+
+	  lex_offset += disp;
+	  input_char_num += disp;
+	  return sub_getch();
+	  }
+
+      lex_offset++;
+      input_char_num++;
+#endif /* GCIC_CPLUS */
       return (unsigned char)input->str[input->offset++];
     }
+
+#ifdef GCIC_CPLUS
+  lex_offset++;
+  input_char_num++;
+#endif /* GCIC_CPLUS */
+
   return GETC ();
 }
 
@@ -198,6 +234,19 @@
     }
   return ch;
 }
+
+#ifdef GCIC_CPLUS
+void ungetch (int c)
+{
+    if (input && input->offset > 0)
+	input->offset--;
+    else
+	UNGETC(c);
+
+    lex_offset--;
+    input_char_num--;
+}
+#endif /* GCIC_CPLUS */
 
 inline
 int
diff -Naur gcc-2.95.3/gcc/cp/lex.c gcc-gcic/gcc/cp/lex.c
--- gcc-2.95.3/gcc/cp/lex.c	Wed Aug 11 20:36:44 1999
+++ gcc-gcic/gcc/cp/lex.c	Sat Aug  3 14:17:41 2002
@@ -22,6 +22,12 @@
 
 /* This file is the lexical analyzer for GNU C++.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   All changes are aimed at tracking the input text position in
+   the original source file for a subsequent use by the patch engine.  */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 /* Cause the `yydebug' variable to be defined.  */
 #define YYDEBUG 1
 
@@ -53,6 +59,20 @@
 extern struct obstack permanent_obstack;
 extern struct obstack *current_obstack, *saveable_obstack;
 
+#ifdef GCIC_CPLUS
+extern int lex_offset;
+extern int lex_token_offset;
+extern int yy_offset;
+extern int real_yylex_nestcount;
+extern int input_char_num;
+extern int flag_gcic_mode;
+extern void reset_token_stack PROTO((void));
+extern void remember_body_start PROTO((int));
+extern void save_gcic_token_stack PROTO((void));
+extern void restore_gcic_token_stack PROTO((void));
+extern void ungetch PROTO((int));
+#endif /* GCIC_CPLUS */
+
 extern void yyprint PROTO((FILE *, int, YYSTYPE));
 
 static tree get_time_identifier PROTO((const char *));
@@ -1189,6 +1209,9 @@
 
   feed_input (pi->buf, pi->len);
   lineno = pi->lineno;
+#ifdef GCIC_CPLUS
+  lex_offset = pi->lex_offset;
+#endif /* GCIC_CPLUS */
   input_filename = pi->filename;
   yychar = PRE_PARSED_FUNCTION_DECL;
   yylval.ttype = build_tree_list ((tree) pi, pi->fndecl);
@@ -1233,6 +1256,10 @@
   if (t == 0)
     return;
 	    
+#ifdef GCIC_CPLUS
+  save_gcic_token_stack();
+#endif /* GCIC_CPLUS */
+
   /* Now start processing the first inline function.  */
   begin_definition_of_inclass_inline (t);
 }
@@ -1270,7 +1297,14 @@
   if (i)
     begin_definition_of_inclass_inline (i);
   else
-    extract_interface_info ();
+#ifdef GCIC_CPLUS
+      {
+      restore_gcic_token_stack();
+#endif /* GCIC_CPLUS */
+      extract_interface_info ();
+#ifdef GCIC_CPLUS
+      }
+#endif /* GCIC_CPLUS */
 }
 
 /* Since inline methods can refer to text which has not yet been seen,
@@ -1333,6 +1367,9 @@
   YYSTYPE yylval, nextyylval;
   struct obstack token_obstack;
   int first_token;
+#ifdef GCIC_CPLUS
+  int lex_offset;
+#endif /* GCIC_CPLUS */
 };
 
 struct pending_input *
@@ -1350,6 +1387,9 @@
   nextchar = -1;
   p->first_token = first_token;
   p->token_obstack = token_obstack;
+#ifdef GCIC_CPLUS
+  p->lex_offset = lex_offset;
+#endif /* GCIC_CPLUS */
 
   first_token = 0;
   gcc_obstack_init (&token_obstack);
@@ -1373,6 +1413,9 @@
   obstack_free (&token_obstack, (char *) 0);
   token_obstack = p->token_obstack;
   end_of_file = p->eof;
+#ifdef GCIC_CPLUS
+  lex_offset = p->lex_offset;
+#endif /* GCIC_CPLUS */
   free (p);
 }
 
@@ -1433,6 +1476,11 @@
   int len;
   int starting_lineno = lineno;
   char *starting_filename = input_filename;
+#ifdef GCIC_CPLUS
+  int starting_lex_offset = yy_offset;
+  if (flag_gcic_mode)
+      reset_token_stack();
+#endif /* GCIC_CPLUS */
 
   reinit_parse_for_block (yychar, &inline_text_obstack);
 
@@ -1462,6 +1510,9 @@
       t->buf = buf;
       t->len = len;
       t->deja_vu = 0;
+#ifdef GCIC_CPLUS
+      t->lex_offset = starting_lex_offset;
+#endif /* GCIC_CPLUS */
 #if 0
       if (interface_unknown && processing_template_defn && flag_external_templates && ! DECL_IN_SYSTEM_HEADER (decl))
 	warn_if_unknown_interface (decl);
@@ -1471,6 +1522,21 @@
     }
 }
 
+#ifdef GCIC_CPLUS
+static push_offset_update (struct obstack *obstackp,
+			   int disp)
+{
+    do
+	{
+	int _disp = disp > 255 ? 255 : disp;
+	obstack_1grow(obstackp,0xff);
+	obstack_1grow(obstackp,_disp);
+	disp -= _disp;
+	}
+    while (disp > 0);
+}
+#endif /* GCIC_CPLUS */
+
 /* Consume a block -- actually, a method beginning
    with `:' or `{' -- and save it away on the specified obstack.  */
 
@@ -1486,6 +1552,11 @@
   int len;
   int look_for_semicolon = 0;
   int look_for_lbrac = 0;
+#ifdef GCIC_CPLUS
+  int starting_offset;
+  if (flag_gcic_mode && pyychar == '{')
+      remember_body_start(yy_offset);
+#endif /* GCIC_CPLUS */
 
   if (pyychar == '{')
     obstack_1grow (obstackp, '{');
@@ -1495,7 +1566,11 @@
     {
       obstack_1grow (obstackp, pyychar);
       /* Add a space so we don't get confused by ': ::A(20)'.  */
+#ifdef GCIC_CPLUS
+      push_offset_update(obstackp,0);
+#else /* !GCIC_CPLUS */
       obstack_1grow (obstackp, ' ');
+#endif /* GCIC_CPLUS */
       look_for_lbrac = 1;
       blev = 0;
     }
@@ -1525,12 +1600,33 @@
   else
     c = getch ();
   
+#ifdef GCIC_CPLUS
+  starting_offset = lex_offset;
+#endif /* GCIC_CPLUS */
+
   while (c != EOF)
     {
       int this_lineno = lineno;
 
       c = skip_white_space (c);
 
+#ifdef GCIC_CPLUS
+      {
+      int disp = lex_offset - starting_offset;
+      int i = lineno - this_lineno;
+      disp -= i;
+
+      while (i-- > 0)
+	  /* don't be smart at all */
+	  obstack_1grow(obstackp, '\n');
+
+      if (disp > 0)
+	  {
+	  push_offset_update(obstackp,disp);
+	  starting_offset = lex_offset;
+	  }
+      }
+#else /* !GCIC_CPLUS */
       /* Don't lose our cool if there are lots of comments.  */
       if (lineno == this_lineno + 1)
 	obstack_1grow (obstackp, '\n');
@@ -1554,12 +1650,17 @@
 	  obstack_1grow (obstackp, '\"');
 	  obstack_1grow (obstackp, '\n');
 	}
+#endif /* GCIC_CPLUS */
 
       while (c > ' ')		/* ASCII dependent...  */
 	{
 	  obstack_1grow (obstackp, c);
 	  if (c == '{')
 	    {
+#ifdef GCIC_CPLUS
+	    if (blev == 0 && pyychar == ':' && flag_gcic_mode)
+		remember_body_start(lex_offset - 1);
+#endif /* GCIC_CPLUS */
 	      look_for_lbrac = 0;
 	      blev++;
 	    }
@@ -1634,6 +1735,9 @@
 	  obstack_1grow (obstackp, c);
 	  c = getch ();
 	}
+#ifdef GCIC_CPLUS
+      starting_offset = lex_offset;
+#endif /* GCIC_CPLUS */
     }
  done:
   obstack_1grow (obstackp, '\0');
@@ -1777,6 +1881,9 @@
   arg = make_node (DEFAULT_ARG);
   DEFARG_LENGTH (arg) = len - 1;
   DEFARG_POINTER (arg) = buf;
+#ifdef GCIC_CPLUS
+  DEFARG_OFFSET (arg) = lex_token_offset + 1; /* +1 bumps after '=' */
+#endif /* GCIC_CPLUS */
   pop_obstacks ();
 
   return arg;
@@ -1809,6 +1916,9 @@
 {
   tree d = TREE_PURPOSE (p);
   feed_input (DEFARG_POINTER (d), DEFARG_LENGTH (d));
+#ifdef GCIC_CPLUS
+  lex_offset = DEFARG_OFFSET (d);
+#endif /* GCIC_CPLUS */
   if (TREE_CODE (f) == FUNCTION_DECL)
     {
       lineno = DECL_SOURCE_LINE (f);
@@ -2431,6 +2541,14 @@
 	  goto skipline;
 	}
 
+#ifdef GCIC_CPLUS
+      /* Restart counting from a stable base just in case the current file is
+	 to be compiled more than once with different conditional blocks
+	 being parsed. This trick was suggested by Vincent Bodson
+	 <vincent.bodson@art.alcatel.fr> */
+      input_char_num = l;
+#endif /* GCIC_CPLUS */
+
       /* Changing files again.  This means currently collected time
 	 is charged against header time, and body time starts back
 	 at 0.  */
@@ -3242,6 +3360,11 @@
   int dollar_seen = 0;
   int i;
 
+#ifdef GCIC_CPLUS
+  real_yylex_nestcount++;
+lex_again:
+#endif /* GCIC_CPLUS */
+
   if (nextchar >= 0)
     c = nextchar, nextchar = -1;
   else
@@ -3275,6 +3398,18 @@
   token_buffer[0] = c;
   token_buffer[1] = 0;
 
+#ifdef GCIC_CPLUS
+  if (real_yylex_nestcount == 1)
+      {
+      /* Keep pointing to the heading token; i did not
+	 want to change real_yylex() prototype to keep
+	 the impact on the original code as minor as possible.
+	 Therefore, i use an ugly global nesting count to prevent
+	 overwriting lex_token_offset while recursing. */
+      lex_token_offset = lex_offset - 1;
+      }
+#endif /* GCIC_CPLUS */
+
 /*  yylloc.first_line = lineno; */
 
   switch (c)
@@ -3506,6 +3641,36 @@
 		}
 
 	      value = (int) ptr->token;
+
+#ifdef GCIC_CPLUS
+	    /* Some compilers allow inline assembler code to be
+	       given within braces -- just eat this code at lexer's level
+	       without passing it back to the parser. */
+	    if (flag_gcic_mode && value == ASM_KEYWORD)
+		{
+		int next_c = getch();
+
+		while (next_c == ' ') /* LF appears as blank  */
+		    next_c = getch();
+
+		if (next_c == '{')
+		    {
+		    int braces = 1;
+
+		    while ((next_c = getch()) != EOF)
+			{
+			if (next_c == '{')
+			    braces++;
+			else if (next_c == '}' && --braces <= 0)
+			    break;
+			}
+
+		    goto lex_again;
+		    }
+		else
+		    ungetch(next_c);
+		}
+#endif /* GCIC_CPLUS */
 	    }
 	}
 
@@ -4492,6 +4657,10 @@
 #endif
 #endif
 
+#ifdef GCIC_CPLUS
+  real_yylex_nestcount--;
+#endif /* GCIC_CPLUS */
+
   return value;
 }
 
@@ -4961,7 +5130,13 @@
       return 1;
     }
 
+#ifdef GCIC_CPLUS
+  /*  Pretend that all unknown pragmas have been successfully processed
+      if running in GCIC instrumentation mode. */
+  return !!flag_gcic_mode;
+#else  /* !GCIC_CPLUS */
   return 0;
+#endif /* GCIC_CPLUS */
 }
 
 /* Return the type-qualifier corresponding to the identifier given by
@@ -5023,3 +5198,18 @@
     }
 }
 #endif /* HANDLE_GENERIC_PRAGMAS */
+
+#ifdef GCIC_CPLUS
+void
+position_after_white_space ()
+{
+  int c;
+
+  if (nextchar != -1)
+    c = nextchar, nextchar = -1;
+  else
+    c = getch();
+
+  ungetch (skip_white_space (c));
+}
+#endif /* GCIC_CPLUS */
diff -Naur gcc-2.95.3/gcc/cp/method.c gcc-gcic/gcc/cp/method.c
--- gcc-2.95.3/gcc/cp/method.c	Sat Jun 10 02:06:44 2000
+++ gcc-gcic/gcc/cp/method.c	Sat Aug  3 14:17:41 2002
@@ -20,6 +20,9 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001. */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
 
 #ifndef __GNUC__
 #define __inline
@@ -2152,6 +2155,10 @@
   tree function = TREE_OPERAND (DECL_INITIAL (thunk_fndecl), 0);
   int delta = THUNK_DELTA (thunk_fndecl);
 
+#ifdef GCIC
+    if (flag_syntax_only)
+	return;
+#endif /* GCIC */
   if (TREE_ASM_WRITTEN (thunk_fndecl))
     return;
 
diff -Naur gcc-2.95.3/gcc/cp/parse.h gcc-gcic/gcc/cp/parse.h
--- gcc-2.95.3/gcc/cp/parse.h	Fri Mar 16 15:13:48 2001
+++ gcc-gcic/gcc/cp/parse.h	Sat Aug  3 14:41:45 2002
@@ -1,90 +1,102 @@
-typedef union {long itype; tree ttype; char *strtype; enum tree_code code; flagged_type_tree ftype; } YYSTYPE;
-#define	IDENTIFIER	258
-#define	TYPENAME	259
-#define	SELFNAME	260
-#define	PFUNCNAME	261
-#define	SCSPEC	262
-#define	TYPESPEC	263
-#define	CV_QUALIFIER	264
-#define	CONSTANT	265
-#define	STRING	266
-#define	ELLIPSIS	267
-#define	SIZEOF	268
-#define	ENUM	269
-#define	IF	270
-#define	ELSE	271
-#define	WHILE	272
-#define	DO	273
-#define	FOR	274
-#define	SWITCH	275
-#define	CASE	276
-#define	DEFAULT	277
-#define	BREAK	278
-#define	CONTINUE	279
-#define	RETURN_KEYWORD	280
-#define	GOTO	281
-#define	ASM_KEYWORD	282
-#define	TYPEOF	283
-#define	ALIGNOF	284
-#define	SIGOF	285
-#define	ATTRIBUTE	286
-#define	EXTENSION	287
-#define	LABEL	288
-#define	REALPART	289
-#define	IMAGPART	290
-#define	AGGR	291
-#define	VISSPEC	292
-#define	DELETE	293
-#define	NEW	294
-#define	THIS	295
-#define	OPERATOR	296
-#define	CXX_TRUE	297
-#define	CXX_FALSE	298
-#define	NAMESPACE	299
-#define	TYPENAME_KEYWORD	300
-#define	USING	301
-#define	LEFT_RIGHT	302
-#define	TEMPLATE	303
-#define	TYPEID	304
-#define	DYNAMIC_CAST	305
-#define	STATIC_CAST	306
-#define	REINTERPRET_CAST	307
-#define	CONST_CAST	308
-#define	SCOPE	309
-#define	EMPTY	310
-#define	PTYPENAME	311
-#define	NSNAME	312
-#define	THROW	313
-#define	ASSIGN	314
-#define	OROR	315
-#define	ANDAND	316
-#define	MIN_MAX	317
-#define	EQCOMPARE	318
-#define	ARITHCOMPARE	319
-#define	LSHIFT	320
-#define	RSHIFT	321
-#define	POINTSAT_STAR	322
-#define	DOT_STAR	323
-#define	UNARY	324
-#define	PLUSPLUS	325
-#define	MINUSMINUS	326
-#define	HYPERUNARY	327
-#define	PAREN_STAR_PAREN	328
-#define	POINTSAT	329
-#define	TRY	330
-#define	CATCH	331
-#define	PRE_PARSED_FUNCTION_DECL	332
-#define	EXTERN_LANG_STRING	333
-#define	ALL	334
-#define	PRE_PARSED_CLASS_DECL	335
-#define	DEFARG	336
-#define	DEFARG_MARKER	337
-#define	TYPENAME_DEFN	338
-#define	IDENTIFIER_DEFN	339
-#define	PTYPENAME_DEFN	340
-#define	END_OF_LINE	341
-#define	END_OF_SAVED_INPUT	342
+#ifndef BISON_PARSE_H
+# define BISON_PARSE_H
+
+#ifndef YYSTYPE
+typedef union {long itype; tree ttype; char *strtype; enum tree_code code; flagged_type_tree ftype; } yystype;
+# define YYSTYPE yystype
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+# define	IDENTIFIER	257
+# define	TYPENAME	258
+# define	SELFNAME	259
+# define	PFUNCNAME	260
+# define	SCSPEC	261
+# define	TYPESPEC	262
+# define	CV_QUALIFIER	263
+# define	CONSTANT	264
+# define	STRING	265
+# define	ELLIPSIS	266
+# define	SIZEOF	267
+# define	ENUM	268
+# define	IF	269
+# define	ELSE	270
+# define	WHILE	271
+# define	DO	272
+# define	FOR	273
+# define	SWITCH	274
+# define	CASE	275
+# define	DEFAULT	276
+# define	BREAK	277
+# define	CONTINUE	278
+# define	RETURN_KEYWORD	279
+# define	GOTO	280
+# define	ASM_KEYWORD	281
+# define	TYPEOF	282
+# define	ALIGNOF	283
+# define	SIGOF	284
+# define	ATTRIBUTE	285
+# define	EXTENSION	286
+# define	LABEL	287
+# define	REALPART	288
+# define	IMAGPART	289
+# define	FLATREF	290
+# define	SENDPORT	291
+# define	RECVPORT	292
+# define	AGGR	293
+# define	VISSPEC	294
+# define	DELETE	295
+# define	NEW	296
+# define	THIS	297
+# define	OPERATOR	298
+# define	CXX_TRUE	299
+# define	CXX_FALSE	300
+# define	NAMESPACE	301
+# define	TYPENAME_KEYWORD	302
+# define	USING	303
+# define	LEFT_RIGHT	304
+# define	TEMPLATE	305
+# define	TYPEID	306
+# define	DYNAMIC_CAST	307
+# define	STATIC_CAST	308
+# define	REINTERPRET_CAST	309
+# define	CONST_CAST	310
+# define	SCOPE	311
+# define	EMPTY	312
+# define	PTYPENAME	313
+# define	NSNAME	314
+# define	THROW	315
+# define	ASSIGN	316
+# define	OROR	317
+# define	ANDAND	318
+# define	MIN_MAX	319
+# define	EQCOMPARE	320
+# define	ARITHCOMPARE	321
+# define	LSHIFT	322
+# define	RSHIFT	323
+# define	POINTSAT_STAR	324
+# define	DOT_STAR	325
+# define	UNARY	326
+# define	PLUSPLUS	327
+# define	MINUSMINUS	328
+# define	HYPERUNARY	329
+# define	PAREN_STAR_PAREN	330
+# define	POINTSAT	331
+# define	TRY	332
+# define	CATCH	333
+# define	PRE_PARSED_FUNCTION_DECL	334
+# define	EXTERN_LANG_STRING	335
+# define	ALL	336
+# define	PRE_PARSED_CLASS_DECL	337
+# define	DEFARG	338
+# define	DEFARG_MARKER	339
+# define	TYPENAME_DEFN	340
+# define	IDENTIFIER_DEFN	341
+# define	PTYPENAME_DEFN	342
+# define	END_OF_LINE	343
+# define	END_OF_SAVED_INPUT	344
 
 
 extern YYSTYPE yylval;
+
+#endif /* not BISON_PARSE_H */
 #define YYEMPTY		-2
diff -Naur gcc-2.95.3/gcc/cp/parse.y gcc-gcic/gcc/cp/parse.y
--- gcc-2.95.3/gcc/cp/parse.y	Mon Aug  9 12:51:17 1999
+++ gcc-gcic/gcc/cp/parse.y	Sat Aug  3 14:41:44 2002
@@ -26,6 +26,13 @@
    all derivations; this is applied before the explicit action, if one
    is given.  Keep this in mind when reading the actions.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    All changes are aimed at feeding the instrumentation engine
+    (in ck/ck.c) with information it will subsequently use to determine
+    the required code modifications in the original source.  */
+ 
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 %{
 /* Cause the `yydebug' variable to be defined.  */
 #define YYDEBUG 1
@@ -86,6 +93,81 @@
   return parms;
 }
 
+extern int flag_gcic_mode;
+extern int yy_offset;
+extern int yy_preemption_lock;
+extern int lex_identifier_offset;
+
+extern void remember_body_start PROTO((int));
+extern void remember_body_end PROTO((int));
+extern void remember_stmt_bounds PROTO((int, int, int));
+extern void analyze_return_stmt PROTO((tree));
+extern void remember_handles_exceptions PROTO((void));
+
+static int *yy_offstack,
+            yy_offmax,
+            yy_offsp,
+            yy_returnstmt,
+            yy_tmpl_processing;
+
+static void gcic_push_offset (int offset)
+
+{
+    if (yy_offmax <= yy_offsp)
+	{
+	yy_offmax += 16;
+
+	if (!yy_offstack)
+	    yy_offstack = (int *)xmalloc(yy_offmax * sizeof(int));
+	else
+	    yy_offstack = (int *)xrealloc(yy_offstack,yy_offmax * sizeof(int));
+	}
+
+    yy_offstack[yy_offsp++] = offset;
+}
+
+static int gcic_pop_offset ()
+
+{ return yy_offstack[--yy_offsp]; }
+
+static int gcic_invalidate_offset ()
+
+{ yy_offstack[yy_offsp - 1] = -1; }
+
+#define GCIC_ENTER_FUNC() { if (flag_gcic_mode) \
+		                 remember_body_start(yy_offset); }
+#define GCIC_EXIT_FUNC()  { if (flag_gcic_mode) \
+		                 remember_body_end(yy_offset); }
+#define GCIC_BEGIN_STMT() { if (flag_gcic_mode) \
+                                 gcic_push_offset(yy_offset); }
+#define GCIC_MARK_STMT()  { if (flag_gcic_mode) { \
+		                 remember_stmt_bounds(gcic_pop_offset(), \
+				                      yy_offset, \
+				                      yy_returnstmt); \
+		                 yy_returnstmt = 0; } }
+#define GCIC_PUSH_YYOFFSET()   { if (flag_gcic_mode) \
+                                      gcic_push_offset(yy_offset); }
+#define GCIC_PUSH_OFFSET(off)   { if (flag_gcic_mode) \
+                                       gcic_push_offset(off); }
+#define GCIC_POP_OFFSET()    (flag_gcic_mode ? gcic_pop_offset() : -1)
+
+#define GCIC_GET_YYOFFSET()    (flag_gcic_mode ? yy_offset : -1)
+
+#define GCIC_FLUSH_TEMPL() { if (flag_gcic_mode) \
+                                  reset_token_stack(); }
+#define GCIC_LOCK_PREEMPTION() { if (flag_gcic_mode) \
+                                      yy_preemption_lock++; }
+#define GCIC_UNLOCK_PREEMPTION() { if (flag_gcic_mode) \
+                                        yy_preemption_lock--; }
+#define GCIC_INHIBIT_TEMPL()   { if (flag_gcic_mode) \
+                                      yy_tmpl_processing = processing_template_decl, \
+                                      processing_template_decl = 0; }
+#define GCIC_RESTORE_TEMPL()   { if (flag_gcic_mode) \
+                                      processing_template_decl = yy_tmpl_processing; }
+#define GCIC_START_COMPOUND()  { if (flag_gcic_mode) \
+                                      remember_compound_start(yy_offset); }
+#define GCIC_END_COMPOUND()    { if (flag_gcic_mode) \
+                                      remember_compound_end(yy_offset); }
 %}
 
 %start program
@@ -135,6 +217,7 @@
 %token SIGOF
 %token ATTRIBUTE EXTENSION LABEL
 %token REALPART IMAGPART
+%token FLATREF SENDPORT RECVPORT /* CK-specific */
 
 /* the reserved words... C++ extensions */
 %token <ttype> AGGR
@@ -372,7 +455,8 @@
 extension:
 	EXTENSION
 		{ $<itype>$ = pedantic;
-		  pedantic = 0; }
+		  pedantic = 0;
+		  GCIC_LOCK_PREEMPTION(); }
 	;
 
 asm_keyword:
@@ -417,7 +501,8 @@
 		{ do_toplevel_using_decl ($1); }
 	| using_directive
 	| extension extdef
-		{ pedantic = $<itype>1; }
+		{ pedantic = $<itype>1;
+		GCIC_UNLOCK_PREEMPTION(); }
 	;
 
 namespace_alias:
@@ -479,6 +564,7 @@
 		    $$ = lastiddecl;
 		  got_scope = $$;
 		}
+        ;
 
 any_id:
 	  unqualified_id
@@ -502,10 +588,12 @@
 	  TEMPLATE '<'
 		{ begin_template_parm_list (); }
 	  template_parm_list '>'
-		{ $$ = end_template_parm_list ($4); }
+		{ $$ = end_template_parm_list ($4);
+		GCIC_FLUSH_TEMPL(); }
 	| TEMPLATE '<' '>'
                 { begin_specialization(); 
-		  $$ = NULL_TREE; }
+		  $$ = NULL_TREE;
+		  GCIC_FLUSH_TEMPL(); }
 	;
 
 template_parm_list:
@@ -520,6 +608,7 @@
 	  	{ $$ = $1; }
 	|	/* empty */
 		{ $$ = NULL_TREE; }
+        ;
 
 template_type_parm:
 	  aggr maybe_identifier
@@ -639,8 +728,10 @@
 	;
 
 fndef:
-	  fn.def1 maybe_return_init ctor_initializer_opt compstmt_or_error
-		{ finish_function (lineno, (int)$3, 0); }
+	  fn.def1 maybe_return_init ctor_initializer_opt { GCIC_ENTER_FUNC(); } compstmt_or_error
+		{ /* must be fired prior to finish_function() */
+		    GCIC_EXIT_FUNC();
+		    finish_function (lineno, (int)$3, 0); }
 	| fn.def1 maybe_return_init function_try_block
 		{ 
 		  int nested = (hack_decl_function_context
@@ -898,9 +989,11 @@
 
 begin_explicit_instantiation: 
       { begin_explicit_instantiation(); }
+      ;
 
 end_explicit_instantiation: 
       { end_explicit_instantiation(); }
+      ;
 
 /* The TYPENAME expansions are to deal with use of a template class name as
   a template within the class itself, where the template decl is hidden by
@@ -921,6 +1014,7 @@
 	| identifier '<' template_arg_list_opt '>'
 	    .finish_template_type
 		{ $$ = $5; }
+        ;
 
 self_template_type:
 	  SELFNAME  '<' template_arg_list_opt template_close_bracket
@@ -936,6 +1030,7 @@
 		  $$ = finish_template_type ($<ttype>-3, $<ttype>-1, 
 					     yychar == SCOPE);
 		}
+        ;
 
 template_close_bracket:
 	  '>'
@@ -1051,10 +1146,18 @@
 
 already_scoped_stmt:
 	  '{'
-                { $<ttype>$ = begin_compound_stmt (1); }
+                {
+		    GCIC_START_COMPOUND();
+		    $<ttype>$ = begin_compound_stmt (1);
+		}
 	  compstmtend
-                { finish_compound_stmt (1, $<ttype>2); }
-	| simple_stmt
+                {
+		    GCIC_END_COMPOUND();
+		    finish_compound_stmt (1, $<ttype>2);
+		}
+	|  { GCIC_BEGIN_STMT(); }
+               simple_stmt
+           { GCIC_MARK_STMT(); }
 	;
 
 
@@ -1083,7 +1186,8 @@
 	/* __extension__ turns off -pedantic for following primary.  */
 	| extension cast_expr  	  %prec UNARY
 		{ $$ = $2;
-		  pedantic = $<itype>1; }
+		  pedantic = $<itype>1;
+		  GCIC_UNLOCK_PREEMPTION(); }
 	| '*' cast_expr   %prec UNARY
 		{ $$ = build_x_indirect_ref ($2, "unary *"); }
 	| '&' cast_expr   %prec UNARY
@@ -1097,15 +1201,19 @@
 		{ if (pedantic)
 		    pedwarn ("ANSI C++ forbids `&&'");
   		  $$ = finish_label_address_expr ($2); }
-	| SIZEOF unary_expr  %prec UNARY
-		{ $$ = expr_sizeof ($2); }
-	| SIZEOF '(' type_id ')'  %prec HYPERUNARY
-		{ $$ = c_sizeof (groktypename ($3.t));
+	| sizeof unary_expr  %prec UNARY
+		{ GCIC_RESTORE_TEMPL(); /* <= must restore template flag now! */
+		  $$ = expr_sizeof ($2); }
+	| sizeof '(' type_id ')'  %prec HYPERUNARY
+		{ GCIC_RESTORE_TEMPL();  /* <= must restore template flag now! */
+		  $$ = c_sizeof (groktypename ($3.t));
 		  check_for_new_type ("sizeof", $3); }
-	| ALIGNOF unary_expr  %prec UNARY
-		{ $$ = grok_alignof ($2); }
-	| ALIGNOF '(' type_id ')'  %prec HYPERUNARY
-		{ $$ = c_alignof (groktypename ($3.t)); 
+	| alignof unary_expr  %prec UNARY
+		{ GCIC_RESTORE_TEMPL();
+		  $$ = grok_alignof ($2); }
+	| alignof '(' type_id ')'  %prec HYPERUNARY
+		{ GCIC_RESTORE_TEMPL();
+		  $$ = c_alignof (groktypename ($3.t)); 
 		  check_for_new_type ("alignof", $3); }
 
 	/* The %prec EMPTY's here are required by the = init initializer
@@ -1165,6 +1273,12 @@
 		{ $$ = build_x_unary_op (IMAGPART_EXPR, $2); }
 	;
 
+sizeof: SIZEOF { GCIC_INHIBIT_TEMPL(); }
+      ;
+
+alignof: ALIGNOF { GCIC_INHIBIT_TEMPL(); }
+       ;
+
         /* Note this rule is not suitable for use in new_placement
 	   since it uses NULL_TREE as the argument to
 	   finish_new_placement.  This rule serves only to avoid
@@ -1173,9 +1287,11 @@
 .finish_new_placement:
 	  ')'
                 { finish_new_placement (NULL_TREE, $<itype>-1); }
+       ;
 
 .begin_new_placement:
                 { $$ = begin_new_placement (); }
+       ;
 
 new_placement:
 	  '(' .begin_new_placement nonnull_exprlist ')'
@@ -1330,6 +1446,7 @@
 		  else
 		    $$ = $<ttype>-1;
 		}
+      ;
 
 template_id:
           PFUNCNAME '<' do_id template_arg_list_opt template_close_bracket 
@@ -1438,14 +1555,21 @@
         /* Koenig lookup support
            We could store lastiddecl in $1 to avoid another lookup,
            but that would result in many additional reduce/reduce conflicts. */
-        | notype_unqualified_id '(' nonnull_exprlist ')'
-               { $$ = finish_call_expr ($1, $3, 1); }
+        | notype_unqualified_id '(' {
+		   GCIC_PUSH_OFFSET(lex_identifier_offset);
+		   GCIC_PUSH_YYOFFSET();
+	} nonnull_exprlist ')'
+               {
+		   int tail_offset = GCIC_POP_OFFSET();
+		   int id_offset = GCIC_POP_OFFSET();
+		   $$ = finish_call_expr ($1, $4, 1, tail_offset, id_offset);
+	       }
         | notype_unqualified_id LEFT_RIGHT
-               { $$ = finish_call_expr ($1, NULL_TREE, 1); }
+               { $$ = finish_call_expr ($1, NULL_TREE, 1, GCIC_GET_YYOFFSET(), lex_identifier_offset); }
 	| primary '(' nonnull_exprlist ')'
-               { $$ = finish_call_expr ($1, $3, 0); }
+               { $$ = finish_call_expr ($1, $3, 0, 0, 0); }
 	| primary LEFT_RIGHT
-               { $$ = finish_call_expr ($1, NULL_TREE, 0); }
+               { $$ = finish_call_expr ($1, NULL_TREE, 0, 0, 0); }
 	| primary '[' expr ']'
 		{ $$ = grok_array_decl ($$, $3); }
 	| primary PLUSPLUS
@@ -1473,22 +1597,22 @@
 		  $$ = build_c_cast (type, build_compound_expr ($3));
 		}
 	| functional_cast
-	| DYNAMIC_CAST '<' type_id '>' '(' expr ')'
-		{ tree type = groktypename ($3.t);
-		  check_for_new_type ("dynamic_cast", $3);
-		  $$ = build_dynamic_cast (type, $6); }
-	| STATIC_CAST '<' type_id '>' '(' expr ')'
-		{ tree type = groktypename ($3.t);
-		  check_for_new_type ("static_cast", $3);
-		  $$ = build_static_cast (type, $6); }
-	| REINTERPRET_CAST '<' type_id '>' '(' expr ')'
-		{ tree type = groktypename ($3.t);
-		  check_for_new_type ("reinterpret_cast", $3);
-		  $$ = build_reinterpret_cast (type, $6); }
-	| CONST_CAST '<' type_id '>' '(' expr ')'
-		{ tree type = groktypename ($3.t);
-		  check_for_new_type ("const_cast", $3);
-		  $$ = build_const_cast (type, $6); }
+	| .gcic.invalidate.preemption DYNAMIC_CAST '<' type_id '>' '(' expr ')'
+		{ tree type = groktypename ($4.t);
+		  check_for_new_type ("dynamic_cast", $4);
+		  $$ = build_dynamic_cast (type, $7); }
+	| .gcic.invalidate.preemption STATIC_CAST '<' type_id '>' '(' expr ')'
+		{ tree type = groktypename ($4.t);
+		  check_for_new_type ("static_cast", $4);
+		  $$ = build_static_cast (type, $7); }
+	| .gcic.invalidate.preemption REINTERPRET_CAST '<' type_id '>' '(' expr ')'
+		{ tree type = groktypename ($4.t);
+		  check_for_new_type ("reinterpret_cast", $4);
+		  $$ = build_reinterpret_cast (type, $7); }
+	| .gcic.invalidate.preemption CONST_CAST '<' type_id '>' '(' expr ')'
+		{ tree type = groktypename ($4.t);
+		  check_for_new_type ("const_cast", $4);
+		  $$ = build_const_cast (type, $7); }
 	| TYPEID '(' expr ')'
 		{ $$ = build_x_typeid ($3); }
 	| TYPEID '(' type_id ')'
@@ -1508,11 +1632,17 @@
 		    $$ = $2;
 		}
 	| overqualified_id  %prec HYPERUNARY
-		{ $$ = build_offset_ref (OP0 ($$), OP1 ($$)); }
+		{
+		    $$ = build_offset_ref (OP0 ($$), OP1 ($$));
+		}
 	| overqualified_id '(' nonnull_exprlist ')'
-                { $$ = finish_qualified_call_expr ($1, $3); }
+                {
+		    $$ = finish_qualified_call_expr ($1, $3);
+		}
 	| overqualified_id LEFT_RIGHT
-		{ $$ = finish_qualified_call_expr ($1, NULL_TREE); }
+		{
+		    $$ = finish_qualified_call_expr ($1, NULL_TREE);
+		}
         | object object_template_id %prec UNARY
                 { 
 		  $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); 
@@ -1522,12 +1652,16 @@
 	| object object_template_id LEFT_RIGHT
                 { $$ = finish_object_call_expr ($2, $1, NULL_TREE); }
 	| object unqualified_id  %prec UNARY
-		{ $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); }
+		{
+		    $$ = build_x_component_ref ($$, $2, NULL_TREE, 1);
+		}
 	| object overqualified_id  %prec UNARY
-		{ if (processing_template_decl)
-		    $$ = build_min_nt (COMPONENT_REF, $1, copy_to_permanent ($2));
-		  else
-		    $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }
+		{
+		    if (processing_template_decl)
+			$$ = build_min_nt (COMPONENT_REF, $1, copy_to_permanent ($2));
+		    else
+			$$ = build_object_ref ($$, OP0 ($2), OP1 ($2));
+		}
 	| object unqualified_id '(' nonnull_exprlist ')'
                 { $$ = finish_object_call_expr ($2, $1, $4); }
 	| object unqualified_id LEFT_RIGHT
@@ -1658,7 +1792,8 @@
 	| declmods ';'
 		{ warning ("empty declaration"); }
 	| extension decl
-		{ pedantic = $<itype>1; }
+		{ pedantic = $<itype>1;
+		GCIC_UNLOCK_PREEMPTION(); }
 	;
 
 /* Any kind of declarator (thus, all declarators allowed
@@ -1822,15 +1957,22 @@
 		{ $$.t = $1; $$.new_type_flag = 0; }
 	| complete_type_name
 		{ $$.t = $1; $$.new_type_flag = 0; }
-	| TYPEOF '(' expr ')'
-		{ $$.t = finish_typeof ($3);
-		  $$.new_type_flag = 0; }
-	| TYPEOF '(' type_id ')'
-		{ $$.t = groktypename ($3.t);
-		  $$.new_type_flag = 0; }
-	| SIGOF '(' expr ')'
+	| typeof '(' expr ')'
+		{
+		    GCIC_RESTORE_TEMPL();  /* <= must restore template flag now! */
+		    $$.t = finish_typeof ($3);
+		    $$.new_type_flag = 0;
+		}
+	| typeof '(' type_id ')'
+		{
+		    GCIC_RESTORE_TEMPL();  /* <= must restore template flag now! */
+		    $$.t = groktypename ($3.t);
+		    $$.new_type_flag = 0;
+		}
+	| sigof '(' expr ')'
 		{ tree type = TREE_TYPE ($3);
 
+		  GCIC_RESTORE_TEMPL();  /* <= must restore template flag now! */
                   $$.new_type_flag = 0;
 		  if (IS_AGGR_TYPE (type))
 		    {
@@ -1843,9 +1985,10 @@
 		      $$.t = error_mark_node;
 		    }
 		}
-	| SIGOF '(' type_id ')'
+	| sigof '(' type_id ')'
 		{ tree type = groktypename ($3.t);
 
+		  GCIC_RESTORE_TEMPL();  /* <= must restore template flag now! */
                   $$.new_type_flag = 0;
 		  if (IS_AGGR_TYPE (type))
 		    {
@@ -1860,6 +2003,12 @@
 		}
 	;
 
+typeof: TYPEOF { GCIC_INHIBIT_TEMPL(); }
+      ;
+
+sigof: SIGOF { GCIC_INHIBIT_TEMPL(); }
+     ;
+
 /* A typespec that is a reserved word, or a type qualifier.  */
 
 typespecqual_reserved:
@@ -1922,17 +2071,19 @@
 	     while its init is parsed! */ 
 	  init
 		{ cp_finish_decl ($<ttype>3, $4, $<ttype>0, 1,
-				  LOOKUP_ONLYCONVERTING);
+				LOOKUP_ONLYCONVERTING);
 		  $$ = $<itype>2; }
 	| maybe_attribute
 		{ tree d;
 		  $$ = parse_decl ($<ttype>-1, $<ttype>-2, $1, 0, &d);
+		  /* must be called prior to cp_finish_decl() */
 		  cp_finish_decl (d, NULL_TREE, $<ttype>0, 1, 0); }
   	;
   
 initdcl0:
 	  declarator maybeasm initdcl0_innards
             { $$ = $3; }
+        ;
   
 notype_initdcl0:
           notype_declarator maybeasm initdcl0_innards
@@ -2016,6 +2167,7 @@
 		{ $$ = NULL_TREE; }
 	| '=' init
 		{ $$ = $2; }
+        ;
 
 /* If we are processing a template, we don't want to expand this
    initializer yet.  */
@@ -2056,12 +2208,15 @@
 		{ start_function (NULL_TREE, TREE_VALUE ($1),
 				  NULL_TREE, 2);
 		  reinit_parse_for_function (); }
+        ;
 
 pending_inline:
 	  fn.defpen maybe_return_init ctor_initializer_opt compstmt_or_error
 		{
 		  int nested = (hack_decl_function_context
 				(current_function_decl) != NULL_TREE);
+		  /* must be fired *before* finish_function() */
+		  GCIC_EXIT_FUNC();
 		  finish_function (lineno, (int)$3 | 2, nested);
 		  process_next_inline ($1);
 		}
@@ -2088,6 +2243,7 @@
 		{ replace_defarg ($1, $2); }
 	| DEFARG_MARKER error END_OF_SAVED_INPUT
 		{ replace_defarg ($1, error_mark_node); }
+        ;
 
 pending_defargs:
 	  /* empty */ %prec EMPTY
@@ -2483,7 +2639,8 @@
 		{ $$ = NULL_TREE; }
 	| extension component_decl
 		{ $$ = $2;
-		  pedantic = $<itype>1; }
+		  pedantic = $<itype>1;
+		  GCIC_UNLOCK_PREEMPTION(); }
         | template_header component_decl
                 {  
 		  if ($2)
@@ -2561,6 +2718,7 @@
 				  build_tree_list ($3, NULL_TREE)); }
 	| using_decl
 		{ $$ = do_class_using_decl ($1); }
+        ;
 
 /* The case of exactly one component is handled directly by component_decl.  */
 /* ??? Huh? ^^^ */
@@ -2738,6 +2896,7 @@
 suspend_mom:
 	  /* empty */
 		{ $<itype>$ = suspend_momentary (); } 
+           ;
 
 /* An expression which will not live on the momentary obstack.  */
 nonmomentary_expr:
@@ -2787,7 +2946,7 @@
 	;
 
 direct_after_type_declarator:
-	  direct_after_type_declarator maybe_parmlist cv_qualifiers exception_specification_opt  %prec '.'
+	  direct_after_type_declarator  maybe_parmlist cv_qualifiers exception_specification_opt  %prec '.'
 		{ $$ = make_call_declarator ($$, $2, $3, $4); }
 	| direct_after_type_declarator '[' nonmomentary_expr ']'
 		{ $$ = build_parse_node (ARRAY_REF, $$, $3); }
@@ -2881,7 +3040,8 @@
 	;
 
 complex_direct_notype_declarator:
-	  direct_notype_declarator maybe_parmlist cv_qualifiers exception_specification_opt  %prec '.'
+	  direct_notype_declarator
+          maybe_parmlist cv_qualifiers exception_specification_opt  %prec '.'
 		{ $$ = make_call_declarator ($$, $2, $3, $4); }
 	| '(' complex_notype_declarator ')'
 		{ $$ = $2; }
@@ -3245,9 +3405,15 @@
 
 compstmt:
 	  '{'
-                { $<ttype>$ = begin_compound_stmt (0); }
+                {
+		    GCIC_START_COMPOUND();
+		    $<ttype>$ = begin_compound_stmt (0);
+		}
 	  compstmtend 
-                { $$ = finish_compound_stmt (0, $<ttype>2); }
+                {
+		    GCIC_END_COMPOUND();
+		    $$ = finish_compound_stmt (0, $<ttype>2);
+		}
 	;
 
 simple_if:
@@ -3264,19 +3430,36 @@
 
 implicitly_scoped_stmt:
 	  compstmt
-	|       { $<ttype>$ = begin_compound_stmt (0); }
+	|       {
+		$<ttype>$ = begin_compound_stmt (0);
+		GCIC_BEGIN_STMT();
+	        }
 	  simple_stmt 
-                { $$ = finish_compound_stmt (0, $<ttype>1); }
+                {
+		    GCIC_MARK_STMT();
+		    $$ = finish_compound_stmt (0, $<ttype>1);
+		}
 	;
 
 stmt:
 	  compstmt
                 {}
-	| simple_stmt
+	|  { GCIC_BEGIN_STMT(); } simple_stmt { GCIC_MARK_STMT(); }
+	;
+
+.gcic.invalidate.preemption:
+	  /* empty */
+		{ if (flag_gcic_mode)
+                      gcic_invalidate_offset(); }
+	;
+
+.gcic.note.return.reached:
+	  /* empty */
+		{ if (flag_gcic_mode) yy_returnstmt++; }
 	;
 
 simple_stmt:
-	  decl
+	  decl .gcic.invalidate.preemption
 		{ finish_stmt (); }
 	| expr ';'
                 { finish_expr_stmt ($1); }
@@ -3323,23 +3506,25 @@
                 { $<ttype>$ = finish_switch_cond ($4); }
 	  implicitly_scoped_stmt
                 { finish_switch_stmt ($4, $<ttype>6); }
-	| CASE expr_no_commas ':'
-                { finish_case_label ($2, NULL_TREE); }
+	| .gcic.invalidate.preemption CASE expr_no_commas ':'
+                { finish_case_label ($3, NULL_TREE); }
 	  stmt
-	| CASE expr_no_commas ELLIPSIS expr_no_commas ':'
-                { finish_case_label ($2, $4); }
+	| .gcic.invalidate.preemption CASE expr_no_commas ELLIPSIS expr_no_commas ':'
+                { finish_case_label ($3, $5); }
 	  stmt
-	| DEFAULT ':'
+	| .gcic.invalidate.preemption DEFAULT ':'
 		{ finish_case_label (NULL_TREE, NULL_TREE); }
 	  stmt
-	| BREAK ';'
+	| .gcic.invalidate.preemption BREAK ';'
                 { finish_break_stmt (); }
-	| CONTINUE ';'
+	| .gcic.invalidate.preemption CONTINUE ';'
                 { finish_continue_stmt (); }
-	| RETURN_KEYWORD ';'
+	| RETURN_KEYWORD ';' .gcic.note.return.reached
                 { finish_return_stmt (NULL_TREE); }
-	| RETURN_KEYWORD expr ';'
-                { finish_return_stmt ($2); }
+	| RETURN_KEYWORD expr ';' .gcic.note.return.reached
+                { finish_return_stmt ($2);
+		  if (flag_gcic_mode)
+		    analyze_return_stmt($2); }
 	| asm_keyword maybe_cv_qualifier '(' string ')' ';'
 		{ 
 		  finish_asm_stmt ($2, $4, NULL_TREE, NULL_TREE,
@@ -3375,10 +3560,10 @@
 	| ';'
 		{ finish_stmt (); }
 	| try_block
-	| using_directive
-	| namespace_using_decl
-	        { do_local_using_decl ($1); }
-	| namespace_alias
+	| .gcic.invalidate.preemption using_directive
+	| .gcic.invalidate.preemption namespace_using_decl
+	        { do_local_using_decl ($2); }
+	| .gcic.invalidate.preemption namespace_alias
 	;
 
 function_try_block:
@@ -3416,7 +3601,9 @@
 
 handler:
 	  CATCH
-                { $<ttype>$ = begin_handler(); }
+                { if (flag_gcic_mode)
+                      remember_handles_exceptions();
+		  $<ttype>$ = begin_handler(); }
           handler_args
                 { finish_handler_parms ($<ttype>2); }
 	  compstmt
diff -Naur gcc-2.95.3/gcc/cp/semantics.c gcc-gcic/gcc/cp/semantics.c
--- gcc-2.95.3/gcc/cp/semantics.c	Sun Jun 20 01:54:52 1999
+++ gcc-gcic/gcc/cp/semantics.c	Sat Aug  3 14:17:41 2002
@@ -24,6 +24,11 @@
    Software Foundation, 59 Temple Place - Suite 330, Boston, MA
    02111-1307, USA.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    Changed finish_call_expr(), finish_id_expr() routines.  */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 #include "system.h"
 #include "tree.h"
@@ -31,6 +36,9 @@
 #include "except.h"
 #include "lex.h"
 #include "toplev.h"
+#ifdef GCIC_CPLUS
+#include "flags.h"
+#endif /* GCIC_CPLUS */
 
 /* There routines provide a modular interface to perform many parsing
    operations.  They may therefore be used during actual parsing, or
@@ -62,6 +70,10 @@
 
 /* Finish an expression-statement, whose EXPRESSION is as indicated.  */
 
+#ifdef GCIC_CPLUS
+extern void substitute_call_wrapper PROTO((tree,int));
+#endif /* GCIC_CPLUS */
+
 void 
 finish_expr_stmt (expr)
      tree expr;
@@ -850,11 +862,21 @@
 /* Finish a call to FN with ARGS.  Returns a representation of the
    call.  */
 
+#ifdef GCIC_CPLUS
+tree 
+finish_call_expr (fn, args, koenig, tail, idoff)
+     tree fn;
+     tree args;
+     int koenig;
+     int tail;
+     int idoff;
+#else
 tree 
 finish_call_expr (fn, args, koenig)
      tree fn;
      tree args;
      int koenig;
+#endif /* GCIC_CPLUS */
 {
   tree result;
 
@@ -864,6 +886,13 @@
 	fn = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND (fn, 0));
       else if (TREE_CODE (fn) != TEMPLATE_ID_EXPR)
 	fn = do_identifier (fn, 2, args);
+#ifdef GCIC_CPLUS
+      /* Use of Koenig lookup implies that the parser has postponed
+	the identification of some variables such as pointers to
+	functions until now. */
+      if (flag_gcic_mode)
+	  substitute_call_wrapper(fn,idoff);
+#endif /* GCIC_CPLUS */
     }
   result = build_x_function_call (fn, args, current_class_ref);
 
diff -Naur gcc-2.95.3/gcc/cp/spew.c gcc-gcic/gcc/cp/spew.c
--- gcc-2.95.3/gcc/cp/spew.c	Wed Dec 16 22:16:11 1998
+++ gcc-gcic/gcc/cp/spew.c	Sat Aug  3 14:17:41 2002
@@ -23,6 +23,12 @@
 /* This file is the type analyzer for GNU C++.  To debug it, define SPEW_DEBUG
    when compiling parse.c and spew.c.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   All changes are aimed at tracking the input text position in
+   the original source file for a subsequent use by the patch engine.  */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 #include "system.h"
 #include "input.h"
@@ -34,6 +40,15 @@
 #include "obstack.h"
 #include "toplev.h"
 
+#ifdef GCIC_CPLUS
+extern int lex_offset;
+extern int lex_token_offset;
+extern int yy_offset;
+extern int lex_identifier_offset;
+extern void insert_gcic_stack_marker PROTO((int));
+extern void feed_gcic_token_stack PROTO((int,int));
+#endif /* GCIC_CPLUS */
+
 /* This takes a token stream that hasn't decided much about types and
    tries to figure out as much as it can, with excessive lookahead and
    backtracking.  */
@@ -44,6 +59,9 @@
   short		yychar;
   short		end_of_file;
   YYSTYPE	yylval;
+#ifdef GCIC_CPLUS
+  int offset;
+#endif /* GCIC_CPLUS */
 };
 
 static int do_aggr PROTO((void));
@@ -70,7 +88,11 @@
 extern int end_of_file;
 
 struct obstack token_obstack;
+#ifdef GCIC
+int first_token = 0;
+#else /* !GCIC */
 int first_token;
+#endif /* GCIC */
   
 #ifdef SPEW_DEBUG
 int spew_debug = 0;
@@ -182,6 +204,9 @@
       tmp->end_of_file = end_of_file;
       tmp->yylval = yylval;
       end_of_file = 0;
+#ifdef GCIC_CPLUS
+      tmp->offset = lex_token_offset;
+#endif /* GCIC_CPLUS */
       if (tmp->yychar == '{'
 	  || tmp->yychar == ':'
 	  || tmp->yychar == ';')
@@ -193,6 +218,9 @@
 	      tmp = ((struct token *)obstack_next_free (&token_obstack))-1;
 	      tmp->yychar = EMPTY;
 	      tmp->end_of_file = 0;
+#ifdef GCIC_CPLUS
+	      tmp->offset = lex_offset;
+#endif /* GCIC_CPLUS */
 	    }
 	}
     }
@@ -264,6 +292,9 @@
       tmp_token.yylval.ttype = snarf_defarg ();
       tmp_token.end_of_file = 0;
       do_snarf_defarg = 0;
+#ifdef GCIC_CPLUS
+      tmp_token.offset = DEFARG_OFFSET (tmp_token.yylval.ttype);
+#endif /* GCIC_CPLUS */
       add_token (&tmp_token);
     }
 
@@ -289,6 +320,9 @@
       tmp_token.yylval = yylval;
       tmp_token.end_of_file = end_of_file;
       add_token (&tmp_token);
+#ifdef GCIC_CPLUS
+      tmp_token.offset = lex_token_offset;
+#endif /* GCIC_CPLUS */
     }
 
   /* many tokens just need to be returned. At first glance, all we
@@ -413,6 +447,21 @@
   if (spew_debug)
     debug_yychar (yychar);
 #endif
+
+#ifdef GCIC_CPLUS
+  yy_offset = tmp_token.offset;
+
+  if (flag_gcic_mode)
+      {
+      if (yychar == IDENTIFIER)
+	  lex_identifier_offset = yy_offset;
+
+      if (yychar == ';' || yychar == END_OF_SAVED_INPUT)
+	  insert_gcic_stack_marker(yy_offset);
+      else
+	  feed_gcic_token_stack(yychar,yy_offset);
+      }
+#endif /* GCIC_CPLUS */
 
   return yychar;
 }
diff -Naur gcc-2.95.3/gcc/cp/typeck.c gcc-gcic/gcc/cp/typeck.c
--- gcc-2.95.3/gcc/cp/typeck.c	Mon Aug  9 10:46:20 1999
+++ gcc-gcic/gcc/cp/typeck.c	Sat Aug  3 14:17:41 2002
@@ -29,6 +29,11 @@
    and to process initializations in declarations (since they work
    like a strange sort of assignment).  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+    Changed build_x_function_call() routine.  */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 #include "system.h"
 #include "tree.h"
@@ -39,6 +44,10 @@
 #include "expr.h"
 #include "toplev.h"
 
+#ifdef GCIC_CPLUS
+extern void remember_handles_exceptions PROTO((void));
+#endif
+
 static tree convert_for_assignment PROTO((tree, tree, const char *, tree,
 					  int));
 static tree pointer_int_sum PROTO((enum tree_code, tree, tree));
@@ -2572,6 +2581,18 @@
 
   if (function == error_mark_node)
     return error_mark_node;
+
+#ifdef GCIC_CPLUS
+  if (flag_gcic_mode &&
+      TREE_CODE(function) == FUNCTION_DECL &&
+      DECL_CONTEXT(function) == NULL_TREE &&
+      DECL_NAME(function) != NULL_TREE &&
+      ((IDENTIFIER_LENGTH(DECL_NAME(function)) == 6 &&
+	!strcmp(IDENTIFIER_POINTER(DECL_NAME(function)),"setjmp")) ||
+       (IDENTIFIER_LENGTH(DECL_NAME(function)) == 10 &&
+	!strcmp(IDENTIFIER_POINTER(DECL_NAME(function)),"getcontext"))))
+      remember_handles_exceptions();
+#endif /* GCIC_CPLUS */
 
   if (processing_template_decl)
     return build_min_nt (CALL_EXPR, function, params, NULL_TREE);
diff -Naur gcc-2.95.3/gcc/flags.h gcc-gcic/gcc/flags.h
--- gcc-2.95.3/gcc/flags.h	Tue May 18 03:05:04 1999
+++ gcc-gcic/gcc/flags.h	Sat Aug  3 14:17:41 2002
@@ -18,6 +18,11 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   Added flag_gcic_mode. */
+ 
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 /* Name of the input .c file being compiled.  */
 extern char *main_input_filename;
 
@@ -538,3 +543,8 @@
    string identifying the compiler.  */
 
 extern int flag_no_ident;
+
+#ifdef GCIC
+/* Non-zero if running in GCIC instrumenter mode */
+extern int flag_gcic_mode;
+#endif /* GCIC */
diff -Naur gcc-2.95.3/gcc/gcic.c gcc-gcic/gcc/gcic.c
--- gcc-2.95.3/gcc/gcic.c	Thu Jan  1 01:00:00 1970
+++ gcc-gcic/gcc/gcic.c	Sat Aug  3 14:17:41 2002
@@ -0,0 +1,1230 @@
+/*
+ * This file is part of the XENOMAI project.
+ *
+ * Copyright (C) 1997-2000 Realiant Systems.  All rights reserved.
+ * Copyright (C) 2001,2002 Philippe Gerum <rpm@xenomai.org>.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * The original code is CarbonKernel - Real-time Operating System Simulator,
+ * released April 15, 2000. The initial developer of the original code is
+ * Realiant Systems (http://www.realiant.com).
+ *
+ * Description: instrumentation engine for C and C++.
+ *
+ * Author(s): rpm
+ * Contributor(s):
+ *
+ * Mostly rewritten for XENOMAI by Philippe Gerum.
+ */
+
+#define DEBUG_LEVEL 0
+
+#include "config.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <ctype.h>
+#include "tree.h"
+#include "flags.h"
+#include "system.h"
+#include "toplev.h"
+
+#ifdef GCIC_C
+
+#include "c-lex.h"
+#include "c-parse.h"
+#include "c-tree.h"
+
+#define ERROR   error
+#define WARNING warning
+
+#else  /* GCIC_CPLUS */
+
+#include "cp-tree.h"
+#include "decl.h"
+#include "lex.h"
+#include "parse.h"
+
+#define ERROR   cp_error
+#define WARNING cp_warning
+
+#ifndef NO_DOLLAR_IN_LABEL
+#  define GLOBAL_THING "_GLOBAL_$"
+#else
+#  ifndef NO_DOT_IN_LABEL
+#    define GLOBAL_THING "_GLOBAL_."
+#  else
+#    define GLOBAL_THING "_GLOBAL__"
+#  endif
+#endif
+
+#define GLOBAL_IORD_P(NODE) \
+  ! strncmp (IDENTIFIER_POINTER(NODE), GLOBAL_THING, sizeof (GLOBAL_THING) - 1)
+
+#endif /* GCIC_C */
+
+#include <sys/types.h>
+#include <signal.h>
+#include "obstack.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+extern char *choose_temp_base PROTO((void));
+
+extern int errorcount;
+
+extern char *input_filename;
+
+extern struct obstack *current_obstack,
+                       permanent_obstack;
+
+extern int flag_gcic_trace_tag;
+
+/* Current input file (output from CPP) */
+FILE *input_file;
+
+/* Current read offset in real source file */
+int lex_offset;
+
+/* Current token start offset in real source file at lexical level */
+int lex_token_offset;
+
+/* Position of last read identifier (follows lastiddecl) */
+int lex_identifier_offset;
+
+/* real_yylex() nesting depth */
+int real_yylex_nestcount;
+
+/* Token offset in real source file at grammatical level */
+int yy_offset;
+
+/* local preemption lock for statements (i.e. no preemption call when
+   non-zero) */
+int yy_preemption_lock;
+
+/* Currently input character number - this counter is reinitialized
+    after each #line directive */
+int input_char_num;
+
+/* Flag indicating a pending reset of the token stack */
+static int flag_reset_token_stack;
+
+/* Flag indicating that the last RETURN expr contains
+   at least one method or function call. */
+static int flag_last_return_calls;
+
+/* Input token obstacks */
+static struct obstack *token_obstack,
+                      primary_token_obstack,
+                      secondary_token_obstack; /* for C++ inlines only */
+/* Last read token */
+static struct digested_input_token last_read_token;
+
+/* Compound state obstack */
+static struct obstack compound_obstack;
+
+/* Patch records obstack */
+static struct obstack patch_obstack;
+
+/* Wrapper obstack (from control file) */
+static struct obstack wrap_obstack;
+
+/* Kludge:: the name of the temporary file to which the instrumenter
+   output will be redirected, so we can insert additional line
+   directives in the source. This extra work is needed to circumvent
+   G++ complaints about misplaced "#pragma implementation" directives
+   for a file re-processed from another place in the source tree. The
+   only way to prevent G++ lexer's from loosing its ground is to
+   ensure that the line information concerning the current input file
+   is in sync with the main input file path itself. */
+static char *temp_output_file;
+
+static char *control_file;
+
+void reset_token_stack PROTO((void));
+
+struct digested_input_token {
+
+	int yychar;
+	int offset;
+};
+
+struct compound_state {
+
+	int extra_closures;
+	int flag_handles_exceptions;
+};
+
+struct patch_record {
+
+#define PATCH_NONE                0
+#define PATCH_BODY_START          1
+#define PATCH_BODY_END            2
+#define PATCH_BODY_FALL           3
+#define PATCH_STMT                4
+#define PATCH_RETURN_STMT         5
+#define PATCH_RETURNL_STMT        6
+#define PATCH_COMPOUND_END        7
+#define PATCH_SUBSTITUTE_WRAPPER  8
+
+    unsigned patch_type,
+             patch_length;
+
+    int patch_offset,
+	patch_forward;
+
+    union {
+	tree identifier;
+	int levels;
+    } patch_link;
+
+    int trace_tag;
+    tree filename;
+    int lineno;
+    tree function;
+};
+
+struct wrap_info {
+
+/* Symbolic hook names -- matched in the wrap_obstack */
+#define GCIC_DECL    "@decl"
+#define GCIC_DINSN   "@dinsn"
+#define GCIC_DFRAME  "@dframe"
+
+    char *src_call;
+    char *dst_call;
+};
+
+static struct obstack scratch_obstack;
+static char *scratch_firstobj;
+
+#define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)
+#define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))
+#define OB_PUTCP(S) (obstack_grow (&scratch_obstack, (S), strlen (S)))
+#define OB_FINISH() (obstack_1grow (&scratch_obstack, '\0'))
+
+void init_gcic_processing (FILE *finput)
+
+{
+    struct wrap_info wrap;
+		
+    //set_yydebug(1);
+    lex_offset = 0;
+    real_yylex_nestcount = 0;
+    yy_offset = 0;
+    input_file = finput;
+    yy_preemption_lock = 0;
+    input_char_num = 0;
+
+    control_file = getenv("GCIC_CONTROL_FILE");
+    gcc_obstack_init(&wrap_obstack);
+    gcc_obstack_init(&scratch_obstack);
+    scratch_firstobj = (char *)obstack_alloc(&scratch_obstack, 0);
+
+    if (control_file)
+	{
+	char buf[BUFSIZ];
+	FILE *fp;
+	
+	fp = fopen(control_file,"r");
+
+	if (fp)
+	    {
+	    struct wrap_info *lastentry = NULL;
+	    char *rp, *wp, *wrapstr;
+	    int clineno = 0;
+
+	    /* Load the control file line by line, ignoring blanks.
+	       Expected format is old_string:new_string. Empty or
+	       comment (^#.*) lines are allowed. */
+
+	    while (fgets(buf,sizeof(buf),fp))
+		{
+		rp = wp = buf;
+		wrapstr = NULL;
+
+		while (*rp)
+		    {
+		    /* skip whitespaces until the ':' delimiter has been seen */
+		    
+		    if (wrapstr || (*rp != ' ' && *rp != '\t'))
+			{
+			if (*rp == '\n')
+			    break;
+			
+			if (*rp == ':')
+			    {
+			    *wp++ = '\0';
+			    wrapstr = wp;
+			    }
+			else
+			    *wp++ = *rp;
+			}
+
+		    rp++;
+		    }
+
+		*wp = '\0';
+
+		clineno++;
+
+		if (wp == buf || *buf == '#')
+		    /* discard empty or comment line */
+		    continue;
+
+		if (!wrapstr)
+		    {
+		    WARNING("gcic: malformed control file entry at %s:%d",
+			    control_file,clineno);
+		    continue;
+		    }
+
+		if (!strcmp(buf,"+"))
+		    {
+		    if (!lastentry)
+			{
+			WARNING("gcic: misplaced chaining symbol at %s:%d",
+				control_file,clineno);
+			continue;
+			}
+
+		    OB_INIT();
+		    OB_PUTCP(lastentry->dst_call);
+		    OB_PUTC('\n');
+		    OB_PUTCP(wrapstr);
+		    OB_FINISH();
+		    lastentry->dst_call =
+			IDENTIFIER_POINTER(get_identifier((char *)obstack_base(&scratch_obstack)));
+		    }
+		else
+		    {
+		    if (!*wrapstr)
+			wrapstr = "\n";
+
+		    wrap.src_call = IDENTIFIER_POINTER(get_identifier(buf));
+		    wrap.dst_call = IDENTIFIER_POINTER(get_identifier(wrapstr));
+		    obstack_grow(&wrap_obstack,&wrap,sizeof(wrap));
+
+		    if (!lastentry)
+			lastentry = (struct wrap_info *)obstack_base(&wrap_obstack);
+		    else
+			lastentry++;
+		    }
+		}
+
+	    fclose(fp);
+	    }
+	else
+	    ERROR("gcic: cannot open instrumenter control file `%s'",
+		  control_file);
+	}
+    else
+	{
+	/* Provide for default hooks if no control file has been given */
+	wrap.src_call = (char *)GCIC_DECL;
+	wrap.dst_call = (char *)
+	    "extern void (*gcic_dinsn)(int);\n"
+	    "extern void (*gcic_dframe)(int);\n";
+	obstack_grow(&wrap_obstack,&wrap,sizeof(wrap));
+	wrap.src_call = (char *)GCIC_DINSN;
+	wrap.dst_call = (char *)"gcic_dinsn(0x%x)";
+	obstack_grow(&wrap_obstack,&wrap,sizeof(wrap));
+	wrap.src_call = (char *)GCIC_DFRAME;
+	wrap.dst_call = (char *)"gcic_dframe(0x%x)";
+	obstack_grow(&wrap_obstack,&wrap,sizeof(wrap));
+	}
+
+    gcc_obstack_init(&primary_token_obstack);
+    gcc_obstack_init(&secondary_token_obstack);
+    token_obstack = &primary_token_obstack;
+    gcc_obstack_init(&patch_obstack);
+    gcc_obstack_init(&compound_obstack);
+
+#ifdef GCIC_CPLUS
+    temp_output_file = getenv("GCIC_TEMP_FILE");
+#endif /* GCIC_C */
+}
+
+static char *get_wrap_code (const char *symbolic)
+
+{
+    struct wrap_info *wrap = (struct wrap_info *)obstack_base(&wrap_obstack);
+    int nnum = obstack_object_size(&wrap_obstack) / sizeof(*wrap);
+
+    while (--nnum >= 0)
+	{
+	if (*wrap->src_call == *symbolic &&
+	    !strcmp(wrap->src_call + 1,symbolic + 1))
+	    return wrap->dst_call;
+
+	wrap++;
+	}
+
+    return NULL;
+}
+
+static char *format_wrapper (const char *symbolic, int flag, char *buf)
+
+{
+    char *wrapcode = get_wrap_code(symbolic);
+
+    if (!wrapcode)
+	sprintf(buf,"{error - undefined wrapper %s}",symbolic);
+    else
+	sprintf(buf,wrapcode,flag);
+
+    return buf;
+}
+
+void remember_body_fall_through (fndecl)
+
+    tree fndecl;
+{
+    struct patch_record *patches;
+    int n;
+
+#ifdef GCIC_CPLUS
+    /* discard internal functions generated by cc1plus */
+    if (GLOBAL_IORD_P(DECL_ASSEMBLER_NAME(fndecl)) ||
+	!DECL_LANG_SPECIFIC(fndecl))
+	return;
+
+    if (!processing_template_decl &&
+	DECL_LANG_SPECIFIC(fndecl) &&
+	DECL_TEMPLATE_INSTANTIATION(fndecl))
+	return;
+#endif /* GCIC_CPLUS */
+
+    patches = (struct patch_record *)obstack_base(&patch_obstack);
+    n = obstack_object_size(&patch_obstack) / sizeof(*patches);
+
+    while (--n >= 0)
+	{
+	/* Promote the last body end marker as the falling one */
+	if (patches[n].patch_type == PATCH_BODY_END)
+	    {
+	    patches[n].patch_type = PATCH_BODY_FALL;
+	    return;
+	    }
+	}
+}
+
+void remember_compound_start (offset)
+
+{
+    struct compound_state s;
+    s.extra_closures = 0;
+    s.flag_handles_exceptions = 0;
+    obstack_grow(&compound_obstack,&s,sizeof(s));
+    reset_token_stack();
+}
+
+void remember_compound_end (offset)
+
+    int offset;
+{
+    struct patch_record patch;
+    struct compound_state *s;
+
+    s = ((struct compound_state *)
+	((char *)obstack_base(&compound_obstack) +
+	 obstack_object_size(&compound_obstack))) - 1;
+
+    if (s->extra_closures > 0)
+	{
+	patch.patch_offset = offset;
+	patch.patch_forward = offset;
+	patch.patch_length = 1;
+	patch.patch_type = PATCH_COMPOUND_END;
+	patch.patch_link.levels = s->extra_closures;
+	obstack_grow(&patch_obstack,&patch,sizeof(patch));
+	}
+
+    obstack_free(&compound_obstack,s);
+}
+
+void remember_body_start (offset)
+
+    int offset;
+{
+    struct patch_record patch;
+    patch.patch_offset = offset;
+    patch.patch_forward = offset;
+    patch.patch_length = 1;
+    patch.patch_type = PATCH_BODY_START;
+    patch.patch_link.identifier = current_function_decl;
+    patch.trace_tag = flag_gcic_trace_tag;
+    obstack_grow(&patch_obstack,&patch,sizeof(patch));
+    remember_compound_start(offset);
+}
+
+void remember_body_end (offset)
+
+    int offset;
+{
+    struct patch_record patch;
+
+#ifdef GCIC_CPLUS
+    remember_compound_end(offset);
+#endif /* GCIC_CPLUS */
+    patch.patch_offset = offset;
+    patch.patch_forward = offset;
+    patch.patch_length = 1;
+    patch.patch_type = PATCH_BODY_END;
+    patch.patch_link.identifier = current_function_decl;
+    patch.trace_tag = flag_gcic_trace_tag;
+    obstack_grow(&patch_obstack,&patch,sizeof(patch));
+}
+
+void remember_stmt_bounds (begin, end, flag_return)
+
+    int begin, end, flag_return;
+{
+    struct patch_record patch;
+
+    if (yy_preemption_lock || begin < 0)
+	return;	/* invalidated */
+
+    /* Identify the case where a token lookahead has taken place in
+       order to adjust the current statement bounds (e.g.  "IF (cond)
+       stmt;" begets a lookahead to check whether a ELSE clause
+       follows or not). If the last read token is not a legal
+       statement delimiter, it should not be included in the
+       preemption block. As a special case, if an extra semi-colon is
+       read as the lookahead token, it can be safely included in the
+       block. */
+
+    if (last_read_token.yychar != EMPTY &&
+	last_read_token.yychar != '}' &&
+	last_read_token.yychar != ';')
+	end--;
+
+    patch.patch_offset = begin;
+    patch.patch_forward = begin;
+    patch.patch_length = end - begin + 1;
+
+    if (flag_return)
+	{
+	patch.patch_type = flag_last_return_calls ?
+	    PATCH_RETURNL_STMT : PATCH_RETURN_STMT;
+	flag_last_return_calls = 0;
+	}
+    else
+	patch.patch_type = PATCH_STMT;
+
+    patch.trace_tag = flag_gcic_trace_tag;
+
+    obstack_grow(&patch_obstack,&patch,sizeof(patch));
+}
+
+void remember_handles_exceptions ()
+
+{
+    ((struct compound_state *)
+     ((char *)obstack_base(&compound_obstack) +
+      obstack_object_size(&compound_obstack)))[-1].flag_handles_exceptions = 1;
+}
+
+/* This routine attempts to substitute a called function name by a
+   wrapper when matched by a substitution expr from the active control
+   file */
+
+void substitute_call_wrapper (tree primary, int offset)
+
+{
+    if (primary != NULL_TREE &&
+	TREE_CODE(primary) == FUNCTION_DECL)
+	{
+	char *wrapcode = NULL, *name;
+
+	name = IDENTIFIER_POINTER(DECL_NAME(primary));
+	wrapcode = get_wrap_code(name);
+
+	if (wrapcode)
+	    {
+	    struct patch_record patch;
+
+	    patch.patch_offset = offset;
+	    patch.patch_forward = offset;
+	    patch.patch_length = strlen(name);
+	    patch.patch_type = PATCH_SUBSTITUTE_WRAPPER;
+	    patch.patch_link.identifier = get_identifier(wrapcode);
+	    obstack_grow(&patch_obstack,&patch,sizeof(patch));
+	    }
+	}
+}
+
+/* This routine is adapted from contains_placeholder_p(); it scans an
+   expression tree, invoking a user-provided test function at each
+   node. The skulking stops when the test function returns a non-zero
+   value, or the whole tree has been scanned. */
+
+static int contains_p_worker (exp, testf)
+
+     tree exp;
+     int (*testf)(tree);
+{
+  enum tree_code code;
+
+  if (!exp)
+      return 0;
+
+  code = TREE_CODE (exp);
+
+  if (testf(exp))
+      return 1;
+
+  switch (TREE_CODE_CLASS (code))
+    {
+    case 'r':
+
+      return contains_p_worker (TREE_OPERAND (exp, 0),testf);
+
+    case 'x':
+
+      if (code == TREE_LIST)
+	return (contains_p_worker (TREE_VALUE (exp),testf)
+		|| (TREE_CHAIN (exp) != 0
+		    && contains_p_worker (TREE_CHAIN (exp),testf)));
+      return 0;
+					
+    case '1':
+    case '2':  case '<':
+    case 'e':
+
+      switch (code)
+	{
+	case COMPOUND_EXPR:
+	case CONSTRUCTOR:
+
+	  return contains_p_worker (TREE_OPERAND (exp, 1),testf);
+
+	case RTL_EXPR:
+
+	  return 0;
+
+	case COND_EXPR:
+
+	  return (contains_p_worker (TREE_OPERAND (exp, 0),testf)
+		  || contains_p_worker (TREE_OPERAND (exp, 1),testf)
+		  || contains_p_worker (TREE_OPERAND (exp, 2),testf));
+
+	case SAVE_EXPR:
+
+	  return contains_p_worker (TREE_OPERAND (exp, 0),testf);
+
+	case TARGET_EXPR:
+
+	    return contains_p_worker (TREE_OPERAND (exp, 0),testf) ||
+		contains_p_worker (TREE_OPERAND (exp, 1),testf);
+
+	default:
+
+	  break;
+	}
+
+      switch (tree_code_length[(int) code])
+	{
+	case 1:
+
+	  return contains_p_worker (TREE_OPERAND (exp, 0),testf);
+
+	case 2:
+
+	  return (contains_p_worker (TREE_OPERAND (exp, 0),testf)
+		  || contains_p_worker (TREE_OPERAND (exp, 1),testf));
+
+	default:
+
+	  return 0;
+	}
+
+    default:
+
+      return 0;
+    }
+}
+
+static int apply_callexpr_p (exp)
+
+     tree exp;
+{
+    enum tree_code code = TREE_CODE (exp);
+    return (code == CALL_EXPR || code == METHOD_CALL_EXPR);
+}
+
+static int contains_callexpr_p (exp)
+
+     tree exp;
+{
+    return contains_p_worker(exp,apply_callexpr_p);
+}
+
+void analyze_return_stmt (retval)
+
+     tree retval;
+
+{ flag_last_return_calls = contains_callexpr_p(retval); }
+
+void save_gcic_token_stack ()
+
+{
+    token_obstack = &secondary_token_obstack;
+    flag_reset_token_stack = 0;
+}
+
+void restore_gcic_token_stack ()
+
+{
+    token_obstack = &primary_token_obstack;
+    flag_reset_token_stack = 0;
+}
+
+void reset_token_stack ()
+
+{
+#if DEBUG_LEVEL > 3
+    struct digested_input_token *tokens =
+	(struct digested_input_token *)obstack_base(token_obstack);
+    int ntokens = obstack_object_size(token_obstack) / sizeof(*tokens), n;
+    for (n = 0; n < ntokens;n++)
+	fprintf(stderr,"flushing token %d at %d\n",tokens[n].yychar,tokens[n].offset);
+#endif
+    obstack_free(token_obstack,obstack_base(token_obstack));
+    flag_reset_token_stack = 0;
+}
+
+void feed_gcic_token_stack (token, offset)
+
+    int token, offset;
+{
+    if (flag_reset_token_stack)
+	reset_token_stack();
+
+    last_read_token.yychar = token;
+    last_read_token.offset = offset;
+    obstack_grow(token_obstack,&last_read_token,sizeof(last_read_token));
+}
+
+void insert_gcic_stack_marker (offset)
+
+    int offset;
+{
+    feed_gcic_token_stack(EMPTY,offset);
+    /* The actions to be applied when the end of a full statement has
+       been reached need to be postponed until this statement has been
+       entirely processed by our hooks; i.e. when the next token is
+       read in. This prevents the parser's look ahead to make our
+       token stack emptied too quickly. */
+    flag_reset_token_stack = 1;
+}
+
+static int sort_patches (const void *e1, const void *e2)
+
+{
+    struct patch_record *p1 = (struct patch_record *)e1;
+    struct patch_record *p2 = (struct patch_record *)e2;
+    int x1 = p1->patch_offset + p1->patch_length - 1;
+    int x2 = p2->patch_offset + p2->patch_length - 1;
+
+    /* patch records cannot overlap; however, a patch can be totally
+       embedded in a larger one.  If one of the patches includes the
+       other one, order them "inner first", "outer last". */
+
+    if (p1->patch_offset <= p2->patch_offset && x1 >= x2)
+	return 1;
+
+    if (p2->patch_offset <= p1->patch_offset && x2 >= x1)
+	return -1;
+
+    return p1->patch_offset - p2->patch_offset;
+}
+
+static void stretch_outer_patches (struct patch_record *patches,
+				   int npatches,
+				   struct patch_record *from,
+				   int len)
+{
+    int n = 0;
+
+    if (!len)
+	return;
+
+    if (len < 0)
+	{
+	ERROR("gcic: internal error: cannot shrink source");
+	return;
+	}
+
+    while (n < npatches)
+	{
+	struct patch_record *to = &patches[n];
+
+	if (from != to)
+	    {
+	    int fromlen = from->patch_offset + from->patch_length - 1;
+
+	    if (to->patch_offset <= from->patch_offset &&
+		to->patch_offset + to->patch_length - 1 >= fromlen)
+		{
+		to->patch_length += len;
+
+#if DEBUG_LEVEL > 1
+		fprintf(stderr,"moving patch of %u to (%d,%d) type %u\n",
+			len,
+			to->patch_offset,
+			to->patch_offset+to->patch_length-1,
+			to->patch_type);
+#endif
+		}
+	    }
+
+	n++;
+	}
+}
+
+static void shift_patches (struct patch_record *from,
+			   int npatches,
+			   int len)
+{
+    struct patch_record *patch = from + 1;
+
+    while (--npatches > 0)
+	{
+	if (patch->patch_forward > from->patch_forward)
+	    patch->patch_forward += len;
+
+	patch++;
+	}
+}
+
+void generate_gcic_code ()
+
+{
+    char *patch_out_filename, buf[BUFSIZ], current_filename[1024], *wrapcode;
+    struct obstack file_obstack, work_obstack;
+    struct obstack *in_obstack,	*out_obstack;
+    int nobj, read_offset, n, c, shift_adv;
+    FILE *patch_in_file, *patch_out_file;
+    int sol_flag, current_lineno;
+    struct patch_record *patch;
+
+    if (errorcount > 0)
+	return;	/* Ooops -- can't go further */
+
+#if DEBUG_LEVEL > 0
+    {
+    int c;
+    fprintf(stderr,">>> SOURCE DUMP\n");
+    rewind(input_file);
+    while ((c = fgetc(input_file)) != EOF)
+	fputc(c,stderr);
+    fprintf(stderr,">>> DONE\n");
+    }
+#endif
+
+    /* have patches sorted by increasing starting offset */
+    patch = (struct patch_record *)obstack_base(&patch_obstack);
+    nobj = obstack_object_size(&patch_obstack) / sizeof(*patch);
+    qsort(patch,nobj,sizeof(struct patch_record),sort_patches);
+
+    gcc_obstack_init(&file_obstack);
+    gcc_obstack_init(&work_obstack);
+
+    /* set up patch files */
+    patch_in_file = input_file;
+    patch_out_filename = choose_temp_base();
+    patch_out_file = fopen(patch_out_filename,"w+");
+    in_obstack = &patch_obstack;
+    out_obstack = &work_obstack;
+
+    if (!patch_out_file)
+	{
+	ERROR("gcic: cannot open %s for writing",patch_out_filename);
+	return;
+	}
+
+#if DEBUG_LEVEL > 1
+    while (nobj-- > 0)
+	{
+	fprintf(stderr,"** patch at (%d,%d) type %u\n",
+		   patch->patch_offset,
+		   patch->patch_offset+patch->patch_length-1,
+		   patch->patch_type);
+	patch++;
+	}
+#endif
+
+    do
+	{
+	/* We *must* run this once, even if no patch is to be applied,
+	   in order to write out the untouched file contents (at
+	   least). */
+	struct obstack *swap_obstack = in_obstack;
+	patch = (struct patch_record *)obstack_base(in_obstack);
+	nobj = obstack_object_size(in_obstack) / sizeof(*patch);
+	read_offset = 0;
+	rewind(patch_in_file);
+
+#if DEBUG_LEVEL > 1
+	fprintf(stderr,"*** RESCAN\n");
+#endif
+
+	while (nobj-- > 0)
+	    {
+	    n = patch->patch_offset - read_offset;
+	    shift_adv = 0;
+
+	    /* "n" may be < 0 if a portion of the current patch is
+	       embedded into a previously applied one (e.g. "for (;;)
+	       ;" is first bracketed as a whole, then, the null stmt
+	       is to be bracketed alone by a preemption call, but it
+	       has already been slurped by the englobing "for(..."
+	       statement.). In such case, wait for the next iteration
+	       to apply it. */
+
+	    if (n < 0)
+		{
+		patch->patch_offset = patch->patch_forward;
+#if DEBUG_LEVEL > 1
+		fprintf(stderr,"delaying patch (%d,%d) type %d\n",
+		       patch->patch_offset,
+		       patch->patch_offset+patch->patch_length-1,
+		       patch->patch_type);
+#endif
+		obstack_grow(out_obstack,patch,sizeof(*patch));
+		patch++;
+		continue;
+		}
+
+#if DEBUG_LEVEL > 1
+	fprintf(stderr,"applying patch at (%d,%d) type %u\n",
+		   patch->patch_offset,
+		   patch->patch_offset+patch->patch_length-1,
+		   patch->patch_type);
+#endif
+
+	    read_offset += n;
+
+	    while (n-- > 0)
+		/* skip the hole to the next patch -- don't trust
+                 fseek() */
+		obstack_1grow(&file_obstack,getc(patch_in_file));
+
+	    n = patch->patch_length;
+
+	    switch (patch->patch_type)
+		{
+		case PATCH_BODY_START:
+
+		    while (n-- > 0)
+			obstack_1grow(&file_obstack,getc(patch_in_file));
+
+		    wrapcode = format_wrapper(GCIC_DFRAME,flag_gcic_trace_tag|0x10,buf);
+		    obstack_1grow(&file_obstack,' ');
+		    obstack_grow(&file_obstack,wrapcode,strlen(wrapcode));
+		    obstack_grow(&file_obstack,"; {",3);
+		    shift_adv = 4 + strlen(wrapcode);
+		    break;
+
+		case PATCH_BODY_END:
+		
+		    obstack_grow(&file_obstack,"} ",2);
+		    shift_adv = 2;
+
+		    while (n-- > 0)
+			obstack_1grow(&file_obstack,getc(patch_in_file));
+
+		    break;
+
+		case PATCH_BODY_FALL:
+
+		    wrapcode = format_wrapper(GCIC_DFRAME,flag_gcic_trace_tag|0x20,buf);
+		    obstack_grow(&file_obstack,"} ",2);
+		    obstack_grow(&file_obstack,wrapcode,strlen(wrapcode));
+		    obstack_grow(&file_obstack,"; ",2);
+		    shift_adv = 4 + strlen(wrapcode);
+
+		    while (n-- > 0)
+			obstack_1grow(&file_obstack,getc(patch_in_file));
+
+		    break;
+
+		case PATCH_STMT:
+
+		    wrapcode = format_wrapper(GCIC_DINSN,flag_gcic_trace_tag,buf);
+		    obstack_grow(&file_obstack,"{ ",2);
+		    obstack_grow(&file_obstack,wrapcode,strlen(wrapcode));
+		    obstack_grow(&file_obstack,"; ",2);
+
+		    while (n-- > 0)
+			obstack_1grow(&file_obstack,getc(patch_in_file));
+
+		    obstack_grow(&file_obstack," }",2);
+		    shift_adv = 6 + strlen(wrapcode);
+		    stretch_outer_patches((struct patch_record *)obstack_base(in_obstack),
+					  obstack_object_size(in_obstack) / sizeof(*patch),
+					  patch,
+					  shift_adv);
+		    break;
+
+		case PATCH_RETURN_STMT:
+		case PATCH_RETURNL_STMT:
+
+		    if (patch->patch_type == PATCH_RETURN_STMT)
+			wrapcode = format_wrapper(GCIC_DFRAME,
+						  flag_gcic_trace_tag|0x20,
+						  buf);
+		    else
+			wrapcode = format_wrapper(GCIC_DFRAME,
+						  flag_gcic_trace_tag|0x40,
+						  buf);
+		    obstack_grow(&file_obstack,"{ ",2);
+		    obstack_grow(&file_obstack,wrapcode,strlen(wrapcode));
+		    obstack_grow(&file_obstack,"; ",2);
+		    shift_adv = 4 + strlen(wrapcode);
+
+		    while (n-- > 0)
+			obstack_1grow(&file_obstack,getc(patch_in_file));
+
+		    obstack_grow(&file_obstack," }",2);
+		    shift_adv += 2;
+		    stretch_outer_patches((struct patch_record *)obstack_base(in_obstack),
+					  obstack_object_size(in_obstack) / sizeof(*patch),
+					  patch,
+					  shift_adv);
+		    break;
+
+		case PATCH_SUBSTITUTE_WRAPPER:
+
+		    /* remove the original function identifier */
+
+		    shift_adv = -n;
+
+		    while (n-- > 0)
+			getc(patch_in_file);
+
+		    obstack_grow(&file_obstack,
+				 IDENTIFIER_POINTER(patch->patch_link.identifier),
+				 IDENTIFIER_LENGTH(patch->patch_link.identifier));
+
+		    shift_adv += IDENTIFIER_LENGTH(patch->patch_link.identifier);
+
+		    if (shift_adv > 0)
+			stretch_outer_patches((struct patch_record *)obstack_base(in_obstack),
+					      obstack_object_size(in_obstack) / sizeof(*patch),
+					      patch,
+					      shift_adv);
+		    else if (shift_adv < 0)
+			{
+			do
+			    /* do blank padding */
+			    obstack_1grow(&file_obstack,' ');
+			while (++shift_adv < 0);
+			}
+
+		    break;
+
+		case PATCH_COMPOUND_END:
+
+		    while (patch->patch_link.levels-- > 0)
+			{
+			obstack_grow(&file_obstack,"} ",2);
+			shift_adv += 2;
+			}
+
+		    stretch_outer_patches((struct patch_record *)obstack_base(in_obstack),
+					  obstack_object_size(in_obstack) / sizeof(*patch),
+					  patch,
+					  shift_adv);
+
+		    /* HACK: Although a compound patch should be
+		   marked to have zero-length, mostly because it does
+		   not actually "replace" any original code, it is set
+		   to be 1 character long, not to wreck the behavior
+		   of the patch stretching/shifting routines.  At this
+		   point (i.e. after those routines have been called),
+		   the length must now be nulled not to wreck the read
+		   character count, because we did not read any! sorry
+		   for this... */
+
+		    patch->patch_length = 0;
+		    break;
+
+		default:
+
+		    ERROR("gcic: internal error: patch information corrupted!");
+		return;
+		}
+
+	    shift_patches(patch,
+			  (struct patch_record *)
+			  ((char *)obstack_base(in_obstack) +
+			   obstack_object_size(in_obstack)) -
+			  patch,
+			  shift_adv);
+
+	    read_offset += patch->patch_length;
+	    patch++;
+	    }
+
+	/* finish up with unpatched trailing text... */
+
+	while ((c = getc(patch_in_file)) != EOF)
+	    obstack_1grow(&file_obstack,c);
+
+	obstack_1grow(&file_obstack,'\0');
+#if DEBUG_LEVEL > 1
+	fprintf(stderr,"AFTER SCAN:\n%s\n",obstack_base(&file_obstack));
+#endif
+	fflush(patch_out_file);
+	rewind(patch_out_file);
+	ftruncate(fileno(patch_out_file),0);
+	fputs(obstack_base(&file_obstack),patch_out_file);
+	fflush(patch_out_file);
+	patch_in_file = patch_out_file;
+	obstack_free(&file_obstack,obstack_base(&file_obstack));
+	obstack_free(in_obstack,obstack_base(in_obstack));
+	in_obstack = out_obstack;
+	out_obstack = swap_obstack;
+	}
+    while (obstack_object_size(in_obstack) > 0);
+
+    /* Start sending the instrumented source code to stdout */
+
+    sol_flag = 1;
+    fputc('\n',stdout);
+    wrapcode = get_wrap_code(GCIC_DECL);
+
+    /* There may be no declaration section */
+    if (wrapcode)
+	{
+	fputs(wrapcode,stdout);
+	fputc('\n',stdout);
+	fputc('\n',stdout);
+	}
+
+    rewind(patch_out_file);
+    strcpy(current_filename,"unknown");
+    current_lineno = 1;
+
+    while ((c = fgetc(patch_out_file)) != EOF)
+	{
+	if (sol_flag)
+	    {
+	    if (c == '#')
+		{
+		if (fgets(buf,sizeof(buf),patch_out_file))
+		    {
+		    char filename[1024], tail[32], *rp;
+		    int lineno;
+
+		    *tail = '\0';
+
+		    /* trace the current filename/lineno */
+
+		    if (sscanf(buf," %d \"%[^\"]\"%[^^]",
+			       &lineno,
+			       filename,
+			       tail) >= 2 ||
+			sscanf(buf,"line %d \"%[^\"]\"%[^^]",
+			       &lineno,
+			       filename,
+			       tail) >= 2)
+			{
+			strcpy(current_filename,filename);
+			current_lineno = lineno;
+			printf("#%s",buf);
+			continue;
+			}
+
+		    if (!temp_output_file)
+			{
+			current_lineno++;
+			continue;
+			}
+
+		    /* This is a workaround to get GCC correctly
+		       re-parse files containing "implementation"
+		       #pragmas. The main idea is to enclose #pragma
+		       implementation directives with line information
+		       GCC will accept as valid one (see
+		       handle_cp_pragma() in lex.c). To be more
+		       specific, we ensure that handle_cp_pragma()
+		       will always find that "main_input_filename" is
+		       equal to the current "input_filename".  This
+		       way, the error case complaining about
+		       implementation directive not occuring at
+		       top-level will never be met by gcic-processed
+		       source.  This kludge is needed because gcic
+		       compiles a patched copy of the user code stored
+		       in a temporary directory which always differs
+		       from the original source location. Doing this
+		       meets two goals: allowing GCC to re-parse
+		       gcic-processed files, and keep the source path
+		       information stored in the executable's debug
+		       section accurate. */
+
+		    rp = buf;
+
+		    while (*rp && isspace(*rp))	rp++;
+
+		    if (*rp++ == 'p' && !strncmp(rp,"ragma",5))
+			{
+			rp += 5;
+			while (*rp && isspace(*rp)) rp++;
+
+			if (*rp++ == 'i' && !strncmp(rp,"mplementation",13))
+			    {
+			    /* We've got a "#pragma implementation" directive here:
+			       enclose it with our line information. We first push the
+			       temporary output file name before the pragma
+			       is read, then restore the original filename after
+			       handle_cp_pragma() has consumed the directive. */
+			    printf("# 1 \"%s\" 1\n",temp_output_file);
+			    printf("#%s",buf);
+			    printf("# %d \"%s\" 2\n",
+				   current_lineno,
+				   current_filename);
+			    }
+			}
+		    else
+			printf("#%s",buf);
+		    }
+
+		current_lineno++;
+		continue;
+		}
+	    else if (!isspace(c))
+		     sol_flag = 0;
+	    }
+
+	if (c == '\n')
+	    sol_flag = 1, current_lineno++;
+
+	fputc(c,stdout);
+	}
+
+    obstack_free(&primary_token_obstack,obstack_base(&primary_token_obstack));
+    obstack_free(&secondary_token_obstack,obstack_base(&secondary_token_obstack));
+    obstack_free(&compound_obstack,obstack_base(&compound_obstack));
+    obstack_free(&wrap_obstack,obstack_base(&wrap_obstack));
+
+    (void)fclose(patch_out_file);
+    (void)unlink(patch_out_filename);
+}
diff -Naur gcc-2.95.3/gcc/jump.c gcc-gcic/gcc/jump.c
--- gcc-2.95.3/gcc/jump.c	Thu Oct 21 08:24:03 1999
+++ gcc-gcic/gcc/jump.c	Sat Aug  3 14:17:41 2002
@@ -51,6 +51,11 @@
    The subroutines delete_insn, redirect_jump, and invert_jump are used
    from other passes as well.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   Changed jump_optimize() to work around an optimizer bug. */
+ 
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 #include "system.h"
 #include "rtl.h"
@@ -130,6 +135,10 @@
 #ifndef HAVE_cc0
 static rtx find_insert_position         PROTO((rtx, rtx));
 #endif
+
+#ifdef GCIC
+int flag_gcic_mode;
+#endif /* GCIC */
 
 /* Main external entry point into the jump optimizer.  See comments before
    jump_optimize_1 for descriptions of the arguments.  */
diff -Naur gcc-2.95.3/gcc/toplev.c gcc-gcic/gcc/toplev.c
--- gcc-2.95.3/gcc/toplev.c	Thu Jan 25 15:03:23 2001
+++ gcc-gcic/gcc/toplev.c	Sat Aug  3 14:17:41 2002
@@ -24,6 +24,11 @@
    in the proper order, and counts the time used by each.
    Error messages and low-level interface to malloc also handled here.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   Added Ck-handling code to start the instrumentation process. */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "config.h"
 #undef FLOAT /* This is for hpux. They should change hpux.  */
 #undef FFS  /* Some systems define this in param.h.  */
@@ -772,6 +777,24 @@
 
 int flag_no_ident = 0;
 
+#ifdef GCIC
+/* Nonzero causes a patched source code to be produced to stdout,
+   including statements preemption and use of data vectors for static
+   variables. Currently available for C and C++. Note: one should pass
+   the --syntax-only flag "manually", along with this one to prevent
+   the machine code output and link phase to be started as we do not
+   want to change gcc's specs. */
+int flag_gcic_mode = 0;
+
+/* Context tag passed to the instrumentation hook. */
+int flag_gcic_trace_tag = 2;
+
+extern void init_gcic_processing PROTO((FILE *));
+
+extern FILE *finput;
+
+#endif /* GCIC */
+
 /* Table of supported debugging formats.  */
 static struct
 {
@@ -980,6 +1003,12 @@
    "External symbols have a leading underscore" },
   {"ident", &flag_no_ident, 0,
    "Process #ident directives"}
+#ifdef GCIC
+  ,{"gcic-mode", &flag_gcic_mode, 1},
+  {"gcic-trace-tag1", &flag_gcic_trace_tag, 0},
+  {"gcic-trace-tag2", &flag_gcic_trace_tag, 1},
+  {"gcic-trace-tag3", &flag_gcic_trace_tag, 2}
+#endif /* GCIC */
 };
 
 #define NUM_ELEM(a)  (sizeof (a) / sizeof ((a)[0]))
@@ -2960,6 +2989,11 @@
   if (flag_caller_saves)
     init_caller_save ();
 
+#ifdef GCIC
+  if (flag_gcic_mode)
+      init_gcic_processing(finput); /* opened by init_parse() */
+#endif /* GCIC */
+
   /* If auxiliary info generation is desired, open the output file.
      This goes in the same directory as the source file--unlike
      all the other output files.  */
@@ -5364,6 +5398,19 @@
   /* Checker uses the frame pointer.  */
   if (flag_check_memory_usage)
     flag_omit_frame_pointer = 0;
+
+#ifdef GCIC
+  if (flag_gcic_mode)
+      {
+      if (strcmp (language_string, "GNU Obj-C") == 0)
+	  sorry("cannot generate GCIC code for Objective-C language");
+
+      /* (-Wreturn-type is needed to have GCC check functions flow control
+               * graphes, telling us whether a function exits without explicitely
+               * RETURNing or not -- we use it for frame tracking.) */
+      warn_return_type = 1;
+      }
+#endif /* GCIC */
 
   if (optimize == 0)
     {
diff -Naur gcc-2.95.3/gcc/tree.def gcc-gcic/gcc/tree.def
--- gcc-2.95.3/gcc/tree.def	Mon May 17 09:21:12 1999
+++ gcc-gcic/gcc/tree.def	Sat Aug  3 14:17:41 2002
@@ -19,7 +19,11 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   Added LEXLOC_NODE tree code. */
  
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 /* The third argument can be:
    'x' for an exceptional code (fits no category).
    't' for a type object code.
@@ -790,6 +794,13 @@
    Operand 1 contains the case values. The way they're organized is
    front-end implementation defined. */
 DEFTREECODE (SWITCH_EXPR, "switch_expr", 'e', 2)
+
+#ifdef GCIC
+/* Internally it looks like an IDENTIFIER_NODE node, with an additional
+   field to store the identifier's original offset in source. */
+DEFTREECODE (LEXLOC_NODE, "lexloc_node", 'c', -1)
+#endif /* GCIC */
+
 /*
 Local variables:
 mode:c
diff -Naur gcc-2.95.3/gcc/tree.h gcc-gcic/gcc/tree.h
--- gcc-2.95.3/gcc/tree.h	Thu Jan 25 15:03:23 2001
+++ gcc-gcic/gcc/tree.h	Sat Aug  3 14:17:41 2002
@@ -19,6 +19,11 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   Changed to support the Ck-specific nodes. */
+ 
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
+
 #include "machmode.h"
 
 #ifndef RTX_CODE
@@ -641,6 +646,20 @@
   char *pointer;
 };
 
+#ifdef GCIC
+#define LEXLOC_LENGTH(NODE)  (LEXLOC_NODE_CHECK(NODE)->lexloc.length)
+#define LEXLOC_POINTER(NODE) (LEXLOC_NODE_CHECK(NODE)->lexloc.pointer)
+#define LEXLOC_OFFSET(NODE)  (LEXLOC_NODE_CHECK(NODE)->lexloc.offset)
+
+struct tree_lexloc
+{
+  char common[sizeof (struct tree_common)];
+  int length;
+  char *pointer;
+  int offset;
+};
+#endif /* GCIC */
+
 /* In a TREE_LIST node.  */
 #define TREE_PURPOSE(NODE) (TREE_LIST_CHECK (NODE)->list.purpose)
 #define TREE_VALUE(NODE) (TREE_LIST_CHECK (NODE)->list.value)
@@ -1386,6 +1405,9 @@
   struct tree_vec vec;
   struct tree_exp exp;
   struct tree_block block;
+#ifdef GCIC
+  struct tree_lexloc lexloc;
+#endif /* GCIC */
  };
 
 #define NULL_TREE (tree) NULL
diff -Naur gcc-2.95.3/gcc/varasm.c gcc-gcic/gcc/varasm.c
--- gcc-2.95.3/gcc/varasm.c	Mon Feb 19 15:02:02 2001
+++ gcc-gcic/gcc/varasm.c	Sat Aug  3 14:17:41 2002
@@ -19,6 +19,10 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
+/* Modified for CarbonKernel by rpm@xenomai.org, January 2001.
+   Trap null pointer references when --syntax-only is in effect. */
+
+/* Adapted to Xenomai by rpm@xenomai.org, January 2002. */
 
 /* This file handles generation of all the assembler code
    *except* the instructions of a function.
@@ -260,6 +264,10 @@
      const char *name;
      int reloc ATTRIBUTE_UNUSED;
 {
+#ifdef GCIC
+    if (flag_syntax_only)
+	return;
+#endif /* GCIC */
   if (decl != NULL_TREE
       && TREE_CODE_CLASS (TREE_CODE (decl)) != 'd')
     abort ();
@@ -878,6 +886,10 @@
 assemble_destructor (name)
      char *name;
 {
+#ifdef GCIC
+    if (flag_syntax_only)
+	return;
+#endif /* GCIC */
 #ifdef ASM_OUTPUT_DESTRUCTOR
   ASM_OUTPUT_DESTRUCTOR (asm_out_file, name);
 #else
@@ -898,6 +910,10 @@
 assemble_constructor (name)
      char *name;
 {
+#ifdef GCIC
+    if (flag_syntax_only)
+	return;
+#endif /* GCIC */
 #ifdef ASM_OUTPUT_CONSTRUCTOR
   ASM_OUTPUT_CONSTRUCTOR (asm_out_file, name);
 #else
@@ -954,6 +970,10 @@
 {
   int align;
 
+#ifdef GCIC
+    if (flag_syntax_only)
+	return;
+#endif /* GCIC */
   /* The following code does not need preprocessing in the assembler.  */
 
   app_disable ();
@@ -1647,7 +1667,11 @@
   if (! SYMBOL_REF_USED (fun))
     {
       SYMBOL_REF_USED (fun) = 1;
-      ASM_OUTPUT_EXTERNAL_LIBCALL (asm_out_file, fun);
+
+#ifdef GCIC
+      if (!flag_syntax_only)
+#endif
+	  ASM_OUTPUT_EXTERNAL_LIBCALL (asm_out_file, fun);
     }
 #endif
 }
@@ -1667,6 +1691,9 @@
 assemble_label (name)
      char *name;
 {
+#ifdef GCIC
+      if (!flag_syntax_only)
+#endif
   ASM_OUTPUT_LABEL (asm_out_file, name);
 }
 
@@ -1693,6 +1720,10 @@
   if (id)
     TREE_SYMBOL_REFERENCED (id) = 1;
 
+#ifdef GCIC
+  if (flag_syntax_only)
+      return;
+#endif
   if (name[0] == '*')
     fputs (&name[1], file);
   else
@@ -1724,6 +1755,10 @@
 
   x = gen_rtx_SYMBOL_REF (Pmode, namestring);
 
+#ifdef GCIC
+  if (flag_syntax_only)
+      return x;
+#endif
 #ifdef ASM_OUTPUT_ALIGNED_DECL_LOCAL
   ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, NULL_TREE, name, size,
 				 BIGGEST_ALIGNMENT);
diff -Naur gcc-2.95.3/gcc/version.c gcc-gcic/gcc/version.c
--- gcc-2.95.3/gcc/version.c	Fri Mar 16 13:52:12 2001
+++ gcc-gcic/gcc/version.c	Sat Aug  3 14:17:41 2002
@@ -1 +1 @@
-char *version_string = "2.95.3 20010315 (release)";
+char *version_string = "2.95.3 20010325 (Xenomai Instrumenter)";
